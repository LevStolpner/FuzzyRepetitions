<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
<!ENTITY % media-entities "./media-entities.tmpl">
<!ENTITY media-indices "./media-indices.tmpl">

<!ENTITY eg                     "e.&nbsp;g.">
<!ENTITY ie                     "i.&nbsp;e.">
<!ENTITY fd                     "File descriptor returned by <link linkend='func-open'><function>open()</function></link>.">
<!ENTITY i2c                    "I<superscript>2</superscript>C">
<!ENTITY return-value		"<title>Return Value</title><para>On success <returnvalue>0</returnvalue> is returned, on error <returnvalue>-1</returnvalue> and the <varname>errno</varname> variable is set appropriately. The generic error codes are described at the <link linkend='gen-errors'>Generic Error Codes</link> chapter.</para>">
<!ENTITY return-value-dvb	"<para>RETURN VALUE</para><para>On success <returnvalue>0</returnvalue> is returned, on error <returnvalue>-1</returnvalue> and the <varname>errno</varname> variable is set appropriately. The generic error codes are described at the <link linkend='gen-errors'>Generic Error Codes</link> chapter.</para>">
<!ENTITY manvol                 "<manvolnum>2</manvolnum>">

<!-- Table templates: structs, structs w/union, defines. -->
<!ENTITY cs-str                 "<colspec colname='c1' colwidth='1*' /><colspec colname='c2' colwidth='1*' /><colspec colname='c3' colwidth='2*' /><spanspec spanname='hspan' namest='c1' nameend='c3' />">
<!ENTITY cs-ustr                "<colspec colname='c1' colwidth='1*' /><colspec colname='c2' colwidth='1*' /><colspec colname='c3' colwidth='1*' /><colspec colname='c4' colwidth='2*' /><spanspec spanname='hspan' namest='c1' nameend='c4' />">
<!ENTITY cs-def                 "<colspec colname='c1' colwidth='3*' /><colspec colname='c2' colwidth='1*' /><colspec colname='c3' colwidth='4*' /><spanspec spanname='hspan' namest='c1' nameend='c3' />">

<!-- Video for Linux mailing list address. -->
<!ENTITY v4l-ml                 "<ulink url='http://www.linuxtv.org/lists.php'>http://www.linuxtv.org/lists.php</ulink>">

<!-- LinuxTV v4l-dvb repository. -->
<!ENTITY v4l-dvb		"<ulink url='http://linuxtv.org/repo/'>http://linuxtv.org/repo/</ulink>">
<!ENTITY dash-ent-8             "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-10            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-12            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-14            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-16            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-20            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-22            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY dash-ent-24            "<entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry><entry>-</entry>">
<!ENTITY rapidio SYSTEM "rapidio.xml">
]>
<d:DocumentationCore xmlns:d="http://math.spbu.ru/drl" xmlns="http://docbook.org/ns/docbook">
  <d:InfElement id="root" name="test">
    <set>
      <setinfo>
        <title>The 802.11 subsystems for kernel developers</title>
        <subtitle>
      Explaining wireless 802.11 networking in the Linux kernel
    </subtitle>
        <copyright>
          <year>2007-2009</year>
          <holder>Johannes Berg</holder>
        </copyright>
        <authorgroup>
          <author>
            <firstname>Johannes</firstname>
            <surname>Berg</surname>
            <affiliation>
              <address>
                <email>johannes@sipsolutions.net</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <legalnotice>
          <para>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2 as published by the Free Software Foundation.
      </para>
          <para>
        This documentation is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        See the GNU General Public License for more details.
      </para>
          <para>
        You should have received a copy of the GNU General Public
        License along with this documentation; if not, write to the Free
        Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
        MA 02111-1307 USA
      </para>
          <para>
        For more details see the file COPYING in the source
        distribution of Linux.
      </para>
        </legalnotice>
        <abstract>
          <para>
        These books attempt to give a description of the
        various subsystems that play a role in 802.11 wireless
        networking in Linux. Since these books are for kernel
        developers they attempts to document the structures
        and functions used in the kernel as well as giving a
        higher-level overview.
      </para>
          <para>
	The reader is expected to be familiar with the 802.11
	standard as published by the IEEE in 802.11-2007 (or
	possibly later versions). References to this standard
	will be given as "802.11-2007 8.1.5".
      </para>
        </abstract>
      </setinfo>
      <book id="cfg80211-developers-guide">
        <bookinfo>
          <title>The cfg80211 subsystem</title>
          <abstract>
!Pinclude/net/cfg80211.h Introduction
      </abstract>
        </bookinfo>
        <chapter>
          <title>Device registration</title>
!Pinclude/net/cfg80211.h Device registration
!Finclude/net/cfg80211.h ieee80211_band
!Finclude/net/cfg80211.h ieee80211_channel_flags
!Finclude/net/cfg80211.h ieee80211_channel
!Finclude/net/cfg80211.h ieee80211_rate_flags
!Finclude/net/cfg80211.h ieee80211_rate
!Finclude/net/cfg80211.h ieee80211_sta_ht_cap
!Finclude/net/cfg80211.h ieee80211_supported_band
!Finclude/net/cfg80211.h cfg80211_signal_type
!Finclude/net/cfg80211.h wiphy_params_flags
!Finclude/net/cfg80211.h wiphy_flags
!Finclude/net/cfg80211.h wiphy
!Finclude/net/cfg80211.h wireless_dev
!Finclude/net/cfg80211.h wiphy_new
!Finclude/net/cfg80211.h wiphy_register
!Finclude/net/cfg80211.h wiphy_unregister
!Finclude/net/cfg80211.h wiphy_free

!Finclude/net/cfg80211.h wiphy_name
!Finclude/net/cfg80211.h wiphy_dev
!Finclude/net/cfg80211.h wiphy_priv
!Finclude/net/cfg80211.h priv_to_wiphy
!Finclude/net/cfg80211.h set_wiphy_dev
!Finclude/net/cfg80211.h wdev_priv
      </chapter>
        <chapter>
          <title>Actions and configuration</title>
!Pinclude/net/cfg80211.h Actions and configuration
!Finclude/net/cfg80211.h cfg80211_ops
!Finclude/net/cfg80211.h vif_params
!Finclude/net/cfg80211.h key_params
!Finclude/net/cfg80211.h survey_info_flags
!Finclude/net/cfg80211.h survey_info
!Finclude/net/cfg80211.h cfg80211_beacon_data
!Finclude/net/cfg80211.h cfg80211_ap_settings
!Finclude/net/cfg80211.h station_parameters
!Finclude/net/cfg80211.h station_info_flags
!Finclude/net/cfg80211.h rate_info_flags
!Finclude/net/cfg80211.h rate_info
!Finclude/net/cfg80211.h station_info
!Finclude/net/cfg80211.h monitor_flags
!Finclude/net/cfg80211.h mpath_info_flags
!Finclude/net/cfg80211.h mpath_info
!Finclude/net/cfg80211.h bss_parameters
!Finclude/net/cfg80211.h ieee80211_txq_params
!Finclude/net/cfg80211.h cfg80211_crypto_settings
!Finclude/net/cfg80211.h cfg80211_auth_request
!Finclude/net/cfg80211.h cfg80211_assoc_request
!Finclude/net/cfg80211.h cfg80211_deauth_request
!Finclude/net/cfg80211.h cfg80211_disassoc_request
!Finclude/net/cfg80211.h cfg80211_ibss_params
!Finclude/net/cfg80211.h cfg80211_connect_params
!Finclude/net/cfg80211.h cfg80211_pmksa
!Finclude/net/cfg80211.h cfg80211_rx_mlme_mgmt
!Finclude/net/cfg80211.h cfg80211_auth_timeout
!Finclude/net/cfg80211.h cfg80211_rx_assoc_resp
!Finclude/net/cfg80211.h cfg80211_assoc_timeout
!Finclude/net/cfg80211.h cfg80211_tx_mlme_mgmt
!Finclude/net/cfg80211.h cfg80211_ibss_joined
!Finclude/net/cfg80211.h cfg80211_connect_result
!Finclude/net/cfg80211.h cfg80211_roamed
!Finclude/net/cfg80211.h cfg80211_disconnected
!Finclude/net/cfg80211.h cfg80211_ready_on_channel
!Finclude/net/cfg80211.h cfg80211_remain_on_channel_expired
!Finclude/net/cfg80211.h cfg80211_new_sta
!Finclude/net/cfg80211.h cfg80211_rx_mgmt
!Finclude/net/cfg80211.h cfg80211_mgmt_tx_status
!Finclude/net/cfg80211.h cfg80211_cqm_rssi_notify
!Finclude/net/cfg80211.h cfg80211_cqm_pktloss_notify
!Finclude/net/cfg80211.h cfg80211_michael_mic_failure
      </chapter>
        <chapter>
          <title>Scanning and BSS list handling</title>
!Pinclude/net/cfg80211.h Scanning and BSS list handling
!Finclude/net/cfg80211.h cfg80211_ssid
!Finclude/net/cfg80211.h cfg80211_scan_request
!Finclude/net/cfg80211.h cfg80211_scan_done
!Finclude/net/cfg80211.h cfg80211_bss
!Finclude/net/cfg80211.h cfg80211_inform_bss_width_frame
!Finclude/net/cfg80211.h cfg80211_inform_bss_width
!Finclude/net/cfg80211.h cfg80211_unlink_bss
!Finclude/net/cfg80211.h cfg80211_find_ie
!Finclude/net/cfg80211.h ieee80211_bss_get_ie
      </chapter>
        <chapter>
          <title>Utility functions</title>
!Pinclude/net/cfg80211.h Utility functions
!Finclude/net/cfg80211.h ieee80211_channel_to_frequency
!Finclude/net/cfg80211.h ieee80211_frequency_to_channel
!Finclude/net/cfg80211.h ieee80211_get_channel
!Finclude/net/cfg80211.h ieee80211_get_response_rate
!Finclude/net/cfg80211.h ieee80211_hdrlen
!Finclude/net/cfg80211.h ieee80211_get_hdrlen_from_skb
!Finclude/net/cfg80211.h ieee80211_radiotap_iterator
      </chapter>
        <chapter>
          <title>Data path helpers</title>
!Pinclude/net/cfg80211.h Data path helpers
!Finclude/net/cfg80211.h ieee80211_data_to_8023
!Finclude/net/cfg80211.h ieee80211_data_from_8023
!Finclude/net/cfg80211.h ieee80211_amsdu_to_8023s
!Finclude/net/cfg80211.h cfg80211_classify8021d
      </chapter>
        <chapter>
          <title>Regulatory enforcement infrastructure</title>
!Pinclude/net/cfg80211.h Regulatory enforcement infrastructure
!Finclude/net/cfg80211.h regulatory_hint
!Finclude/net/cfg80211.h wiphy_apply_custom_regulatory
!Finclude/net/cfg80211.h freq_reg_info
      </chapter>
        <chapter>
          <title>RFkill integration</title>
!Pinclude/net/cfg80211.h RFkill integration
!Finclude/net/cfg80211.h wiphy_rfkill_set_hw_state
!Finclude/net/cfg80211.h wiphy_rfkill_start_polling
!Finclude/net/cfg80211.h wiphy_rfkill_stop_polling
      </chapter>
        <chapter>
          <title>Test mode</title>
!Pinclude/net/cfg80211.h Test mode
!Finclude/net/cfg80211.h cfg80211_testmode_alloc_reply_skb
!Finclude/net/cfg80211.h cfg80211_testmode_reply
!Finclude/net/cfg80211.h cfg80211_testmode_alloc_event_skb
!Finclude/net/cfg80211.h cfg80211_testmode_event
      </chapter>
      </book>
      <book id="mac80211-developers-guide">
        <bookinfo>
          <title>The mac80211 subsystem</title>
          <abstract>
!Pinclude/net/mac80211.h Introduction
!Pinclude/net/mac80211.h Warning
      </abstract>
        </bookinfo>
        <toc>
        </toc>
        <!--
  Generally, this document shall be ordered by increasing complexity.
  It is important to note that readers should be able to read only
  the first few sections to get a working driver and only advanced
  usage should require reading the full document.
  -->
        <part>
          <title>The basic mac80211 driver interface</title>
          <partintro>
            <para>
          You should read and understand the information contained
          within this part of the book while implementing a driver.
          In some chapters, advanced usage is noted, that may be
          skipped at first.
        </para>
            <para>
          This part of the book only covers station and monitor mode
          functionality, additional information required to implement
          the other modes is covered in the second part of the book.
        </para>
          </partintro>
          <chapter id="basics">
            <title>Basic hardware handling</title>
            <para>TBD</para>
            <para>
          This chapter shall contain information on getting a hw
          struct allocated and registered with mac80211.
        </para>
            <para>
          Since it is required to allocate rates/modes before registering
          a hw struct, this chapter shall also contain information on setting
          up the rate/mode structs.
        </para>
            <para>
          Additionally, some discussion about the callbacks and
          the general programming model should be in here, including
          the definition of ieee80211_ops which will be referred to
          a lot.
        </para>
            <para>
          Finally, a discussion of hardware capabilities should be done
          with references to other parts of the book.
        </para>
            <!-- intentionally multiple !F lines to get proper order -->
!Finclude/net/mac80211.h ieee80211_hw
!Finclude/net/mac80211.h ieee80211_hw_flags
!Finclude/net/mac80211.h SET_IEEE80211_DEV
!Finclude/net/mac80211.h SET_IEEE80211_PERM_ADDR
!Finclude/net/mac80211.h ieee80211_ops
!Finclude/net/mac80211.h ieee80211_alloc_hw
!Finclude/net/mac80211.h ieee80211_register_hw
!Finclude/net/mac80211.h ieee80211_unregister_hw
!Finclude/net/mac80211.h ieee80211_free_hw
      </chapter>
          <chapter id="phy-handling">
            <title>PHY configuration</title>
            <para>TBD</para>
            <para>
          This chapter should describe PHY handling including
          start/stop callbacks and the various structures used.
        </para>
!Finclude/net/mac80211.h ieee80211_conf
!Finclude/net/mac80211.h ieee80211_conf_flags
      </chapter>
          <chapter id="iface-handling">
            <title>Virtual interfaces</title>
            <para>TBD</para>
            <para>
          This chapter should describe virtual interface basics
          that are relevant to the driver (VLANs, MGMT etc are not.)
          It should explain the use of the add_iface/remove_iface
          callbacks as well as the interface configuration callbacks.
        </para>
            <para>Things related to AP mode should be discussed there.</para>
            <para>
          Things related to supporting multiple interfaces should be
          in the appropriate chapter, a BIG FAT note should be here about
          this though and the recommendation to allow only a single
          interface in STA mode at first!
        </para>
!Finclude/net/mac80211.h ieee80211_vif
      </chapter>
          <chapter id="rx-tx">
            <title>Receive and transmit processing</title>
            <sect1>
              <title>what should be here</title>
              <para>TBD</para>
              <para>
            This should describe the receive and transmit
            paths in mac80211/the drivers as well as
            transmit status handling.
          </para>
            </sect1>
            <sect1>
              <title>Frame format</title>
!Pinclude/net/mac80211.h Frame format
        </sect1>
            <sect1>
              <title>Packet alignment</title>
!Pnet/mac80211/rx.c Packet alignment
        </sect1>
            <sect1>
              <title>Calling into mac80211 from interrupts</title>
!Pinclude/net/mac80211.h Calling mac80211 from interrupts
        </sect1>
            <sect1>
              <title>functions/definitions</title>
!Finclude/net/mac80211.h ieee80211_rx_status
!Finclude/net/mac80211.h mac80211_rx_flags
!Finclude/net/mac80211.h mac80211_tx_info_flags
!Finclude/net/mac80211.h mac80211_tx_control_flags
!Finclude/net/mac80211.h mac80211_rate_control_flags
!Finclude/net/mac80211.h ieee80211_tx_rate
!Finclude/net/mac80211.h ieee80211_tx_info
!Finclude/net/mac80211.h ieee80211_tx_info_clear_status
!Finclude/net/mac80211.h ieee80211_rx
!Finclude/net/mac80211.h ieee80211_rx_ni
!Finclude/net/mac80211.h ieee80211_rx_irqsafe
!Finclude/net/mac80211.h ieee80211_tx_status
!Finclude/net/mac80211.h ieee80211_tx_status_ni
!Finclude/net/mac80211.h ieee80211_tx_status_irqsafe
!Finclude/net/mac80211.h ieee80211_rts_get
!Finclude/net/mac80211.h ieee80211_rts_duration
!Finclude/net/mac80211.h ieee80211_ctstoself_get
!Finclude/net/mac80211.h ieee80211_ctstoself_duration
!Finclude/net/mac80211.h ieee80211_generic_frame_duration
!Finclude/net/mac80211.h ieee80211_wake_queue
!Finclude/net/mac80211.h ieee80211_stop_queue
!Finclude/net/mac80211.h ieee80211_wake_queues
!Finclude/net/mac80211.h ieee80211_stop_queues
!Finclude/net/mac80211.h ieee80211_queue_stopped
        </sect1>
          </chapter>
          <chapter id="filters">
            <title>Frame filtering</title>
!Pinclude/net/mac80211.h Frame filtering
!Finclude/net/mac80211.h ieee80211_filter_flags
      </chapter>
          <chapter id="workqueue">
            <title>The mac80211 workqueue</title>
!Pinclude/net/mac80211.h mac80211 workqueue
!Finclude/net/mac80211.h ieee80211_queue_work
!Finclude/net/mac80211.h ieee80211_queue_delayed_work
      </chapter>
        </part>
        <part id="advanced">
          <title>Advanced driver interface</title>
          <partintro>
            <para>
         Information contained within this part of the book is
         of interest only for advanced interaction of mac80211
         with drivers to exploit more hardware capabilities and
         improve performance.
        </para>
          </partintro>
          <chapter id="led-support">
            <title>LED support</title>
            <para>
         Mac80211 supports various ways of blinking LEDs. Wherever possible,
         device LEDs should be exposed as LED class devices and hooked up to
         the appropriate trigger, which will then be triggered appropriately
         by mac80211.
        </para>
!Finclude/net/mac80211.h ieee80211_get_tx_led_name
!Finclude/net/mac80211.h ieee80211_get_rx_led_name
!Finclude/net/mac80211.h ieee80211_get_assoc_led_name
!Finclude/net/mac80211.h ieee80211_get_radio_led_name
!Finclude/net/mac80211.h ieee80211_tpt_blink
!Finclude/net/mac80211.h ieee80211_tpt_led_trigger_flags
!Finclude/net/mac80211.h ieee80211_create_tpt_led_trigger
      </chapter>
          <chapter id="hardware-crypto-offload">
            <title>Hardware crypto acceleration</title>
!Pinclude/net/mac80211.h Hardware crypto acceleration
  <!-- intentionally multiple !F lines to get proper order -->
!Finclude/net/mac80211.h set_key_cmd
!Finclude/net/mac80211.h ieee80211_key_conf
!Finclude/net/mac80211.h ieee80211_key_flags
!Finclude/net/mac80211.h ieee80211_get_tkip_p1k
!Finclude/net/mac80211.h ieee80211_get_tkip_p1k_iv
!Finclude/net/mac80211.h ieee80211_get_tkip_p2k
      </chapter>
          <chapter id="powersave">
            <title>Powersave support</title>
!Pinclude/net/mac80211.h Powersave support
      </chapter>
          <chapter id="beacon-filter">
            <title>Beacon filter support</title>
!Pinclude/net/mac80211.h Beacon filter support
!Finclude/net/mac80211.h ieee80211_beacon_loss
      </chapter>
          <chapter id="qos">
            <title>Multiple queues and QoS support</title>
            <para>TBD</para>
!Finclude/net/mac80211.h ieee80211_tx_queue_params
      </chapter>
          <chapter id="AP">
            <title>Access point mode support</title>
            <para>TBD</para>
            <para>Some parts of the if_conf should be discussed here instead</para>
            <para>
          Insert notes about VLAN interfaces with hw crypto here or
          in the hw crypto chapter.
        </para>
            <section id="ps-client">
              <title>support for powersaving clients</title>
!Pinclude/net/mac80211.h AP support for powersaving clients
      </section>
!Finclude/net/mac80211.h ieee80211_get_buffered_bc
!Finclude/net/mac80211.h ieee80211_beacon_get
!Finclude/net/mac80211.h ieee80211_sta_eosp
!Finclude/net/mac80211.h ieee80211_frame_release_type
!Finclude/net/mac80211.h ieee80211_sta_ps_transition
!Finclude/net/mac80211.h ieee80211_sta_ps_transition_ni
!Finclude/net/mac80211.h ieee80211_sta_set_buffered
!Finclude/net/mac80211.h ieee80211_sta_block_awake
      </chapter>
          <chapter id="multi-iface">
            <title>Supporting multiple virtual interfaces</title>
            <para>TBD</para>
            <para>
          Note: WDS with identical MAC address should almost always be OK
        </para>
            <para>
          Insert notes about having multiple virtual interfaces with
          different MAC addresses here, note which configurations are
          supported by mac80211, add notes about supporting hw crypto
          with it.
        </para>
!Finclude/net/mac80211.h ieee80211_iterate_active_interfaces
!Finclude/net/mac80211.h ieee80211_iterate_active_interfaces_atomic
      </chapter>
          <chapter id="station-handling">
            <title>Station handling</title>
            <para>TODO</para>
!Finclude/net/mac80211.h ieee80211_sta
!Finclude/net/mac80211.h sta_notify_cmd
!Finclude/net/mac80211.h ieee80211_find_sta
!Finclude/net/mac80211.h ieee80211_find_sta_by_ifaddr
      </chapter>
          <chapter id="hardware-scan-offload">
            <title>Hardware scan offload</title>
            <para>TBD</para>
!Finclude/net/mac80211.h ieee80211_scan_completed
      </chapter>
          <chapter id="aggregation">
            <title>Aggregation</title>
            <sect1>
              <title>TX A-MPDU aggregation</title>
!Pnet/mac80211/agg-tx.c TX A-MPDU aggregation
!Cnet/mac80211/agg-tx.c
        </sect1>
            <sect1>
              <title>RX A-MPDU aggregation</title>
!Pnet/mac80211/agg-rx.c RX A-MPDU aggregation
!Cnet/mac80211/agg-rx.c
        </sect1>
!Finclude/net/mac80211.h ieee80211_ampdu_mlme_action
      </chapter>
          <chapter id="smps">
            <title>Spatial Multiplexing Powersave (SMPS)</title>
!Pinclude/net/mac80211.h Spatial multiplexing power save
!Finclude/net/mac80211.h ieee80211_request_smps
!Finclude/net/mac80211.h ieee80211_smps_mode
      </chapter>
        </part>
        <part id="rate-control">
          <title>Rate control interface</title>
          <partintro>
            <para>TBD</para>
            <para>
         This part of the book describes the rate control algorithm
         interface and how it relates to mac80211 and drivers.
        </para>
          </partintro>
          <chapter id="ratecontrol-api">
            <title>Rate Control API</title>
            <para>TBD</para>
!Finclude/net/mac80211.h ieee80211_start_tx_ba_session
!Finclude/net/mac80211.h ieee80211_start_tx_ba_cb_irqsafe
!Finclude/net/mac80211.h ieee80211_stop_tx_ba_session
!Finclude/net/mac80211.h ieee80211_stop_tx_ba_cb_irqsafe
!Finclude/net/mac80211.h ieee80211_rate_control_changed
!Finclude/net/mac80211.h ieee80211_tx_rate_control
!Finclude/net/mac80211.h rate_control_send_low
      </chapter>
        </part>
        <part id="internal">
          <title>Internals</title>
          <partintro>
            <para>TBD</para>
            <para>
         This part of the book describes mac80211 internals.
        </para>
          </partintro>
          <chapter id="key-handling">
            <title>Key handling</title>
            <sect1>
              <title>Key handling basics</title>
!Pnet/mac80211/key.c Key handling basics
        </sect1>
            <sect1>
              <title>MORE TBD</title>
              <para>TBD</para>
            </sect1>
          </chapter>
          <chapter id="rx-processing">
            <title>Receive processing</title>
            <para>TBD</para>
          </chapter>
          <chapter id="tx-processing">
            <title>Transmit processing</title>
            <para>TBD</para>
          </chapter>
          <chapter id="sta-info">
            <title>Station info handling</title>
            <sect1>
              <title>Programming information</title>
!Fnet/mac80211/sta_info.h sta_info
!Fnet/mac80211/sta_info.h ieee80211_sta_info_flags
        </sect1>
            <sect1>
              <title>STA information lifetime rules</title>
!Pnet/mac80211/sta_info.c STA information lifetime rules
        </sect1>
          </chapter>
          <chapter id="aggregation-internals">
            <title>Aggregation</title>
!Fnet/mac80211/sta_info.h sta_ampdu_mlme
!Fnet/mac80211/sta_info.h tid_ampdu_tx
!Fnet/mac80211/sta_info.h tid_ampdu_rx
      </chapter>
          <chapter id="synchronisation">
            <title>Synchronisation</title>
            <para>TBD</para>
            <para>Locking, lots of RCU</para>
          </chapter>
        </part>
      </book>
    </set>
    <set>
      <setinfo>
        <title>The 802.11 subsystems for kernel developers</title>
        <subtitle>
      Explaining wireless 802.11 networking in the Linux kernel
    </subtitle>
        <copyright>
          <year>2007-2009</year>
          <holder>Johannes Berg</holder>
        </copyright>
        <authorgroup>
          <author>
            <firstname>Johannes</firstname>
            <surname>Berg</surname>
            <affiliation>
              <address>
                <email>johannes@sipsolutions.net</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <legalnotice>
          <para>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2 as published by the Free Software Foundation.
      </para>
          <para>
        This documentation is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        See the GNU General Public License for more details.
      </para>
          <para>
        You should have received a copy of the GNU General Public
        License along with this documentation; if not, write to the Free
        Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
        MA 02111-1307 USA
      </para>
          <para>
        For more details see the file COPYING in the source
        distribution of Linux.
      </para>
        </legalnotice>
        <abstract>
          <para>
        These books attempt to give a description of the
        various subsystems that play a role in 802.11 wireless
        networking in Linux. Since these books are for kernel
        developers they attempts to document the structures
        and functions used in the kernel as well as giving a
        higher-level overview.
      </para>
          <para>
	The reader is expected to be familiar with the 802.11
	standard as published by the IEEE in 802.11-2007 (or
	possibly later versions). References to this standard
	will be given as "802.11-2007 8.1.5".
      </para>
        </abstract>
      </setinfo>
      <book id="cfg80211-developers-guide">
        <bookinfo>
          <title>The cfg80211 subsystem</title>
          <abstract>
!Pinclude/net/cfg80211.h Introduction
      </abstract>
        </bookinfo>
        <chapter>
          <title>Device registration</title>
!Pinclude/net/cfg80211.h Device registration
!Finclude/net/cfg80211.h ieee80211_band
!Finclude/net/cfg80211.h ieee80211_channel_flags
!Finclude/net/cfg80211.h ieee80211_channel
!Finclude/net/cfg80211.h ieee80211_rate_flags
!Finclude/net/cfg80211.h ieee80211_rate
!Finclude/net/cfg80211.h ieee80211_sta_ht_cap
!Finclude/net/cfg80211.h ieee80211_supported_band
!Finclude/net/cfg80211.h cfg80211_signal_type
!Finclude/net/cfg80211.h wiphy_params_flags
!Finclude/net/cfg80211.h wiphy_flags
!Finclude/net/cfg80211.h wiphy
!Finclude/net/cfg80211.h wireless_dev
!Finclude/net/cfg80211.h wiphy_new
!Finclude/net/cfg80211.h wiphy_register
!Finclude/net/cfg80211.h wiphy_unregister
!Finclude/net/cfg80211.h wiphy_free

!Finclude/net/cfg80211.h wiphy_name
!Finclude/net/cfg80211.h wiphy_dev
!Finclude/net/cfg80211.h wiphy_priv
!Finclude/net/cfg80211.h priv_to_wiphy
!Finclude/net/cfg80211.h set_wiphy_dev
!Finclude/net/cfg80211.h wdev_priv
      </chapter>
        <chapter>
          <title>Actions and configuration</title>
!Pinclude/net/cfg80211.h Actions and configuration
!Finclude/net/cfg80211.h cfg80211_ops
!Finclude/net/cfg80211.h vif_params
!Finclude/net/cfg80211.h key_params
!Finclude/net/cfg80211.h survey_info_flags
!Finclude/net/cfg80211.h survey_info
!Finclude/net/cfg80211.h cfg80211_beacon_data
!Finclude/net/cfg80211.h cfg80211_ap_settings
!Finclude/net/cfg80211.h station_parameters
!Finclude/net/cfg80211.h station_info_flags
!Finclude/net/cfg80211.h rate_info_flags
!Finclude/net/cfg80211.h rate_info
!Finclude/net/cfg80211.h station_info
!Finclude/net/cfg80211.h monitor_flags
!Finclude/net/cfg80211.h mpath_info_flags
!Finclude/net/cfg80211.h mpath_info
!Finclude/net/cfg80211.h bss_parameters
!Finclude/net/cfg80211.h ieee80211_txq_params
!Finclude/net/cfg80211.h cfg80211_crypto_settings
!Finclude/net/cfg80211.h cfg80211_auth_request
!Finclude/net/cfg80211.h cfg80211_assoc_request
!Finclude/net/cfg80211.h cfg80211_deauth_request
!Finclude/net/cfg80211.h cfg80211_disassoc_request
!Finclude/net/cfg80211.h cfg80211_ibss_params
!Finclude/net/cfg80211.h cfg80211_connect_params
!Finclude/net/cfg80211.h cfg80211_pmksa
!Finclude/net/cfg80211.h cfg80211_rx_mlme_mgmt
!Finclude/net/cfg80211.h cfg80211_auth_timeout
!Finclude/net/cfg80211.h cfg80211_rx_assoc_resp
!Finclude/net/cfg80211.h cfg80211_assoc_timeout
!Finclude/net/cfg80211.h cfg80211_tx_mlme_mgmt
!Finclude/net/cfg80211.h cfg80211_ibss_joined
!Finclude/net/cfg80211.h cfg80211_connect_result
!Finclude/net/cfg80211.h cfg80211_roamed
!Finclude/net/cfg80211.h cfg80211_disconnected
!Finclude/net/cfg80211.h cfg80211_ready_on_channel
!Finclude/net/cfg80211.h cfg80211_remain_on_channel_expired
!Finclude/net/cfg80211.h cfg80211_new_sta
!Finclude/net/cfg80211.h cfg80211_rx_mgmt
!Finclude/net/cfg80211.h cfg80211_mgmt_tx_status
!Finclude/net/cfg80211.h cfg80211_cqm_rssi_notify
!Finclude/net/cfg80211.h cfg80211_cqm_pktloss_notify
!Finclude/net/cfg80211.h cfg80211_michael_mic_failure
      </chapter>
        <chapter>
          <title>Scanning and BSS list handling</title>
!Pinclude/net/cfg80211.h Scanning and BSS list handling
!Finclude/net/cfg80211.h cfg80211_ssid
!Finclude/net/cfg80211.h cfg80211_scan_request
!Finclude/net/cfg80211.h cfg80211_scan_done
!Finclude/net/cfg80211.h cfg80211_bss
!Finclude/net/cfg80211.h cfg80211_inform_bss_width_frame
!Finclude/net/cfg80211.h cfg80211_inform_bss_width
!Finclude/net/cfg80211.h cfg80211_unlink_bss
!Finclude/net/cfg80211.h cfg80211_find_ie
!Finclude/net/cfg80211.h ieee80211_bss_get_ie
      </chapter>
        <chapter>
          <title>Utility functions</title>
!Pinclude/net/cfg80211.h Utility functions
!Finclude/net/cfg80211.h ieee80211_channel_to_frequency
!Finclude/net/cfg80211.h ieee80211_frequency_to_channel
!Finclude/net/cfg80211.h ieee80211_get_channel
!Finclude/net/cfg80211.h ieee80211_get_response_rate
!Finclude/net/cfg80211.h ieee80211_hdrlen
!Finclude/net/cfg80211.h ieee80211_get_hdrlen_from_skb
!Finclude/net/cfg80211.h ieee80211_radiotap_iterator
      </chapter>
        <chapter>
          <title>Data path helpers</title>
!Pinclude/net/cfg80211.h Data path helpers
!Finclude/net/cfg80211.h ieee80211_data_to_8023
!Finclude/net/cfg80211.h ieee80211_data_from_8023
!Finclude/net/cfg80211.h ieee80211_amsdu_to_8023s
!Finclude/net/cfg80211.h cfg80211_classify8021d
      </chapter>
        <chapter>
          <title>Regulatory enforcement infrastructure</title>
!Pinclude/net/cfg80211.h Regulatory enforcement infrastructure
!Finclude/net/cfg80211.h regulatory_hint
!Finclude/net/cfg80211.h wiphy_apply_custom_regulatory
!Finclude/net/cfg80211.h freq_reg_info
      </chapter>
        <chapter>
          <title>RFkill integration</title>
!Pinclude/net/cfg80211.h RFkill integration
!Finclude/net/cfg80211.h wiphy_rfkill_set_hw_state
!Finclude/net/cfg80211.h wiphy_rfkill_start_polling
!Finclude/net/cfg80211.h wiphy_rfkill_stop_polling
      </chapter>
        <chapter>
          <title>Test mode</title>
!Pinclude/net/cfg80211.h Test mode
!Finclude/net/cfg80211.h cfg80211_testmode_alloc_reply_skb
!Finclude/net/cfg80211.h cfg80211_testmode_reply
!Finclude/net/cfg80211.h cfg80211_testmode_alloc_event_skb
!Finclude/net/cfg80211.h cfg80211_testmode_event
      </chapter>
      </book>
      <book id="mac80211-developers-guide">
        <bookinfo>
          <title>The mac80211 subsystem</title>
          <abstract>
!Pinclude/net/mac80211.h Introduction
!Pinclude/net/mac80211.h Warning
      </abstract>
        </bookinfo>
        <toc>
        </toc>
        <!--
  Generally, this document shall be ordered by increasing complexity.
  It is important to note that readers should be able to read only
  the first few sections to get a working driver and only advanced
  usage should require reading the full document.
  -->
        <part>
          <title>The basic mac80211 driver interface</title>
          <partintro>
            <para>
          You should read and understand the information contained
          within this part of the book while implementing a driver.
          In some chapters, advanced usage is noted, that may be
          skipped at first.
        </para>
            <para>
          This part of the book only covers station and monitor mode
          functionality, additional information required to implement
          the other modes is covered in the second part of the book.
        </para>
          </partintro>
          <chapter id="basics">
            <title>Basic hardware handling</title>
            <para>TBD</para>
            <para>
          This chapter shall contain information on getting a hw
          struct allocated and registered with mac80211.
        </para>
            <para>
          Since it is required to allocate rates/modes before registering
          a hw struct, this chapter shall also contain information on setting
          up the rate/mode structs.
        </para>
            <para>
          Additionally, some discussion about the callbacks and
          the general programming model should be in here, including
          the definition of ieee80211_ops which will be referred to
          a lot.
        </para>
            <para>
          Finally, a discussion of hardware capabilities should be done
          with references to other parts of the book.
        </para>
            <!-- intentionally multiple !F lines to get proper order -->
!Finclude/net/mac80211.h ieee80211_hw
!Finclude/net/mac80211.h ieee80211_hw_flags
!Finclude/net/mac80211.h SET_IEEE80211_DEV
!Finclude/net/mac80211.h SET_IEEE80211_PERM_ADDR
!Finclude/net/mac80211.h ieee80211_ops
!Finclude/net/mac80211.h ieee80211_alloc_hw
!Finclude/net/mac80211.h ieee80211_register_hw
!Finclude/net/mac80211.h ieee80211_unregister_hw
!Finclude/net/mac80211.h ieee80211_free_hw
      </chapter>
          <chapter id="phy-handling">
            <title>PHY configuration</title>
            <para>TBD</para>
            <para>
          This chapter should describe PHY handling including
          start/stop callbacks and the various structures used.
        </para>
!Finclude/net/mac80211.h ieee80211_conf
!Finclude/net/mac80211.h ieee80211_conf_flags
      </chapter>
          <chapter id="iface-handling">
            <title>Virtual interfaces</title>
            <para>TBD</para>
            <para>
          This chapter should describe virtual interface basics
          that are relevant to the driver (VLANs, MGMT etc are not.)
          It should explain the use of the add_iface/remove_iface
          callbacks as well as the interface configuration callbacks.
        </para>
            <para>Things related to AP mode should be discussed there.</para>
            <para>
          Things related to supporting multiple interfaces should be
          in the appropriate chapter, a BIG FAT note should be here about
          this though and the recommendation to allow only a single
          interface in STA mode at first!
        </para>
!Finclude/net/mac80211.h ieee80211_vif
      </chapter>
          <chapter id="rx-tx">
            <title>Receive and transmit processing</title>
            <sect1>
              <title>what should be here</title>
              <para>TBD</para>
              <para>
            This should describe the receive and transmit
            paths in mac80211/the drivers as well as
            transmit status handling.
          </para>
            </sect1>
            <sect1>
              <title>Frame format</title>
!Pinclude/net/mac80211.h Frame format
        </sect1>
            <sect1>
              <title>Packet alignment</title>
!Pnet/mac80211/rx.c Packet alignment
        </sect1>
            <sect1>
              <title>Calling into mac80211 from interrupts</title>
!Pinclude/net/mac80211.h Calling mac80211 from interrupts
        </sect1>
            <sect1>
              <title>functions/definitions</title>
!Finclude/net/mac80211.h ieee80211_rx_status
!Finclude/net/mac80211.h mac80211_rx_flags
!Finclude/net/mac80211.h mac80211_tx_info_flags
!Finclude/net/mac80211.h mac80211_tx_control_flags
!Finclude/net/mac80211.h mac80211_rate_control_flags
!Finclude/net/mac80211.h ieee80211_tx_rate
!Finclude/net/mac80211.h ieee80211_tx_info
!Finclude/net/mac80211.h ieee80211_tx_info_clear_status
!Finclude/net/mac80211.h ieee80211_rx
!Finclude/net/mac80211.h ieee80211_rx_ni
!Finclude/net/mac80211.h ieee80211_rx_irqsafe
!Finclude/net/mac80211.h ieee80211_tx_status
!Finclude/net/mac80211.h ieee80211_tx_status_ni
!Finclude/net/mac80211.h ieee80211_tx_status_irqsafe
!Finclude/net/mac80211.h ieee80211_rts_get
!Finclude/net/mac80211.h ieee80211_rts_duration
!Finclude/net/mac80211.h ieee80211_ctstoself_get
!Finclude/net/mac80211.h ieee80211_ctstoself_duration
!Finclude/net/mac80211.h ieee80211_generic_frame_duration
!Finclude/net/mac80211.h ieee80211_wake_queue
!Finclude/net/mac80211.h ieee80211_stop_queue
!Finclude/net/mac80211.h ieee80211_wake_queues
!Finclude/net/mac80211.h ieee80211_stop_queues
!Finclude/net/mac80211.h ieee80211_queue_stopped
        </sect1>
          </chapter>
          <chapter id="filters">
            <title>Frame filtering</title>
!Pinclude/net/mac80211.h Frame filtering
!Finclude/net/mac80211.h ieee80211_filter_flags
      </chapter>
          <chapter id="workqueue">
            <title>The mac80211 workqueue</title>
!Pinclude/net/mac80211.h mac80211 workqueue
!Finclude/net/mac80211.h ieee80211_queue_work
!Finclude/net/mac80211.h ieee80211_queue_delayed_work
      </chapter>
        </part>
        <part id="advanced">
          <title>Advanced driver interface</title>
          <partintro>
            <para>
         Information contained within this part of the book is
         of interest only for advanced interaction of mac80211
         with drivers to exploit more hardware capabilities and
         improve performance.
        </para>
          </partintro>
          <chapter id="led-support">
            <title>LED support</title>
            <para>
         Mac80211 supports various ways of blinking LEDs. Wherever possible,
         device LEDs should be exposed as LED class devices and hooked up to
         the appropriate trigger, which will then be triggered appropriately
         by mac80211.
        </para>
!Finclude/net/mac80211.h ieee80211_get_tx_led_name
!Finclude/net/mac80211.h ieee80211_get_rx_led_name
!Finclude/net/mac80211.h ieee80211_get_assoc_led_name
!Finclude/net/mac80211.h ieee80211_get_radio_led_name
!Finclude/net/mac80211.h ieee80211_tpt_blink
!Finclude/net/mac80211.h ieee80211_tpt_led_trigger_flags
!Finclude/net/mac80211.h ieee80211_create_tpt_led_trigger
      </chapter>
          <chapter id="hardware-crypto-offload">
            <title>Hardware crypto acceleration</title>
!Pinclude/net/mac80211.h Hardware crypto acceleration
  <!-- intentionally multiple !F lines to get proper order -->
!Finclude/net/mac80211.h set_key_cmd
!Finclude/net/mac80211.h ieee80211_key_conf
!Finclude/net/mac80211.h ieee80211_key_flags
!Finclude/net/mac80211.h ieee80211_get_tkip_p1k
!Finclude/net/mac80211.h ieee80211_get_tkip_p1k_iv
!Finclude/net/mac80211.h ieee80211_get_tkip_p2k
      </chapter>
          <chapter id="powersave">
            <title>Powersave support</title>
!Pinclude/net/mac80211.h Powersave support
      </chapter>
          <chapter id="beacon-filter">
            <title>Beacon filter support</title>
!Pinclude/net/mac80211.h Beacon filter support
!Finclude/net/mac80211.h ieee80211_beacon_loss
      </chapter>
          <chapter id="qos">
            <title>Multiple queues and QoS support</title>
            <para>TBD</para>
!Finclude/net/mac80211.h ieee80211_tx_queue_params
      </chapter>
          <chapter id="AP">
            <title>Access point mode support</title>
            <para>TBD</para>
            <para>Some parts of the if_conf should be discussed here instead</para>
            <para>
          Insert notes about VLAN interfaces with hw crypto here or
          in the hw crypto chapter.
        </para>
            <section id="ps-client">
              <title>support for powersaving clients</title>
!Pinclude/net/mac80211.h AP support for powersaving clients
      </section>
!Finclude/net/mac80211.h ieee80211_get_buffered_bc
!Finclude/net/mac80211.h ieee80211_beacon_get
!Finclude/net/mac80211.h ieee80211_sta_eosp
!Finclude/net/mac80211.h ieee80211_frame_release_type
!Finclude/net/mac80211.h ieee80211_sta_ps_transition
!Finclude/net/mac80211.h ieee80211_sta_ps_transition_ni
!Finclude/net/mac80211.h ieee80211_sta_set_buffered
!Finclude/net/mac80211.h ieee80211_sta_block_awake
      </chapter>
          <chapter id="multi-iface">
            <title>Supporting multiple virtual interfaces</title>
            <para>TBD</para>
            <para>
          Note: WDS with identical MAC address should almost always be OK
        </para>
            <para>
          Insert notes about having multiple virtual interfaces with
          different MAC addresses here, note which configurations are
          supported by mac80211, add notes about supporting hw crypto
          with it.
        </para>
!Finclude/net/mac80211.h ieee80211_iterate_active_interfaces
!Finclude/net/mac80211.h ieee80211_iterate_active_interfaces_atomic
      </chapter>
          <chapter id="station-handling">
            <title>Station handling</title>
            <para>TODO</para>
!Finclude/net/mac80211.h ieee80211_sta
!Finclude/net/mac80211.h sta_notify_cmd
!Finclude/net/mac80211.h ieee80211_find_sta
!Finclude/net/mac80211.h ieee80211_find_sta_by_ifaddr
      </chapter>
          <chapter id="hardware-scan-offload">
            <title>Hardware scan offload</title>
            <para>TBD</para>
!Finclude/net/mac80211.h ieee80211_scan_completed
      </chapter>
          <chapter id="aggregation">
            <title>Aggregation</title>
            <sect1>
              <title>TX A-MPDU aggregation</title>
!Pnet/mac80211/agg-tx.c TX A-MPDU aggregation
!Cnet/mac80211/agg-tx.c
        </sect1>
            <sect1>
              <title>RX A-MPDU aggregation</title>
!Pnet/mac80211/agg-rx.c RX A-MPDU aggregation
!Cnet/mac80211/agg-rx.c
        </sect1>
!Finclude/net/mac80211.h ieee80211_ampdu_mlme_action
      </chapter>
          <chapter id="smps">
            <title>Spatial Multiplexing Powersave (SMPS)</title>
!Pinclude/net/mac80211.h Spatial multiplexing power save
!Finclude/net/mac80211.h ieee80211_request_smps
!Finclude/net/mac80211.h ieee80211_smps_mode
      </chapter>
        </part>
        <part id="rate-control">
          <title>Rate control interface</title>
          <partintro>
            <para>TBD</para>
            <para>
         This part of the book describes the rate control algorithm
         interface and how it relates to mac80211 and drivers.
        </para>
          </partintro>
          <chapter id="ratecontrol-api">
            <title>Rate Control API</title>
            <para>TBD</para>
!Finclude/net/mac80211.h ieee80211_start_tx_ba_session
!Finclude/net/mac80211.h ieee80211_start_tx_ba_cb_irqsafe
!Finclude/net/mac80211.h ieee80211_stop_tx_ba_session
!Finclude/net/mac80211.h ieee80211_stop_tx_ba_cb_irqsafe
!Finclude/net/mac80211.h ieee80211_rate_control_changed
!Finclude/net/mac80211.h ieee80211_tx_rate_control
!Finclude/net/mac80211.h rate_control_send_low
      </chapter>
        </part>
        <part id="internal">
          <title>Internals</title>
          <partintro>
            <para>TBD</para>
            <para>
         This part of the book describes mac80211 internals.
        </para>
          </partintro>
          <chapter id="key-handling">
            <title>Key handling</title>
            <sect1>
              <title>Key handling basics</title>
!Pnet/mac80211/key.c Key handling basics
        </sect1>
            <sect1>
              <title>MORE TBD</title>
              <para>TBD</para>
            </sect1>
          </chapter>
          <chapter id="rx-processing">
            <title>Receive processing</title>
            <para>TBD</para>
          </chapter>
          <chapter id="tx-processing">
            <title>Transmit processing</title>
            <para>TBD</para>
          </chapter>
          <chapter id="sta-info">
            <title>Station info handling</title>
            <sect1>
              <title>Programming information</title>
!Fnet/mac80211/sta_info.h sta_info
!Fnet/mac80211/sta_info.h ieee80211_sta_info_flags
        </sect1>
            <sect1>
              <title>STA information lifetime rules</title>
!Pnet/mac80211/sta_info.c STA information lifetime rules
        </sect1>
          </chapter>
          <chapter id="aggregation-internals">
            <title>Aggregation</title>
!Fnet/mac80211/sta_info.h sta_ampdu_mlme
!Fnet/mac80211/sta_info.h tid_ampdu_tx
!Fnet/mac80211/sta_info.h tid_ampdu_rx
      </chapter>
          <chapter id="synchronisation">
            <title>Synchronisation</title>
            <para>TBD</para>
            <para>Locking, lots of RCU</para>
          </chapter>
        </part>
      </book>
    </set>
    <!-- ****************************************************** -->
    <!-- Header  -->
    <!-- ****************************************************** -->
    <book id="ALSA-Driver-API">
      <bookinfo>
        <title>The ALSA Driver API</title>
        <legalnotice>
          <para>
    This document is free; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version. 
    </para>
          <para>
    This document is distributed in the hope that it will be useful,
    but <emphasis>WITHOUT ANY WARRANTY</emphasis>; without even the
    implied warranty of <emphasis>MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE</emphasis>. See the GNU General Public License
    for more details.
    </para>
          <para>
    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
    MA 02111-1307 USA
    </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter>
        <title>Management of Cards and Devices</title>
        <sect1>
          <title>Card Management</title>
!Esound/core/init.c
     </sect1>
        <sect1>
          <title>Device Components</title>
!Esound/core/device.c
     </sect1>
        <sect1>
          <title>Module requests and Device File Entries</title>
!Esound/core/sound.c
     </sect1>
        <sect1>
          <title>Memory Management Helpers</title>
!Esound/core/memory.c
!Esound/core/memalloc.c
     </sect1>
      </chapter>
      <chapter>
        <title>PCM API</title>
        <sect1>
          <title>PCM Core</title>
!Esound/core/pcm.c
!Esound/core/pcm_lib.c
!Esound/core/pcm_native.c
     </sect1>
        <sect1>
          <title>PCM Format Helpers</title>
!Esound/core/pcm_misc.c
     </sect1>
        <sect1>
          <title>PCM Memory Management</title>
!Esound/core/pcm_memory.c
     </sect1>
      </chapter>
      <chapter>
        <title>Control/Mixer API</title>
        <sect1>
          <title>General Control Interface</title>
!Esound/core/control.c
     </sect1>
        <sect1>
          <title>AC97 Codec API</title>
!Esound/pci/ac97/ac97_codec.c
!Esound/pci/ac97/ac97_pcm.c
     </sect1>
        <sect1>
          <title>Virtual Master Control API</title>
!Esound/core/vmaster.c
!Iinclude/sound/control.h
     </sect1>
      </chapter>
      <chapter>
        <title>MIDI API</title>
        <sect1>
          <title>Raw MIDI API</title>
!Esound/core/rawmidi.c
     </sect1>
        <sect1>
          <title>MPU401-UART API</title>
!Esound/drivers/mpu401/mpu401_uart.c
     </sect1>
      </chapter>
      <chapter>
        <title>Proc Info API</title>
        <sect1>
          <title>Proc Info Interface</title>
!Esound/core/info.c
     </sect1>
      </chapter>
      <chapter>
        <title>Miscellaneous Functions</title>
        <sect1>
          <title>Hardware-Dependent Devices API</title>
!Esound/core/hwdep.c
     </sect1>
        <sect1>
          <title>Jack Abstraction Layer API</title>
!Esound/core/jack.c
     </sect1>
        <sect1>
          <title>ISA DMA Helpers</title>
!Esound/core/isadma.c
     </sect1>
        <sect1>
          <title>Other Helper Macros</title>
!Iinclude/sound/core.h
     </sect1>
      </chapter>
    </book>
    <book id="debug-objects-guide">
      <bookinfo>
        <title>Debug objects life time</title>
        <authorgroup>
          <author>
            <firstname>Thomas</firstname>
            <surname>Gleixner</surname>
            <affiliation>
              <address>
                <email>tglx@linutronix.de</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2008</year>
          <holder>Thomas Gleixner</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
      debugobjects is a generic infrastructure to track the life time
      of kernel objects and validate the operations on those.
    </para>
        <para>
      debugobjects is useful to check for the following error patterns:
	<itemizedlist><listitem><para>Activation of uninitialized objects</para></listitem><listitem><para>Initialization of active objects</para></listitem><listitem><para>Usage of freed/destroyed objects</para></listitem></itemizedlist></para>
        <para>
      debugobjects is not changing the data structure of the real
      object so it can be compiled in with a minimal runtime impact
      and enabled on demand with a kernel command line option.
    </para>
      </chapter>
      <chapter id="howto">
        <title>Howto use debugobjects</title>
        <para>
      A kernel subsystem needs to provide a data structure which
      describes the object type and add calls into the debug code at
      appropriate places. The data structure to describe the object
      type needs at minimum the name of the object type. Optional
      functions can and should be provided to fixup detected problems
      so the kernel can continue to work and the debug information can
      be retrieved from a live system instead of hard core debugging
      with serial consoles and stack trace transcripts from the
      monitor.
    </para>
        <para>
      The debug calls provided by debugobjects are:
      <itemizedlist><listitem><para>debug_object_init</para></listitem><listitem><para>debug_object_init_on_stack</para></listitem><listitem><para>debug_object_activate</para></listitem><listitem><para>debug_object_deactivate</para></listitem><listitem><para>debug_object_destroy</para></listitem><listitem><para>debug_object_free</para></listitem><listitem><para>debug_object_assert_init</para></listitem></itemizedlist>
      Each of these functions takes the address of the real object and
      a pointer to the object type specific debug description
      structure.
    </para>
        <para>
      Each detected error is reported in the statistics and a limited
      number of errors are printk'ed including a full stack trace.
    </para>
        <para>
      The statistics are available via /sys/kernel/debug/debug_objects/stats.
      They provide information about the number of warnings and the
      number of successful fixups along with information about the
      usage of the internal tracking objects and the state of the
      internal tracking objects pool.
    </para>
      </chapter>
      <chapter id="debugfunctions">
        <title>Debug functions</title>
        <sect1 id="prototypes">
          <title>Debug object function reference</title>
!Elib/debugobjects.c
    </sect1>
        <sect1 id="debug_object_init">
          <title>debug_object_init</title>
          <para>
	This function is called whenever the initialization function
	of a real object is called.
      </para>
          <para>
	When the real object is already tracked by debugobjects it is
	checked, whether the object can be initialized.  Initializing
	is not allowed for active and destroyed objects. When
	debugobjects detects an error, then it calls the fixup_init
	function of the object type description structure if provided
	by the caller. The fixup function can correct the problem
	before the real initialization of the object happens. E.g. it
	can deactivate an active object in order to prevent damage to
	the subsystem.
      </para>
          <para>
	When the real object is not yet tracked by debugobjects,
	debugobjects allocates a tracker object for the real object
	and sets the tracker object state to ODEBUG_STATE_INIT. It
	verifies that the object is not on the callers stack. If it is
	on the callers stack then a limited number of warnings
	including a full stack trace is printk'ed. The calling code
	must use debug_object_init_on_stack() and remove the object
	before leaving the function which allocated it. See next
	section.
      </para>
        </sect1>
        <sect1 id="debug_object_init_on_stack">
          <title>debug_object_init_on_stack</title>
          <para>
	This function is called whenever the initialization function
	of a real object which resides on the stack is called.
      </para>
          <para>
	When the real object is already tracked by debugobjects it is
	checked, whether the object can be initialized. Initializing
	is not allowed for active and destroyed objects. When
	debugobjects detects an error, then it calls the fixup_init
	function of the object type description structure if provided
	by the caller. The fixup function can correct the problem
	before the real initialization of the object happens. E.g. it
	can deactivate an active object in order to prevent damage to
	the subsystem.
      </para>
          <para>
	When the real object is not yet tracked by debugobjects
	debugobjects allocates a tracker object for the real object
	and sets the tracker object state to ODEBUG_STATE_INIT. It
	verifies that the object is on the callers stack.
      </para>
          <para>
	An object which is on the stack must be removed from the
	tracker by calling debug_object_free() before the function
	which allocates the object returns. Otherwise we keep track of
	stale objects.
      </para>
        </sect1>
        <sect1 id="debug_object_activate">
          <title>debug_object_activate</title>
          <para>
	This function is called whenever the activation function of a
	real object is called.
      </para>
          <para>
	When the real object is already tracked by debugobjects it is
	checked, whether the object can be activated.  Activating is
	not allowed for active and destroyed objects. When
	debugobjects detects an error, then it calls the
	fixup_activate function of the object type description
	structure if provided by the caller. The fixup function can
	correct the problem before the real activation of the object
	happens. E.g. it can deactivate an active object in order to
	prevent damage to the subsystem.
      </para>
          <para>
	When the real object is not yet tracked by debugobjects then
	the fixup_activate function is called if available. This is
	necessary to allow the legitimate activation of statically
	allocated and initialized objects. The fixup function checks
	whether the object is valid and calls the debug_objects_init()
	function to initialize the tracking of this object.
      </para>
          <para>
	When the activation is legitimate, then the state of the
	associated tracker object is set to ODEBUG_STATE_ACTIVE.
      </para>
        </sect1>
        <sect1 id="debug_object_deactivate">
          <title>debug_object_deactivate</title>
          <para>
	This function is called whenever the deactivation function of
	a real object is called.
      </para>
          <para>
	When the real object is tracked by debugobjects it is checked,
	whether the object can be deactivated. Deactivating is not
	allowed for untracked or destroyed objects.
      </para>
          <para>
	When the deactivation is legitimate, then the state of the
	associated tracker object is set to ODEBUG_STATE_INACTIVE.
      </para>
        </sect1>
        <sect1 id="debug_object_destroy">
          <title>debug_object_destroy</title>
          <para>
	This function is called to mark an object destroyed. This is
	useful to prevent the usage of invalid objects, which are
	still available in memory: either statically allocated objects
	or objects which are freed later.
      </para>
          <para>
	When the real object is tracked by debugobjects it is checked,
	whether the object can be destroyed. Destruction is not
	allowed for active and destroyed objects. When debugobjects
	detects an error, then it calls the fixup_destroy function of
	the object type description structure if provided by the
	caller. The fixup function can correct the problem before the
	real destruction of the object happens. E.g. it can deactivate
	an active object in order to prevent damage to the subsystem.
      </para>
          <para>
	When the destruction is legitimate, then the state of the
	associated tracker object is set to ODEBUG_STATE_DESTROYED.
      </para>
        </sect1>
        <sect1 id="debug_object_free">
          <title>debug_object_free</title>
          <para>
	This function is called before an object is freed.
      </para>
          <para>
	When the real object is tracked by debugobjects it is checked,
	whether the object can be freed. Free is not allowed for
	active objects. When debugobjects detects an error, then it
	calls the fixup_free function of the object type description
	structure if provided by the caller. The fixup function can
	correct the problem before the real free of the object
	happens. E.g. it can deactivate an active object in order to
	prevent damage to the subsystem.
      </para>
          <para>
	Note that debug_object_free removes the object from the
	tracker. Later usage of the object is detected by the other
	debug checks.
      </para>
        </sect1>
        <sect1 id="debug_object_assert_init">
          <title>debug_object_assert_init</title>
          <para>
	This function is called to assert that an object has been
	initialized.
      </para>
          <para>
	When the real object is not tracked by debugobjects, it calls
	fixup_assert_init of the object type description structure
	provided by the caller, with the hardcoded object state
	ODEBUG_NOT_AVAILABLE. The fixup function can correct the problem
	by calling debug_object_init and other specific initializing
	functions.
      </para>
          <para>
	When the real object is already tracked by debugobjects it is
	ignored.
      </para>
        </sect1>
      </chapter>
      <chapter id="fixupfunctions">
        <title>Fixup functions</title>
        <sect1 id="debug_obj_descr">
          <title>Debug object type description structure</title>
!Iinclude/linux/debugobjects.h
    </sect1>
        <sect1 id="fixup_init">
          <title>fixup_init</title>
          <para>
	This function is called from the debug code whenever a problem
	in debug_object_init is detected. The function takes the
	address of the object and the state which is currently
	recorded in the tracker.
      </para>
          <para>
	Called from debug_object_init when the object state is:
	<itemizedlist><listitem><para>ODEBUG_STATE_ACTIVE</para></listitem></itemizedlist></para>
          <para>
	The function returns 1 when the fixup was successful,
	otherwise 0. The return value is used to update the
	statistics.
      </para>
          <para>
	Note, that the function needs to call the debug_object_init()
	function again, after the damage has been repaired in order to
	keep the state consistent.
      </para>
        </sect1>
        <sect1 id="fixup_activate">
          <title>fixup_activate</title>
          <para>
	This function is called from the debug code whenever a problem
	in debug_object_activate is detected.
      </para>
          <para>
	Called from debug_object_activate when the object state is:
	<itemizedlist><listitem><para>ODEBUG_STATE_NOTAVAILABLE</para></listitem><listitem><para>ODEBUG_STATE_ACTIVE</para></listitem></itemizedlist></para>
          <para>
	The function returns 1 when the fixup was successful,
	otherwise 0. The return value is used to update the
	statistics.
      </para>
          <para>
	Note that the function needs to call the debug_object_activate()
	function again after the damage has been repaired in order to
	keep the state consistent.
      </para>
          <para>
	The activation of statically initialized objects is a special
	case. When debug_object_activate() has no tracked object for
	this object address then fixup_activate() is called with
	object state ODEBUG_STATE_NOTAVAILABLE. The fixup function
	needs to check whether this is a legitimate case of a
	statically initialized object or not. In case it is it calls
	debug_object_init() and debug_object_activate() to make the
	object known to the tracker and marked active. In this case
	the function should return 0 because this is not a real fixup.
      </para>
        </sect1>
        <sect1 id="fixup_destroy">
          <title>fixup_destroy</title>
          <para>
	This function is called from the debug code whenever a problem
	in debug_object_destroy is detected.
      </para>
          <para>
	Called from debug_object_destroy when the object state is:
	<itemizedlist><listitem><para>ODEBUG_STATE_ACTIVE</para></listitem></itemizedlist></para>
          <para>
	The function returns 1 when the fixup was successful,
	otherwise 0. The return value is used to update the
	statistics.
      </para>
        </sect1>
        <sect1 id="fixup_free">
          <title>fixup_free</title>
          <para>
	This function is called from the debug code whenever a problem
	in debug_object_free is detected. Further it can be called
	from the debug checks in kfree/vfree, when an active object is
	detected from the debug_check_no_obj_freed() sanity checks.
      </para>
          <para>
	Called from debug_object_free() or debug_check_no_obj_freed()
	when the object state is:
	<itemizedlist><listitem><para>ODEBUG_STATE_ACTIVE</para></listitem></itemizedlist></para>
          <para>
	The function returns 1 when the fixup was successful,
	otherwise 0. The return value is used to update the
	statistics.
      </para>
        </sect1>
        <sect1 id="fixup_assert_init">
          <title>fixup_assert_init</title>
          <para>
	This function is called from the debug code whenever a problem
	in debug_object_assert_init is detected.
      </para>
          <para>
	Called from debug_object_assert_init() with a hardcoded state
	ODEBUG_STATE_NOTAVAILABLE when the object is not found in the
	debug bucket.
      </para>
          <para>
	The function returns 1 when the fixup was successful,
	otherwise 0. The return value is used to update the
	statistics.
      </para>
          <para>
	Note, this function should make sure debug_object_init() is
	called before returning.
      </para>
          <para>
	The handling of statically initialized objects is a special
	case. The fixup function should check if this is a legitimate
	case of a statically initialized object or not. In this case only
	debug_object_init() should be called to make the object known to
	the tracker. Then the function should return 0 because this is not
	a real fixup.
      </para>
        </sect1>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs And Assumptions</title>
        <para>
	None (knock on wood).
    </para>
      </chapter>
    </book>
    <book id="LinuxDriversAPI">
      <bookinfo>
        <title>Linux Device Drivers</title>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="Basics">
        <title>Driver Basics</title>
        <sect1>
          <title>Driver Entry and Exit points</title>
!Iinclude/linux/init.h
     </sect1>
        <sect1>
          <title>Atomic and pointer manipulation</title>
!Iarch/x86/include/asm/atomic.h
     </sect1>
        <sect1>
          <title>Delaying, scheduling, and timer routines</title>
!Iinclude/linux/sched.h
!Ekernel/sched/core.c
!Ikernel/sched/cpupri.c
!Ikernel/sched/fair.c
!Iinclude/linux/completion.h
!Ekernel/timer.c
     </sect1>
        <sect1>
          <title>Wait queues and Wake events</title>
!Iinclude/linux/wait.h
!Ekernel/sched/wait.c
     </sect1>
        <sect1>
          <title>High-resolution timers</title>
!Iinclude/linux/ktime.h
!Iinclude/linux/hrtimer.h
!Ekernel/hrtimer.c
     </sect1>
        <sect1>
          <title>Workqueues and Kevents</title>
!Ekernel/workqueue.c
     </sect1>
        <sect1>
          <title>Internal Functions</title>
!Ikernel/exit.c
!Ikernel/signal.c
!Iinclude/linux/kthread.h
!Ekernel/kthread.c
     </sect1>
        <sect1>
          <title>Kernel objects manipulation</title>
          <!--
X!Iinclude/linux/kobject.h
-->
!Elib/kobject.c
     </sect1>
        <sect1>
          <title>Kernel utility functions</title>
!Iinclude/linux/kernel.h
!Ekernel/printk/printk.c
!Ekernel/panic.c
!Ekernel/sys.c
!Ekernel/rcu/srcu.c
!Ekernel/rcu/tree.c
!Ekernel/rcu/tree_plugin.h
!Ekernel/rcu/update.c
     </sect1>
        <sect1>
          <title>Device Resource Management</title>
!Edrivers/base/devres.c
     </sect1>
      </chapter>
      <chapter id="devdrivers">
        <title>Device drivers infrastructure</title>
        <sect1>
          <title>The Basic Device Driver-Model Structures </title>
!Iinclude/linux/device.h
     </sect1>
        <sect1>
          <title>Device Drivers Base</title>
!Idrivers/base/init.c
!Edrivers/base/driver.c
!Edrivers/base/core.c
!Edrivers/base/syscore.c
!Edrivers/base/class.c
!Idrivers/base/node.c
!Edrivers/base/firmware_class.c
!Edrivers/base/transport_class.c
<!-- Cannot be included, because
     attribute_container_add_class_device_adapter
 and attribute_container_classdev_to_container
     exceed allowed 44 characters maximum
X!Edrivers/base/attribute_container.c
-->
!Edrivers/base/dd.c
<!--
X!Edrivers/base/interface.c
-->
!Iinclude/linux/platform_device.h
!Edrivers/base/platform.c
!Edrivers/base/bus.c
     </sect1>
        <sect1>
          <title>Device Drivers DMA Management</title>
!Edrivers/base/dma-buf.c
!Edrivers/base/reservation.c
!Iinclude/linux/reservation.h
!Edrivers/base/dma-coherent.c
!Edrivers/base/dma-mapping.c
     </sect1>
        <sect1>
          <title>Device Drivers Power Management</title>
!Edrivers/base/power/main.c
     </sect1>
        <sect1>
          <title>Device Drivers ACPI Support</title>
          <!-- Internal functions only
X!Edrivers/acpi/sleep/main.c
X!Edrivers/acpi/sleep/wakeup.c
X!Edrivers/acpi/motherboard.c
X!Edrivers/acpi/bus.c
-->
!Edrivers/acpi/scan.c
!Idrivers/acpi/scan.c
<!-- No correct structured comments
X!Edrivers/acpi/pci_bind.c
--></sect1>
        <sect1>
          <title>Device drivers PnP support</title>
!Idrivers/pnp/core.c
<!-- No correct structured comments
X!Edrivers/pnp/system.c
 -->
!Edrivers/pnp/card.c
!Idrivers/pnp/driver.c
!Edrivers/pnp/manager.c
!Edrivers/pnp/support.c
     </sect1>
        <sect1>
          <title>Userspace IO devices</title>
!Edrivers/uio/uio.c
!Iinclude/linux/uio_driver.h
     </sect1>
      </chapter>
      <chapter id="parportdev">
        <title>Parallel Port Devices</title>
!Iinclude/linux/parport.h
!Edrivers/parport/ieee1284.c
!Edrivers/parport/share.c
!Idrivers/parport/daisy.c
  </chapter>
      <chapter id="message_devices">
        <title>Message-based devices</title>
        <sect1>
          <title>Fusion message devices</title>
!Edrivers/message/fusion/mptbase.c
!Idrivers/message/fusion/mptbase.c
!Edrivers/message/fusion/mptscsih.c
!Idrivers/message/fusion/mptscsih.c
!Idrivers/message/fusion/mptctl.c
!Idrivers/message/fusion/mptspi.c
!Idrivers/message/fusion/mptfc.c
!Idrivers/message/fusion/mptlan.c
     </sect1>
        <sect1>
          <title>I2O message devices</title>
!Iinclude/linux/i2o.h
!Idrivers/message/i2o/core.h
!Edrivers/message/i2o/iop.c
!Idrivers/message/i2o/iop.c
!Idrivers/message/i2o/config-osm.c
!Edrivers/message/i2o/exec-osm.c
!Idrivers/message/i2o/exec-osm.c
!Idrivers/message/i2o/bus-osm.c
!Edrivers/message/i2o/device.c
!Idrivers/message/i2o/device.c
!Idrivers/message/i2o/driver.c
!Idrivers/message/i2o/pci.c
!Idrivers/message/i2o/i2o_block.c
!Idrivers/message/i2o/i2o_scsi.c
!Idrivers/message/i2o/i2o_proc.c
     </sect1>
      </chapter>
      <chapter id="snddev">
        <title>Sound Devices</title>
!Iinclude/sound/core.h
!Esound/sound_core.c
!Iinclude/sound/pcm.h
!Esound/core/pcm.c
!Esound/core/device.c
!Esound/core/info.c
!Esound/core/rawmidi.c
!Esound/core/sound.c
!Esound/core/memory.c
!Esound/core/pcm_memory.c
!Esound/core/init.c
!Esound/core/isadma.c
!Esound/core/control.c
!Esound/core/pcm_lib.c
!Esound/core/hwdep.c
!Esound/core/pcm_native.c
!Esound/core/memalloc.c
<!-- FIXME: Removed for now since no structured comments in source
X!Isound/sound_firmware.c
--></chapter>
      <chapter id="uart16x50">
        <title>16x50 UART Driver</title>
!Edrivers/tty/serial/serial_core.c
!Edrivers/tty/serial/8250/8250_core.c
  </chapter>
      <chapter id="fbdev">
        <title>Frame Buffer Library</title>
        <para>
       The frame buffer drivers depend heavily on four data structures.
       These structures are declared in include/linux/fb.h.  They are
       fb_info, fb_var_screeninfo, fb_fix_screeninfo and fb_monospecs.
       The last three can be made available to and from userland.
     </para>
        <para>
       fb_info defines the current state of a particular video card.
       Inside fb_info, there exists a fb_ops structure which is a
       collection of needed functions to make fbdev and fbcon work.
       fb_info is only visible to the kernel.
     </para>
        <para>
       fb_var_screeninfo is used to describe the features of a video card
       that are user defined.  With fb_var_screeninfo, things such as
       depth and the resolution may be defined.
     </para>
        <para>
       The next structure is fb_fix_screeninfo. This defines the
       properties of a card that are created when a mode is set and can't
       be changed otherwise.  A good example of this is the start of the
       frame buffer memory.  This "locks" the address of the frame buffer
       memory, so that it cannot be changed or moved.
     </para>
        <para>
       The last structure is fb_monospecs. In the old API, there was
       little importance for fb_monospecs. This allowed for forbidden things
       such as setting a mode of 800x600 on a fix frequency monitor. With
       the new API, fb_monospecs prevents such things, and if used
       correctly, can prevent a monitor from being cooked.  fb_monospecs
       will not be useful until kernels 2.5.x.
     </para>
        <sect1>
          <title>Frame Buffer Memory</title>
!Edrivers/video/fbmem.c
     </sect1>
        <!--
     <sect1><title>Frame Buffer Console</title>
X!Edrivers/video/console/fbcon.c
     </sect1>
-->
        <sect1>
          <title>Frame Buffer Colormap</title>
!Edrivers/video/fbcmap.c
     </sect1>
        <!-- FIXME:
  drivers/video/fbgen.c has no docs, which stuffs up the sgml.  Comment
  out until somebody adds docs.  KAO
     <sect1><title>Frame Buffer Generic Functions</title>
X!Idrivers/video/fbgen.c
     </sect1>
KAO -->
        <sect1>
          <title>Frame Buffer Video Mode Database</title>
!Idrivers/video/modedb.c
!Edrivers/video/modedb.c
     </sect1>
        <sect1>
          <title>Frame Buffer Macintosh Video Mode Database</title>
!Edrivers/video/macmodes.c
     </sect1>
        <sect1>
          <title>Frame Buffer Fonts</title>
          <para>
           Refer to the file lib/fonts/fonts.c for more information.
        </para>
          <!-- FIXME: Removed for now since no structured comments in source
X!Ilib/fonts/fonts.c
-->
        </sect1>
      </chapter>
      <chapter id="input_subsystem">
        <title>Input Subsystem</title>
        <sect1>
          <title>Input core</title>
!Iinclude/linux/input.h
!Edrivers/input/input.c
!Edrivers/input/ff-core.c
!Edrivers/input/ff-memless.c
     </sect1>
        <sect1>
          <title>Multitouch Library</title>
!Iinclude/linux/input/mt.h
!Edrivers/input/input-mt.c
     </sect1>
        <sect1>
          <title>Polled input devices</title>
!Iinclude/linux/input-polldev.h
!Edrivers/input/input-polldev.c
     </sect1>
        <sect1>
          <title>Matrix keyboars/keypads</title>
!Iinclude/linux/input/matrix_keypad.h
     </sect1>
        <sect1>
          <title>Sparse keymap support</title>
!Iinclude/linux/input/sparse-keymap.h
!Edrivers/input/sparse-keymap.c
     </sect1>
      </chapter>
      <chapter id="spi">
        <title>Serial Peripheral Interface (SPI)</title>
        <para>
	SPI is the "Serial Peripheral Interface", widely used with
	embedded systems because it is a simple and efficient
	interface:  basically a multiplexed shift register.
	Its three signal wires hold a clock (SCK, often in the range
	of 1-20 MHz), a "Master Out, Slave In" (MOSI) data line, and
	a "Master In, Slave Out" (MISO) data line.
	SPI is a full duplex protocol; for each bit shifted out the
	MOSI line (one per clock) another is shifted in on the MISO line.
	Those bits are assembled into words of various sizes on the
	way to and from system memory.
	An additional chipselect line is usually active-low (nCS);
	four signals are normally used for each peripheral, plus
	sometimes an interrupt.
  </para>
        <para>
	The SPI bus facilities listed here provide a generalized
	interface to declare SPI busses and devices, manage them
	according to the standard Linux driver model, and perform
	input/output operations.
	At this time, only "master" side interfaces are supported,
	where Linux talks to SPI peripherals and does not implement
	such a peripheral itself.
	(Interfaces to support implementing SPI slaves would
	necessarily look different.)
  </para>
        <para>
	The programming interface is structured around two kinds of driver,
	and two kinds of device.
	A "Controller Driver" abstracts the controller hardware, which may
	be as simple as a set of GPIO pins or as complex as a pair of FIFOs
	connected to dual DMA engines on the other side of the SPI shift
	register (maximizing throughput).  Such drivers bridge between
	whatever bus they sit on (often the platform bus) and SPI, and
	expose the SPI side of their device as a
	<structname>struct spi_master</structname>.
	SPI devices are children of that master, represented as a
	<structname>struct spi_device</structname> and manufactured from
	<structname>struct spi_board_info</structname> descriptors which
	are usually provided by board-specific initialization code.
	A <structname>struct spi_driver</structname> is called a
	"Protocol Driver", and is bound to a spi_device using normal
	driver model calls.
  </para>
        <para>
	The I/O model is a set of queued messages.  Protocol drivers
	submit one or more <structname>struct spi_message</structname>
	objects, which are processed and completed asynchronously.
	(There are synchronous wrappers, however.)  Messages are
	built from one or more <structname>struct spi_transfer</structname>
	objects, each of which wraps a full duplex SPI transfer.
	A variety of protocol tweaking options are needed, because
	different chips adopt very different policies for how they
	use the bits transferred with SPI.
  </para>
!Iinclude/linux/spi/spi.h
!Fdrivers/spi/spi.c spi_register_board_info
!Edrivers/spi/spi.c
  </chapter>
      <chapter id="i2c">
        <title>I<superscript>2</superscript>C and SMBus Subsystem</title>
        <para>
	I<superscript>2</superscript>C (or without fancy typography, "I2C")
	is an acronym for the "Inter-IC" bus, a simple bus protocol which is
	widely used where low data rate communications suffice.
	Since it's also a licensed trademark, some vendors use another
	name (such as "Two-Wire Interface", TWI) for the same bus.
	I2C only needs two signals (SCL for clock, SDA for data), conserving
	board real estate and minimizing signal quality issues.
	Most I2C devices use seven bit addresses, and bus speeds of up
	to 400 kHz; there's a high speed extension (3.4 MHz) that's not yet
	found wide use.
	I2C is a multi-master bus; open drain signaling is used to
	arbitrate between masters, as well as to handshake and to
	synchronize clocks from slower clients.
     </para>
        <para>
	The Linux I2C programming interfaces support only the master
	side of bus interactions, not the slave side.
	The programming interface is structured around two kinds of driver,
	and two kinds of device.
	An I2C "Adapter Driver" abstracts the controller hardware; it binds
	to a physical device (perhaps a PCI device or platform_device) and
	exposes a <structname>struct i2c_adapter</structname> representing
	each I2C bus segment it manages.
	On each I2C bus segment will be I2C devices represented by a
	<structname>struct i2c_client</structname>.  Those devices will
	be bound to a <structname>struct i2c_driver</structname>,
	which should follow the standard Linux driver model.
	(At this writing, a legacy model is more widely used.)
	There are functions to perform various I2C protocol operations; at
	this writing all such functions are usable only from task context.
     </para>
        <para>
	The System Management Bus (SMBus) is a sibling protocol.  Most SMBus
	systems are also I2C conformant.  The electrical constraints are
	tighter for SMBus, and it standardizes particular protocol messages
	and idioms.  Controllers that support I2C can also support most
	SMBus operations, but SMBus controllers don't support all the protocol
	options that an I2C controller will.
	There are functions to perform various SMBus protocol operations,
	either using I2C primitives or by issuing SMBus commands to
	i2c_adapter devices which don't support those I2C operations.
     </para>

!Iinclude/linux/i2c.h
!Fdrivers/i2c/i2c-boardinfo.c i2c_register_board_info
!Edrivers/i2c/i2c-core.c
  </chapter>
      <chapter id="hsi">
        <title>High Speed Synchronous Serial Interface (HSI)</title>
        <para>
	High Speed Synchronous Serial Interface (HSI) is a
	serial interface mainly used for connecting application
	engines (APE) with cellular modem engines (CMT) in cellular
	handsets.

	HSI provides multiplexing for up to 16 logical channels,
	low-latency and full duplex communication.
     </para>

!Iinclude/linux/hsi/hsi.h
!Edrivers/hsi/hsi.c
  </chapter>
    </book>
    <book id="DoingIO">
      <bookinfo>
        <title>Bus-Independent Device Accesses</title>
        <authorgroup>
          <author>
            <firstname>Matthew</firstname>
            <surname>Wilcox</surname>
            <affiliation>
              <address>
                <email>matthew@wil.cx</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <authorgroup>
          <author>
            <firstname>Alan</firstname>
            <surname>Cox</surname>
            <affiliation>
              <address>
                <email>alan@lxorguk.ukuu.org.uk</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2001</year>
          <holder>Matthew Wilcox</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
	Linux provides an API which abstracts performing IO across all busses
	and devices, allowing device drivers to be written independently of
	bus type.
  </para>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs And Assumptions</title>
        <para>
	None.	
  </para>
      </chapter>
      <chapter id="mmio">
        <title>Memory Mapped IO</title>
        <sect1 id="getting_access_to_the_device">
          <title>Getting Access to the Device</title>
          <para>
	The most widely supported form of IO is memory mapped IO.
	That is, a part of the CPU's address space is interpreted
	not as accesses to memory, but as accesses to a device.  Some
	architectures define devices to be at a fixed address, but most
	have some method of discovering devices.  The PCI bus walk is a
	good example of such a scheme.	This document does not cover how
	to receive such an address, but assumes you are starting with one.
	Physical addresses are of type unsigned long. 
      </para>
          <para>
	This address should not be used directly.  Instead, to get an
	address suitable for passing to the accessor functions described
	below, you should call <function>ioremap</function>.
	An address suitable for accessing the device will be returned to you.
      </para>
          <para>
	After you've finished using the device (say, in your module's
	exit routine), call <function>iounmap</function> in order to return
	the address space to the kernel.  Most architectures allocate new
	address space each time you call <function>ioremap</function>, and
	they can run out unless you call <function>iounmap</function>.
      </para>
        </sect1>
        <sect1 id="accessing_the_device">
          <title>Accessing the device</title>
          <para>
	The part of the interface most used by drivers is reading and
	writing memory-mapped registers on the device.	Linux provides
	interfaces to read and write 8-bit, 16-bit, 32-bit and 64-bit
	quantities.  Due to a historical accident, these are named byte,
	word, long and quad accesses.  Both read and write accesses are
	supported; there is no prefetch support at this time.
      </para>
          <para>
	The functions are named <function>readb</function>,
	<function>readw</function>, <function>readl</function>,
	<function>readq</function>, <function>readb_relaxed</function>,
	<function>readw_relaxed</function>, <function>readl_relaxed</function>,
	<function>readq_relaxed</function>, <function>writeb</function>,
	<function>writew</function>, <function>writel</function> and
	<function>writeq</function>.
      </para>
          <para>
	Some devices (such as framebuffers) would like to use larger
	transfers than 8 bytes at a time.  For these devices, the
	<function>memcpy_toio</function>, <function>memcpy_fromio</function>
	and <function>memset_io</function> functions are provided.
	Do not use memset or memcpy on IO addresses; they
	are not guaranteed to copy data in order.
      </para>
          <para>
	The read and write functions are defined to be ordered. That is the
	compiler is not permitted to reorder the I/O sequence. When the 
	ordering can be compiler optimised, you can use <function>
	__readb</function> and friends to indicate the relaxed ordering. Use 
	this with care.
      </para>
          <para>
	While the basic functions are defined to be synchronous with respect
	to each other and ordered with respect to each other the busses the
	devices sit on may themselves have asynchronicity. In particular many
	authors are burned by the fact that PCI bus writes are posted
	asynchronously. A driver author must issue a read from the same
	device to ensure that writes have occurred in the specific cases the
	author cares. This kind of property cannot be hidden from driver
	writers in the API.  In some cases, the read used to flush the device
	may be expected to fail (if the card is resetting, for example).  In
	that case, the read should be done from config space, which is
	guaranteed to soft-fail if the card doesn't respond.
      </para>
          <para>
	The following is an example of flushing a write to a device when
	the driver would like to ensure the write's effects are visible prior
	to continuing execution.
      </para>
          <programlisting>
static inline void
qla1280_disable_intrs(struct scsi_qla_host *ha)
{
	struct device_reg *reg;

	reg = ha-&gt;iobase;
	/* disable risc and host interrupts */
	WRT_REG_WORD(&amp;reg-&gt;ictrl, 0);
	/*
	 * The following read will ensure that the above write
	 * has been received by the device before we return from this
	 * function.
	 */
	RD_REG_WORD(&amp;reg-&gt;ictrl);
	ha-&gt;flags.ints_enabled = 0;
}
</programlisting>
          <para>
	In addition to write posting, on some large multiprocessing systems
	(e.g. SGI Challenge, Origin and Altix machines) posted writes won't
	be strongly ordered coming from different CPUs.  Thus it's important
	to properly protect parts of your driver that do memory-mapped writes
	with locks and use the <function>mmiowb</function> to make sure they
	arrive in the order intended.  Issuing a regular <function>readX
	</function> will also ensure write ordering, but should only be used
	when the driver has to be sure that the write has actually arrived
	at the device (not that it's simply ordered with respect to other
	writes), since a full <function>readX</function> is a relatively
	expensive operation.
      </para>
          <para>
	Generally, one should use <function>mmiowb</function> prior to
	releasing a spinlock that protects regions using <function>writeb
	</function> or similar functions that aren't surrounded by <function>
	readb</function> calls, which will ensure ordering and flushing.  The
	following pseudocode illustrates what might occur if write ordering
	isn't guaranteed via <function>mmiowb</function> or one of the
	<function>readX</function> functions.
      </para>
          <programlisting>
CPU A:  spin_lock_irqsave(&amp;dev_lock, flags)
CPU A:  ...
CPU A:  writel(newval, ring_ptr);
CPU A:  spin_unlock_irqrestore(&amp;dev_lock, flags)
        ...
CPU B:  spin_lock_irqsave(&amp;dev_lock, flags)
CPU B:  writel(newval2, ring_ptr);
CPU B:  ...
CPU B:  spin_unlock_irqrestore(&amp;dev_lock, flags)
</programlisting>
          <para>
	In the case above, newval2 could be written to ring_ptr before
	newval.  Fixing it is easy though:
      </para>
          <programlisting>
CPU A:  spin_lock_irqsave(&amp;dev_lock, flags)
CPU A:  ...
CPU A:  writel(newval, ring_ptr);
CPU A:  mmiowb(); /* ensure no other writes beat us to the device */
CPU A:  spin_unlock_irqrestore(&amp;dev_lock, flags)
        ...
CPU B:  spin_lock_irqsave(&amp;dev_lock, flags)
CPU B:  writel(newval2, ring_ptr);
CPU B:  ...
CPU B:  mmiowb();
CPU B:  spin_unlock_irqrestore(&amp;dev_lock, flags)
</programlisting>
          <para>
	See tg3.c for a real world example of how to use <function>mmiowb
	</function></para>
          <para>
	PCI ordering rules also guarantee that PIO read responses arrive
	after any outstanding DMA writes from that bus, since for some devices
	the result of a <function>readb</function> call may signal to the
	driver that a DMA transaction is complete.  In many cases, however,
	the driver may want to indicate that the next
	<function>readb</function> call has no relation to any previous DMA
	writes performed by the device.  The driver can use
	<function>readb_relaxed</function> for these cases, although only
	some platforms will honor the relaxed semantics.  Using the relaxed
	read functions will provide significant performance benefits on
	platforms that support it.  The qla2xxx driver provides examples
	of how to use <function>readX_relaxed</function>.  In many cases,
	a majority of the driver's <function>readX</function> calls can
	safely be converted to <function>readX_relaxed</function> calls, since
	only a few will indicate or depend on DMA completion.
      </para>
        </sect1>
      </chapter>
      <chapter id="port_space_accesses">
        <title>Port Space Accesses</title>
        <sect1 id="port_space_explained">
          <title>Port Space Explained</title>
          <para>
	Another form of IO commonly supported is Port Space.  This is a
	range of addresses separate to the normal memory address space.
	Access to these addresses is generally not as fast as accesses
	to the memory mapped addresses, and it also has a potentially
	smaller address space.
      </para>
          <para>
	Unlike memory mapped IO, no preparation is required
	to access port space.
      </para>
        </sect1>
        <sect1 id="accessing_port_space">
          <title>Accessing Port Space</title>
          <para>
	Accesses to this space are provided through a set of functions
	which allow 8-bit, 16-bit and 32-bit accesses; also
	known as byte, word and long.  These functions are
	<function>inb</function>, <function>inw</function>,
	<function>inl</function>, <function>outb</function>,
	<function>outw</function> and <function>outl</function>.
      </para>
          <para>
	Some variants are provided for these functions.  Some devices
	require that accesses to their ports are slowed down.  This
	functionality is provided by appending a <function>_p</function>
	to the end of the function.  There are also equivalents to memcpy.
	The <function>ins</function> and <function>outs</function>
	functions copy bytes, words or longs to the given port.
      </para>
        </sect1>
      </chapter>
      <chapter id="pubfunctions">
        <title>Public Functions Provided</title>
!Iarch/x86/include/asm/io.h
!Elib/pci_iomap.c
  </chapter>
    </book>
    <book id="drmDevelopersGuide">
      <bookinfo>
        <title>Linux DRM Developer's Guide</title>
        <authorgroup>
          <author>
            <firstname>Jesse</firstname>
            <surname>Barnes</surname>
            <contrib>Initial version</contrib>
            <affiliation>
              <orgname>Intel Corporation</orgname>
              <address>
                <email>jesse.barnes@intel.com</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>Laurent</firstname>
            <surname>Pinchart</surname>
            <contrib>Driver internals</contrib>
            <affiliation>
              <orgname>Ideas on board SPRL</orgname>
              <address>
                <email>laurent.pinchart@ideasonboard.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2008-2009</year>
          <year>2012</year>
          <holder>Intel Corporation</holder>
          <holder>Laurent Pinchart</holder>
        </copyright>
        <legalnotice>
          <para>
	The contents of this file may be used under the terms of the GNU
	General Public License version 2 (the "GPL") as distributed in
	the kernel source COPYING file.
      </para>
        </legalnotice>
        <revhistory>
          <!-- Put document revisions here, newest first. -->
          <revision>
            <revnumber>1.0</revnumber>
            <date>2012-07-13</date>
            <authorinitials>LP</authorinitials>
            <revremark>Added extensive documentation about driver internals.
	</revremark>
          </revision>
        </revhistory>
      </bookinfo>
      <toc>
      </toc>
      <!-- Introduction -->
      <chapter id="drmIntroduction">
        <title>Introduction</title>
        <para>
      The Linux DRM layer contains code intended to support the needs
      of complex graphics devices, usually containing programmable
      pipelines well suited to 3D graphics acceleration.  Graphics
      drivers in the kernel may make use of DRM functions to make
      tasks like memory management, interrupt handling and DMA easier,
      and provide a uniform interface to applications.
    </para>
        <para>
      A note on versions: this guide covers features found in the DRM
      tree, including the TTM memory manager, output configuration and
      mode setting, and the new vblank internals, in addition to all
      the regular features found in current kernels.
    </para>
        <para>
      [Insert diagram of typical DRM stack here]
    </para>
      </chapter>
      <!-- Internals -->
      <chapter id="drmInternals">
        <title>DRM Internals</title>
        <para>
      This chapter documents DRM internals relevant to driver authors
      and developers working to add support for the latest features to
      existing drivers.
    </para>
        <para>
      First, we go over some typical driver initialization
      requirements, like setting up command buffers, creating an
      initial output configuration, and initializing core services.
      Subsequent sections cover core internals in more detail,
      providing implementation notes and examples.
    </para>
        <para>
      The DRM layer provides several services to graphics drivers,
      many of them driven by the application interfaces it provides
      through libdrm, the library that wraps most of the DRM ioctls.
      These include vblank event handling, memory
      management, output management, framebuffer management, command
      submission &amp; fencing, suspend/resume support, and DMA
      services.
    </para>
        <!-- Internals: driver init -->
        <sect1>
          <title>Driver Initialization</title>
          <para>
      At the core of every DRM driver is a <structname>drm_driver</structname>
      structure. Drivers typically statically initialize a drm_driver structure,
      and then pass it to one of the <function>drm_*_init()</function> functions
      to register it with the DRM subsystem.
    </para>
          <para>
      The <structname>drm_driver</structname> structure contains static
      information that describes the driver and features it supports, and
      pointers to methods that the DRM core will call to implement the DRM API.
      We will first go through the <structname>drm_driver</structname> static
      information fields, and will then describe individual operations in
      details as they get used in later sections.
    </para>
          <sect2>
            <title>Driver Information</title>
            <sect3>
              <title>Driver Features</title>
              <para>
          Drivers inform the DRM core about their requirements and supported
          features by setting appropriate flags in the
          <structfield>driver_features</structfield> field. Since those flags
          influence the DRM core behaviour since registration time, most of them
          must be set to registering the <structname>drm_driver</structname>
          instance.
        </para>
              <synopsis>u32 driver_features;</synopsis>
              <variablelist>
                <title>Driver Feature Flags</title>
                <varlistentry>
                  <term>DRIVER_USE_AGP</term>
                  <listitem>
                    <para>
              Driver uses AGP interface, the DRM core will manage AGP resources.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_REQUIRE_AGP</term>
                  <listitem>
                    <para>
              Driver needs AGP interface to function. AGP initialization failure
              will become a fatal error.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_PCI_DMA</term>
                  <listitem>
                    <para>
              Driver is capable of PCI DMA, mapping of PCI DMA buffers to
              userspace will be enabled. Deprecated.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_SG</term>
                  <listitem>
                    <para>
              Driver can perform scatter/gather DMA, allocation and mapping of
              scatter/gather buffers will be enabled. Deprecated.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_HAVE_DMA</term>
                  <listitem>
                    <para>
              Driver supports DMA, the userspace DMA API will be supported.
              Deprecated.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_HAVE_IRQ</term>
                  <term>DRIVER_IRQ_SHARED</term>
                  <listitem>
                    <para>
              DRIVER_HAVE_IRQ indicates whether the driver has an IRQ handler
              managed by the DRM Core. The core will support simple IRQ handler
              installation when the flag is set. The installation process is
              described in <xref linkend="drm-irq-registration" />.</para>
                    <para>DRIVER_IRQ_SHARED indicates whether the device &amp; handler
              support shared IRQs (note that this is required of PCI  drivers).
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_GEM</term>
                  <listitem>
                    <para>
              Driver use the GEM memory manager.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_MODESET</term>
                  <listitem>
                    <para>
              Driver supports mode setting interfaces (KMS).
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_PRIME</term>
                  <listitem>
                    <para>
              Driver implements DRM PRIME buffer sharing.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>DRIVER_RENDER</term>
                  <listitem>
                    <para>
              Driver supports dedicated render nodes.
            </para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </sect3>
            <sect3>
              <title>Major, Minor and Patchlevel</title>
              <synopsis>int major;
int minor;
int patchlevel;</synopsis>
              <para>
          The DRM core identifies driver versions by a major, minor and patch
          level triplet. The information is printed to the kernel log at
          initialization time and passed to userspace through the
          DRM_IOCTL_VERSION ioctl.
        </para>
              <para>
          The major and minor numbers are also used to verify the requested driver
          API version passed to DRM_IOCTL_SET_VERSION. When the driver API changes
          between minor versions, applications can call DRM_IOCTL_SET_VERSION to
          select a specific version of the API. If the requested major isn't equal
          to the driver major, or the requested minor is larger than the driver
          minor, the DRM_IOCTL_SET_VERSION call will return an error. Otherwise
          the driver's set_version() method will be called with the requested
          version.
        </para>
            </sect3>
            <sect3>
              <title>Name, Description and Date</title>
              <synopsis>char *name;
char *desc;
char *date;</synopsis>
              <para>
          The driver name is printed to the kernel log at initialization time,
          used for IRQ registration and passed to userspace through
          DRM_IOCTL_VERSION.
        </para>
              <para>
          The driver description is a purely informative string passed to
          userspace through the DRM_IOCTL_VERSION ioctl and otherwise unused by
          the kernel.
        </para>
              <para>
          The driver date, formatted as YYYYMMDD, is meant to identify the date of
          the latest modification to the driver. However, as most drivers fail to
          update it, its value is mostly useless. The DRM core prints it to the
          kernel log at initialization time and passes it to userspace through the
          DRM_IOCTL_VERSION ioctl.
        </para>
            </sect3>
          </sect2>
          <sect2>
            <title>Driver Load</title>
            <para>
        The <methodname>load</methodname> method is the driver and device
        initialization entry point. The method is responsible for allocating and
        initializing driver private data, specifying supported performance
        counters, performing resource allocation and mapping (e.g. acquiring
        clocks, mapping registers or allocating command buffers), initializing
        the memory manager (<xref linkend="drm-memory-management" />), installing
        the IRQ handler (<xref linkend="drm-irq-registration" />), setting up
        vertical blanking handling (<xref linkend="drm-vertical-blank" />), mode
	setting (<xref linkend="drm-mode-setting" />) and initial output
	configuration (<xref linkend="drm-kms-init" />).
      </para>
            <note>
              <para>
        If compatibility is a concern (e.g. with drivers converted over from
        User Mode Setting to Kernel Mode Setting), care must be taken to prevent
        device initialization and control that is incompatible with currently
        active userspace drivers. For instance, if user level mode setting
        drivers are in use, it would be problematic to perform output discovery
        &amp; configuration at load time. Likewise, if user-level drivers
        unaware of memory management are in use, memory management and command
        buffer setup may need to be omitted. These requirements are
        driver-specific, and care needs to be taken to keep both old and new
        applications and libraries working.
      </para>
            </note>
            <synopsis>int (*load) (struct drm_device *, unsigned long flags);</synopsis>
            <para>
        The method takes two arguments, a pointer to the newly created
	<structname>drm_device</structname> and flags. The flags are used to
	pass the <structfield>driver_data</structfield> field of the device id
	corresponding to the device passed to <function>drm_*_init()</function>.
	Only PCI devices currently use this, USB and platform DRM drivers have
	their <methodname>load</methodname> method called with flags to 0.
      </para>
            <sect3>
              <title>Driver Private &amp; Performance Counters</title>
              <para>
          The driver private hangs off the main
          <structname>drm_device</structname> structure and can be used for
          tracking various device-specific bits of information, like register
          offsets, command buffer status, register state for suspend/resume, etc.
          At load time, a driver may simply allocate one and set
          <structname>drm_device</structname>.<structfield>dev_priv</structfield>
          appropriately; it should be freed and
          <structname>drm_device</structname>.<structfield>dev_priv</structfield>
          set to NULL when the driver is unloaded.
        </para>
              <para>
          DRM supports several counters which were used for rough performance
          characterization. This stat counter system is deprecated and should not
          be used. If performance monitoring is desired, the developer should
          investigate and potentially enhance the kernel perf and tracing
          infrastructure to export GPU related performance information for
          consumption by performance monitoring tools and applications.
        </para>
            </sect3>
            <sect3 id="drm-irq-registration">
              <title>IRQ Registration</title>
              <para>
          The DRM core tries to facilitate IRQ handler registration and
          unregistration by providing <function>drm_irq_install</function> and
          <function>drm_irq_uninstall</function> functions. Those functions only
          support a single interrupt per device, devices that use more than one
          IRQs need to be handled manually.
        </para>
              <sect4>
                <title>Managed IRQ Registration</title>
                <para>
            Both the <function>drm_irq_install</function> and
	    <function>drm_irq_uninstall</function> functions get the device IRQ by
	    calling <function>drm_dev_to_irq</function>. This inline function will
	    call a bus-specific operation to retrieve the IRQ number. For platform
	    devices, <function>platform_get_irq</function>(..., 0) is used to
	    retrieve the IRQ number.
          </para>
                <para>
                  <function>drm_irq_install</function> starts by calling the
            <methodname>irq_preinstall</methodname> driver operation. The operation
            is optional and must make sure that the interrupt will not get fired by
            clearing all pending interrupt flags or disabling the interrupt.
          </para>
                <para>
            The IRQ will then be requested by a call to
            <function>request_irq</function>. If the DRIVER_IRQ_SHARED driver
            feature flag is set, a shared (IRQF_SHARED) IRQ handler will be
            requested.
          </para>
                <para>
            The IRQ handler function must be provided as the mandatory irq_handler
            driver operation. It will get passed directly to
            <function>request_irq</function> and thus has the same prototype as all
            IRQ handlers. It will get called with a pointer to the DRM device as the
            second argument.
          </para>
                <para>
            Finally the function calls the optional
            <methodname>irq_postinstall</methodname> driver operation. The operation
            usually enables interrupts (excluding the vblank interrupt, which is
            enabled separately), but drivers may choose to enable/disable interrupts
            at a different time.
          </para>
                <para>
                  <function>drm_irq_uninstall</function> is similarly used to uninstall an
            IRQ handler. It starts by waking up all processes waiting on a vblank
            interrupt to make sure they don't hang, and then calls the optional
            <methodname>irq_uninstall</methodname> driver operation. The operation
            must disable all hardware interrupts. Finally the function frees the IRQ
            by calling <function>free_irq</function>.
          </para>
              </sect4>
              <sect4>
                <title>Manual IRQ Registration</title>
                <para>
            Drivers that require multiple interrupt handlers can't use the managed
            IRQ registration functions. In that case IRQs must be registered and
            unregistered manually (usually with the <function>request_irq</function>
            and <function>free_irq</function> functions, or their devm_* equivalent).
          </para>
                <para>
            When manually registering IRQs, drivers must not set the DRIVER_HAVE_IRQ
            driver feature flag, and must not provide the
	    <methodname>irq_handler</methodname> driver operation. They must set the
	    <structname>drm_device</structname><structfield>irq_enabled</structfield>
	    field to 1 upon registration of the IRQs, and clear it to 0 after
	    unregistering the IRQs.
          </para>
              </sect4>
            </sect3>
            <sect3>
              <title>Memory Manager Initialization</title>
              <para>
          Every DRM driver requires a memory manager which must be initialized at
          load time. DRM currently contains two memory managers, the Translation
          Table Manager (TTM) and the Graphics Execution Manager (GEM).
          This document describes the use of the GEM memory manager only. See
          <xref linkend="drm-memory-management" /> for details.
        </para>
            </sect3>
            <sect3>
              <title>Miscellaneous Device Configuration</title>
              <para>
          Another task that may be necessary for PCI devices during configuration
          is mapping the video BIOS. On many devices, the VBIOS describes device
          configuration, LCD panel timings (if any), and contains flags indicating
          device state. Mapping the BIOS can be done using the pci_map_rom() call,
          a convenience function that takes care of mapping the actual ROM,
          whether it has been shadowed into memory (typically at address 0xc0000)
          or exists on the PCI device in the ROM BAR. Note that after the ROM has
          been mapped and any necessary information has been extracted, it should
          be unmapped; on many devices, the ROM address decoder is shared with
          other BARs, so leaving it mapped could cause undesired behaviour like
          hangs or memory corruption.
  <!--!Fdrivers/pci/rom.c pci_map_rom--></para>
            </sect3>
          </sect2>
        </sect1>
        <!-- Internals: memory management -->
        <sect1 id="drm-memory-management">
          <title>Memory management</title>
          <para>
      Modern Linux systems require large amount of graphics memory to store
      frame buffers, textures, vertices and other graphics-related data. Given
      the very dynamic nature of many of that data, managing graphics memory
      efficiently is thus crucial for the graphics stack and plays a central
      role in the DRM infrastructure.
    </para>
          <para>
      The DRM core includes two memory managers, namely Translation Table Maps
      (TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
      manager to be developed and tried to be a one-size-fits-them all
      solution. It provides a single userspace API to accommodate the need of
      all hardware, supporting both Unified Memory Architecture (UMA) devices
      and devices with dedicated video RAM (i.e. most discrete video cards).
      This resulted in a large, complex piece of code that turned out to be
      hard to use for driver development.
    </para>
          <para>
      GEM started as an Intel-sponsored project in reaction to TTM's
      complexity. Its design philosophy is completely different: instead of
      providing a solution to every graphics memory-related problems, GEM
      identified common code between drivers and created a support library to
      share it. GEM has simpler initialization and execution requirements than
      TTM, but has no video RAM management capabitilies and is thus limited to
      UMA devices.
    </para>
          <sect2>
            <title>The Translation Table Manager (TTM)</title>
            <para>
	TTM design background and information belongs here.
      </para>
            <sect3>
              <title>TTM initialization</title>
              <warning>
                <para>This section is outdated.</para>
              </warning>
              <para>
          Drivers wishing to support TTM must fill out a drm_bo_driver
          structure. The structure contains several fields with function
          pointers for initializing the TTM, allocating and freeing memory,
          waiting for command completion and fence synchronization, and memory
          migration. See the radeon_ttm.c file for an example of usage.
	</para>
              <para>
	  The ttm_global_reference structure is made up of several fields:
	</para>
              <programlisting>
	  struct ttm_global_reference {
	  	enum ttm_global_types global_type;
	  	size_t size;
	  	void *object;
	  	int (*init) (struct ttm_global_reference *);
	  	void (*release) (struct ttm_global_reference *);
	  };
	</programlisting>
              <para>
	  There should be one global reference structure for your memory
	  manager as a whole, and there will be others for each object
	  created by the memory manager at runtime.  Your global TTM should
	  have a type of TTM_GLOBAL_TTM_MEM.  The size field for the global
	  object should be sizeof(struct ttm_mem_global), and the init and
	  release hooks should point at your driver-specific init and
	  release routines, which probably eventually call
	  ttm_mem_global_init and ttm_mem_global_release, respectively.
	</para>
              <para>
	  Once your global TTM accounting structure is set up and initialized
	  by calling ttm_global_item_ref() on it,
	  you need to create a buffer object TTM to
	  provide a pool for buffer object allocation by clients and the
	  kernel itself.  The type of this object should be TTM_GLOBAL_TTM_BO,
	  and its size should be sizeof(struct ttm_bo_global).  Again,
	  driver-specific init and release functions may be provided,
	  likely eventually calling ttm_bo_global_init() and
	  ttm_bo_global_release(), respectively.  Also, like the previous
	  object, ttm_global_item_ref() is used to create an initial reference
	  count for the TTM, which will call your initialization function.
	</para>
            </sect3>
          </sect2>
          <sect2 id="drm-gem">
            <title>The Graphics Execution Manager (GEM)</title>
            <para>
        The GEM design approach has resulted in a memory manager that doesn't
        provide full coverage of all (or even all common) use cases in its
        userspace or kernel API. GEM exposes a set of standard memory-related
        operations to userspace and a set of helper functions to drivers, and let
        drivers implement hardware-specific operations with their own private API.
      </para>
            <para>
        The GEM userspace API is described in the
        <ulink url="http://lwn.net/Articles/283798/"><citetitle>GEM - the Graphics
        Execution Manager</citetitle></ulink> article on LWN. While slightly
        outdated, the document provides a good overview of the GEM API principles.
        Buffer allocation and read and write operations, described as part of the
        common GEM API, are currently implemented using driver-specific ioctls.
      </para>
            <para>
        GEM is data-agnostic. It manages abstract buffer objects without knowing
        what individual buffers contain. APIs that require knowledge of buffer
        contents or purpose, such as buffer allocation or synchronization
        primitives, are thus outside of the scope of GEM and must be implemented
        using driver-specific ioctls.
      </para>
            <para>
	On a fundamental level, GEM involves several operations:
	<itemizedlist><listitem>Memory allocation and freeing</listitem><listitem>Command execution</listitem><listitem>Aperture management at command execution time</listitem></itemizedlist>
	Buffer object allocation is relatively straightforward and largely
        provided by Linux's shmem layer, which provides memory to back each
        object.
      </para>
            <para>
        Device-specific operations, such as command execution, pinning, buffer
	read &amp; write, mapping, and domain ownership transfers are left to
        driver-specific ioctls.
      </para>
            <sect3>
              <title>GEM Initialization</title>
              <para>
          Drivers that use GEM must set the DRIVER_GEM bit in the struct
          <structname>drm_driver</structname><structfield>driver_features</structfield> field. The DRM core will
          then automatically initialize the GEM core before calling the
          <methodname>load</methodname> operation. Behind the scene, this will
          create a DRM Memory Manager object which provides an address space
          pool for object allocation.
        </para>
              <para>
          In a KMS configuration, drivers need to allocate and initialize a
          command ring buffer following core GEM initialization if required by
          the hardware. UMA devices usually have what is called a "stolen"
          memory region, which provides space for the initial framebuffer and
          large, contiguous memory regions required by the device. This space is
          typically not managed by GEM, and must be initialized separately into
          its own DRM MM object.
        </para>
            </sect3>
            <sect3>
              <title>GEM Objects Creation</title>
              <para>
          GEM splits creation of GEM objects and allocation of the memory that
          backs them in two distinct operations.
        </para>
              <para>
          GEM objects are represented by an instance of struct
          <structname>drm_gem_object</structname>. Drivers usually need to extend
          GEM objects with private information and thus create a driver-specific
          GEM object structure type that embeds an instance of struct
          <structname>drm_gem_object</structname>.
        </para>
              <para>
          To create a GEM object, a driver allocates memory for an instance of its
          specific GEM object type and initializes the embedded struct
          <structname>drm_gem_object</structname> with a call to
          <function>drm_gem_object_init</function>. The function takes a pointer to
          the DRM device, a pointer to the GEM object and the buffer object size
          in bytes.
        </para>
              <para>
          GEM uses shmem to allocate anonymous pageable memory.
          <function>drm_gem_object_init</function> will create an shmfs file of
          the requested size and store it into the struct
          <structname>drm_gem_object</structname><structfield>filp</structfield>
          field. The memory is used as either main storage for the object when the
          graphics hardware uses system memory directly or as a backing store
          otherwise.
        </para>
              <para>
          Drivers are responsible for the actual physical pages allocation by
          calling <function>shmem_read_mapping_page_gfp</function> for each page.
          Note that they can decide to allocate pages when initializing the GEM
          object, or to delay allocation until the memory is needed (for instance
          when a page fault occurs as a result of a userspace memory access or
          when the driver needs to start a DMA transfer involving the memory).
        </para>
              <para>
          Anonymous pageable memory allocation is not always desired, for instance
          when the hardware requires physically contiguous system memory as is
          often the case in embedded devices. Drivers can create GEM objects with
          no shmfs backing (called private GEM objects) by initializing them with
          a call to <function>drm_gem_private_object_init</function> instead of
          <function>drm_gem_object_init</function>. Storage for private GEM
          objects must be managed by drivers.
        </para>
              <para>
          Drivers that do not need to extend GEM objects with private information
          can call the <function>drm_gem_object_alloc</function> function to
          allocate and initialize a struct <structname>drm_gem_object</structname>
          instance. The GEM core will call the optional driver
          <methodname>gem_init_object</methodname> operation after initializing
          the GEM object with <function>drm_gem_object_init</function>.
          <synopsis>int (*gem_init_object) (struct drm_gem_object *obj);</synopsis></para>
              <para>
          No alloc-and-init function exists for private GEM objects.
        </para>
            </sect3>
            <sect3>
              <title>GEM Objects Lifetime</title>
              <para>
          All GEM objects are reference-counted by the GEM core. References can be
          acquired and release by <function>calling drm_gem_object_reference</function>
          and <function>drm_gem_object_unreference</function> respectively. The
          caller must hold the <structname>drm_device</structname><structfield>struct_mutex</structfield> lock. As a convenience, GEM
          provides the <function>drm_gem_object_reference_unlocked</function> and
          <function>drm_gem_object_unreference_unlocked</function> functions that
          can be called without holding the lock.
        </para>
              <para>
          When the last reference to a GEM object is released the GEM core calls
          the <structname>drm_driver</structname><methodname>gem_free_object</methodname> operation. That operation is
          mandatory for GEM-enabled drivers and must free the GEM object and all
          associated resources.
        </para>
              <para>
                <synopsis>void (*gem_free_object) (struct drm_gem_object *obj);</synopsis>
          Drivers are responsible for freeing all GEM object resources, including
          the resources created by the GEM core. If an mmap offset has been
          created for the object (in which case
          <structname>drm_gem_object</structname>::<structfield>map_list</structfield>::<structfield>map</structfield>
          is not NULL) it must be freed by a call to
          <function>drm_gem_free_mmap_offset</function>. The shmfs backing store
          must be released by calling <function>drm_gem_object_release</function>
          (that function can safely be called if no shmfs backing store has been
          created).
        </para>
            </sect3>
            <sect3>
              <title>GEM Objects Naming</title>
              <para>
          Communication between userspace and the kernel refers to GEM objects
          using local handles, global names or, more recently, file descriptors.
          All of those are 32-bit integer values; the usual Linux kernel limits
          apply to the file descriptors.
        </para>
              <para>
          GEM handles are local to a DRM file. Applications get a handle to a GEM
          object through a driver-specific ioctl, and can use that handle to refer
          to the GEM object in other standard or driver-specific ioctls. Closing a
          DRM file handle frees all its GEM handles and dereferences the
          associated GEM objects.
        </para>
              <para>
          To create a handle for a GEM object drivers call
          <function>drm_gem_handle_create</function>. The function takes a pointer
          to the DRM file and the GEM object and returns a locally unique handle.
          When the handle is no longer needed drivers delete it with a call to
          <function>drm_gem_handle_delete</function>. Finally the GEM object
          associated with a handle can be retrieved by a call to
          <function>drm_gem_object_lookup</function>.
        </para>
              <para>
          Handles don't take ownership of GEM objects, they only take a reference
          to the object that will be dropped when the handle is destroyed. To
          avoid leaking GEM objects, drivers must make sure they drop the
          reference(s) they own (such as the initial reference taken at object
          creation time) as appropriate, without any special consideration for the
          handle. For example, in the particular case of combined GEM object and
          handle creation in the implementation of the
          <methodname>dumb_create</methodname> operation, drivers must drop the
          initial reference to the GEM object before returning the handle.
        </para>
              <para>
          GEM names are similar in purpose to handles but are not local to DRM
          files. They can be passed between processes to reference a GEM object
          globally. Names can't be used directly to refer to objects in the DRM
          API, applications must convert handles to names and names to handles
          using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls
          respectively. The conversion is handled by the DRM core without any
          driver-specific support.
        </para>
              <para>
          Similar to global names, GEM file descriptors are also used to share GEM
          objects across processes. They offer additional security: as file
          descriptors must be explicitly sent over UNIX domain sockets to be shared
          between applications, they can't be guessed like the globally unique GEM
          names.
        </para>
              <para>
          Drivers that support GEM file descriptors, also known as the DRM PRIME
          API, must set the DRIVER_PRIME bit in the struct
          <structname>drm_driver</structname><structfield>driver_features</structfield> field, and implement the
          <methodname>prime_handle_to_fd</methodname> and
          <methodname>prime_fd_to_handle</methodname> operations.
        </para>
              <para>
                <synopsis>int (*prime_handle_to_fd)(struct drm_device *dev,
                            struct drm_file *file_priv, uint32_t handle,
                            uint32_t flags, int *prime_fd);
  int (*prime_fd_to_handle)(struct drm_device *dev,
                            struct drm_file *file_priv, int prime_fd,
                            uint32_t *handle);</synopsis>
          Those two operations convert a handle to a PRIME file descriptor and
          vice versa. Drivers must use the kernel dma-buf buffer sharing framework
          to manage the PRIME file descriptors.
        </para>
              <para>
          While non-GEM drivers must implement the operations themselves, GEM
          drivers must use the <function>drm_gem_prime_handle_to_fd</function>
          and <function>drm_gem_prime_fd_to_handle</function> helper functions.
          Those helpers rely on the driver
          <methodname>gem_prime_export</methodname> and
          <methodname>gem_prime_import</methodname> operations to create a dma-buf
          instance from a GEM object (dma-buf exporter role) and to create a GEM
          object from a dma-buf instance (dma-buf importer role).
        </para>
              <para>
                <synopsis>struct dma_buf * (*gem_prime_export)(struct drm_device *dev,
                                       struct drm_gem_object *obj,
                                       int flags);
  struct drm_gem_object * (*gem_prime_import)(struct drm_device *dev,
                                              struct dma_buf *dma_buf);</synopsis>
          These two operations are mandatory for GEM drivers that support DRM
          PRIME.
        </para>
              <sect4>
                <title>DRM PRIME Helper Functions Reference</title>
!Pdrivers/gpu/drm/drm_prime.c PRIME Helpers
        </sect4>
            </sect3>
            <sect3 id="drm-gem-objects-mapping">
              <title>GEM Objects Mapping</title>
              <para>
          Because mapping operations are fairly heavyweight GEM favours
          read/write-like access to buffers, implemented through driver-specific
          ioctls, over mapping buffers to userspace. However, when random access
          to the buffer is needed (to perform software rendering for instance),
          direct access to the object can be more efficient.
        </para>
              <para>
          The mmap system call can't be used directly to map GEM objects, as they
          don't have their own file handle. Two alternative methods currently
          co-exist to map GEM objects to userspace. The first method uses a
          driver-specific ioctl to perform the mapping operation, calling
          <function>do_mmap</function> under the hood. This is often considered
          dubious, seems to be discouraged for new GEM-enabled drivers, and will
          thus not be described here.
        </para>
              <para>
          The second method uses the mmap system call on the DRM file handle.
          <synopsis>void *mmap(void *addr, size_t length, int prot, int flags, int fd,
             off_t offset);</synopsis>
          DRM identifies the GEM object to be mapped by a fake offset passed
          through the mmap offset argument. Prior to being mapped, a GEM object
          must thus be associated with a fake offset. To do so, drivers must call
          <function>drm_gem_create_mmap_offset</function> on the object. The
          function allocates a fake offset range from a pool and stores the
          offset divided by PAGE_SIZE in
          <literal>obj-&gt;map_list.hash.key</literal>. Care must be taken not to
          call <function>drm_gem_create_mmap_offset</function> if a fake offset
          has already been allocated for the object. This can be tested by
          <literal>obj-&gt;map_list.map</literal> being non-NULL.
        </para>
              <para>
          Once allocated, the fake offset value
          (<literal>obj-&gt;map_list.hash.key &lt;&lt; PAGE_SHIFT</literal>)
          must be passed to the application in a driver-specific way and can then
          be used as the mmap offset argument.
        </para>
              <para>
          The GEM core provides a helper method <function>drm_gem_mmap</function>
          to handle object mapping. The method can be set directly as the mmap
          file operation handler. It will look up the GEM object based on the
          offset value and set the VMA operations to the
          <structname>drm_driver</structname><structfield>gem_vm_ops</structfield>
          field. Note that <function>drm_gem_mmap</function> doesn't map memory to
          userspace, but relies on the driver-provided fault handler to map pages
          individually.
        </para>
              <para>
          To use <function>drm_gem_mmap</function>, drivers must fill the struct
          <structname>drm_driver</structname><structfield>gem_vm_ops</structfield>
          field with a pointer to VM operations.
        </para>
              <para>
                <synopsis>struct vm_operations_struct *gem_vm_ops

  struct vm_operations_struct {
          void (*open)(struct vm_area_struct * area);
          void (*close)(struct vm_area_struct * area);
          int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
  };</synopsis>
              </para>
              <para>
          The <methodname>open</methodname> and <methodname>close</methodname>
          operations must update the GEM object reference count. Drivers can use
          the <function>drm_gem_vm_open</function> and
          <function>drm_gem_vm_close</function> helper functions directly as open
          and close handlers.
        </para>
              <para>
          The fault operation handler is responsible for mapping individual pages
          to userspace when a page fault occurs. Depending on the memory
          allocation scheme, drivers can allocate pages at fault time, or can
          decide to allocate memory for the GEM object at the time the object is
          created.
        </para>
              <para>
          Drivers that want to map the GEM object upfront instead of handling page
          faults can implement their own mmap file operation handler.
        </para>
            </sect3>
            <sect3>
              <title>Dumb GEM Objects</title>
              <para>
          The GEM API doesn't standardize GEM objects creation and leaves it to
          driver-specific ioctls. While not an issue for full-fledged graphics
          stacks that include device-specific userspace components (in libdrm for
          instance), this limit makes DRM-based early boot graphics unnecessarily
          complex.
        </para>
              <para>
          Dumb GEM objects partly alleviate the problem by providing a standard
          API to create dumb buffers suitable for scanout, which can then be used
          to create KMS frame buffers.
        </para>
              <para>
          To support dumb GEM objects drivers must implement the
          <methodname>dumb_create</methodname>,
          <methodname>dumb_destroy</methodname> and
          <methodname>dumb_map_offset</methodname> operations.
        </para>
              <itemizedlist>
                <listitem>
                  <synopsis>int (*dumb_create)(struct drm_file *file_priv, struct drm_device *dev,
                     struct drm_mode_create_dumb *args);</synopsis>
                  <para>
              The <methodname>dumb_create</methodname> operation creates a GEM
              object suitable for scanout based on the width, height and depth
              from the struct <structname>drm_mode_create_dumb</structname>
              argument. It fills the argument's <structfield>handle</structfield>,
              <structfield>pitch</structfield> and <structfield>size</structfield>
              fields with a handle for the newly created GEM object and its line
              pitch and size in bytes.
            </para>
                </listitem>
                <listitem>
                  <synopsis>int (*dumb_destroy)(struct drm_file *file_priv, struct drm_device *dev,
                      uint32_t handle);</synopsis>
                  <para>
              The <methodname>dumb_destroy</methodname> operation destroys a dumb
              GEM object created by <methodname>dumb_create</methodname>.
            </para>
                </listitem>
                <listitem>
                  <synopsis>int (*dumb_map_offset)(struct drm_file *file_priv, struct drm_device *dev,
                         uint32_t handle, uint64_t *offset);</synopsis>
                  <para>
              The <methodname>dumb_map_offset</methodname> operation associates an
              mmap fake offset with the GEM object given by the handle and returns
              it. Drivers must use the
              <function>drm_gem_create_mmap_offset</function> function to
              associate the fake offset as described in
              <xref linkend="drm-gem-objects-mapping" />.
            </para>
                </listitem>
              </itemizedlist>
            </sect3>
            <sect3>
              <title>Memory Coherency</title>
              <para>
          When mapped to the device or used in a command buffer, backing pages
          for an object are flushed to memory and marked write combined so as to
          be coherent with the GPU. Likewise, if the CPU accesses an object
          after the GPU has finished rendering to the object, then the object
          must be made coherent with the CPU's view of memory, usually involving
          GPU cache flushing of various kinds. This core CPU&lt;-&gt;GPU
          coherency management is provided by a device-specific ioctl, which
          evaluates an object's current domain and performs any necessary
          flushing or synchronization to put the object into the desired
          coherency domain (note that the object may be busy, i.e. an active
          render target; in that case, setting the domain blocks the client and
          waits for rendering to complete before performing any necessary
          flushing operations).
        </para>
            </sect3>
            <sect3>
              <title>Command Execution</title>
              <para>
	  Perhaps the most important GEM function for GPU devices is providing a
          command execution interface to clients. Client programs construct
          command buffers containing references to previously allocated memory
          objects, and then submit them to GEM. At that point, GEM takes care to
          bind all the objects into the GTT, execute the buffer, and provide
          necessary synchronization between clients accessing the same buffers.
          This often involves evicting some objects from the GTT and re-binding
          others (a fairly expensive operation), and providing relocation
          support which hides fixed GTT offsets from clients. Clients must take
          care not to submit command buffers that reference more objects than
          can fit in the GTT; otherwise, GEM will reject them and no rendering
          will occur. Similarly, if several objects in the buffer require fence
          registers to be allocated for correct rendering (e.g. 2D blits on
          pre-965 chips), care must be taken not to require more fence registers
          than are available to the client. Such resource management should be
          abstracted from the client in libdrm.
        </para>
            </sect3>
          </sect2>
        </sect1>
        <!-- Internals: mode setting -->
        <sect1 id="drm-mode-setting">
          <title>Mode Setting</title>
          <para>
      Drivers must initialize the mode setting core by calling
      <function>drm_mode_config_init</function> on the DRM device. The function
      initializes the <structname>drm_device</structname><structfield>mode_config</structfield> field and never fails. Once done,
      mode configuration must be setup by initializing the following fields.
    </para>
          <itemizedlist>
            <listitem>
              <synopsis>int min_width, min_height;
int max_width, max_height;</synopsis>
              <para>
	  Minimum and maximum width and height of the frame buffers in pixel
	  units.
	</para>
            </listitem>
            <listitem>
              <synopsis>struct drm_mode_config_funcs *funcs;</synopsis>
              <para>Mode setting functions.</para>
            </listitem>
          </itemizedlist>
          <sect2>
            <title>Frame Buffer Creation</title>
            <synopsis>struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
				     struct drm_file *file_priv,
				     struct drm_mode_fb_cmd2 *mode_cmd);</synopsis>
            <para>
        Frame buffers are abstract memory objects that provide a source of
        pixels to scanout to a CRTC. Applications explicitly request the
        creation of frame buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and
        receive an opaque handle that can be passed to the KMS CRTC control,
        plane configuration and page flip functions.
      </para>
            <para>
        Frame buffers rely on the underneath memory manager for low-level memory
        operations. When creating a frame buffer applications pass a memory
        handle (or a list of memory handles for multi-planar formats) through
        the <parameter>drm_mode_fb_cmd2</parameter> argument. This document
        assumes that the driver uses GEM, those handles thus reference GEM
        objects.
      </para>
            <para>
        Drivers must first validate the requested frame buffer parameters passed
        through the mode_cmd argument. In particular this is where invalid
        sizes, pixel formats or pitches can be caught.
      </para>
            <para>
        If the parameters are deemed valid, drivers then create, initialize and
        return an instance of struct <structname>drm_framebuffer</structname>.
        If desired the instance can be embedded in a larger driver-specific
	structure. Drivers must fill its <structfield>width</structfield>,
	<structfield>height</structfield>, <structfield>pitches</structfield>,
        <structfield>offsets</structfield>, <structfield>depth</structfield>,
        <structfield>bits_per_pixel</structfield> and
        <structfield>pixel_format</structfield> fields from the values passed
        through the <parameter>drm_mode_fb_cmd2</parameter> argument. They
        should call the <function>drm_helper_mode_fill_fb_struct</function>
        helper function to do so.
      </para>
            <para>
	The initailization of the new framebuffer instance is finalized with a
	call to <function>drm_framebuffer_init</function> which takes a pointer
	to DRM frame buffer operations (struct
	<structname>drm_framebuffer_funcs</structname>). Note that this function
	publishes the framebuffer and so from this point on it can be accessed
	concurrently from other threads. Hence it must be the last step in the
	driver's framebuffer initialization sequence. Frame buffer operations
	are
        <itemizedlist><listitem><synopsis>int (*create_handle)(struct drm_framebuffer *fb,
		     struct drm_file *file_priv, unsigned int *handle);</synopsis><para>
              Create a handle to the frame buffer underlying memory object. If
              the frame buffer uses a multi-plane format, the handle will
              reference the memory object associated with the first plane.
            </para><para>
              Drivers call <function>drm_gem_handle_create</function> to create
              the handle.
            </para></listitem><listitem><synopsis>void (*destroy)(struct drm_framebuffer *framebuffer);</synopsis><para>
              Destroy the frame buffer object and frees all associated
              resources. Drivers must call
              <function>drm_framebuffer_cleanup</function> to free resources
              allocated by the DRM core for the frame buffer object, and must
              make sure to unreference all memory objects associated with the
              frame buffer. Handles created by the
              <methodname>create_handle</methodname> operation are released by
              the DRM core.
            </para></listitem><listitem><synopsis>int (*dirty)(struct drm_framebuffer *framebuffer,
	     struct drm_file *file_priv, unsigned flags, unsigned color,
	     struct drm_clip_rect *clips, unsigned num_clips);</synopsis><para>
              This optional operation notifies the driver that a region of the
              frame buffer has changed in response to a DRM_IOCTL_MODE_DIRTYFB
              ioctl call.
            </para></listitem></itemizedlist></para>
            <para>
	The lifetime of a drm framebuffer is controlled with a reference count,
	drivers can grab additional references with
	<function>drm_framebuffer_reference</function></para> and drop them
	again with <function>drm_framebuffer_unreference</function>. For
	driver-private framebuffers for which the last reference is never
	dropped (e.g. for the fbdev framebuffer when the struct
	<structname>drm_framebuffer</structname> is embedded into the fbdev
	helper struct) drivers can manually clean up a framebuffer at module
	unload time with
	<function>drm_framebuffer_unregister_private</function>.
    </sect2>
          <sect2>
            <title>Output Polling</title>
            <synopsis>void (*output_poll_changed)(struct drm_device *dev);</synopsis>
            <para>
        This operation notifies the driver that the status of one or more
        connectors has changed. Drivers that use the fb helper can just call the
        <function>drm_fb_helper_hotplug_event</function> function to handle this
        operation.
      </para>
          </sect2>
          <sect2>
            <title>Locking</title>
            <para>
        Beside some lookup structures with their own locking (which is hidden
	behind the interface functions) most of the modeset state is protected
	by the <code>dev-&lt;mode_config.lock</code> mutex and additionally
	per-crtc locks to allow cursor updates, pageflips and similar operations
	to occur concurrently with background tasks like output detection.
	Operations which cross domains like a full modeset always grab all
	locks. Drivers there need to protect resources shared between crtcs with
	additional locking. They also need to be careful to always grab the
	relevant crtc locks if a modset functions touches crtc state, e.g. for
	load detection (which does only grab the <code>mode_config.lock</code>
	to allow concurrent screen updates on live crtcs).
      </para>
          </sect2>
        </sect1>
        <!-- Internals: kms initialization and cleanup -->
        <sect1 id="drm-kms-init">
          <title>KMS Initialization and Cleanup</title>
          <para>
      A KMS device is abstracted and exposed as a set of planes, CRTCs, encoders
      and connectors. KMS drivers must thus create and initialize all those
      objects at load time after initializing mode setting.
    </para>
          <sect2>
            <title>CRTCs (struct <structname>drm_crtc</structname>)</title>
            <para>
        A CRTC is an abstraction representing a part of the chip that contains a
	pointer to a scanout buffer. Therefore, the number of CRTCs available
	determines how many independent scanout buffers can be active at any
	given time. The CRTC structure contains several fields to support this:
	a pointer to some video memory (abstracted as a frame buffer object), a
	display mode, and an (x, y) offset into the video memory to support
	panning or configurations where one piece of video memory spans multiple
	CRTCs.
      </para>
            <sect3>
              <title>CRTC Initialization</title>
              <para>
          A KMS device must create and register at least one struct
          <structname>drm_crtc</structname> instance. The instance is allocated
          and zeroed by the driver, possibly as part of a larger structure, and
          registered with a call to <function>drm_crtc_init</function> with a
          pointer to CRTC functions.
        </para>
            </sect3>
            <sect3>
              <title>CRTC Operations</title>
              <sect4>
                <title>Set Configuration</title>
                <synopsis>int (*set_config)(struct drm_mode_set *set);</synopsis>
                <para>
            Apply a new CRTC configuration to the device. The configuration
            specifies a CRTC, a frame buffer to scan out from, a (x,y) position in
            the frame buffer, a display mode and an array of connectors to drive
            with the CRTC if possible.
          </para>
                <para>
            If the frame buffer specified in the configuration is NULL, the driver
            must detach all encoders connected to the CRTC and all connectors
            attached to those encoders and disable them.
          </para>
                <para>
            This operation is called with the mode config lock held.
          </para>
                <note>
                  <para>
            FIXME: How should set_config interact with DPMS? If the CRTC is
            suspended, should it be resumed?
          </para>
                </note>
              </sect4>
              <sect4>
                <title>Page Flipping</title>
                <synopsis>int (*page_flip)(struct drm_crtc *crtc, struct drm_framebuffer *fb,
                   struct drm_pending_vblank_event *event);</synopsis>
                <para>
            Schedule a page flip to the given frame buffer for the CRTC. This
            operation is called with the mode config mutex held.
          </para>
                <para>
            Page flipping is a synchronization mechanism that replaces the frame
            buffer being scanned out by the CRTC with a new frame buffer during
            vertical blanking, avoiding tearing. When an application requests a page
            flip the DRM core verifies that the new frame buffer is large enough to
            be scanned out by  the CRTC in the currently configured mode and then
            calls the CRTC <methodname>page_flip</methodname> operation with a
            pointer to the new frame buffer.
          </para>
                <para>
            The <methodname>page_flip</methodname> operation schedules a page flip.
            Once any pending rendering targeting the new frame buffer has
            completed, the CRTC will be reprogrammed to display that frame buffer
            after the next vertical refresh. The operation must return immediately
            without waiting for rendering or page flip to complete and must block
            any new rendering to the frame buffer until the page flip completes.
          </para>
                <para>
            If a page flip can be successfully scheduled the driver must set the
            <code>drm_crtc-&lt;fb</code> field to the new framebuffer pointed to
            by <code>fb</code>. This is important so that the reference counting
            on framebuffers stays balanced.
          </para>
                <para>
            If a page flip is already pending, the
            <methodname>page_flip</methodname> operation must return
            -<errorname>EBUSY</errorname>.
          </para>
                <para>
            To synchronize page flip to vertical blanking the driver will likely
            need to enable vertical blanking interrupts. It should call
            <function>drm_vblank_get</function> for that purpose, and call
            <function>drm_vblank_put</function> after the page flip completes.
          </para>
                <para>
            If the application has requested to be notified when page flip completes
            the <methodname>page_flip</methodname> operation will be called with a
            non-NULL <parameter>event</parameter> argument pointing to a
            <structname>drm_pending_vblank_event</structname> instance. Upon page
            flip completion the driver must call <methodname>drm_send_vblank_event</methodname>
            to fill in the event and send to wake up any waiting processes.
            This can be performed with
            <programlisting><![CDATA[
            spin_lock_irqsave(&dev->event_lock, flags);
            ...
            drm_send_vblank_event(dev, pipe, event);
            spin_unlock_irqrestore(&dev->event_lock, flags);
            ]]></programlisting></para>
                <note>
                  <para>
            FIXME: Could drivers that don't need to wait for rendering to complete
            just add the event to <literal>dev-&gt;vblank_event_list</literal> and
            let the DRM core handle everything, as for "normal" vertical blanking
            events?
          </para>
                </note>
                <para>
            While waiting for the page flip to complete, the
            <literal>event-&gt;base.link</literal> list head can be used freely by
            the driver to store the pending event in a driver-specific list.
          </para>
                <para>
            If the file handle is closed before the event is signaled, drivers must
            take care to destroy the event in their
            <methodname>preclose</methodname> operation (and, if needed, call
            <function>drm_vblank_put</function>).
          </para>
              </sect4>
              <sect4>
                <title>Miscellaneous</title>
                <itemizedlist>
                  <listitem>
                    <synopsis>void (*set_property)(struct drm_crtc *crtc,
                     struct drm_property *property, uint64_t value);</synopsis>
                    <para>
                Set the value of the given CRTC property to
                <parameter>value</parameter>. See <xref linkend="drm-kms-properties" />
                for more information about properties.
              </para>
                  </listitem>
                  <listitem>
                    <synopsis>void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
                        uint32_t start, uint32_t size);</synopsis>
                    <para>
                Apply a gamma table to the device. The operation is optional.
              </para>
                  </listitem>
                  <listitem>
                    <synopsis>void (*destroy)(struct drm_crtc *crtc);</synopsis>
                    <para>
                Destroy the CRTC when not needed anymore. See
                <xref linkend="drm-kms-init" />.
              </para>
                  </listitem>
                </itemizedlist>
              </sect4>
            </sect3>
          </sect2>
          <sect2>
            <title>Planes (struct <structname>drm_plane</structname>)</title>
            <para>
        A plane represents an image source that can be blended with or overlayed
	on top of a CRTC during the scanout process. Planes are associated with
	a frame buffer to crop a portion of the image memory (source) and
	optionally scale it to a destination size. The result is then blended
	with or overlayed on top of a CRTC.
      </para>
            <sect3>
              <title>Plane Initialization</title>
              <para>
          Planes are optional. To create a plane, a KMS drivers allocates and
          zeroes an instances of struct <structname>drm_plane</structname>
          (possibly as part of a larger structure) and registers it with a call
          to <function>drm_plane_init</function>. The function takes a bitmask
          of the CRTCs that can be associated with the plane, a pointer to the
          plane functions and a list of format supported formats.
        </para>
            </sect3>
            <sect3>
              <title>Plane Operations</title>
              <itemizedlist>
                <listitem>
                  <synopsis>int (*update_plane)(struct drm_plane *plane, struct drm_crtc *crtc,
                        struct drm_framebuffer *fb, int crtc_x, int crtc_y,
                        unsigned int crtc_w, unsigned int crtc_h,
                        uint32_t src_x, uint32_t src_y,
                        uint32_t src_w, uint32_t src_h);</synopsis>
                  <para>
              Enable and configure the plane to use the given CRTC and frame buffer.
            </para>
                  <para>
              The source rectangle in frame buffer memory coordinates is given by
              the <parameter>src_x</parameter>, <parameter>src_y</parameter>,
              <parameter>src_w</parameter> and <parameter>src_h</parameter>
              parameters (as 16.16 fixed point values). Devices that don't support
              subpixel plane coordinates can ignore the fractional part.
            </para>
                  <para>
              The destination rectangle in CRTC coordinates is given by the
              <parameter>crtc_x</parameter>, <parameter>crtc_y</parameter>,
              <parameter>crtc_w</parameter> and <parameter>crtc_h</parameter>
              parameters (as integer values). Devices scale the source rectangle to
              the destination rectangle. If scaling is not supported, and the source
              rectangle size doesn't match the destination rectangle size, the
              driver must return a -<errorname>EINVAL</errorname> error.
            </para>
                </listitem>
                <listitem>
                  <synopsis>int (*disable_plane)(struct drm_plane *plane);</synopsis>
                  <para>
              Disable the plane. The DRM core calls this method in response to a
              DRM_IOCTL_MODE_SETPLANE ioctl call with the frame buffer ID set to 0.
              Disabled planes must not be processed by the CRTC.
            </para>
                </listitem>
                <listitem>
                  <synopsis>void (*destroy)(struct drm_plane *plane);</synopsis>
                  <para>
              Destroy the plane when not needed anymore. See
              <xref linkend="drm-kms-init" />.
            </para>
                </listitem>
              </itemizedlist>
            </sect3>
          </sect2>
          <sect2>
            <title>Encoders (struct <structname>drm_encoder</structname>)</title>
            <para>
        An encoder takes pixel data from a CRTC and converts it to a format
	suitable for any attached connectors. On some devices, it may be
	possible to have a CRTC send data to more than one encoder. In that
	case, both encoders would receive data from the same scanout buffer,
	resulting in a "cloned" display configuration across the connectors
	attached to each encoder.
      </para>
            <sect3>
              <title>Encoder Initialization</title>
              <para>
          As for CRTCs, a KMS driver must create, initialize and register at
          least one struct <structname>drm_encoder</structname> instance. The
          instance is allocated and zeroed by the driver, possibly as part of a
          larger structure.
        </para>
              <para>
          Drivers must initialize the struct <structname>drm_encoder</structname><structfield>possible_crtcs</structfield> and
          <structfield>possible_clones</structfield> fields before registering the
          encoder. Both fields are bitmasks of respectively the CRTCs that the
          encoder can be connected to, and sibling encoders candidate for cloning.
        </para>
              <para>
          After being initialized, the encoder must be registered with a call to
          <function>drm_encoder_init</function>. The function takes a pointer to
          the encoder functions and an encoder type. Supported types are
          <itemizedlist><listitem>
              DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A
              </listitem><listitem>
              DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort
            </listitem><listitem>
              DRM_MODE_ENCODER_LVDS for display panels
            </listitem><listitem>
              DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video, Component,
              SCART)
            </listitem><listitem>
              DRM_MODE_ENCODER_VIRTUAL for virtual machine displays
            </listitem></itemizedlist></para>
              <para>
          Encoders must be attached to a CRTC to be used. DRM drivers leave
          encoders unattached at initialization time. Applications (or the fbdev
          compatibility layer when implemented) are responsible for attaching the
          encoders they want to use to a CRTC.
        </para>
            </sect3>
            <sect3>
              <title>Encoder Operations</title>
              <itemizedlist>
                <listitem>
                  <synopsis>void (*destroy)(struct drm_encoder *encoder);</synopsis>
                  <para>
              Called to destroy the encoder when not needed anymore. See
              <xref linkend="drm-kms-init" />.
            </para>
                </listitem>
                <listitem>
                  <synopsis>void (*set_property)(struct drm_plane *plane,
                     struct drm_property *property, uint64_t value);</synopsis>
                  <para>
              Set the value of the given plane property to
              <parameter>value</parameter>. See <xref linkend="drm-kms-properties" />
              for more information about properties.
            </para>
                </listitem>
              </itemizedlist>
            </sect3>
          </sect2>
          <sect2>
            <title>Connectors (struct <structname>drm_connector</structname>)</title>
            <para>
        A connector is the final destination for pixel data on a device, and
	usually connects directly to an external display device like a monitor
	or laptop panel. A connector can only be attached to one encoder at a
	time. The connector is also the structure where information about the
	attached display is kept, so it contains fields for display data, EDID
	data, DPMS &amp; connection status, and information about modes
	supported on the attached displays.
      </para>
            <sect3>
              <title>Connector Initialization</title>
              <para>
          Finally a KMS driver must create, initialize, register and attach at
          least one struct <structname>drm_connector</structname> instance. The
          instance is created as other KMS objects and initialized by setting the
          following fields.
        </para>
              <variablelist>
                <varlistentry>
                  <term>
                    <structfield>interlace_allowed</structfield>
                  </term>
                  <listitem>
                    <para>
              Whether the connector can handle interlaced modes.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>
                    <structfield>doublescan_allowed</structfield>
                  </term>
                  <listitem>
                    <para>
              Whether the connector can handle doublescan.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>
                    <structfield>display_info
            </structfield>
                  </term>
                  <listitem>
                    <para>
              Display information is filled from EDID information when a display
              is detected. For non hot-pluggable displays such as flat panels in
              embedded systems, the driver should initialize the
              <structfield>display_info</structfield>.<structfield>width_mm</structfield>
              and
              <structfield>display_info</structfield>.<structfield>height_mm</structfield>
              fields with the physical size of the display.
            </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term id="drm-kms-connector-polled">
                    <structfield>polled</structfield>
                  </term>
                  <listitem>
                    <para>
              Connector polling mode, a combination of
              <variablelist><varlistentry><term>DRM_CONNECTOR_POLL_HPD</term><listitem><para>
                    The connector generates hotplug events and doesn't need to be
                    periodically polled. The CONNECT and DISCONNECT flags must not
                    be set together with the HPD flag.
                  </para></listitem></varlistentry><varlistentry><term>DRM_CONNECTOR_POLL_CONNECT</term><listitem><para>
                    Periodically poll the connector for connection.
                  </para></listitem></varlistentry><varlistentry><term>DRM_CONNECTOR_POLL_DISCONNECT</term><listitem><para>
                    Periodically poll the connector for disconnection.
                  </para></listitem></varlistentry></variablelist>
              Set to 0 for connectors that don't support connection status
              discovery.
            </para>
                  </listitem>
                </varlistentry>
              </variablelist>
              <para>
          The connector is then registered with a call to
          <function>drm_connector_init</function> with a pointer to the connector
          functions and a connector type, and exposed through sysfs with a call to
          <function>drm_sysfs_connector_add</function>.
        </para>
              <para>
          Supported connector types are
          <itemizedlist><listitem>DRM_MODE_CONNECTOR_VGA</listitem><listitem>DRM_MODE_CONNECTOR_DVII</listitem><listitem>DRM_MODE_CONNECTOR_DVID</listitem><listitem>DRM_MODE_CONNECTOR_DVIA</listitem><listitem>DRM_MODE_CONNECTOR_Composite</listitem><listitem>DRM_MODE_CONNECTOR_SVIDEO</listitem><listitem>DRM_MODE_CONNECTOR_LVDS</listitem><listitem>DRM_MODE_CONNECTOR_Component</listitem><listitem>DRM_MODE_CONNECTOR_9PinDIN</listitem><listitem>DRM_MODE_CONNECTOR_DisplayPort</listitem><listitem>DRM_MODE_CONNECTOR_HDMIA</listitem><listitem>DRM_MODE_CONNECTOR_HDMIB</listitem><listitem>DRM_MODE_CONNECTOR_TV</listitem><listitem>DRM_MODE_CONNECTOR_eDP</listitem><listitem>DRM_MODE_CONNECTOR_VIRTUAL</listitem></itemizedlist></para>
              <para>
          Connectors must be attached to an encoder to be used. For devices that
          map connectors to encoders 1:1, the connector should be attached at
          initialization time with a call to
          <function>drm_mode_connector_attach_encoder</function>. The driver must
          also set the <structname>drm_connector</structname><structfield>encoder</structfield> field to point to the attached
          encoder.
        </para>
              <para>
          Finally, drivers must initialize the connectors state change detection
          with a call to <function>drm_kms_helper_poll_init</function>. If at
          least one connector is pollable but can't generate hotplug interrupts
          (indicated by the DRM_CONNECTOR_POLL_CONNECT and
          DRM_CONNECTOR_POLL_DISCONNECT connector flags), a delayed work will
          automatically be queued to periodically poll for changes. Connectors
          that can generate hotplug interrupts must be marked with the
          DRM_CONNECTOR_POLL_HPD flag instead, and their interrupt handler must
          call <function>drm_helper_hpd_irq_event</function>. The function will
          queue a delayed work to check the state of all connectors, but no
          periodic polling will be done.
        </para>
            </sect3>
            <sect3>
              <title>Connector Operations</title>
              <note>
                <para>
          Unless otherwise state, all operations are mandatory.
        </para>
              </note>
              <sect4>
                <title>DPMS</title>
                <synopsis>void (*dpms)(struct drm_connector *connector, int mode);</synopsis>
                <para>
            The DPMS operation sets the power state of a connector. The mode
            argument is one of
            <itemizedlist><listitem><para>DRM_MODE_DPMS_ON</para></listitem><listitem><para>DRM_MODE_DPMS_STANDBY</para></listitem><listitem><para>DRM_MODE_DPMS_SUSPEND</para></listitem><listitem><para>DRM_MODE_DPMS_OFF</para></listitem></itemizedlist></para>
                <para>
            In all but DPMS_ON mode the encoder to which the connector is attached
            should put the display in low-power mode by driving its signals
            appropriately. If more than one connector is attached to the encoder
            care should be taken not to change the power state of other displays as
            a side effect. Low-power mode should be propagated to the encoders and
            CRTCs when all related connectors are put in low-power mode.
          </para>
              </sect4>
              <sect4>
                <title>Modes</title>
                <synopsis>int (*fill_modes)(struct drm_connector *connector, uint32_t max_width,
                      uint32_t max_height);</synopsis>
                <para>
            Fill the mode list with all supported modes for the connector. If the
            <parameter>max_width</parameter> and <parameter>max_height</parameter>
            arguments are non-zero, the implementation must ignore all modes wider
            than <parameter>max_width</parameter> or higher than
            <parameter>max_height</parameter>.
          </para>
                <para>
            The connector must also fill in this operation its
            <structfield>display_info</structfield><structfield>width_mm</structfield> and
            <structfield>height_mm</structfield> fields with the connected display
            physical size in millimeters. The fields should be set to 0 if the value
            isn't known or is not applicable (for instance for projector devices).
          </para>
              </sect4>
              <sect4>
                <title>Connection Status</title>
                <para>
            The connection status is updated through polling or hotplug events when
            supported (see <xref linkend="drm-kms-connector-polled" />). The status
            value is reported to userspace through ioctls and must not be used
            inside the driver, as it only gets initialized by a call to
            <function>drm_mode_getconnector</function> from userspace.
          </para>
                <synopsis>enum drm_connector_status (*detect)(struct drm_connector *connector,
                                        bool force);</synopsis>
                <para>
            Check to see if anything is attached to the connector. The
            <parameter>force</parameter> parameter is set to false whilst polling or
            to true when checking the connector due to user request.
            <parameter>force</parameter> can be used by the driver to avoid
            expensive, destructive operations during automated probing.
          </para>
                <para>
            Return connector_status_connected if something is connected to the
            connector, connector_status_disconnected if nothing is connected and
            connector_status_unknown if the connection state isn't known.
          </para>
                <para>
            Drivers should only return connector_status_connected if the connection
            status has really been probed as connected. Connectors that can't detect
            the connection status, or failed connection status probes, should return
            connector_status_unknown.
          </para>
              </sect4>
              <sect4>
                <title>Miscellaneous</title>
                <itemizedlist>
                  <listitem>
                    <synopsis>void (*set_property)(struct drm_connector *connector,
                     struct drm_property *property, uint64_t value);</synopsis>
                    <para>
                Set the value of the given connector property to
                <parameter>value</parameter>. See <xref linkend="drm-kms-properties" />
                for more information about properties.
              </para>
                  </listitem>
                  <listitem>
                    <synopsis>void (*destroy)(struct drm_connector *connector);</synopsis>
                    <para>
                Destroy the connector when not needed anymore. See
                <xref linkend="drm-kms-init" />.
              </para>
                  </listitem>
                </itemizedlist>
              </sect4>
            </sect3>
          </sect2>
          <sect2>
            <title>Cleanup</title>
            <para>
        The DRM core manages its objects' lifetime. When an object is not needed
	anymore the core calls its destroy function, which must clean up and
	free every resource allocated for the object. Every
	<function>drm_*_init</function> call must be matched with a
	corresponding <function>drm_*_cleanup</function> call to cleanup CRTCs
	(<function>drm_crtc_cleanup</function>), planes
	(<function>drm_plane_cleanup</function>), encoders
	(<function>drm_encoder_cleanup</function>) and connectors
	(<function>drm_connector_cleanup</function>). Furthermore, connectors
	that have been added to sysfs must be removed by a call to
	<function>drm_sysfs_connector_remove</function> before calling
	<function>drm_connector_cleanup</function>.
      </para>
            <para>
        Connectors state change detection must be cleanup up with a call to
	<function>drm_kms_helper_poll_fini</function>.
      </para>
          </sect2>
          <sect2>
            <title>Output discovery and initialization example</title>
            <programlisting><![CDATA[
void intel_crt_init(struct drm_device *dev)
{
	struct drm_connector *connector;
	struct intel_output *intel_output;

	intel_output = kzalloc(sizeof(struct intel_output), GFP_KERNEL);
	if (!intel_output)
		return;

	connector = &intel_output->base;
	drm_connector_init(dev, &intel_output->base,
			   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);

	drm_encoder_init(dev, &intel_output->enc, &intel_crt_enc_funcs,
			 DRM_MODE_ENCODER_DAC);

	drm_mode_connector_attach_encoder(&intel_output->base,
					  &intel_output->enc);

	/* Set up the DDC bus. */
	intel_output->ddc_bus = intel_i2c_create(dev, GPIOA, "CRTDDC_A");
	if (!intel_output->ddc_bus) {
		dev_printk(KERN_ERR, &dev->pdev->dev, "DDC bus registration "
			   "failed.\n");
		return;
	}

	intel_output->type = INTEL_OUTPUT_ANALOG;
	connector->interlace_allowed = 0;
	connector->doublescan_allowed = 0;

	drm_encoder_helper_add(&intel_output->enc, &intel_crt_helper_funcs);
	drm_connector_helper_add(connector, &intel_crt_connector_helper_funcs);

	drm_sysfs_connector_add(connector);
}]]></programlisting>
            <para>
        In the example above (taken from the i915 driver), a CRTC, connector and
        encoder combination is created. A device-specific i2c bus is also
        created for fetching EDID data and performing monitor detection. Once
        the process is complete, the new connector is registered with sysfs to
        make its properties available to applications.
      </para>
          </sect2>
          <sect2>
            <title>KMS API Functions</title>
!Edrivers/gpu/drm/drm_crtc.c
    </sect2>
        </sect1>
        <!-- Internals: kms helper functions -->
        <sect1>
          <title>Mode Setting Helper Functions</title>
          <para>
      The CRTC, encoder and connector functions provided by the drivers
      implement the DRM API. They're called by the DRM core and ioctl handlers
      to handle device state changes and configuration request. As implementing
      those functions often requires logic not specific to drivers, mid-layer
      helper functions are available to avoid duplicating boilerplate code.
    </para>
          <para>
      The DRM core contains one mid-layer implementation. The mid-layer provides
      implementations of several CRTC, encoder and connector functions (called
      from the top of the mid-layer) that pre-process requests and call
      lower-level functions provided by the driver (at the bottom of the
      mid-layer). For instance, the
      <function>drm_crtc_helper_set_config</function> function can be used to
      fill the struct <structname>drm_crtc_funcs</structname><structfield>set_config</structfield> field. When called, it will split
      the <methodname>set_config</methodname> operation in smaller, simpler
      operations and call the driver to handle them.
    </para>
          <para>
      To use the mid-layer, drivers call <function>drm_crtc_helper_add</function>,
      <function>drm_encoder_helper_add</function> and
      <function>drm_connector_helper_add</function> functions to install their
      mid-layer bottom operations handlers, and fill the
      <structname>drm_crtc_funcs</structname>,
      <structname>drm_encoder_funcs</structname> and
      <structname>drm_connector_funcs</structname> structures with pointers to
      the mid-layer top API functions. Installing the mid-layer bottom operation
      handlers is best done right after registering the corresponding KMS object.
    </para>
          <para>
      The mid-layer is not split between CRTC, encoder and connector operations.
      To use it, a driver must provide bottom functions for all of the three KMS
      entities.
    </para>
          <sect2>
            <title>Helper Functions</title>
            <itemizedlist>
              <listitem>
                <synopsis>int drm_crtc_helper_set_config(struct drm_mode_set *set);</synopsis>
                <para>
            The <function>drm_crtc_helper_set_config</function> helper function
            is a CRTC <methodname>set_config</methodname> implementation. It
            first tries to locate the best encoder for each connector by calling
            the connector <methodname>best_encoder</methodname> helper
            operation.
          </para>
                <para>
            After locating the appropriate encoders, the helper function will
            call the <methodname>mode_fixup</methodname> encoder and CRTC helper
            operations to adjust the requested mode, or reject it completely in
            which case an error will be returned to the application. If the new
            configuration after mode adjustment is identical to the current
            configuration the helper function will return without performing any
            other operation.
          </para>
                <para>
            If the adjusted mode is identical to the current mode but changes to
            the frame buffer need to be applied, the
            <function>drm_crtc_helper_set_config</function> function will call
            the CRTC <methodname>mode_set_base</methodname> helper operation. If
            the adjusted mode differs from the current mode, or if the
            <methodname>mode_set_base</methodname> helper operation is not
            provided, the helper function performs a full mode set sequence by
            calling the <methodname>prepare</methodname>,
            <methodname>mode_set</methodname> and
            <methodname>commit</methodname> CRTC and encoder helper operations,
            in that order.
          </para>
              </listitem>
              <listitem>
                <synopsis>void drm_helper_connector_dpms(struct drm_connector *connector, int mode);</synopsis>
                <para>
            The <function>drm_helper_connector_dpms</function> helper function
            is a connector <methodname>dpms</methodname> implementation that
            tracks power state of connectors. To use the function, drivers must
            provide <methodname>dpms</methodname> helper operations for CRTCs
            and encoders to apply the DPMS state to the device.
          </para>
                <para>
            The mid-layer doesn't track the power state of CRTCs and encoders.
            The <methodname>dpms</methodname> helper operations can thus be
            called with a mode identical to the currently active mode.
          </para>
              </listitem>
              <listitem>
                <synopsis>int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
                                            uint32_t maxX, uint32_t maxY);</synopsis>
                <para>
            The <function>drm_helper_probe_single_connector_modes</function> helper
            function is a connector <methodname>fill_modes</methodname>
            implementation that updates the connection status for the connector
            and then retrieves a list of modes by calling the connector
            <methodname>get_modes</methodname> helper operation.
          </para>
                <para>
            The function filters out modes larger than
            <parameter>max_width</parameter> and <parameter>max_height</parameter>
            if specified. It then calls the connector
            <methodname>mode_valid</methodname> helper operation for  each mode in
            the probed list to check whether the mode is valid for the connector.
          </para>
              </listitem>
            </itemizedlist>
          </sect2>
          <sect2>
            <title>CRTC Helper Operations</title>
            <itemizedlist>
              <listitem id="drm-helper-crtc-mode-fixup">
                <synopsis>bool (*mode_fixup)(struct drm_crtc *crtc,
                       const struct drm_display_mode *mode,
                       struct drm_display_mode *adjusted_mode);</synopsis>
                <para>
            Let CRTCs adjust the requested mode or reject it completely. This
            operation returns true if the mode is accepted (possibly after being
            adjusted) or false if it is rejected.
          </para>
                <para>
            The <methodname>mode_fixup</methodname> operation should reject the
            mode if it can't reasonably use it. The definition of "reasonable"
            is currently fuzzy in this context. One possible behaviour would be
            to set the adjusted mode to the panel timings when a fixed-mode
            panel is used with hardware capable of scaling. Another behaviour
            would be to accept any input mode and adjust it to the closest mode
            supported by the hardware (FIXME: This needs to be clarified).
          </para>
              </listitem>
              <listitem>
                <synopsis>int (*mode_set_base)(struct drm_crtc *crtc, int x, int y,
                     struct drm_framebuffer *old_fb)</synopsis>
                <para>
            Move the CRTC on the current frame buffer (stored in
            <literal>crtc-&gt;fb</literal>) to position (x,y). Any of the frame
            buffer, x position or y position may have been modified.
          </para>
                <para>
            This helper operation is optional. If not provided, the
            <function>drm_crtc_helper_set_config</function> function will fall
            back to the <methodname>mode_set</methodname> helper operation.
          </para>
                <note>
                  <para>
            FIXME: Why are x and y passed as arguments, as they can be accessed
            through <literal>crtc-&gt;x</literal> and
            <literal>crtc-&gt;y</literal>?
          </para>
                </note>
              </listitem>
              <listitem>
                <synopsis>void (*prepare)(struct drm_crtc *crtc);</synopsis>
                <para>
            Prepare the CRTC for mode setting. This operation is called after
            validating the requested mode. Drivers use it to perform
            device-specific operations required before setting the new mode.
          </para>
              </listitem>
              <listitem>
                <synopsis>int (*mode_set)(struct drm_crtc *crtc, struct drm_display_mode *mode,
                struct drm_display_mode *adjusted_mode, int x, int y,
                struct drm_framebuffer *old_fb);</synopsis>
                <para>
            Set a new mode, position and frame buffer. Depending on the device
            requirements, the mode can be stored internally by the driver and
            applied in the <methodname>commit</methodname> operation, or
            programmed to the hardware immediately.
          </para>
                <para>
            The <methodname>mode_set</methodname> operation returns 0 on success
	    or a negative error code if an error occurs.
          </para>
              </listitem>
              <listitem>
                <synopsis>void (*commit)(struct drm_crtc *crtc);</synopsis>
                <para>
            Commit a mode. This operation is called after setting the new mode.
            Upon return the device must use the new mode and be fully
            operational.
          </para>
              </listitem>
            </itemizedlist>
          </sect2>
          <sect2>
            <title>Encoder Helper Operations</title>
            <itemizedlist>
              <listitem>
                <synopsis>bool (*mode_fixup)(struct drm_encoder *encoder,
                       const struct drm_display_mode *mode,
                       struct drm_display_mode *adjusted_mode);</synopsis>
                <para>
            Let encoders adjust the requested mode or reject it completely. This
            operation returns true if the mode is accepted (possibly after being
            adjusted) or false if it is rejected. See the
            <link linkend="drm-helper-crtc-mode-fixup">mode_fixup CRTC helper
            operation</link> for an explanation of the allowed adjustments.
          </para>
              </listitem>
              <listitem>
                <synopsis>void (*prepare)(struct drm_encoder *encoder);</synopsis>
                <para>
            Prepare the encoder for mode setting. This operation is called after
            validating the requested mode. Drivers use it to perform
            device-specific operations required before setting the new mode.
          </para>
              </listitem>
              <listitem>
                <synopsis>void (*mode_set)(struct drm_encoder *encoder,
                 struct drm_display_mode *mode,
                 struct drm_display_mode *adjusted_mode);</synopsis>
                <para>
            Set a new mode. Depending on the device requirements, the mode can
            be stored internally by the driver and applied in the
            <methodname>commit</methodname> operation, or programmed to the
            hardware immediately.
          </para>
              </listitem>
              <listitem>
                <synopsis>void (*commit)(struct drm_encoder *encoder);</synopsis>
                <para>
            Commit a mode. This operation is called after setting the new mode.
            Upon return the device must use the new mode and be fully
            operational.
          </para>
              </listitem>
            </itemizedlist>
          </sect2>
          <sect2>
            <title>Connector Helper Operations</title>
            <itemizedlist>
              <listitem>
                <synopsis>struct drm_encoder *(*best_encoder)(struct drm_connector *connector);</synopsis>
                <para>
            Return a pointer to the best encoder for the connecter. Device that
            map connectors to encoders 1:1 simply return the pointer to the
            associated encoder. This operation is mandatory.
          </para>
              </listitem>
              <listitem>
                <synopsis>int (*get_modes)(struct drm_connector *connector);</synopsis>
                <para>
            Fill the connector's <structfield>probed_modes</structfield> list
            by parsing EDID data with <function>drm_add_edid_modes</function> or
            calling <function>drm_mode_probed_add</function> directly for every
            supported mode and return the number of modes it has detected. This
            operation is mandatory.
          </para>
                <para>
            When adding modes manually the driver creates each mode with a call to
            <function>drm_mode_create</function> and must fill the following fields.
            <itemizedlist><listitem><synopsis>__u32 type;</synopsis><para>
                  Mode type bitmask, a combination of
                  <variablelist><varlistentry><term>DRM_MODE_TYPE_BUILTIN</term><listitem><para>not used?</para></listitem></varlistentry><varlistentry><term>DRM_MODE_TYPE_CLOCK_C</term><listitem><para>not used?</para></listitem></varlistentry><varlistentry><term>DRM_MODE_TYPE_CRTC_C</term><listitem><para>not used?</para></listitem></varlistentry><varlistentry><term>
        DRM_MODE_TYPE_PREFERRED - The preferred mode for the connector
                      </term><listitem><para>not used?</para></listitem></varlistentry><varlistentry><term>DRM_MODE_TYPE_DEFAULT</term><listitem><para>not used?</para></listitem></varlistentry><varlistentry><term>DRM_MODE_TYPE_USERDEF</term><listitem><para>not used?</para></listitem></varlistentry><varlistentry><term>DRM_MODE_TYPE_DRIVER</term><listitem><para>
                          The mode has been created by the driver (as opposed to
                          to user-created modes).
                        </para></listitem></varlistentry></variablelist>
                  Drivers must set the DRM_MODE_TYPE_DRIVER bit for all modes they
                  create, and set the DRM_MODE_TYPE_PREFERRED bit for the preferred
                  mode.
                </para></listitem><listitem><synopsis>__u32 clock;</synopsis><para>Pixel clock frequency in kHz unit</para></listitem><listitem><synopsis>__u16 hdisplay, hsync_start, hsync_end, htotal;
    __u16 vdisplay, vsync_start, vsync_end, vtotal;</synopsis><para>Horizontal and vertical timing information</para><screen><![CDATA[
             Active                 Front           Sync           Back
             Region                 Porch                          Porch
    <-----------------------><----------------><-------------><-------------->

      //////////////////////|
     ////////////////////// |
    //////////////////////  |..................               ................
                                               _______________

    <----- [hv]display ----->
    <------------- [hv]sync_start ------------>
    <--------------------- [hv]sync_end --------------------->
    <-------------------------------- [hv]total ----------------------------->
]]></screen></listitem><listitem><synopsis>__u16 hskew;
    __u16 vscan;</synopsis><para>Unknown</para></listitem><listitem><synopsis>__u32 flags;</synopsis><para>
                  Mode flags, a combination of
                  <variablelist><varlistentry><term>DRM_MODE_FLAG_PHSYNC</term><listitem><para>
                        Horizontal sync is active high
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_NHSYNC</term><listitem><para>
                        Horizontal sync is active low
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_PVSYNC</term><listitem><para>
                        Vertical sync is active high
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_NVSYNC</term><listitem><para>
                        Vertical sync is active low
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_INTERLACE</term><listitem><para>
                        Mode is interlaced
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_DBLSCAN</term><listitem><para>
                        Mode uses doublescan
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_CSYNC</term><listitem><para>
                        Mode uses composite sync
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_PCSYNC</term><listitem><para>
                        Composite sync is active high
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_NCSYNC</term><listitem><para>
                        Composite sync is active low
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_HSKEW</term><listitem><para>
                        hskew provided (not used?)
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_BCAST</term><listitem><para>
                        not used?
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_PIXMUX</term><listitem><para>
                        not used?
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_DBLCLK</term><listitem><para>
                        not used?
                      </para></listitem></varlistentry><varlistentry><term>DRM_MODE_FLAG_CLKDIV2</term><listitem><para>
                        ?
                      </para></listitem></varlistentry></variablelist></para><para>
                  Note that modes marked with the INTERLACE or DBLSCAN flags will be
                  filtered out by
                  <function>drm_helper_probe_single_connector_modes</function> if
                  the connector's <structfield>interlace_allowed</structfield> or
                  <structfield>doublescan_allowed</structfield> field is set to 0.
                </para></listitem><listitem><synopsis>char name[DRM_DISPLAY_MODE_LEN];</synopsis><para>
                  Mode name. The driver must call
                  <function>drm_mode_set_name</function> to fill the mode name from
                  <structfield>hdisplay</structfield>,
                  <structfield>vdisplay</structfield> and interlace flag after
                  filling the corresponding fields.
                </para></listitem></itemizedlist></para>
                <para>
            The <structfield>vrefresh</structfield> value is computed by
            <function>drm_helper_probe_single_connector_modes</function>.
          </para>
                <para>
            When parsing EDID data, <function>drm_add_edid_modes</function> fill the
            connector <structfield>display_info</structfield><structfield>width_mm</structfield> and
            <structfield>height_mm</structfield> fields. When creating modes
            manually the <methodname>get_modes</methodname> helper operation must
            set the <structfield>display_info</structfield><structfield>width_mm</structfield> and
            <structfield>height_mm</structfield> fields if they haven't been set
            already (for instance at initilization time when a fixed-size panel is
            attached to the connector). The mode <structfield>width_mm</structfield>
            and <structfield>height_mm</structfield> fields are only used internally
            during EDID parsing and should not be set when creating modes manually.
          </para>
              </listitem>
              <listitem>
                <synopsis>int (*mode_valid)(struct drm_connector *connector,
		  struct drm_display_mode *mode);</synopsis>
                <para>
            Verify whether a mode is valid for the connector. Return MODE_OK for
            supported modes and one of the enum drm_mode_status values (MODE_*)
            for unsupported modes. This operation is mandatory.
          </para>
                <para>
            As the mode rejection reason is currently not used beside for
            immediately removing the unsupported mode, an implementation can
            return MODE_BAD regardless of the exact reason why the mode is not
            valid.
          </para>
                <note>
                  <para>
            Note that the <methodname>mode_valid</methodname> helper operation is
            only called for modes detected by the device, and
            <emphasis>not</emphasis> for modes set by the user through the CRTC
            <methodname>set_config</methodname> operation.
          </para>
                </note>
              </listitem>
            </itemizedlist>
          </sect2>
          <sect2>
            <title>Modeset Helper Functions Reference</title>
!Edrivers/gpu/drm/drm_crtc_helper.c
    </sect2>
          <sect2>
            <title>fbdev Helper Functions Reference</title>
!Pdrivers/gpu/drm/drm_fb_helper.c fbdev helpers
!Edrivers/gpu/drm/drm_fb_helper.c
!Iinclude/drm/drm_fb_helper.h
    </sect2>
          <sect2>
            <title>Display Port Helper Functions Reference</title>
!Pdrivers/gpu/drm/drm_dp_helper.c dp helpers
!Iinclude/drm/drm_dp_helper.h
!Edrivers/gpu/drm/drm_dp_helper.c
    </sect2>
          <sect2>
            <title>EDID Helper Functions Reference</title>
!Edrivers/gpu/drm/drm_edid.c
    </sect2>
          <sect2>
            <title>Rectangle Utilities Reference</title>
!Pinclude/drm/drm_rect.h rect utils
!Iinclude/drm/drm_rect.h
!Edrivers/gpu/drm/drm_rect.c
    </sect2>
          <sect2>
            <title>Flip-work Helper Reference</title>
!Pinclude/drm/drm_flip_work.h flip utils
!Iinclude/drm/drm_flip_work.h
!Edrivers/gpu/drm/drm_flip_work.c
    </sect2>
          <sect2>
            <title>VMA Offset Manager</title>
!Pdrivers/gpu/drm/drm_vma_manager.c vma offset manager
!Edrivers/gpu/drm/drm_vma_manager.c
!Iinclude/drm/drm_vma_manager.h
    </sect2>
        </sect1>
        <!-- Internals: kms properties -->
        <sect1 id="drm-kms-properties">
          <title>KMS Properties</title>
          <para>
      Drivers may need to expose additional parameters to applications than
      those described in the previous sections. KMS supports attaching
      properties to CRTCs, connectors and planes and offers a userspace API to
      list, get and set the property values.
    </para>
          <para>
      Properties are identified by a name that uniquely defines the property
      purpose, and store an associated value. For all property types except blob
      properties the value is a 64-bit unsigned integer.
    </para>
          <para>
      KMS differentiates between properties and property instances. Drivers
      first create properties and then create and associate individual instances
      of those properties to objects. A property can be instantiated multiple
      times and associated with different objects. Values are stored in property
      instances, and all other property information are stored in the propery
      and shared between all instances of the property.
    </para>
          <para>
      Every property is created with a type that influences how the KMS core
      handles the property. Supported property types are
      <variablelist><varlistentry><term>DRM_MODE_PROP_RANGE</term><listitem><para>Range properties report their minimum and maximum
            admissible values. The KMS core verifies that values set by
            application fit in that range.</para></listitem></varlistentry><varlistentry><term>DRM_MODE_PROP_ENUM</term><listitem><para>Enumerated properties take a numerical value that
            ranges from 0 to the number of enumerated values defined by the
            property minus one, and associate a free-formed string name to each
            value. Applications can retrieve the list of defined value-name pairs
            and use the numerical value to get and set property instance values.
            </para></listitem></varlistentry><varlistentry><term>DRM_MODE_PROP_BITMASK</term><listitem><para>Bitmask properties are enumeration properties that
            additionally restrict all enumerated values to the 0..63 range.
            Bitmask property instance values combine one or more of the
            enumerated bits defined by the property.</para></listitem></varlistentry><varlistentry><term>DRM_MODE_PROP_BLOB</term><listitem><para>Blob properties store a binary blob without any format
            restriction. The binary blobs are created as KMS standalone objects,
            and blob property instance values store the ID of their associated
            blob object.</para><para>Blob properties are only used for the connector EDID property
	    and cannot be created by drivers.</para></listitem></varlistentry></variablelist></para>
          <para>
      To create a property drivers call one of the following functions depending
      on the property type. All property creation functions take property flags
      and name, as well as type-specific arguments.
      <itemizedlist><listitem><synopsis>struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
                                               const char *name,
                                               uint64_t min, uint64_t max);</synopsis><para>Create a range property with the given minimum and maximum
            values.</para></listitem><listitem><synopsis>struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
                                              const char *name,
                                              const struct drm_prop_enum_list *props,
                                              int num_values);</synopsis><para>Create an enumerated property. The <parameter>props</parameter>
            argument points to an array of <parameter>num_values</parameter>
            value-name pairs.</para></listitem><listitem><synopsis>struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
                                                 int flags, const char *name,
                                                 const struct drm_prop_enum_list *props,
                                                 int num_values);</synopsis><para>Create a bitmask property. The <parameter>props</parameter>
            argument points to an array of <parameter>num_values</parameter>
            value-name pairs.</para></listitem></itemizedlist></para>
          <para>
      Properties can additionally be created as immutable, in which case they
      will be read-only for applications but can be modified by the driver. To
      create an immutable property drivers must set the DRM_MODE_PROP_IMMUTABLE
      flag at property creation time.
    </para>
          <para>
      When no array of value-name pairs is readily available at property
      creation time for enumerated or range properties, drivers can create
      the property using the <function>drm_property_create</function> function
      and manually add enumeration value-name pairs by calling the
      <function>drm_property_add_enum</function> function. Care must be taken to
      properly specify the property type through the <parameter>flags</parameter>
      argument.
    </para>
          <para>
      After creating properties drivers can attach property instances to CRTC,
      connector and plane objects by calling the
      <function>drm_object_attach_property</function>. The function takes a
      pointer to the target object, a pointer to the previously created property
      and an initial instance value.
    </para>
        </sect1>
        <!-- Internals: vertical blanking -->
        <sect1 id="drm-vertical-blank">
          <title>Vertical Blanking</title>
          <para>
      Vertical blanking plays a major role in graphics rendering. To achieve
      tear-free display, users must synchronize page flips and/or rendering to
      vertical blanking. The DRM API offers ioctls to perform page flips
      synchronized to vertical blanking and wait for vertical blanking.
    </para>
          <para>
      The DRM core handles most of the vertical blanking management logic, which
      involves filtering out spurious interrupts, keeping race-free blanking
      counters, coping with counter wrap-around and resets and keeping use
      counts. It relies on the driver to generate vertical blanking interrupts
      and optionally provide a hardware vertical blanking counter. Drivers must
      implement the following operations.
    </para>
          <itemizedlist>
            <listitem>
              <synopsis>int (*enable_vblank) (struct drm_device *dev, int crtc);
void (*disable_vblank) (struct drm_device *dev, int crtc);</synopsis>
              <para>
	  Enable or disable vertical blanking interrupts for the given CRTC.
	</para>
            </listitem>
            <listitem>
              <synopsis>u32 (*get_vblank_counter) (struct drm_device *dev, int crtc);</synopsis>
              <para>
	  Retrieve the value of the vertical blanking counter for the given
	  CRTC. If the hardware maintains a vertical blanking counter its value
	  should be returned. Otherwise drivers can use the
	  <function>drm_vblank_count</function> helper function to handle this
	  operation.
	</para>
            </listitem>
          </itemizedlist>
          <para>
      Drivers must initialize the vertical blanking handling core with a call to
      <function>drm_vblank_init</function> in their
      <methodname>load</methodname> operation. The function will set the struct
      <structname>drm_device</structname><structfield>vblank_disable_allowed</structfield> field to 0. This will
      keep vertical blanking interrupts enabled permanently until the first mode
      set operation, where <structfield>vblank_disable_allowed</structfield> is
      set to 1. The reason behind this is not clear. Drivers can set the field
      to 1 after <function>calling drm_vblank_init</function> to make vertical
      blanking interrupts dynamically managed from the beginning.
    </para>
          <para>
      Vertical blanking interrupts can be enabled by the DRM core or by drivers
      themselves (for instance to handle page flipping operations). The DRM core
      maintains a vertical blanking use count to ensure that the interrupts are
      not disabled while a user still needs them. To increment the use count,
      drivers call <function>drm_vblank_get</function>. Upon return vertical
      blanking interrupts are guaranteed to be enabled.
    </para>
          <para>
      To decrement the use count drivers call
      <function>drm_vblank_put</function>. Only when the use count drops to zero
      will the DRM core disable the vertical blanking interrupts after a delay
      by scheduling a timer. The delay is accessible through the vblankoffdelay
      module parameter or the <varname>drm_vblank_offdelay</varname> global
      variable and expressed in milliseconds. Its default value is 5000 ms.
    </para>
          <para>
      When a vertical blanking interrupt occurs drivers only need to call the
      <function>drm_handle_vblank</function> function to account for the
      interrupt.
    </para>
          <para>
      Resources allocated by <function>drm_vblank_init</function> must be freed
      with a call to <function>drm_vblank_cleanup</function> in the driver
      <methodname>unload</methodname> operation handler.
    </para>
        </sect1>
        <!-- Internals: open/close, file operations and ioctls -->
        <sect1>
          <title>Open/Close, File Operations and IOCTLs</title>
          <sect2>
            <title>Open and Close</title>
            <synopsis>int (*firstopen) (struct drm_device *);
void (*lastclose) (struct drm_device *);
int (*open) (struct drm_device *, struct drm_file *);
void (*preclose) (struct drm_device *, struct drm_file *);
void (*postclose) (struct drm_device *, struct drm_file *);</synopsis>
            <abstract>Open and close handlers. None of those methods are mandatory.
      </abstract>
            <para>
        The <methodname>firstopen</methodname> method is called by the DRM core
	for legacy UMS (User Mode Setting) drivers only when an application
	opens a device that has no other opened file handle. UMS drivers can
	implement it to acquire device resources. KMS drivers can't use the
	method and must acquire resources in the <methodname>load</methodname>
	method instead.
      </para>
            <para>
	Similarly the <methodname>lastclose</methodname> method is called when
	the last application holding a file handle opened on the device closes
	it, for both UMS and KMS drivers. Additionally, the method is also
	called at module unload time or, for hot-pluggable devices, when the
	device is unplugged. The <methodname>firstopen</methodname> and
	<methodname>lastclose</methodname> calls can thus be unbalanced.
      </para>
            <para>
        The <methodname>open</methodname> method is called every time the device
	is opened by an application. Drivers can allocate per-file private data
	in this method and store them in the struct
	<structname>drm_file</structname><structfield>driver_priv</structfield>
	field. Note that the <methodname>open</methodname> method is called
	before <methodname>firstopen</methodname>.
      </para>
            <para>
        The close operation is split into <methodname>preclose</methodname> and
	<methodname>postclose</methodname> methods. Drivers must stop and
	cleanup all per-file operations in the <methodname>preclose</methodname>
	method. For instance pending vertical blanking and page flip events must
	be cancelled. No per-file operation is allowed on the file handle after
	returning from the <methodname>preclose</methodname> method.
      </para>
            <para>
        Finally the <methodname>postclose</methodname> method is called as the
	last step of the close operation, right before calling the
	<methodname>lastclose</methodname> method if no other open file handle
	exists for the device. Drivers that have allocated per-file private data
	in the <methodname>open</methodname> method should free it here.
      </para>
            <para>
        The <methodname>lastclose</methodname> method should restore CRTC and
	plane properties to default value, so that a subsequent open of the
	device will not inherit state from the previous user. It can also be
	used to execute delayed power switching state changes, e.g. in
	conjunction with the vga-switcheroo infrastructure. Beyond that KMS
	drivers should not do any further cleanup. Only legacy UMS drivers might
	need to clean up device state so that the vga console or an independent
	fbdev driver could take over.
      </para>
          </sect2>
          <sect2>
            <title>File Operations</title>
            <synopsis>const struct file_operations *fops</synopsis>
            <abstract>File operations for the DRM device node.</abstract>
            <para>
        Drivers must define the file operations structure that forms the DRM
	userspace API entry point, even though most of those operations are
	implemented in the DRM core. The <methodname>open</methodname>,
	<methodname>release</methodname> and <methodname>ioctl</methodname>
	operations are handled by
	<programlisting>
	.owner = THIS_MODULE,
	.open = drm_open,
	.release = drm_release,
	.unlocked_ioctl = drm_ioctl,
  #ifdef CONFIG_COMPAT
	.compat_ioctl = drm_compat_ioctl,
  #endif
        </programlisting></para>
            <para>
        Drivers that implement private ioctls that requires 32/64bit
	compatibility support must provide their own
	<methodname>compat_ioctl</methodname> handler that processes private
	ioctls and calls <function>drm_compat_ioctl</function> for core ioctls.
      </para>
            <para>
        The <methodname>read</methodname> and <methodname>poll</methodname>
	operations provide support for reading DRM events and polling them. They
	are implemented by
	<programlisting>
	.poll = drm_poll,
	.read = drm_read,
	.llseek = no_llseek,
	</programlisting></para>
            <para>
        The memory mapping implementation varies depending on how the driver
	manages memory. Pre-GEM drivers will use <function>drm_mmap</function>,
	while GEM-aware drivers will use <function>drm_gem_mmap</function>. See
	<xref linkend="drm-gem" />.
	<programlisting>
	.mmap = drm_gem_mmap,
	</programlisting></para>
            <para>
        No other file operation is supported by the DRM API.
      </para>
          </sect2>
          <sect2>
            <title>IOCTLs</title>
            <synopsis>struct drm_ioctl_desc *ioctls;
int num_ioctls;</synopsis>
            <abstract>Driver-specific ioctls descriptors table.</abstract>
            <para>
        Driver-specific ioctls numbers start at DRM_COMMAND_BASE. The ioctls
	descriptors table is indexed by the ioctl number offset from the base
	value. Drivers can use the DRM_IOCTL_DEF_DRV() macro to initialize the
	table entries.
      </para>
            <para>
              <programlisting>DRM_IOCTL_DEF_DRV(ioctl, func, flags)</programlisting>
              <para>
                <parameter>ioctl</parameter> is the ioctl name. Drivers must define
	  the DRM_##ioctl and DRM_IOCTL_##ioctl macros to the ioctl number
	  offset from DRM_COMMAND_BASE and the ioctl number respectively. The
	  first macro is private to the device while the second must be exposed
	  to userspace in a public header.
	</para>
              <para>
                <parameter>func</parameter> is a pointer to the ioctl handler function
	  compatible with the <type>drm_ioctl_t</type> type.
	  <programlisting>typedef int drm_ioctl_t(struct drm_device *dev, void *data,
		struct drm_file *file_priv);</programlisting></para>
              <para>
                <parameter>flags</parameter> is a bitmask combination of the following
	  values. It restricts how the ioctl is allowed to be called.
	  <itemizedlist><listitem><para>
	      DRM_AUTH - Only authenticated callers allowed
	    </para></listitem><listitem><para>
	      DRM_MASTER - The ioctl can only be called on the master file
	      handle
	    </para></listitem><listitem><para>
	      DRM_ROOT_ONLY - Only callers with the SYSADMIN capability allowed
	    </para></listitem><listitem><para>
	      DRM_CONTROL_ALLOW - The ioctl can only be called on a control
	      device
	    </para></listitem><listitem><para>
	      DRM_UNLOCKED - The ioctl handler will be called without locking
	      the DRM global mutex
	    </para></listitem></itemizedlist></para>
            </para>
          </sect2>
        </sect1>
        <sect1>
          <title>Command submission &amp; fencing</title>
          <para>
      This should cover a few device-specific command submission
      implementations.
    </para>
        </sect1>
        <!-- Internals: suspend/resume -->
        <sect1>
          <title>Suspend/Resume</title>
          <para>
      The DRM core provides some suspend/resume code, but drivers wanting full
      suspend/resume support should provide save() and restore() functions.
      These are called at suspend, hibernate, or resume time, and should perform
      any state save or restore required by your device across suspend or
      hibernate states.
    </para>
          <synopsis>int (*suspend) (struct drm_device *, pm_message_t state);
int (*resume) (struct drm_device *);</synopsis>
          <para>
      Those are legacy suspend and resume methods. New driver should use the
      power management interface provided by their bus type (usually through
      the struct <structname>device_driver</structname> dev_pm_ops) and set
      these methods to NULL.
    </para>
        </sect1>
        <sect1>
          <title>DMA services</title>
          <para>
      This should cover how DMA mapping etc. is supported by the core.
      These functions are deprecated and should not be used.
    </para>
        </sect1>
      </chapter>
      <!-- TODO

- Add a glossary
- Document the struct_mutex catch-all lock
- Document connector properties

- Why is the load method optional?
- What are drivers supposed to set the initial display state to, and how?
  Connector's DPMS states are not initialized and are thus equal to
  DRM_MODE_DPMS_ON. The fbcon compatibility layer calls
  drm_helper_disable_unused_functions(), which disables unused encoders and
  CRTCs, but doesn't touch the connectors' DPMS state, and
  drm_helper_connector_dpms() in reaction to fbdev blanking events. Do drivers
  that don't implement (or just don't use) fbcon compatibility need to call
  those functions themselves?
- KMS drivers must call drm_vblank_pre_modeset() and drm_vblank_post_modeset()
  around mode setting. Should this be done in the DRM core?
- vblank_disable_allowed is set to 1 in the first drm_vblank_post_modeset()
  call and never set back to 0. It seems to be safe to permanently set it to 1
  in drm_vblank_init() for KMS driver, and it might be safe for UMS drivers as
  well. This should be investigated.
- crtc and connector .save and .restore operations are only used internally in
  drivers, should they be removed from the core?
- encoder mid-layer .save and .restore operations are only used internally in
  drivers, should they be removed from the core?
- encoder mid-layer .detect operation is only used internally in drivers,
  should it be removed from the core?
-->
      <!-- External interfaces -->
      <chapter id="drmExternals">
        <title>Userland interfaces</title>
        <para>
      The DRM core exports several interfaces to applications,
      generally intended to be used through corresponding libdrm
      wrapper functions.  In addition, drivers export device-specific
      interfaces for use by userspace drivers &amp; device-aware
      applications through ioctls and sysfs files.
    </para>
        <para>
      External interfaces include: memory mapping, context management,
      DMA operations, AGP management, vblank control, fence
      management, memory management, and output management.
    </para>
        <para>
      Cover generic ioctls and sysfs layout here.  We only need high-level
      info, since man pages should cover the rest.
    </para>
        <!-- External: render nodes -->
        <sect1>
          <title>Render nodes</title>
          <para>
        DRM core provides multiple character-devices for user-space to use.
        Depending on which device is opened, user-space can perform a different
        set of operations (mainly ioctls). The primary node is always created
        and called <term>card&lt;num&gt;</term>. Additionally, a currently
        unused control node, called <term>controlD&lt;num&gt;</term> is also
        created. The primary node provides all legacy operations and
        historically was the only interface used by userspace. With KMS, the
        control node was introduced. However, the planned KMS control interface
        has never been written and so the control node stays unused to date.
      </para>
          <para>
        With the increased use of offscreen renderers and GPGPU applications,
        clients no longer require running compositors or graphics servers to
        make use of a GPU. But the DRM API required unprivileged clients to
        authenticate to a DRM-Master prior to getting GPU access. To avoid this
        step and to grant clients GPU access without authenticating, render
        nodes were introduced. Render nodes solely serve render clients, that
        is, no modesetting or privileged ioctls can be issued on render nodes.
        Only non-global rendering commands are allowed. If a driver supports
        render nodes, it must advertise it via the <term>DRIVER_RENDER</term>
        DRM driver capability. If not supported, the primary node must be used
        for render clients together with the legacy drmAuth authentication
        procedure.
      </para>
          <para>
        If a driver advertises render node support, DRM core will create a
        separate render node called <term>renderD&lt;num&gt;</term>. There will
        be one render node per device. No ioctls except  PRIME-related ioctls
        will be allowed on this node. Especially <term>GEM_OPEN</term> will be
        explicitly prohibited. Render nodes are designed to avoid the
        buffer-leaks, which occur if clients guess the flink names or mmap
        offsets on the legacy interface. Additionally to this basic interface,
        drivers must mark their driver-dependent render-only ioctls as
        <term>DRM_RENDER_ALLOW</term> so render clients can use them. Driver
        authors must be careful not to allow any privileged ioctls on render
        nodes.
      </para>
          <para>
        With render nodes, user-space can now control access to the render node
        via basic file-system access-modes. A running graphics server which
        authenticates clients on the privileged primary/legacy node is no longer
        required. Instead, a client can open the render node and is immediately
        granted GPU access. Communication between clients (or servers) is done
        via PRIME. FLINK from render node to legacy node is not supported. New
        clients must not use the insecure FLINK interface.
      </para>
          <para>
        Besides dropping all modeset/global ioctls, render nodes also drop the
        DRM-Master concept. There is no reason to associate render clients with
        a DRM-Master as they are independent of any graphics server. Besides,
        they must work without any running master, anyway.
        Drivers must be able to run without a master object if they support
        render nodes. If, on the other hand, a driver requires shared state
        between clients which is visible to user-space and accessible beyond
        open-file boundaries, they cannot support render nodes.
      </para>
        </sect1>
        <!-- External: vblank handling -->
        <sect1>
          <title>VBlank event handling</title>
          <para>
        The DRM core exposes two vertical blank related ioctls:
        <variablelist><varlistentry><term>DRM_IOCTL_WAIT_VBLANK</term><listitem><para>
                This takes a struct drm_wait_vblank structure as its argument,
                and it is used to block or request a signal when a specified
                vblank event occurs.
              </para></listitem></varlistentry><varlistentry><term>DRM_IOCTL_MODESET_CTL</term><listitem><para>
                This should be called by application level drivers before and
                after mode setting, since on many devices the vertical blank
                counter is reset at that time.  Internally, the DRM snapshots
                the last vblank count when the ioctl is called with the
                _DRM_PRE_MODESET command, so that the counter won't go backwards
                (which is dealt with when _DRM_POST_MODESET is used).
              </para></listitem></varlistentry></variablelist><!--!Edrivers/char/drm/drm_irq.c--></para>
        </sect1>
      </chapter>
      <!-- API reference -->
      <appendix id="drmDriverApi">
        <title>DRM Driver API</title>
        <para>
      Include auto-generated API reference here (need to reference it
      from paragraphs above too).
    </para>
      </appendix>
    </book>
    <book id="Linux-filesystems-API">
      <bookinfo>
        <title>Linux Filesystems API</title>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="vfs">
        <title>The Linux VFS</title>
        <sect1 id="the_filesystem_types">
          <title>The Filesystem types</title>
!Iinclude/linux/fs.h
     </sect1>
        <sect1 id="the_directory_cache">
          <title>The Directory Cache</title>
!Efs/dcache.c
!Iinclude/linux/dcache.h
     </sect1>
        <sect1 id="inode_handling">
          <title>Inode Handling</title>
!Efs/inode.c
!Efs/bad_inode.c
     </sect1>
        <sect1 id="registration_and_superblocks">
          <title>Registration and Superblocks</title>
!Efs/super.c
     </sect1>
        <sect1 id="file_locks">
          <title>File Locks</title>
!Efs/locks.c
!Ifs/locks.c
     </sect1>
        <sect1 id="other_functions">
          <title>Other Functions</title>
!Efs/mpage.c
!Efs/namei.c
!Efs/buffer.c
!Efs/bio.c
!Efs/seq_file.c
!Efs/filesystems.c
!Efs/fs-writeback.c
!Efs/block_dev.c
     </sect1>
      </chapter>
      <chapter id="proc">
        <title>The proc filesystem</title>
        <sect1 id="sysctl_interface">
          <title>sysctl interface</title>
!Ekernel/sysctl.c
     </sect1>
        <sect1 id="proc_filesystem_interface">
          <title>proc filesystem interface</title>
!Ifs/proc/base.c
     </sect1>
      </chapter>
      <chapter id="fs_events">
        <title>Events based on file descriptors</title>
!Efs/eventfd.c
  </chapter>
      <chapter id="sysfs">
        <title>The Filesystem for Exporting Kernel Objects</title>
!Efs/sysfs/file.c
!Efs/sysfs/symlink.c
  </chapter>
      <chapter id="debugfs">
        <title>The debugfs filesystem</title>
        <sect1 id="debugfs_interface">
          <title>debugfs interface</title>
!Efs/debugfs/inode.c
!Efs/debugfs/file.c
     </sect1>
      </chapter>
      <chapter id="LinuxJDBAPI">
        <chapterinfo>
          <title>The Linux Journalling API</title>
          <authorgroup>
            <author>
              <firstname>Roger</firstname>
              <surname>Gammans</surname>
              <affiliation>
                <address>
                  <email>rgammans@computer-surgery.co.uk</email>
                </address>
              </affiliation>
            </author>
          </authorgroup>
          <authorgroup>
            <author>
              <firstname>Stephen</firstname>
              <surname>Tweedie</surname>
              <affiliation>
                <address>
                  <email>sct@redhat.com</email>
                </address>
              </affiliation>
            </author>
          </authorgroup>
          <copyright>
            <year>2002</year>
            <holder>Roger Gammans</holder>
          </copyright>
        </chapterinfo>
        <title>The Linux Journalling API</title>
        <sect1 id="journaling_overview">
          <title>Overview</title>
          <sect2 id="journaling_details">
            <title>Details</title>
            <para>
The journalling layer is  easy to use. You need to
first of all create a journal_t data structure. There are
two calls to do this dependent on how you decide to allocate the physical
media on which the journal resides. The journal_init_inode() call
is for journals stored in filesystem inodes, or the journal_init_dev()
call can be use for journal stored on a raw device (in a continuous range
of blocks). A journal_t is a typedef for a struct pointer, so when
you are finally finished make sure you call journal_destroy() on it
to free up any used kernel memory.
</para>
            <para>
Once you have got your journal_t object you need to 'mount' or load the journal
file, unless of course you haven't initialised it yet - in which case you
need to call journal_create().
</para>
            <para>
Most of the time however your journal file will already have been created, but
before you load it you must call journal_wipe() to empty the journal file.
Hang on, you say , what if the filesystem wasn't cleanly umount()'d . Well, it is the
job of the client file system to detect this and skip the call to journal_wipe().
</para>
            <para>
In either case the next call should be to journal_load() which prepares the
journal file for use. Note that journal_wipe(..,0) calls journal_skip_recovery()
for you if it detects any outstanding transactions in the journal and similarly
journal_load() will call journal_recover() if necessary.
I would advise reading fs/ext3/super.c for examples on this stage.
[RGG: Why is the journal_wipe() call necessary - doesn't this needlessly
complicate the API. Or isn't a good idea for the journal layer to hide
dirty mounts from the client fs]
</para>
            <para>
Now you can go ahead and start modifying the underlying
filesystem. Almost.
</para>
            <para>

You still need to actually journal your filesystem changes, this
is done by wrapping them into transactions. Additionally you
also need to wrap the modification of each of the buffers
with calls to the journal layer, so it knows what the modifications
you are actually making are. To do this use  journal_start() which
returns a transaction handle.
</para>
            <para>
journal_start()
and its counterpart journal_stop(), which indicates the end of a transaction
are nestable calls, so you can reenter a transaction if necessary,
but remember you must call journal_stop() the same number of times as
journal_start() before the transaction is completed (or more accurately
leaves the update phase). Ext3/VFS makes use of this feature to simplify
quota support.
</para>
            <para>
Inside each transaction you need to wrap the modifications to the
individual buffers (blocks). Before you start to modify a buffer you
need to call journal_get_{create,write,undo}_access() as appropriate,
this allows the journalling layer to copy the unmodified data if it
needs to. After all the buffer may be part of a previously uncommitted
transaction.
At this point you are at last ready to modify a buffer, and once
you are have done so you need to call journal_dirty_{meta,}data().
Or if you've asked for access to a buffer you now know is now longer
required to be pushed back on the device you can call journal_forget()
in much the same way as you might have used bforget() in the past.
</para>
            <para>
A journal_flush() may be called at any time to commit and checkpoint
all your transactions.
</para>
            <para>
Then at umount time , in your put_super() you can then call journal_destroy()
to clean up your in-core journal object.
</para>
            <para>
Unfortunately there a couple of ways the journal layer can cause a deadlock.
The first thing to note is that each task can only have
a single outstanding transaction at any one time, remember nothing
commits until the outermost journal_stop(). This means
you must complete the transaction at the end of each file/inode/address
etc. operation you perform, so that the journalling system isn't re-entered
on another journal. Since transactions can't be nested/batched
across differing journals, and another filesystem other than
yours (say ext3) may be modified in a later syscall.
</para>
            <para>
The second case to bear in mind is that journal_start() can
block if there isn't enough space in the journal for your transaction
(based on the passed nblocks param) - when it blocks it merely(!) needs to
wait for transactions to complete and be committed from other tasks,
so essentially we are waiting for journal_stop(). So to avoid
deadlocks you must treat journal_start/stop() as if they
were semaphores and include them in your semaphore ordering rules to prevent
deadlocks. Note that journal_extend() has similar blocking behaviour to
journal_start() so you can deadlock here just as easily as on journal_start().
</para>
            <para>
Try to reserve the right number of blocks the first time. ;-). This will
be the maximum number of blocks you are going to touch in this transaction.
I advise having a look at at least ext3_jbd.h to see the basis on which
ext3 uses to make these decisions.
</para>
            <para>
Another wriggle to watch out for is your on-disk block allocation strategy.
why? Because, if you undo a delete, you need to ensure you haven't reused any
of the freed blocks in a later transaction. One simple way of doing this
is make sure any blocks you allocate only have checkpointed transactions
listed against them. Ext3 does this in ext3_test_allocatable().
</para>
            <para>
Lock is also providing through journal_{un,}lock_updates(),
ext3 uses this when it wants a window with a clean and stable fs for a moment.
eg.
</para>
            <programlisting>

	journal_lock_updates() //stop new stuff happening..
	journal_flush()        // checkpoint everything.
	..do stuff on stable fs
	journal_unlock_updates() // carry on with filesystem use.
</programlisting>
            <para>
The opportunities for abuse and DOS attacks with this should be obvious,
if you allow unprivileged userspace to trigger codepaths containing these
calls.
</para>
            <para>
A new feature of jbd since 2.5.25 is commit callbacks with the new
journal_callback_set() function you can now ask the journalling layer
to call you back when the transaction is finally committed to disk, so that
you can do some of your own management. The key to this is the journal_callback
struct, this maintains the internal callback information but you can
extend it like this:-
</para>
            <programlisting>
	struct  myfs_callback_s {
		//Data structure element required by jbd..
		struct journal_callback for_jbd;
		// Stuff for myfs allocated together.
		myfs_inode*    i_commited;

	}
</programlisting>
            <para>
this would be useful if you needed to know when data was committed to a
particular inode.
</para>
          </sect2>
          <sect2 id="jbd_summary">
            <title>Summary</title>
            <para>
Using the journal is a matter of wrapping the different context changes,
being each mount, each modification (transaction) and each changed buffer
to tell the journalling layer about them.
</para>
            <para>
Here is a some pseudo code to give you an idea of how it works, as
an example.
</para>
            <programlisting>
  journal_t* my_jnrl = journal_create();
  journal_init_{dev,inode}(jnrl,...)
  if (clean) journal_wipe();
  journal_load();

   foreach(transaction) { /*transactions must be
                            completed before
                            a syscall returns to
                            userspace*/

          handle_t * xct=journal_start(my_jnrl);
          foreach(bh) {
                journal_get_{create,write,undo}_access(xact,bh);
                if ( myfs_modify(bh) ) { /* returns true
                                        if makes changes */
                           journal_dirty_{meta,}data(xact,bh);
                } else {
                           journal_forget(bh);
                }
          }
          journal_stop(xct);
   }
   journal_destroy(my_jrnl);
</programlisting>
          </sect2>
        </sect1>
        <sect1 id="data_types">
          <title>Data Types</title>
          <para>
	The journalling layer uses typedefs to 'hide' the concrete definitions
	of the structures used. As a client of the JBD layer you can
	just rely on the using the pointer as a magic cookie  of some sort.

	Obviously the hiding is not enforced as this is 'C'.
     </para>
          <sect2 id="structures">
            <title>Structures</title>
!Iinclude/linux/jbd.h
	</sect2>
        </sect1>
        <sect1 id="functions">
          <title>Functions</title>
          <para>
	The functions here are split into two groups those that
	affect a journal as a whole, and those which are used to
	manage transactions
     </para>
          <sect2 id="journal_level">
            <title>Journal Level</title>
!Efs/jbd/journal.c
!Ifs/jbd/recovery.c
	</sect2>
          <sect2 id="transaction_level">
            <title>Transasction Level</title>
!Efs/jbd/transaction.c
	</sect2>
        </sect1>
        <sect1 id="see_also">
          <title>See also</title>
          <para>
            <citation>
              <ulink url="http://kernel.org/pub/linux/kernel/people/sct/ext3/journal-design.ps.gz">
	   	Journaling the Linux ext2fs Filesystem, LinuxExpo 98, Stephen Tweedie
	   </ulink>
            </citation>
          </para>
          <para>
            <citation>
              <ulink url="http://olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html">
	   	Ext3 Journalling FileSystem, OLS 2000, Dr. Stephen Tweedie
	   </ulink>
            </citation>
          </para>
        </sect1>
      </chapter>
      <chapter id="splice">
        <title>splice API</title>
        <para>
	splice is a method for moving blocks of data around inside the
	kernel, without continually transferring them between the kernel
	and user space.
  </para>
!Ffs/splice.c
  </chapter>
      <chapter id="pipes">
        <title>pipes API</title>
        <para>
	Pipe interfaces are all for in-kernel (builtin image) use.
	They are not exported for use by modules.
  </para>
!Iinclude/linux/pipe_fs_i.h
!Ffs/pipe.c
  </chapter>
    </book>
    <book id="USB-Gadget-API">
      <bookinfo>
        <title>USB Gadget API for Linux</title>
        <date>20 August 2004</date>
        <edition>20 August 2004</edition>
        <legalnotice>
          <para>
	 This documentation is free software; you can redistribute
	 it and/or modify it under the terms of the GNU General Public
	 License as published by the Free Software Foundation; either
	 version 2 of the License, or (at your option) any later
	 version.
       </para>
          <para>
	 This program is distributed in the hope that it will be
	 useful, but WITHOUT ANY WARRANTY; without even the implied
	 warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	 See the GNU General Public License for more details.
       </para>
          <para>
	 You should have received a copy of the GNU General Public
	 License along with this program; if not, write to the Free
	 Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
	 MA 02111-1307 USA
       </para>
          <para>
	 For more details see the file COPYING in the source
	 distribution of Linux.
       </para>
        </legalnotice>
        <copyright>
          <year>2003-2004</year>
          <holder>David Brownell</holder>
        </copyright>
        <author>
          <firstname>David</firstname>
          <surname>Brownell</surname>
          <affiliation>
            <address>
              <email>dbrownell@users.sourceforge.net</email>
            </address>
          </affiliation>
        </author>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>This document presents a Linux-USB "Gadget"
kernel mode
API, for use within peripherals and other USB devices
that embed Linux.
It provides an overview of the API structure,
and shows how that fits into a system development project.
This is the first such API released on Linux to address
a number of important problems, including: </para>
        <itemizedlist>
          <listitem>
            <para>Supports USB 2.0, for high speed devices which
	can stream data at several dozen megabytes per second.
	</para>
          </listitem>
          <listitem>
            <para>Handles devices with dozens of endpoints just as
	well as ones with just two fixed-function ones.  Gadget drivers
	can be written so they're easy to port to new hardware.
	</para>
          </listitem>
          <listitem>
            <para>Flexible enough to expose more complex USB device
	capabilities such as multiple configurations, multiple interfaces,
	composite devices,
	and alternate interface settings.
	</para>
          </listitem>
          <listitem>
            <para>USB "On-The-Go" (OTG) support, in conjunction
	with updates to the Linux-USB host side.
	</para>
          </listitem>
          <listitem>
            <para>Sharing data structures and API models with the
	Linux-USB host side API.  This helps the OTG support, and
	looks forward to more-symmetric frameworks (where the same
	I/O model is used by both host and device side drivers).
	</para>
          </listitem>
          <listitem>
            <para>Minimalist, so it's easier to support new device
	controller hardware.  I/O processing doesn't imply large
	demands for memory or CPU resources.
	</para>
          </listitem>
        </itemizedlist>
        <para>Most Linux developers will not be able to use this API, since they
have USB "host" hardware in a PC, workstation, or server.
Linux users with embedded systems are more likely to
have USB peripheral hardware.
To distinguish drivers running inside such hardware from the
more familiar Linux "USB device drivers",
which are host side proxies for the real USB devices,
a different term is used:
the drivers inside the peripherals are "USB gadget drivers".
In USB protocol interactions, the device driver is the master
(or "client driver")
and the gadget driver is the slave (or "function driver").
</para>
        <para>The gadget API resembles the host side Linux-USB API in that both
use queues of request objects to package I/O buffers, and those requests
may be submitted or canceled.
They share common definitions for the standard USB
<emphasis>Chapter 9</emphasis> messages, structures, and constants.
Also, both APIs bind and unbind drivers to devices.
The APIs differ in detail, since the host side's current
URB framework exposes a number of implementation details
and assumptions that are inappropriate for a gadget API.
While the model for control transfers and configuration
management is necessarily different (one side is a hardware-neutral master,
the other is a hardware-aware slave), the endpoint I/0 API used here
should also be usable for an overhead-reduced host side API.
</para>
      </chapter>
      <chapter id="structure">
        <title>Structure of Gadget Drivers</title>
        <para>A system running inside a USB peripheral
normally has at least three layers inside the kernel to handle
USB protocol processing, and may have additional layers in
user space code.
The "gadget" API is used by the middle layer to interact
with the lowest level (which directly handles hardware).
</para>
        <para>In Linux, from the bottom up, these layers are:
</para>
        <variablelist>
          <varlistentry>
            <term>
              <emphasis>USB Controller Driver</emphasis>
            </term>
            <listitem>
              <para>This is the lowest software level.
	It is the only layer that talks to hardware,
	through registers, fifos, dma, irqs, and the like.
	The <filename>&lt;linux/usb/gadget.h&gt;</filename> API abstracts
	the peripheral controller endpoint hardware.
	That hardware is exposed through endpoint objects, which accept
	streams of IN/OUT buffers, and through callbacks that interact
	with gadget drivers.
	Since normal USB devices only have one upstream
	port, they only have one of these drivers.
	The controller driver can support any number of different
	gadget drivers, but only one of them can be used at a time.
	</para>
              <para>Examples of such controller hardware include
	the PCI-based NetChip 2280 USB 2.0 high speed controller,
	the SA-11x0 or PXA-25x UDC (found within many PDAs),
	and a variety of other products.
	</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis>Gadget Driver</emphasis>
            </term>
            <listitem>
              <para>The lower boundary of this driver implements hardware-neutral
	USB functions, using calls to the controller driver.
	Because such hardware varies widely in capabilities and restrictions,
	and is used in embedded environments where space is at a premium,
	the gadget driver is often configured at compile time
	to work with endpoints supported by one particular controller.
	Gadget drivers may be portable to several different controllers,
	using conditional compilation.
	(Recent kernels substantially simplify the work involved in
	supporting new hardware, by <emphasis>autoconfiguring</emphasis>
	endpoints automatically for many bulk-oriented drivers.)
	Gadget driver responsibilities include:
	</para>
              <itemizedlist>
                <listitem>
                  <para>handling setup requests (ep0 protocol responses)
		possibly including class-specific functionality
		</para>
                </listitem>
                <listitem>
                  <para>returning configuration and string descriptors
		</para>
                </listitem>
                <listitem>
                  <para>(re)setting configurations and interface
		altsettings, including enabling and configuring endpoints
		</para>
                </listitem>
                <listitem>
                  <para>handling life cycle events, such as managing
		bindings to hardware,
		USB suspend/resume, remote wakeup,
		and disconnection from the USB host.
		</para>
                </listitem>
                <listitem>
                  <para>managing IN and OUT transfers on all currently
		enabled endpoints
		</para>
                </listitem>
              </itemizedlist>
              <para>
	Such drivers may be modules of proprietary code, although
	that approach is discouraged in the Linux community.
	</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis>Upper Level</emphasis>
            </term>
            <listitem>
              <para>Most gadget drivers have an upper boundary that connects
	to some Linux driver or framework in Linux.
	Through that boundary flows the data which the gadget driver
	produces and/or consumes through protocol transfers over USB.
	Examples include:
	</para>
              <itemizedlist>
                <listitem>
                  <para>user mode code, using generic (gadgetfs)
	        or application specific files in
		<filename>/dev</filename></para>
                </listitem>
                <listitem>
                  <para>networking subsystem (for network gadgets,
		like the CDC Ethernet Model gadget driver)
		</para>
                </listitem>
                <listitem>
                  <para>data capture drivers, perhaps video4Linux or
		 a scanner driver; or test and measurement hardware.
		 </para>
                </listitem>
                <listitem>
                  <para>input subsystem (for HID gadgets)
		</para>
                </listitem>
                <listitem>
                  <para>sound subsystem (for audio gadgets)
		</para>
                </listitem>
                <listitem>
                  <para>file system (for PTP gadgets)
		</para>
                </listitem>
                <listitem>
                  <para>block i/o subsystem (for usb-storage gadgets)
		</para>
                </listitem>
                <listitem>
                  <para>... and more </para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <emphasis>Additional Layers</emphasis>
            </term>
            <listitem>
              <para>Other layers may exist.
	These could include kernel layers, such as network protocol stacks,
	as well as user mode applications building on standard POSIX
	system call APIs such as
	<emphasis>open()</emphasis>, <emphasis>close()</emphasis>,
	<emphasis>read()</emphasis> and <emphasis>write()</emphasis>.
	On newer systems, POSIX Async I/O calls may be an option.
	Such user mode code will not necessarily be subject to
	the GNU General Public License (GPL).
	</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>OTG-capable systems will also need to include a standard Linux-USB
host side stack,
with <emphasis>usbcore</emphasis>,
one or more <emphasis>Host Controller Drivers</emphasis> (HCDs),
<emphasis>USB Device Drivers</emphasis> to support
the OTG "Targeted Peripheral List",
and so forth.
There will also be an <emphasis>OTG Controller Driver</emphasis>,
which is visible to gadget and device driver developers only indirectly.
That helps the host and device side USB controllers implement the
two new OTG protocols (HNP and SRP).
Roles switch (host to peripheral, or vice versa) using HNP
during USB suspend processing, and SRP can be viewed as a
more battery-friendly kind of device wakeup protocol.
</para>
        <para>Over time, reusable utilities are evolving to help make some
gadget driver tasks simpler.
For example, building configuration descriptors from vectors of
descriptors for the configurations interfaces and endpoints is
now automated, and many drivers now use autoconfiguration to
choose hardware endpoints and initialize their descriptors.

A potential example of particular interest
is code implementing standard USB-IF protocols for
HID, networking, storage, or audio classes.
Some developers are interested in KDB or KGDB hooks, to let
target hardware be remotely debugged.
Most such USB protocol code doesn't need to be hardware-specific,
any more than network protocols like X11, HTTP, or NFS are.
Such gadget-side interface drivers should eventually be combined,
to implement composite devices.
</para>
      </chapter>
      <chapter id="api">
        <title>Kernel Mode Gadget API</title>
        <para>Gadget drivers declare themselves through a
<emphasis>struct usb_gadget_driver</emphasis>, which is responsible for
most parts of enumeration for a <emphasis>struct usb_gadget</emphasis>.
The response to a set_configuration usually involves
enabling one or more of the <emphasis>struct usb_ep</emphasis> objects
exposed by the gadget, and submitting one or more
<emphasis>struct usb_request</emphasis> buffers to transfer data.
Understand those four data types, and their operations, and
you will understand how this API works.
</para>
        <note>
          <title>Incomplete Data Type Descriptions</title>
          <para>This documentation was prepared using the standard Linux
kernel <filename>docproc</filename> tool, which turns text
and in-code comments into SGML DocBook and then into usable
formats such as HTML or PDF.
Other than the "Chapter 9" data types, most of the significant
data types and functions are described here.
</para>
          <para>However, docproc does not understand all the C constructs
that are used, so some relevant information is likely omitted from
what you are reading.  
One example of such information is endpoint autoconfiguration.
You'll have to read the header file, and use example source
code (such as that for "Gadget Zero"), to fully understand the API.
</para>
          <para>The part of the API implementing some basic
driver capabilities is specific to the version of the
Linux kernel that's in use.
The 2.6 kernel includes a <emphasis>driver model</emphasis>
framework that has no analogue on earlier kernels;
so those parts of the gadget API are not fully portable.
(They are implemented on 2.4 kernels, but in a different way.)
The driver model state is another part of this API that is
ignored by the kerneldoc tools.
</para>
        </note>
        <para>The core API does not expose
every possible hardware feature, only the most widely available ones.
There are significant hardware features, such as device-to-device DMA
(without temporary storage in a memory buffer)
that would be added using hardware-specific APIs.
</para>
        <para>This API allows drivers to use conditional compilation to handle
endpoint capabilities of different hardware, but doesn't require that.
Hardware tends to have arbitrary restrictions, relating to
transfer types, addressing, packet sizes, buffering, and availability.
As a rule, such differences only matter for "endpoint zero" logic
that handles device configuration and management.
The API supports limited run-time
detection of capabilities, through naming conventions for endpoints.
Many drivers will be able to at least partially autoconfigure
themselves.
In particular, driver init sections will often have endpoint
autoconfiguration logic that scans the hardware's list of endpoints
to find ones matching the driver requirements
(relying on those conventions), to eliminate some of the most
common reasons for conditional compilation.
</para>
        <para>Like the Linux-USB host side API, this API exposes
the "chunky" nature of USB messages:  I/O requests are in terms
of one or more "packets", and packet boundaries are visible to drivers.
Compared to RS-232 serial protocols, USB resembles
synchronous protocols like HDLC
(N bytes per frame, multipoint addressing, host as the primary
station and devices as secondary stations)
more than asynchronous ones
(tty style:  8 data bits per frame, no parity, one stop bit).
So for example the controller drivers won't buffer
two single byte writes into a single two-byte USB IN packet,
although gadget drivers may do so when they implement
protocols where packet boundaries (and "short packets")
are not significant.
</para>
        <sect1 id="lifecycle">
          <title>Driver Life Cycle</title>
          <para>Gadget drivers make endpoint I/O requests to hardware without
needing to know many details of the hardware, but driver
setup/configuration code needs to handle some differences.
Use the API like this:
</para>
          <orderedlist numeration="arabic">
            <listitem>
              <para>Register a driver for the particular device side
usb controller hardware,
such as the net2280 on PCI (USB 2.0),
sa11x0 or pxa25x as found in Linux PDAs,
and so on.
At this point the device is logically in the USB ch9 initial state
("attached"), drawing no power and not usable
(since it does not yet support enumeration).
Any host should not see the device, since it's not
activated the data line pullup used by the host to
detect a device, even if VBUS power is available.
</para>
            </listitem>
            <listitem>
              <para>Register a gadget driver that implements some higher level
device function.  That will then bind() to a usb_gadget, which
activates the data line pullup sometime after detecting VBUS.
</para>
            </listitem>
            <listitem>
              <para>The hardware driver can now start enumerating.
The steps it handles are to accept USB power and set_address requests.
Other steps are handled by the gadget driver.
If the gadget driver module is unloaded before the host starts to
enumerate, steps before step 7 are skipped.
</para>
            </listitem>
            <listitem>
              <para>The gadget driver's setup() call returns usb descriptors,
based both on what the bus interface hardware provides and on the
functionality being implemented.
That can involve alternate settings or configurations,
unless the hardware prevents such operation.
For OTG devices, each configuration descriptor includes
an OTG descriptor.
</para>
            </listitem>
            <listitem>
              <para>The gadget driver handles the last step of enumeration,
when the USB host issues a set_configuration call.
It enables all endpoints used in that configuration,
with all interfaces in their default settings.
That involves using a list of the hardware's endpoints, enabling each
endpoint according to its descriptor.
It may also involve using <function>usb_gadget_vbus_draw</function>
to let more power be drawn from VBUS, as allowed by that configuration.
For OTG devices, setting a configuration may also involve reporting
HNP capabilities through a user interface.
</para>
            </listitem>
            <listitem>
              <para>Do real work and perform data transfers, possibly involving
changes to interface settings or switching to new configurations, until the
device is disconnect()ed from the host.
Queue any number of transfer requests to each endpoint.
It may be suspended and resumed several times before being disconnected.
On disconnect, the drivers go back to step 3 (above).
</para>
            </listitem>
            <listitem>
              <para>When the gadget driver module is being unloaded,
the driver unbind() callback is issued.  That lets the controller
driver be unloaded.
</para>
            </listitem>
          </orderedlist>
          <para>Drivers will normally be arranged so that just loading the
gadget driver module (or statically linking it into a Linux kernel)
allows the peripheral device to be enumerated, but some drivers
will defer enumeration until some higher level component (like
a user mode daemon) enables it.
Note that at this lowest level there are no policies about how
ep0 configuration logic is implemented,
except that it should obey USB specifications.
Such issues are in the domain of gadget drivers,
including knowing about implementation constraints
imposed by some USB controllers
or understanding that composite devices might happen to
be built by integrating reusable components.
</para>
          <para>Note that the lifecycle above can be slightly different
for OTG devices.
Other than providing an additional OTG descriptor in each
configuration, only the HNP-related differences are particularly
visible to driver code.
They involve reporting requirements during the SET_CONFIGURATION
request, and the option to invoke HNP during some suspend callbacks.
Also, SRP changes the semantics of
<function>usb_gadget_wakeup</function>
slightly.
</para>
        </sect1>
        <sect1 id="ch9">
          <title>USB 2.0 Chapter 9 Types and Constants</title>
          <para>Gadget drivers
rely on common USB structures and constants
defined in the
<filename>&lt;linux/usb/ch9.h&gt;</filename>
header file, which is standard in Linux 2.6 kernels.
These are the same types and constants used by host
side drivers (and usbcore).
</para>

!Iinclude/linux/usb/ch9.h
</sect1>
        <sect1 id="core">
          <title>Core Objects and Methods</title>
          <para>These are declared in
<filename>&lt;linux/usb/gadget.h&gt;</filename>,
and are used by gadget drivers to interact with
USB peripheral controller drivers.
</para>
          <!-- yeech, this is ugly in nsgmls PDF output.

	     the PDF bookmark and refentry output nesting is wrong,
	     and the member/argument documentation indents ugly.

	     plus something (docproc?) adds whitespace before the
	     descriptive paragraph text, so it can't line up right
	     unless the explanations are trivial.
	  -->

!Iinclude/linux/usb/gadget.h
</sect1>
        <sect1 id="utils">
          <title>Optional Utilities</title>
          <para>The core API is sufficient for writing a USB Gadget Driver,
but some optional utilities are provided to simplify common tasks.
These utilities include endpoint autoconfiguration.
</para>

!Edrivers/usb/gadget/usbstring.c
!Edrivers/usb/gadget/config.c
<!-- !Edrivers/usb/gadget/epautoconf.c --></sect1>
        <sect1 id="composite">
          <title>Composite Device Framework</title>
          <para>The core API is sufficient for writing drivers for composite
USB devices (with more than one function in a given configuration),
and also multi-configuration devices (also more than one function,
but not necessarily sharing a given configuration).
There is however an optional framework which makes it easier to
reuse and combine functions.
</para>
          <para>Devices using this framework provide a <emphasis>struct
usb_composite_driver</emphasis>, which in turn provides one or
more <emphasis>struct usb_configuration</emphasis> instances.
Each such configuration includes at least one
<emphasis>struct usb_function</emphasis>, which packages a user
visible role such as "network link" or "mass storage device".
Management functions may also exist, such as "Device Firmware
Upgrade".
</para>

!Iinclude/linux/usb/composite.h
!Edrivers/usb/gadget/composite.c

</sect1>
        <sect1 id="functions">
          <title>Composite Device Functions</title>
          <para>At this writing, a few of the current gadget drivers have
been converted to this framework.
Near-term plans include converting all of them, except for "gadgetfs".
</para>

!Edrivers/usb/gadget/f_acm.c
!Edrivers/usb/gadget/f_ecm.c
!Edrivers/usb/gadget/f_subset.c
!Edrivers/usb/gadget/f_obex.c
!Edrivers/usb/gadget/f_serial.c

</sect1>
      </chapter>
      <chapter id="controllers">
        <title>Peripheral Controller Drivers</title>
        <para>The first hardware supporting this API was the NetChip 2280
controller, which supports USB 2.0 high speed and is based on PCI.
This is the <filename>net2280</filename> driver module.
The driver supports Linux kernel versions 2.4 and 2.6;
contact NetChip Technologies for development boards and product
information.
</para>
        <para>Other hardware working in the "gadget" framework includes:
Intel's PXA 25x and IXP42x series processors
(<filename>pxa2xx_udc</filename>),
Toshiba TC86c001 "Goku-S" (<filename>goku_udc</filename>),
Renesas SH7705/7727 (<filename>sh_udc</filename>),
MediaQ 11xx (<filename>mq11xx_udc</filename>),
Hynix HMS30C7202 (<filename>h7202_udc</filename>),
National 9303/4 (<filename>n9604_udc</filename>),
Texas Instruments OMAP (<filename>omap_udc</filename>),
Sharp LH7A40x (<filename>lh7a40x_udc</filename>),
and more.
Most of those are full speed controllers.
</para>
        <para>At this writing, there are people at work on drivers in
this framework for several other USB device controllers,
with plans to make many of them be widely available.
</para>
        <!-- !Edrivers/usb/gadget/net2280.c -->
        <para>A partial USB simulator,
the <filename>dummy_hcd</filename> driver, is available.
It can act like a net2280, a pxa25x, or an sa11x0 in terms
of available endpoints and device speeds; and it simulates
control, bulk, and to some extent interrupt transfers.
That lets you develop some parts of a gadget driver on a normal PC,
without any special hardware, and perhaps with the assistance
of tools such as GDB running with User Mode Linux.
At least one person has expressed interest in adapting that
approach, hooking it up to a simulator for a microcontroller.
Such simulators can help debug subsystems where the runtime hardware
is unfriendly to software development, or is not yet available.
</para>
        <para>Support for other controllers is expected to be developed
and contributed
over time, as this driver framework evolves.
</para>
      </chapter>
      <chapter id="gadget">
        <title>Gadget Drivers</title>
        <para>In addition to <emphasis>Gadget Zero</emphasis>
(used primarily for testing and development with drivers
for usb controller hardware), other gadget drivers exist.
</para>
        <para>There's an <emphasis>ethernet</emphasis> gadget
driver, which implements one of the most useful
<emphasis>Communications Device Class</emphasis> (CDC) models.  
One of the standards for cable modem interoperability even
specifies the use of this ethernet model as one of two
mandatory options.
Gadgets using this code look to a USB host as if they're
an Ethernet adapter.
It provides access to a network where the gadget's CPU is one host,
which could easily be bridging, routing, or firewalling
access to other networks.
Since some hardware can't fully implement the CDC Ethernet
requirements, this driver also implements a "good parts only"
subset of CDC Ethernet.
(That subset doesn't advertise itself as CDC Ethernet,
to avoid creating problems.)
</para>
        <para>Support for Microsoft's <emphasis>RNDIS</emphasis>
protocol has been contributed by Pengutronix and Auerswald GmbH.
This is like CDC Ethernet, but it runs on more slightly USB hardware
(but less than the CDC subset).
However, its main claim to fame is being able to connect directly to
recent versions of Windows, using drivers that Microsoft bundles
and supports, making it much simpler to network with Windows.
</para>
        <para>There is also support for user mode gadget drivers,
using <emphasis>gadgetfs</emphasis>.
This provides a <emphasis>User Mode API</emphasis> that presents
each endpoint as a single file descriptor.  I/O is done using
normal <emphasis>read()</emphasis> and <emphasis>read()</emphasis> calls.
Familiar tools like GDB and pthreads can be used to
develop and debug user mode drivers, so that once a robust
controller driver is available many applications for it
won't require new kernel mode software.
Linux 2.6 <emphasis>Async I/O (AIO)</emphasis>
support is available, so that user mode software
can stream data with only slightly more overhead
than a kernel driver.
</para>
        <para>There's a USB Mass Storage class driver, which provides
a different solution for interoperability with systems such
as MS-Windows and MacOS.
That <emphasis>Mass Storage</emphasis> driver uses a
file or block device as backing store for a drive,
like the <filename>loop</filename> driver.
The USB host uses the BBB, CB, or CBI versions of the mass
storage class specification, using transparent SCSI commands
to access the data from the backing store.
</para>
        <para>There's a "serial line" driver, useful for TTY style
operation over USB.
The latest version of that driver supports CDC ACM style
operation, like a USB modem, and so on most hardware it can
interoperate easily with MS-Windows.
One interesting use of that driver is in boot firmware (like a BIOS),
which can sometimes use that model with very small systems without
real serial lines.
</para>
        <para>Support for other kinds of gadget is expected to
be developed and contributed
over time, as this driver framework evolves.
</para>
      </chapter>
      <chapter id="otg">
        <title>USB On-The-GO (OTG)</title>
        <para>USB OTG support on Linux 2.6 was initially developed
by Texas Instruments for
<ulink url="http://www.omap.com">OMAP</ulink> 16xx and 17xx
series processors.
Other OTG systems should work in similar ways, but the
hardware level details could be very different.
</para>
        <para>Systems need specialized hardware support to implement OTG,
notably including a special <emphasis>Mini-AB</emphasis> jack
and associated transciever to support <emphasis>Dual-Role</emphasis>
operation:
they can act either as a host, using the standard
Linux-USB host side driver stack,
or as a peripheral, using this "gadget" framework.
To do that, the system software relies on small additions
to those programming interfaces,
and on a new internal component (here called an "OTG Controller")
affecting which driver stack connects to the OTG port.
In each role, the system can re-use the existing pool of
hardware-neutral drivers, layered on top of the controller
driver interfaces (<emphasis>usb_bus</emphasis> or
<emphasis>usb_gadget</emphasis>).
Such drivers need at most minor changes, and most of the calls
added to support OTG can also benefit non-OTG products.
</para>
        <itemizedlist>
          <listitem>
            <para>Gadget drivers test the <emphasis>is_otg</emphasis>
	flag, and use it to determine whether or not to include
	an OTG descriptor in each of their configurations.
	</para>
          </listitem>
          <listitem>
            <para>Gadget drivers may need changes to support the
	two new OTG protocols, exposed in new gadget attributes
	such as <emphasis>b_hnp_enable</emphasis> flag.
	HNP support should be reported through a user interface
	(two LEDs could suffice), and is triggered in some cases
	when the host suspends the peripheral.
	SRP support can be user-initiated just like remote wakeup,
	probably by pressing the same button.
	</para>
          </listitem>
          <listitem>
            <para>On the host side, USB device drivers need
	to be taught to trigger HNP at appropriate moments, using
	<function>usb_suspend_device()</function>.
	That also conserves battery power, which is useful even
	for non-OTG configurations.
	</para>
          </listitem>
          <listitem>
            <para>Also on the host side, a driver must support the
	OTG "Targeted Peripheral List".  That's just a whitelist,
	used to reject peripherals not supported with a given
	Linux OTG host.
	<emphasis>This whitelist is product-specific;
	each product must modify <filename>otg_whitelist.h</filename>
	to match its interoperability specification.
	</emphasis></para>
            <para>Non-OTG Linux hosts, like PCs and workstations,
	normally have some solution for adding drivers, so that
	peripherals that aren't recognized can eventually be supported.
	That approach is unreasonable for consumer products that may
	never have their firmware upgraded, and where it's usually
	unrealistic to expect traditional PC/workstation/server kinds
	of support model to work.
	For example, it's often impractical to change device firmware
	once the product has been distributed, so driver bugs can't
	normally be fixed if they're found after shipment.
	</para>
          </listitem>
        </itemizedlist>
        <para>
Additional changes are needed below those hardware-neutral
<emphasis>usb_bus</emphasis> and <emphasis>usb_gadget</emphasis>
driver interfaces; those aren't discussed here in any detail.
Those affect the hardware-specific code for each USB Host or Peripheral
controller, and how the HCD initializes (since OTG can be active only
on a single port).
They also involve what may be called an <emphasis>OTG Controller
Driver</emphasis>, managing the OTG transceiver and the OTG state
machine logic as well as much of the root hub behavior for the
OTG port.
The OTG controller driver needs to activate and deactivate USB
controllers depending on the relevant device role.
Some related changes were needed inside usbcore, so that it
can identify OTG-capable devices and respond appropriately
to HNP or SRP protocols.
</para>
      </chapter>
    </book>
    <!--
	vim:syntax=sgml:sw=4
-->
    <book id="Generic-IRQ-Guide">
      <bookinfo>
        <title>Linux generic IRQ handling</title>
        <authorgroup>
          <author>
            <firstname>Thomas</firstname>
            <surname>Gleixner</surname>
            <affiliation>
              <address>
                <email>tglx@linutronix.de</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>Ingo</firstname>
            <surname>Molnar</surname>
            <affiliation>
              <address>
                <email>mingo@elte.hu</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2005-2010</year>
          <holder>Thomas Gleixner</holder>
        </copyright>
        <copyright>
          <year>2005-2006</year>
          <holder>Ingo Molnar</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
	The generic interrupt handling layer is designed to provide a
	complete abstraction of interrupt handling for device drivers.
	It is able to handle all the different types of interrupt controller
	hardware. Device drivers use generic API functions to request, enable,
	disable and free interrupts. The drivers do not have to know anything
	about interrupt hardware details, so they can be used on different
	platforms without code changes.
    </para>
        <para>
  	This documentation is provided to developers who want to implement
	an interrupt subsystem based for their architecture, with the help
	of the generic IRQ handling layer.
    </para>
      </chapter>
      <chapter id="rationale">
        <title>Rationale</title>
        <para>
	The original implementation of interrupt handling in Linux uses
	the __do_IRQ() super-handler, which is able to deal with every
	type of interrupt logic.
	</para>
        <para>
	Originally, Russell King identified different types of handlers to
	build a quite universal set for the ARM interrupt handler
	implementation in Linux 2.5/2.6. He distinguished between:
	<itemizedlist><listitem><para>Level type</para></listitem><listitem><para>Edge type</para></listitem><listitem><para>Simple type</para></listitem></itemizedlist>
	During the implementation we identified another type:
	<itemizedlist><listitem><para>Fast EOI type</para></listitem></itemizedlist>
	In the SMP world of the __do_IRQ() super-handler another type
	was identified:
	<itemizedlist><listitem><para>Per CPU type</para></listitem></itemizedlist></para>
        <para>
	This split implementation of high-level IRQ handlers allows us to
	optimize the flow of the interrupt handling for each specific
	interrupt type. This reduces complexity in that particular code path
	and allows the optimized handling of a given type.
	</para>
        <para>
	The original general IRQ implementation used hw_interrupt_type
	structures and their -&gt;ack(), -&gt;end() [etc.] callbacks to
	differentiate the flow control in the super-handler. This leads to
	a mix of flow logic and low-level hardware logic, and it also leads
	to unnecessary code duplication: for example in i386, there is an
	ioapic_level_irq and an ioapic_edge_irq IRQ-type which share many
	of the low-level details but have different flow handling.
	</para>
        <para>
	A more natural abstraction is the clean separation of the
	'irq flow' and the 'chip details'.
	</para>
        <para>
	Analysing a couple of architecture's IRQ subsystem implementations
	reveals that most of them can use a generic set of 'irq flow'
	methods and only need to add the chip-level specific code.
	The separation is also valuable for (sub)architectures
	which need specific quirks in the IRQ flow itself but not in the
	chip details - and thus provides a more transparent IRQ subsystem
	design.
	</para>
        <para>
	Each interrupt descriptor is assigned its own high-level flow
	handler, which is normally one of the generic
	implementations. (This high-level flow handler implementation also
	makes it simple to provide demultiplexing handlers which can be
	found in embedded platforms on various architectures.)
	</para>
        <para>
	The separation makes the generic interrupt handling layer more
	flexible and extensible. For example, an (sub)architecture can
	use a generic IRQ-flow implementation for 'level type' interrupts
	and add a (sub)architecture specific 'edge type' implementation.
	</para>
        <para>
	To make the transition to the new model easier and prevent the
	breakage of existing implementations, the __do_IRQ() super-handler
	is still available. This leads to a kind of duality for the time
	being. Over time the new model should be used in more and more
	architectures, as it enables smaller and cleaner IRQ subsystems.
	It's deprecated for three years now and about to be removed.
	</para>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs And Assumptions</title>
        <para>
	None (knock on wood).
    </para>
      </chapter>
      <chapter id="Abstraction">
        <title>Abstraction layers</title>
        <para>
	There are three main levels of abstraction in the interrupt code:
	<orderedlist><listitem><para>High-level driver API</para></listitem><listitem><para>High-level IRQ flow handlers</para></listitem><listitem><para>Chip-level hardware encapsulation</para></listitem></orderedlist></para>
        <sect1 id="Interrupt_control_flow">
          <title>Interrupt control flow</title>
          <para>
	Each interrupt is described by an interrupt descriptor structure
	irq_desc. The interrupt is referenced by an 'unsigned int' numeric
	value which selects the corresponding interrupt decription structure
	in the descriptor structures array.
	The descriptor structure contains status information and pointers
	to the interrupt flow method and the interrupt chip structure
	which are assigned to this interrupt.
	</para>
          <para>
	Whenever an interrupt triggers, the low-level architecture code calls
	into the generic interrupt code by calling desc-&gt;handle_irq().
	This high-level IRQ handling function only uses desc-&gt;irq_data.chip
	primitives referenced by the assigned chip descriptor structure.
	</para>
        </sect1>
        <sect1 id="Highlevel_Driver_API">
          <title>High-level Driver API</title>
          <para>
	  The high-level Driver API consists of following functions:
	  <itemizedlist><listitem><para>request_irq()</para></listitem><listitem><para>free_irq()</para></listitem><listitem><para>disable_irq()</para></listitem><listitem><para>enable_irq()</para></listitem><listitem><para>disable_irq_nosync() (SMP only)</para></listitem><listitem><para>synchronize_irq() (SMP only)</para></listitem><listitem><para>irq_set_irq_type()</para></listitem><listitem><para>irq_set_irq_wake()</para></listitem><listitem><para>irq_set_handler_data()</para></listitem><listitem><para>irq_set_chip()</para></listitem><listitem><para>irq_set_chip_data()</para></listitem></itemizedlist>
	  See the autogenerated function documentation for details.
	</para>
        </sect1>
        <sect1 id="Highlevel_IRQ_flow_handlers">
          <title>High-level IRQ flow handlers</title>
          <para>
	  The generic layer provides a set of pre-defined irq-flow methods:
	  <itemizedlist><listitem><para>handle_level_irq</para></listitem><listitem><para>handle_edge_irq</para></listitem><listitem><para>handle_fasteoi_irq</para></listitem><listitem><para>handle_simple_irq</para></listitem><listitem><para>handle_percpu_irq</para></listitem><listitem><para>handle_edge_eoi_irq</para></listitem><listitem><para>handle_bad_irq</para></listitem></itemizedlist>
	  The interrupt flow handlers (either pre-defined or architecture
	  specific) are assigned to specific interrupts by the architecture
	  either during bootup or during device initialization.
	</para>
          <sect2 id="Default_flow_implementations">
            <title>Default flow implementations</title>
            <sect3 id="Helper_functions">
              <title>Helper functions</title>
              <para>
		The helper functions call the chip primitives and
		are used by the default flow implementations.
		The following helper functions are implemented (simplified excerpt):
		<programlisting>
default_enable(struct irq_data *data)
{
	desc-&gt;irq_data.chip-&gt;irq_unmask(data);
}

default_disable(struct irq_data *data)
{
	if (!delay_disable(data))
		desc-&gt;irq_data.chip-&gt;irq_mask(data);
}

default_ack(struct irq_data *data)
{
	chip-&gt;irq_ack(data);
}

default_mask_ack(struct irq_data *data)
{
	if (chip-&gt;irq_mask_ack) {
		chip-&gt;irq_mask_ack(data);
	} else {
		chip-&gt;irq_mask(data);
		chip-&gt;irq_ack(data);
	}
}

noop(struct irq_data *data))
{
}

		</programlisting></para>
            </sect3>
          </sect2>
          <sect2 id="Default_flow_handler_implementations">
            <title>Default flow handler implementations</title>
            <sect3 id="Default_Level_IRQ_flow_handler">
              <title>Default Level IRQ flow handler</title>
              <para>
		handle_level_irq provides a generic implementation
		for level-triggered interrupts.
		</para>
              <para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
desc-&gt;irq_data.chip-&gt;irq_mask_ack();
handle_irq_event(desc-&gt;action);
desc-&gt;irq_data.chip-&gt;irq_unmask();
		</programlisting></para>
            </sect3>
            <sect3 id="Default_FASTEOI_IRQ_flow_handler">
              <title>Default Fast EOI IRQ flow handler</title>
              <para>
		handle_fasteoi_irq provides a generic implementation
		for interrupts, which only need an EOI at the end of
		the handler.
		</para>
              <para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
handle_irq_event(desc-&gt;action);
desc-&gt;irq_data.chip-&gt;irq_eoi();
		</programlisting></para>
            </sect3>
            <sect3 id="Default_Edge_IRQ_flow_handler">
              <title>Default Edge IRQ flow handler</title>
              <para>
		handle_edge_irq provides a generic implementation
		for edge-triggered interrupts.
		</para>
              <para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
if (desc-&gt;status &amp; running) {
	desc-&gt;irq_data.chip-&gt;irq_mask_ack();
	desc-&gt;status |= pending | masked;
	return;
}
desc-&gt;irq_data.chip-&gt;irq_ack();
desc-&gt;status |= running;
do {
	if (desc-&gt;status &amp; masked)
		desc-&gt;irq_data.chip-&gt;irq_unmask();
	desc-&gt;status &amp;= ~pending;
	handle_irq_event(desc-&gt;action);
} while (status &amp; pending);
desc-&gt;status &amp;= ~running;
		</programlisting></para>
            </sect3>
            <sect3 id="Default_simple_IRQ_flow_handler">
              <title>Default simple IRQ flow handler</title>
              <para>
		handle_simple_irq provides a generic implementation
		for simple interrupts.
		</para>
              <para>
		Note: The simple flow handler does not call any
		handler/chip primitives.
		</para>
              <para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
handle_irq_event(desc-&gt;action);
		</programlisting></para>
            </sect3>
            <sect3 id="Default_per_CPU_flow_handler">
              <title>Default per CPU flow handler</title>
              <para>
		handle_percpu_irq provides a generic implementation
		for per CPU interrupts.
		</para>
              <para>
		Per CPU interrupts are only available on SMP and
		the handler provides a simplified version without
		locking.
		</para>
              <para>
		The following control flow is implemented (simplified excerpt):
		<programlisting>
if (desc-&gt;irq_data.chip-&gt;irq_ack)
	desc-&gt;irq_data.chip-&gt;irq_ack();
handle_irq_event(desc-&gt;action);
if (desc-&gt;irq_data.chip-&gt;irq_eoi)
        desc-&gt;irq_data.chip-&gt;irq_eoi();
		</programlisting></para>
            </sect3>
            <sect3 id="EOI_Edge_IRQ_flow_handler">
              <title>EOI Edge IRQ flow handler</title>
              <para>
		handle_edge_eoi_irq provides an abnomination of the edge
		handler which is solely used to tame a badly wreckaged
		irq controller on powerpc/cell.
		</para>
            </sect3>
            <sect3 id="BAD_IRQ_flow_handler">
              <title>Bad IRQ flow handler</title>
              <para>
		handle_bad_irq is used for spurious interrupts which
		have no real handler assigned..
		</para>
            </sect3>
          </sect2>
          <sect2 id="Quirks_and_optimizations">
            <title>Quirks and optimizations</title>
            <para>
	The generic functions are intended for 'clean' architectures and chips,
	which have no platform-specific IRQ handling quirks. If an architecture
	needs to implement quirks on the 'flow' level then it can do so by
	overriding the high-level irq-flow handler.
	</para>
          </sect2>
          <sect2 id="Delayed_interrupt_disable">
            <title>Delayed interrupt disable</title>
            <para>
	This per interrupt selectable feature, which was introduced by Russell
	King in the ARM interrupt implementation, does not mask an interrupt
	at the hardware level when disable_irq() is called. The interrupt is
	kept enabled and is masked in the flow handler when an interrupt event
	happens. This prevents losing edge interrupts on hardware which does
	not store an edge interrupt event while the interrupt is disabled at
	the hardware level. When an interrupt arrives while the IRQ_DISABLED
	flag is set, then the interrupt is masked at the hardware level and
	the IRQ_PENDING bit is set. When the interrupt is re-enabled by
	enable_irq() the pending bit is checked and if it is set, the
	interrupt is resent either via hardware or by a software resend
	mechanism. (It's necessary to enable CONFIG_HARDIRQS_SW_RESEND when
	you want to use the delayed interrupt disable feature and your
	hardware is not capable of retriggering	an interrupt.)
	The delayed interrupt disable is not configurable.
	</para>
          </sect2>
        </sect1>
        <sect1 id="Chiplevel_hardware_encapsulation">
          <title>Chip-level hardware encapsulation</title>
          <para>
	The chip-level hardware descriptor structure irq_chip
	contains all the direct chip relevant functions, which
	can be utilized by the irq flow implementations.
	  <itemizedlist><listitem><para>irq_ack()</para></listitem><listitem><para>irq_mask_ack() - Optional, recommended for performance</para></listitem><listitem><para>irq_mask()</para></listitem><listitem><para>irq_unmask()</para></listitem><listitem><para>irq_eoi() - Optional, required for EOI flow handlers</para></listitem><listitem><para>irq_retrigger() - Optional</para></listitem><listitem><para>irq_set_type() - Optional</para></listitem><listitem><para>irq_set_wake() - Optional</para></listitem></itemizedlist>
	These primitives are strictly intended to mean what they say: ack means
	ACK, masking means masking of an IRQ line, etc. It is up to the flow
	handler(s) to use these basic units of low-level functionality.
	</para>
        </sect1>
      </chapter>
      <chapter id="doirq">
        <title>__do_IRQ entry point</title>
        <para>
	The original implementation __do_IRQ() was an alternative entry
	point for all types of interrupts. It no longer exists.
     </para>
        <para>
	This handler turned out to be not suitable for all
	interrupt hardware and was therefore reimplemented with split
	functionality for edge/level/simple/percpu interrupts. This is not
	only a functional optimization. It also shortens code paths for
	interrupts.
      </para>
      </chapter>
      <chapter id="locking">
        <title>Locking on SMP</title>
        <para>
	The locking of chip registers is up to the architecture that
	defines the chip primitives. The per-irq structure is
	protected via desc-&gt;lock, by the generic layer.
     </para>
      </chapter>
      <chapter id="genericchip">
        <title>Generic interrupt chip</title>
        <para>
       To avoid copies of identical implementations of IRQ chips the
       core provides a configurable generic interrupt chip
       implementation. Developers should check carefuly whether the
       generic chip fits their needs before implementing the same
       functionality slightly differently themselves.
     </para>
!Ekernel/irq/generic-chip.c
  </chapter>
      <chapter id="structs">
        <title>Structures</title>
        <para>
     This chapter contains the autogenerated documentation of the structures which are
     used in the generic IRQ layer.
     </para>
!Iinclude/linux/irq.h
!Iinclude/linux/interrupt.h
  </chapter>
      <chapter id="pubfunctions">
        <title>Public Functions Provided</title>
        <para>
     This chapter contains the autogenerated documentation of the kernel API functions
      which are exported.
     </para>
!Ekernel/irq/manage.c
!Ekernel/irq/chip.c
  </chapter>
      <chapter id="intfunctions">
        <title>Internal Functions Provided</title>
        <para>
     This chapter contains the autogenerated documentation of the internal functions.
     </para>
!Ikernel/irq/irqdesc.c
!Ikernel/irq/handle.c
!Ikernel/irq/chip.c
  </chapter>
      <chapter id="credits">
        <title>Credits</title>
        <para>
		The following people have contributed to this document:
		<orderedlist><listitem><para>Thomas Gleixner<email>tglx@linutronix.de</email></para></listitem><listitem><para>Ingo Molnar<email>mingo@elte.hu</email></para></listitem></orderedlist></para>
      </chapter>
    </book>
    <book id="LinuxKernelAPI">
      <bookinfo>
        <title>The Linux Kernel API</title>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="adt">
        <title>Data Types</title>
        <sect1>
          <title>Doubly Linked Lists</title>
!Iinclude/linux/list.h
     </sect1>
      </chapter>
      <chapter id="libc">
        <title>Basic C Library Functions</title>
        <para>
       When writing drivers, you cannot in general use routines which are
       from the C Library.  Some of the functions have been found generally
       useful and they are listed below.  The behaviour of these functions
       may vary slightly from those defined by ANSI, and these deviations
       are noted in the text.
     </para>
        <sect1>
          <title>String Conversions</title>
!Elib/vsprintf.c
!Finclude/linux/kernel.h kstrtol
!Finclude/linux/kernel.h kstrtoul
!Elib/kstrtox.c
     </sect1>
        <sect1>
          <title>String Manipulation</title>
          <!-- All functions are exported at now
X!Ilib/string.c
 -->
!Elib/string.c
     </sect1>
        <sect1>
          <title>Bit Operations</title>
!Iarch/x86/include/asm/bitops.h
     </sect1>
      </chapter>
      <chapter id="kernel-lib">
        <title>Basic Kernel Library Functions</title>
        <para>
       The Linux kernel provides more basic utility functions.
     </para>
        <sect1>
          <title>Bitmap Operations</title>
!Elib/bitmap.c
!Ilib/bitmap.c
     </sect1>
        <sect1>
          <title>Command-line Parsing</title>
!Elib/cmdline.c
     </sect1>
        <sect1 id="crc">
          <title>CRC Functions</title>
!Elib/crc7.c
!Elib/crc16.c
!Elib/crc-itu-t.c
!Elib/crc32.c
!Elib/crc-ccitt.c
     </sect1>
        <sect1 id="idr">
          <title>idr/ida Functions</title>
!Pinclude/linux/idr.h idr sync
!Plib/idr.c IDA description
!Elib/idr.c
     </sect1>
      </chapter>
      <chapter id="mm">
        <title>Memory Management in Linux</title>
        <sect1>
          <title>The Slab Cache</title>
!Iinclude/linux/slab.h
!Emm/slab.c
     </sect1>
        <sect1>
          <title>User Space Memory Access</title>
!Iarch/x86/include/asm/uaccess_32.h
!Earch/x86/lib/usercopy_32.c
     </sect1>
        <sect1>
          <title>More Memory Management Functions</title>
!Emm/readahead.c
!Emm/filemap.c
!Emm/memory.c
!Emm/vmalloc.c
!Imm/page_alloc.c
!Emm/mempool.c
!Emm/dmapool.c
!Emm/page-writeback.c
!Emm/truncate.c
     </sect1>
      </chapter>
      <chapter id="ipc">
        <title>Kernel IPC facilities</title>
        <sect1>
          <title>IPC utilities</title>
!Iipc/util.c
     </sect1>
      </chapter>
      <chapter id="kfifo">
        <title>FIFO Buffer</title>
        <sect1>
          <title>kfifo interface</title>
!Iinclude/linux/kfifo.h
     </sect1>
      </chapter>
      <chapter id="relayfs">
        <title>relay interface support</title>
        <para>
	Relay interface support
	is designed to provide an efficient mechanism for tools and
	facilities to relay large amounts of data from kernel space to
	user space.
     </para>
        <sect1>
          <title>relay interface</title>
!Ekernel/relay.c
!Ikernel/relay.c
     </sect1>
      </chapter>
      <chapter id="modload">
        <title>Module Support</title>
        <sect1>
          <title>Module Loading</title>
!Ekernel/kmod.c
     </sect1>
        <sect1>
          <title>Inter Module support</title>
          <para>
           Refer to the file kernel/module.c for more information.
        </para>
          <!-- FIXME: Removed for now since no structured comments in source
X!Ekernel/module.c
-->
        </sect1>
      </chapter>
      <chapter id="hardware">
        <title>Hardware Interfaces</title>
        <sect1>
          <title>Interrupt Handling</title>
!Ekernel/irq/manage.c
     </sect1>
        <sect1>
          <title>DMA Channels</title>
!Ekernel/dma.c
     </sect1>
        <sect1>
          <title>Resources Management</title>
!Ikernel/resource.c
!Ekernel/resource.c
     </sect1>
        <sect1>
          <title>MTRR Handling</title>
!Earch/x86/kernel/cpu/mtrr/main.c
     </sect1>
        <sect1>
          <title>PCI Support Library</title>
!Edrivers/pci/pci.c
!Edrivers/pci/pci-driver.c
!Edrivers/pci/remove.c
!Edrivers/pci/search.c
!Edrivers/pci/msi.c
!Edrivers/pci/bus.c
!Edrivers/pci/access.c
!Edrivers/pci/irq.c
!Edrivers/pci/htirq.c
<!-- FIXME: Removed for now since no structured comments in source
X!Edrivers/pci/hotplug.c
-->
!Edrivers/pci/probe.c
!Edrivers/pci/slot.c
!Edrivers/pci/rom.c
!Edrivers/pci/iov.c
!Idrivers/pci/pci-sysfs.c
     </sect1>
        <sect1>
          <title>PCI Hotplug Support Library</title>
!Edrivers/pci/hotplug/pci_hotplug_core.c
     </sect1>
      </chapter>
      <chapter id="firmware">
        <title>Firmware Interfaces</title>
        <sect1>
          <title>DMI Interfaces</title>
!Edrivers/firmware/dmi_scan.c
     </sect1>
        <sect1>
          <title>EDD Interfaces</title>
!Idrivers/firmware/edd.c
     </sect1>
      </chapter>
      <chapter id="security">
        <title>Security Framework</title>
!Isecurity/security.c
!Esecurity/inode.c
  </chapter>
      <chapter id="audit">
        <title>Audit Interfaces</title>
!Ekernel/audit.c
!Ikernel/auditsc.c
!Ikernel/auditfilter.c
  </chapter>
      <chapter id="accounting">
        <title>Accounting Framework</title>
!Ikernel/acct.c
  </chapter>
      <chapter id="blkdev">
        <title>Block Devices</title>
!Eblock/blk-core.c
!Iblock/blk-core.c
!Eblock/blk-map.c
!Iblock/blk-sysfs.c
!Eblock/blk-settings.c
!Eblock/blk-exec.c
!Eblock/blk-flush.c
!Eblock/blk-lib.c
!Eblock/blk-tag.c
!Iblock/blk-tag.c
!Eblock/blk-integrity.c
!Ikernel/trace/blktrace.c
!Iblock/genhd.c
!Eblock/genhd.c
  </chapter>
      <chapter id="chrdev">
        <title>Char devices</title>
!Efs/char_dev.c
  </chapter>
      <chapter id="miscdev">
        <title>Miscellaneous Devices</title>
!Edrivers/char/misc.c
  </chapter>
      <chapter id="clk">
        <title>Clock Framework</title>
        <para>
	The clock framework defines programming interfaces to support
	software management of the system clock tree.
	This framework is widely used with System-On-Chip (SOC) platforms
	to support power management and various devices which may need
	custom clock rates.
	Note that these "clocks" don't relate to timekeeping or real
	time clocks (RTCs), each of which have separate frameworks.
	These <structname>struct clk</structname> instances may be used
	to manage for example a 96 MHz signal that is used to shift bits
	into and out of peripherals or busses, or otherwise trigger
	synchronous state machine transitions in system hardware.
     </para>
        <para>
	Power management is supported by explicit software clock gating:
	unused clocks are disabled, so the system doesn't waste power
	changing the state of transistors that aren't in active use.
	On some systems this may be backed by hardware clock gating,
	where clocks are gated without being disabled in software.
	Sections of chips that are powered but not clocked may be able
	to retain their last state.
	This low power state is often called a <emphasis>retention
	mode</emphasis>.
	This mode still incurs leakage currents, especially with finer
	circuit geometries, but for CMOS circuits power is mostly used
	by clocked state changes.
     </para>
        <para>
	Power-aware drivers only enable their clocks when the device
	they manage is in active use.  Also, system sleep states often
	differ according to which clock domains are active:  while a
	"standby" state may allow wakeup from several active domains, a
	"mem" (suspend-to-RAM) state may require a more wholesale shutdown
	of clocks derived from higher speed PLLs and oscillators, limiting
	the number of possible wakeup event sources.  A driver's suspend
	method may need to be aware of system-specific clock constraints
	on the target sleep state.
     </para>
        <para>
        Some platforms support programmable clock generators.  These
	can be used by external chips of various kinds, such as other
	CPUs, multimedia codecs, and devices with strict requirements
	for interface clocking.
     </para>

!Iinclude/linux/clk.h
  </chapter>
    </book>
    <book id="lk-hacking-guide">
      <bookinfo>
        <title>Unreliable Guide To Hacking The Linux Kernel</title>
        <authorgroup>
          <author>
            <firstname>Rusty</firstname>
            <surname>Russell</surname>
            <affiliation>
              <address>
                <email>rusty@rustcorp.com.au</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2005</year>
          <holder>Rusty Russell</holder>
        </copyright>
        <legalnotice>
          <para>
    This documentation is free software; you can redistribute
    it and/or modify it under the terms of the GNU General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later
    version.
   </para>
          <para>
    This program is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.
   </para>
          <para>
    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
    MA 02111-1307 USA
   </para>
          <para>
    For more details see the file COPYING in the source
    distribution of Linux.
   </para>
        </legalnotice>
        <releaseinfo>
   This is the first release of this document as part of the kernel tarball.
  </releaseinfo>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="introduction">
        <title>Introduction</title>
        <para>
   Welcome, gentle reader, to Rusty's Remarkably Unreliable Guide to Linux
   Kernel Hacking.  This document describes the common routines and
   general requirements for kernel code: its goal is to serve as a
   primer for Linux kernel development for experienced C
   programmers.  I avoid implementation details: that's what the
   code is for, and I ignore whole tracts of useful routines.
  </para>
        <para>
   Before you read this, please understand that I never wanted to
   write this document, being grossly under-qualified, but I always
   wanted to read it, and this was the only way.  I hope it will
   grow into a compendium of best practice, common starting points
   and random information.
  </para>
      </chapter>
      <chapter id="basic-players">
        <title>The Players</title>
        <para>
   At any time each of the CPUs in a system can be:
  </para>
        <itemizedlist>
          <listitem>
            <para>
     not associated with any process, serving a hardware interrupt;
    </para>
          </listitem>
          <listitem>
            <para>
     not associated with any process, serving a softirq or tasklet;
    </para>
          </listitem>
          <listitem>
            <para>
     running in kernel space, associated with a process (user context);
    </para>
          </listitem>
          <listitem>
            <para>
     running a process in user space.
    </para>
          </listitem>
        </itemizedlist>
        <para>
   There is an ordering between these.  The bottom two can preempt
   each other, but above that is a strict hierarchy: each can only be
   preempted by the ones above it.  For example, while a softirq is
   running on a CPU, no other softirq will preempt it, but a hardware
   interrupt can.  However, any other CPUs in the system execute
   independently.
  </para>
        <para>
   We'll see a number of ways that the user context can block
   interrupts, to become truly non-preemptable.
  </para>
        <sect1 id="basics-usercontext">
          <title>User Context</title>
          <para>
    User context is when you are coming in from a system call or other
    trap: like userspace, you can be preempted by more important tasks
    and by interrupts.  You can sleep, by calling
    <function>schedule()</function>.
   </para>
          <note>
            <para>
     You are always in user context on module load and unload,
     and on operations on the block device layer.
    </para>
          </note>
          <para>
    In user context, the <varname>current</varname> pointer (indicating 
    the task we are currently executing) is valid, and
    <function>in_interrupt()</function>
    (<filename>include/linux/interrupt.h</filename>) is <returnvalue>false
    </returnvalue>.  
   </para>
          <caution>
            <para>
     Beware that if you have preemption or softirqs disabled
     (see below), <function>in_interrupt()</function> will return a 
     false positive.
    </para>
          </caution>
        </sect1>
        <sect1 id="basics-hardirqs">
          <title>Hardware Interrupts (Hard IRQs)</title>
          <para>
    Timer ticks, <hardware>network cards</hardware> and 
    <hardware>keyboard</hardware> are examples of real
    hardware which produce interrupts at any time.  The kernel runs
    interrupt handlers, which services the hardware.  The kernel
    guarantees that this handler is never re-entered: if the same
    interrupt arrives, it is queued (or dropped).  Because it
    disables interrupts, this handler has to be fast: frequently it
    simply acknowledges the interrupt, marks a 'software interrupt'
    for execution and exits.
   </para>
          <para>
    You can tell you are in a hardware interrupt, because 
    <function>in_irq()</function> returns <returnvalue>true</returnvalue>.  
   </para>
          <caution>
            <para>
     Beware that this will return a false positive if interrupts are disabled 
     (see below).
    </para>
          </caution>
        </sect1>
        <sect1 id="basics-softirqs">
          <title>Software Interrupt Context: Softirqs and Tasklets</title>
          <para>
    Whenever a system call is about to return to userspace, or a
    hardware interrupt handler exits, any 'software interrupts'
    which are marked pending (usually by hardware interrupts) are
    run (<filename>kernel/softirq.c</filename>).
   </para>
          <para>
    Much of the real interrupt handling work is done here.  Early in
    the transition to <acronym>SMP</acronym>, there were only 'bottom
    halves' (BHs), which didn't take advantage of multiple CPUs.  Shortly 
    after we switched from wind-up computers made of match-sticks and snot,
    we abandoned this limitation and switched to 'softirqs'.
   </para>
          <para>
            <filename class="headerfile">include/linux/interrupt.h</filename> lists the
    different softirqs.  A very important softirq is the
    timer softirq (<filename class="headerfile">include/linux/timer.h</filename>): you can
    register to have it call functions for you in a given length of
    time.
   </para>
          <para>
    Softirqs are often a pain to deal with, since the same softirq
    will run simultaneously on more than one CPU.  For this reason,
    tasklets (<filename class="headerfile">include/linux/interrupt.h</filename>) are more
    often used: they are dynamically-registrable (meaning you can have
    as many as you want), and they also guarantee that any tasklet
    will only run on one CPU at any time, although different tasklets
    can run simultaneously.
   </para>
          <caution>
            <para>
     The name 'tasklet' is misleading: they have nothing to do with 'tasks',
     and probably more to do with some bad vodka Alexey Kuznetsov had at the 
     time.
    </para>
          </caution>
          <para>
    You can tell you are in a softirq (or tasklet)
    using the <function>in_softirq()</function> macro 
    (<filename class="headerfile">include/linux/interrupt.h</filename>).
   </para>
          <caution>
            <para>
     Beware that this will return a false positive if a bh lock (see below)
     is held.
    </para>
          </caution>
        </sect1>
      </chapter>
      <chapter id="basic-rules">
        <title>Some Basic Rules</title>
        <variablelist>
          <varlistentry>
            <term>No memory protection</term>
            <listitem>
              <para>
      If you corrupt memory, whether in user context or
      interrupt context, the whole machine will crash.  Are you
      sure you can't do what you want in userspace?
     </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>No floating point or <acronym>MMX</acronym></term>
            <listitem>
              <para>
      The <acronym>FPU</acronym> context is not saved; even in user
      context the <acronym>FPU</acronym> state probably won't
      correspond with the current process: you would mess with some
      user process' <acronym>FPU</acronym> state.  If you really want
      to do this, you would have to explicitly save/restore the full
      <acronym>FPU</acronym> state (and avoid context switches).  It
      is generally a bad idea; use fixed point arithmetic first.
     </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>A rigid stack limit</term>
            <listitem>
              <para>
      Depending on configuration options the kernel stack is about 3K to 6K for most 32-bit architectures: it's
      about 14K on most 64-bit archs, and often shared with interrupts
      so you can't use it all.  Avoid deep recursion and huge local
      arrays on the stack (allocate them dynamically instead).
     </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>The Linux kernel is portable</term>
            <listitem>
              <para>
      Let's keep it that way.  Your code should be 64-bit clean,
      and endian-independent.  You should also minimize CPU
      specific stuff, e.g. inline assembly should be cleanly
      encapsulated and minimized to ease porting.  Generally it
      should be restricted to the architecture-dependent part of
      the kernel tree.
     </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </chapter>
      <chapter id="ioctls">
        <title>ioctls: Not writing a new system call</title>
        <para>
   A system call generally looks like this
  </para>
        <programlisting>
asmlinkage long sys_mycall(int arg)
{
        return 0; 
}
  </programlisting>
        <para>
   First, in most cases you don't want to create a new system call.
   You create a character device and implement an appropriate ioctl
   for it.  This is much more flexible than system calls, doesn't have
   to be entered in every architecture's
   <filename class="headerfile">include/asm/unistd.h</filename> and
   <filename>arch/kernel/entry.S</filename> file, and is much more
   likely to be accepted by Linus.
  </para>
        <para>
   If all your routine does is read or write some parameter, consider
   implementing a <function>sysfs</function> interface instead.
  </para>
        <para>
   Inside the ioctl you're in user context to a process.  When a
   error occurs you return a negated errno (see
   <filename class="headerfile">include/linux/errno.h</filename>),
   otherwise you return <returnvalue>0</returnvalue>.
  </para>
        <para>
   After you slept you should check if a signal occurred: the
   Unix/Linux way of handling signals is to temporarily exit the
   system call with the <constant>-ERESTARTSYS</constant> error.  The
   system call entry code will switch back to user context, process
   the signal handler and then your system call will be restarted
   (unless the user disabled that).  So you should be prepared to
   process the restart, e.g. if you're in the middle of manipulating
   some data structure.
  </para>
        <programlisting>
if (signal_pending(current))
        return -ERESTARTSYS;
  </programlisting>
        <para>
   If you're doing longer computations: first think userspace. If you
   <emphasis>really</emphasis> want to do it in kernel you should
   regularly check if you need to give up the CPU (remember there is
   cooperative multitasking per CPU).  Idiom:
  </para>
        <programlisting>
cond_resched(); /* Will sleep */ 
  </programlisting>
        <para>
   A short note on interface design: the UNIX system call motto is
   "Provide mechanism not policy".
  </para>
      </chapter>
      <chapter id="deadlock-recipes">
        <title>Recipes for Deadlock</title>
        <para>
   You cannot call any routines which may sleep, unless:
  </para>
        <itemizedlist>
          <listitem>
            <para>
     You are in user context.
    </para>
          </listitem>
          <listitem>
            <para>
     You do not own any spinlocks.
    </para>
          </listitem>
          <listitem>
            <para>
     You have interrupts enabled (actually, Andi Kleen says
     that the scheduling code will enable them for you, but
     that's probably not what you wanted).
    </para>
          </listitem>
        </itemizedlist>
        <para>
   Note that some functions may sleep implicitly: common ones are
   the user space access functions (*_user) and memory allocation
   functions without <symbol>GFP_ATOMIC</symbol>.
  </para>
        <para>
   You should always compile your kernel
   <symbol>CONFIG_DEBUG_ATOMIC_SLEEP</symbol> on, and it will warn
   you if you break these rules.  If you <emphasis>do</emphasis> break
   the rules, you will eventually lock up your box.
  </para>
        <para>
   Really.
  </para>
      </chapter>
      <chapter id="common-routines">
        <title>Common Routines</title>
        <sect1 id="routines-printk">
          <title>
            <function>printk()</function>
            <filename class="headerfile">include/linux/kernel.h</filename>
          </title>
          <para>
            <function>printk()</function> feeds kernel messages to the
    console, dmesg, and the syslog daemon.  It is useful for debugging
    and reporting errors, and can be used inside interrupt context,
    but use with caution: a machine which has its console flooded with
    printk messages is unusable.  It uses a format string mostly
    compatible with ANSI C printf, and C string concatenation to give
    it a first "priority" argument:
   </para>
          <programlisting>
printk(KERN_INFO "i = %u\n", i);
   </programlisting>
          <para>
    See <filename class="headerfile">include/linux/kernel.h</filename>;
    for other KERN_ values; these are interpreted by syslog as the
    level.  Special case: for printing an IP address use
   </para>
          <programlisting>
__be32 ipaddress;
printk(KERN_INFO "my ip: %pI4\n", &amp;ipaddress);
   </programlisting>
          <para>
            <function>printk()</function> internally uses a 1K buffer and does
    not catch overruns.  Make sure that will be enough.
   </para>
          <note>
            <para>
     You will know when you are a real kernel hacker
     when you start typoing printf as printk in your user programs :)
    </para>
          </note>
          <!--- From the Lions book reader department -->
          <note>
            <para>
     Another sidenote: the original Unix Version 6 sources had a
     comment on top of its printf function: "Printf should not be
     used for chit-chat".  You should follow that advice.
    </para>
          </note>
        </sect1>
        <sect1 id="routines-copy">
          <title>
            <function>copy_[to/from]_user()</function>
    /
    <function>get_user()</function>
    /
    <function>put_user()</function><filename class="headerfile">include/asm/uaccess.h</filename></title>
          <para>
            <emphasis>[SLEEPS]</emphasis>
          </para>
          <para>
            <function>put_user()</function> and <function>get_user()</function>
    are used to get and put single values (such as an int, char, or
    long) from and to userspace.  A pointer into userspace should
    never be simply dereferenced: data should be copied using these
    routines.  Both return <constant>-EFAULT</constant> or 0.
   </para>
          <para>
            <function>copy_to_user()</function> and
    <function>copy_from_user()</function> are more general: they copy
    an arbitrary amount of data to and from userspace.
    <caution><para>
      Unlike <function>put_user()</function> and
      <function>get_user()</function>, they return the amount of
      uncopied data (ie. <returnvalue>0</returnvalue> still means
      success).
     </para></caution>
    [Yes, this moronic interface makes me cringe.  The flamewar comes up every year or so. --RR.]
   </para>
          <para>
    The functions may sleep implicitly. This should never be called
    outside user context (it makes no sense), with interrupts
    disabled, or a spinlock held.
   </para>
        </sect1>
        <sect1 id="routines-kmalloc">
          <title>
            <function>kmalloc()</function>/<function>kfree()</function><filename class="headerfile">include/linux/slab.h</filename></title>
          <para>
            <emphasis>[MAY SLEEP: SEE BELOW]</emphasis>
          </para>
          <para>
    These routines are used to dynamically request pointer-aligned
    chunks of memory, like malloc and free do in userspace, but
    <function>kmalloc()</function> takes an extra flag word.
    Important values:
   </para>
          <variablelist>
            <varlistentry>
              <term>
                <constant>
       GFP_KERNEL
      </constant>
              </term>
              <listitem>
                <para>
       May sleep and swap to free memory. Only allowed in user
       context, but is the most reliable way to allocate memory.
      </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <constant>
       GFP_ATOMIC
      </constant>
              </term>
              <listitem>
                <para>
       Don't sleep. Less reliable than <constant>GFP_KERNEL</constant>,
       but may be called from interrupt context. You should
       <emphasis>really</emphasis> have a good out-of-memory
       error-handling strategy.
      </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <constant>
       GFP_DMA
      </constant>
              </term>
              <listitem>
                <para>
       Allocate ISA DMA lower than 16MB. If you don't know what that
       is you don't need it.  Very unreliable.
      </para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>
    If you see a <errorname>sleeping function called from invalid
    context</errorname> warning message, then maybe you called a
    sleeping allocation function from interrupt context without
    <constant>GFP_ATOMIC</constant>.  You should really fix that.
    Run, don't walk.
   </para>
          <para>
    If you are allocating at least <constant>PAGE_SIZE</constant>
    (<filename class="headerfile">include/asm/page.h</filename>) bytes,
    consider using <function>__get_free_pages()</function>

    (<filename class="headerfile">include/linux/mm.h</filename>).  It
    takes an order argument (0 for page sized, 1 for double page, 2
    for four pages etc.) and the same memory priority flag word as
    above.
   </para>
          <para>
    If you are allocating more than a page worth of bytes you can use
    <function>vmalloc()</function>.  It'll allocate virtual memory in
    the kernel map.  This block is not contiguous in physical memory,
    but the <acronym>MMU</acronym> makes it look like it is for you
    (so it'll only look contiguous to the CPUs, not to external device
    drivers).  If you really need large physically contiguous memory
    for some weird device, you have a problem: it is poorly supported
    in Linux because after some time memory fragmentation in a running
    kernel makes it hard.  The best way is to allocate the block early
    in the boot process via the <function>alloc_bootmem()</function>
    routine.
   </para>
          <para>
    Before inventing your own cache of often-used objects consider
    using a slab cache in
    <filename class="headerfile">include/linux/slab.h</filename></para>
        </sect1>
        <sect1 id="routines-current">
          <title>
            <function>current</function>
            <filename class="headerfile">include/asm/current.h</filename>
          </title>
          <para>
    This global variable (really a macro) contains a pointer to
    the current task structure, so is only valid in user context.
    For example, when a process makes a system call, this will
    point to the task structure of the calling process.  It is
    <emphasis>not NULL</emphasis> in interrupt context.
   </para>
        </sect1>
        <sect1 id="routines-udelay">
          <title>
            <function>mdelay()</function>/<function>udelay()</function><filename class="headerfile">include/asm/delay.h</filename><filename class="headerfile">include/linux/delay.h</filename></title>
          <para>
    The <function>udelay()</function> and <function>ndelay()</function> functions can be used for small pauses.
    Do not use large values with them as you risk
    overflow - the helper function <function>mdelay()</function> is useful
    here, or consider <function>msleep()</function>.
   </para>
        </sect1>
        <sect1 id="routines-endian">
          <title>
            <function>cpu_to_be32()</function>/<function>be32_to_cpu()</function>/<function>cpu_to_le32()</function>/<function>le32_to_cpu()</function><filename class="headerfile">include/asm/byteorder.h</filename></title>
          <para>
    The <function>cpu_to_be32()</function> family (where the "32" can
    be replaced by 64 or 16, and the "be" can be replaced by "le") are
    the general way to do endian conversions in the kernel: they
    return the converted value.  All variations supply the reverse as
    well: <function>be32_to_cpu()</function>, etc.
   </para>
          <para>
    There are two major variations of these functions: the pointer
    variation, such as <function>cpu_to_be32p()</function>, which take
    a pointer to the given type, and return the converted value.  The
    other variation is the "in-situ" family, such as
    <function>cpu_to_be32s()</function>, which convert value referred
    to by the pointer, and return void.
   </para>
        </sect1>
        <sect1 id="routines-local-irqs">
          <title>
            <function>local_irq_save()</function>/<function>local_irq_restore()</function><filename class="headerfile">include/asm/system.h</filename></title>
          <para>
    These routines disable hard interrupts on the local CPU, and
    restore them.  They are reentrant; saving the previous state in
    their one <varname>unsigned long flags</varname> argument.  If you
    know that interrupts are enabled, you can simply use
    <function>local_irq_disable()</function> and
    <function>local_irq_enable()</function>.
   </para>
        </sect1>
        <sect1 id="routines-softirqs">
          <title>
            <function>local_bh_disable()</function>/<function>local_bh_enable()</function><filename class="headerfile">include/linux/interrupt.h</filename></title>
          <para>
    These routines disable soft interrupts on the local CPU, and
    restore them.  They are reentrant; if soft interrupts were
    disabled before, they will still be disabled after this pair
    of functions has been called.  They prevent softirqs and tasklets
    from running on the current CPU.
   </para>
        </sect1>
        <sect1 id="routines-processorids">
          <title>
            <function>smp_processor_id</function>()
    <filename class="headerfile">include/asm/smp.h</filename></title>
          <para>
            <function>get_cpu()</function> disables preemption (so you won't
    suddenly get moved to another CPU) and returns the current
    processor number, between 0 and <symbol>NR_CPUS</symbol>.  Note
    that the CPU numbers are not necessarily continuous.  You return
    it again with <function>put_cpu()</function> when you are done.
   </para>
          <para>
    If you know you cannot be preempted by another task (ie. you are
    in interrupt context, or have preemption disabled) you can use
    smp_processor_id().
   </para>
        </sect1>
        <sect1 id="routines-init">
          <title>
            <type>__init</type>/<type>__exit</type>/<type>__initdata</type><filename class="headerfile">include/linux/init.h</filename></title>
          <para>
    After boot, the kernel frees up a special section; functions
    marked with <type>__init</type> and data structures marked with
    <type>__initdata</type> are dropped after boot is complete: similarly
    modules discard this memory after initialization.  <type>__exit</type>
    is used to declare a function which is only required on exit: the
    function will be dropped if this file is not compiled as a module.
    See the header file for use. Note that it makes no sense for a function
    marked with <type>__init</type> to be exported to modules with 
    <function>EXPORT_SYMBOL()</function> - this will break.
   </para>
        </sect1>
        <sect1 id="routines-init-again">
          <title>
            <function>__initcall()</function>/<function>module_init()</function><filename class="headerfile">include/linux/init.h</filename></title>
          <para>
    Many parts of the kernel are well served as a module
    (dynamically-loadable parts of the kernel).  Using the
    <function>module_init()</function> and
    <function>module_exit()</function> macros it is easy to write code
    without #ifdefs which can operate both as a module or built into
    the kernel.
   </para>
          <para>
    The <function>module_init()</function> macro defines which
    function is to be called at module insertion time (if the file is
    compiled as a module), or at boot time: if the file is not
    compiled as a module the <function>module_init()</function> macro
    becomes equivalent to <function>__initcall()</function>, which
    through linker magic ensures that the function is called on boot.
   </para>
          <para>
    The function can return a negative error number to cause
    module loading to fail (unfortunately, this has no effect if
    the module is compiled into the kernel).  This function is
    called in user context with interrupts enabled, so it can sleep.
   </para>
        </sect1>
        <sect1 id="routines-moduleexit">
          <title>
            <function>module_exit()</function>
            <filename class="headerfile">include/linux/init.h</filename>
          </title>
          <para>
    This macro defines the function to be called at module removal
    time (or never, in the case of the file compiled into the
    kernel).  It will only be called if the module usage count has
    reached zero.  This function can also sleep, but cannot fail:
    everything must be cleaned up by the time it returns.
   </para>
          <para>
    Note that this macro is optional: if it is not present, your
    module will not be removable (except for 'rmmod -f').
   </para>
        </sect1>
        <sect1 id="routines-module-use-counters">
          <title>
            <function>try_module_get()</function>/<function>module_put()</function><filename class="headerfile">include/linux/module.h</filename></title>
          <para>
    These manipulate the module usage count, to protect against
    removal (a module also can't be removed if another module uses one
    of its exported symbols: see below).  Before calling into module
    code, you should call <function>try_module_get()</function> on
    that module: if it fails, then the module is being removed and you
    should act as if it wasn't there.  Otherwise, you can safely enter
    the module, and call <function>module_put()</function> when you're
    finished.
   </para>
          <para>
   Most registerable structures have an
   <structfield>owner</structfield> field, such as in the
   <structname>file_operations</structname> structure. Set this field
   to the macro <symbol>THIS_MODULE</symbol>.
   </para>
        </sect1>
        <!-- add info on new-style module refcounting here -->
      </chapter>
      <chapter id="queues">
        <title>Wait Queues
   <filename class="headerfile">include/linux/wait.h</filename></title>
        <para>
          <emphasis>[SLEEPS]</emphasis>
        </para>
        <para>
   A wait queue is used to wait for someone to wake you up when a
   certain condition is true.  They must be used carefully to ensure
   there is no race condition.  You declare a
   <type>wait_queue_head_t</type>, and then processes which want to
   wait for that condition declare a <type>wait_queue_t</type>
   referring to themselves, and place that in the queue.
  </para>
        <sect1 id="queue-declaring">
          <title>Declaring</title>
          <para>
    You declare a <type>wait_queue_head_t</type> using the
    <function>DECLARE_WAIT_QUEUE_HEAD()</function> macro, or using the
    <function>init_waitqueue_head()</function> routine in your
    initialization code.
   </para>
        </sect1>
        <sect1 id="queue-waitqueue">
          <title>Queuing</title>
          <para>
    Placing yourself in the waitqueue is fairly complex, because you
    must put yourself in the queue before checking the condition.
    There is a macro to do this:
    <function>wait_event_interruptible()</function><filename class="headerfile">include/linux/wait.h</filename> The
    first argument is the wait queue head, and the second is an
    expression which is evaluated; the macro returns
    <returnvalue>0</returnvalue> when this expression is true, or
    <returnvalue>-ERESTARTSYS</returnvalue> if a signal is received.
    The <function>wait_event()</function> version ignores signals.
   </para>
          <para>
   Do not use the <function>sleep_on()</function> function family -
   it is very easy to accidentally introduce races; almost certainly
   one of the <function>wait_event()</function> family will do, or a
   loop around <function>schedule_timeout()</function>. If you choose
   to loop around <function>schedule_timeout()</function> remember
   you must set the task state (with 
   <function>set_current_state()</function>) on each iteration to avoid
   busy-looping.
   </para>
        </sect1>
        <sect1 id="queue-waking">
          <title>Waking Up Queued Tasks</title>
          <para>
    Call <function>wake_up()</function><filename class="headerfile">include/linux/wait.h</filename>;,
    which will wake up every process in the queue.  The exception is
    if one has <constant>TASK_EXCLUSIVE</constant> set, in which case
    the remainder of the queue will not be woken.  There are other variants
    of this basic function available in the same header.
   </para>
        </sect1>
      </chapter>
      <chapter id="atomic-ops">
        <title>Atomic Operations</title>
        <para>
   Certain operations are guaranteed atomic on all platforms.  The
   first class of operations work on <type>atomic_t</type><filename class="headerfile">include/asm/atomic.h</filename>; this
   contains a signed integer (at least 32 bits long), and you must use
   these functions to manipulate or read atomic_t variables.
   <function>atomic_read()</function> and
   <function>atomic_set()</function> get and set the counter,
   <function>atomic_add()</function>,
   <function>atomic_sub()</function>,
   <function>atomic_inc()</function>,
   <function>atomic_dec()</function>, and
   <function>atomic_dec_and_test()</function> (returns
   <returnvalue>true</returnvalue> if it was decremented to zero).
  </para>
        <para>
   Yes.  It returns <returnvalue>true</returnvalue> (i.e. != 0) if the
   atomic variable is zero.
  </para>
        <para>
   Note that these functions are slower than normal arithmetic, and
   so should not be used unnecessarily.
  </para>
        <para>
   The second class of atomic operations is atomic bit operations on an
   <type>unsigned long</type>, defined in

   <filename class="headerfile">include/linux/bitops.h</filename>.  These
   operations generally take a pointer to the bit pattern, and a bit
   number: 0 is the least significant bit.
   <function>set_bit()</function>, <function>clear_bit()</function>
   and <function>change_bit()</function> set, clear, and flip the
   given bit.  <function>test_and_set_bit()</function>,
   <function>test_and_clear_bit()</function> and
   <function>test_and_change_bit()</function> do the same thing,
   except return true if the bit was previously set; these are
   particularly useful for atomically setting flags.
  </para>
        <para>
   It is possible to call these operations with bit indices greater
   than BITS_PER_LONG.  The resulting behavior is strange on big-endian
   platforms though so it is a good idea not to do this.
  </para>
      </chapter>
      <chapter id="symbols">
        <title>Symbols</title>
        <para>
   Within the kernel proper, the normal linking rules apply
   (ie. unless a symbol is declared to be file scope with the
   <type>static</type> keyword, it can be used anywhere in the
   kernel).  However, for modules, a special exported symbol table is
   kept which limits the entry points to the kernel proper.  Modules
   can also export symbols.
  </para>
        <sect1 id="sym-exportsymbols">
          <title>
            <function>EXPORT_SYMBOL()</function>
            <filename class="headerfile">include/linux/export.h</filename>
          </title>
          <para>
    This is the classic method of exporting a symbol: dynamically
    loaded modules will be able to use the symbol as normal.
   </para>
        </sect1>
        <sect1 id="sym-exportsymbols-gpl">
          <title>
            <function>EXPORT_SYMBOL_GPL()</function>
            <filename class="headerfile">include/linux/export.h</filename>
          </title>
          <para>
    Similar to <function>EXPORT_SYMBOL()</function> except that the
    symbols exported by <function>EXPORT_SYMBOL_GPL()</function> can
    only be seen by modules with a
    <function>MODULE_LICENSE()</function> that specifies a GPL
    compatible license.  It implies that the function is considered
    an internal implementation issue, and not really an interface.
   </para>
        </sect1>
      </chapter>
      <chapter id="conventions">
        <title>Routines and Conventions</title>
        <sect1 id="conventions-doublelinkedlist">
          <title>Double-linked lists
    <filename class="headerfile">include/linux/list.h</filename></title>
          <para>
    There used to be three sets of linked-list routines in the kernel
    headers, but this one is the winner.  If you don't have some
    particular pressing need for a single list, it's a good choice.
   </para>
          <para>
    In particular, <function>list_for_each_entry</function> is useful.
   </para>
        </sect1>
        <sect1 id="convention-returns">
          <title>Return Conventions</title>
          <para>
    For code called in user context, it's very common to defy C
    convention, and return <returnvalue>0</returnvalue> for success,
    and a negative error number
    (eg. <returnvalue>-EFAULT</returnvalue>) for failure.  This can be
    unintuitive at first, but it's fairly widespread in the kernel.
   </para>
          <para>
    Using <function>ERR_PTR()</function><filename class="headerfile">include/linux/err.h</filename>; to
    encode a negative error number into a pointer, and
    <function>IS_ERR()</function> and <function>PTR_ERR()</function>
    to get it back out again: avoids a separate pointer parameter for
    the error number.  Icky, but in a good way.
   </para>
        </sect1>
        <sect1 id="conventions-borkedcompile">
          <title>Breaking Compilation</title>
          <para>
    Linus and the other developers sometimes change function or
    structure names in development kernels; this is not done just to
    keep everyone on their toes: it reflects a fundamental change
    (eg. can no longer be called with interrupts on, or does extra
    checks, or doesn't do checks which were caught before).  Usually
    this is accompanied by a fairly complete note to the linux-kernel
    mailing list; search the archive.  Simply doing a global replace
    on the file usually makes things <emphasis>worse</emphasis>.
   </para>
        </sect1>
        <sect1 id="conventions-initialising">
          <title>Initializing structure members</title>
          <para>
    The preferred method of initializing structures is to use
    designated initialisers, as defined by ISO C99, eg:
   </para>
          <programlisting>
static struct block_device_operations opt_fops = {
        .open               = opt_open,
        .release            = opt_release,
        .ioctl              = opt_ioctl,
        .check_media_change = opt_media_change,
};
   </programlisting>
          <para>
    This makes it easy to grep for, and makes it clear which
    structure fields are set.  You should do this because it looks
    cool.
   </para>
        </sect1>
        <sect1 id="conventions-gnu-extns">
          <title>GNU Extensions</title>
          <para>
    GNU Extensions are explicitly allowed in the Linux kernel.
    Note that some of the more complex ones are not very well
    supported, due to lack of general use, but the following are
    considered standard (see the GCC info page section "C
    Extensions" for more details - Yes, really the info page, the
    man page is only a short summary of the stuff in info).
   </para>
          <itemizedlist>
            <listitem>
              <para>
      Inline functions
     </para>
            </listitem>
            <listitem>
              <para>
      Statement expressions (ie. the ({ and }) constructs).
     </para>
            </listitem>
            <listitem>
              <para>
      Declaring attributes of a function / variable / type
      (__attribute__)
     </para>
            </listitem>
            <listitem>
              <para>
      typeof
     </para>
            </listitem>
            <listitem>
              <para>
      Zero length arrays
     </para>
            </listitem>
            <listitem>
              <para>
      Macro varargs
     </para>
            </listitem>
            <listitem>
              <para>
      Arithmetic on void pointers
     </para>
            </listitem>
            <listitem>
              <para>
      Non-Constant initializers
     </para>
            </listitem>
            <listitem>
              <para>
      Assembler Instructions (not outside arch/ and include/asm/)
     </para>
            </listitem>
            <listitem>
              <para>
      Function names as strings (__func__).
     </para>
            </listitem>
            <listitem>
              <para>
      __builtin_constant_p()
     </para>
            </listitem>
          </itemizedlist>
          <para>
    Be wary when using long long in the kernel, the code gcc generates for
    it is horrible and worse: division and multiplication does not work
    on i386 because the GCC runtime functions for it are missing from
    the kernel environment.
   </para>
          <!-- FIXME: add a note about ANSI aliasing cleanness -->
        </sect1>
        <sect1 id="conventions-cplusplus">
          <title>C++</title>
          <para>
    Using C++ in the kernel is usually a bad idea, because the
    kernel does not provide the necessary runtime environment
    and the include files are not tested for it.  It is still
    possible, but not recommended.  If you really want to do
    this, forget about exceptions at least.
   </para>
        </sect1>
        <sect1 id="conventions-ifdef">
          <title>if</title>
          <para>
    It is generally considered cleaner to use macros in header files
    (or at the top of .c files) to abstract away functions rather than
    using `#if' pre-processor statements throughout the source code.
   </para>
        </sect1>
      </chapter>
      <chapter id="submitting">
        <title>Putting Your Stuff in the Kernel</title>
        <para>
   In order to get your stuff into shape for official inclusion, or
   even to make a neat patch, there's administrative work to be
   done:
  </para>
        <itemizedlist>
          <listitem>
            <para>
     Figure out whose pond you've been pissing in.  Look at the top of
     the source files, inside the <filename>MAINTAINERS</filename>
     file, and last of all in the <filename>CREDITS</filename> file.
     You should coordinate with this person to make sure you're not
     duplicating effort, or trying something that's already been
     rejected.
    </para>
            <para>
     Make sure you put your name and EMail address at the top of
     any files you create or mangle significantly.  This is the
     first place people will look when they find a bug, or when
     <emphasis>they</emphasis> want to make a change.
    </para>
          </listitem>
          <listitem>
            <para>
     Usually you want a configuration option for your kernel hack.
     Edit <filename>Kconfig</filename> in the appropriate directory.
     The Config language is simple to use by cut and paste, and there's
     complete documentation in
     <filename>Documentation/kbuild/kconfig-language.txt</filename>.
    </para>
            <para>
     In your description of the option, make sure you address both the
     expert user and the user who knows nothing about your feature.  Mention
     incompatibilities and issues here.  <emphasis> Definitely
     </emphasis> end your description with <quote> if in doubt, say N
     </quote> (or, occasionally, `Y'); this is for people who have no
     idea what you are talking about.
    </para>
          </listitem>
          <listitem>
            <para>
     Edit the <filename>Makefile</filename>: the CONFIG variables are
     exported here so you can usually just add a "obj-$(CONFIG_xxx) +=
     xxx.o" line.  The syntax is documented in
     <filename>Documentation/kbuild/makefiles.txt</filename>.
    </para>
          </listitem>
          <listitem>
            <para>
     Put yourself in <filename>CREDITS</filename> if you've done
     something noteworthy, usually beyond a single file (your name
     should be at the top of the source files anyway).
     <filename>MAINTAINERS</filename> means you want to be consulted
     when changes are made to a subsystem, and hear about bugs; it
     implies a more-than-passing commitment to some part of the code.
    </para>
          </listitem>
          <listitem>
            <para>
     Finally, don't forget to read <filename>Documentation/SubmittingPatches</filename>
     and possibly <filename>Documentation/SubmittingDrivers</filename>.
    </para>
          </listitem>
        </itemizedlist>
      </chapter>
      <chapter id="cantrips">
        <title>Kernel Cantrips</title>
        <para>
   Some favorites from browsing the source.  Feel free to add to this
   list.
  </para>
        <para>
          <filename>arch/x86/include/asm/delay.h:</filename>
        </para>
        <programlisting>
#define ndelay(n) (__builtin_constant_p(n) ? \
        ((n) &gt; 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
        __ndelay(n))
  </programlisting>
        <para>
          <filename>include/linux/fs.h</filename>:
  </para>
        <programlisting>
/*
 * Kernel pointers have redundant information, so we can use a
 * scheme where we can return either an error code or a dentry
 * pointer with the same return value.
 *
 * This should be a per-architecture thing, to allow different
 * error and pointer decisions.
 */
 #define ERR_PTR(err)    ((void *)((long)(err)))
 #define PTR_ERR(ptr)    ((long)(ptr))
 #define IS_ERR(ptr)     ((unsigned long)(ptr) &gt; (unsigned long)(-1000))
</programlisting>
        <para>
          <filename>arch/x86/include/asm/uaccess_32.h:</filename>
        </para>
        <programlisting>
#define copy_to_user(to,from,n)                         \
        (__builtin_constant_p(n) ?                      \
         __constant_copy_to_user((to),(from),(n)) :     \
         __generic_copy_to_user((to),(from),(n)))
  </programlisting>
        <para>
          <filename>arch/sparc/kernel/head.S:</filename>
        </para>
        <programlisting>
/*
 * Sun people can't spell worth damn. "compatability" indeed.
 * At least we *know* we can't spell, and use a spell-checker.
 */

/* Uh, actually Linus it is I who cannot spell. Too much murky
 * Sparc assembly will do this to ya.
 */
C_LABEL(cputypvar):
        .asciz "compatibility"

/* Tested on SS-5, SS-10. Probably someone at Sun applied a spell-checker. */
        .align 4
C_LABEL(cputypvar_sun4m):
        .asciz "compatible"
  </programlisting>
        <para>
          <filename>arch/sparc/lib/checksum.S:</filename>
        </para>
        <programlisting>
        /* Sun, you just can't beat me, you just can't.  Stop trying,
         * give up.  I'm serious, I am going to kick the living shit
         * out of you, game over, lights out.
         */
  </programlisting>
      </chapter>
      <chapter id="credits">
        <title>Thanks</title>
        <para>
   Thanks to Andi Kleen for the idea, answering my questions, fixing
   my mistakes, filling content, etc.  Philipp Rumpf for more spelling
   and clarity fixes, and some excellent non-obvious points.  Werner
   Almesberger for giving me a great summary of
   <function>disable_irq()</function>, and Jes Sorensen and Andrea
   Arcangeli added caveats. Michael Elizabeth Chastain for checking
   and adding to the Configure section. <!-- Rusty insisted on this
   bit; I didn't do it! --> Telsa Gwynne for teaching me DocBook. 
  </para>
      </chapter>
    </book>
    <book id="LKLockingGuide">
      <bookinfo>
        <title>Unreliable Guide To Locking</title>
        <authorgroup>
          <author>
            <firstname>Rusty</firstname>
            <surname>Russell</surname>
            <affiliation>
              <address>
                <email>rusty@rustcorp.com.au</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2003</year>
          <holder>Rusty Russell</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
     Welcome, to Rusty's Remarkably Unreliable Guide to Kernel
     Locking issues.  This document describes the locking systems in
     the Linux Kernel in 2.6.
   </para>
        <para>
     With the wide availability of HyperThreading, and <firstterm linkend="gloss-preemption">preemption </firstterm> in the Linux
     Kernel, everyone hacking on the kernel needs to know the
     fundamentals of concurrency and locking for
     <firstterm linkend="gloss-smp"><acronym>SMP</acronym></firstterm>.
   </para>
      </chapter>
      <chapter id="races">
        <title>The Problem With Concurrency</title>
        <para>
      (Skip this if you know what a Race Condition is).
    </para>
        <para>
      In a normal program, you can increment a counter like so:
    </para>
        <programlisting>
      very_important_count++;
    </programlisting>
        <para>
      This is what they would expect to happen:
    </para>
        <table>
          <title>Expected Results</title>
          <tgroup cols="2" align="left">
            <thead>
              <row>
                <entry>Instance 1</entry>
                <entry>Instance 2</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>read very_important_count (5)</entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>add 1 (6)</entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>write very_important_count (6)</entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>read very_important_count (6)</entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>add 1 (7)</entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>write very_important_count (7)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>
     This is what might happen:
    </para>
        <table>
          <title>Possible Results</title>
          <tgroup cols="2" align="left">
            <thead>
              <row>
                <entry>Instance 1</entry>
                <entry>Instance 2</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>read very_important_count (5)</entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>read very_important_count (5)</entry>
              </row>
              <row>
                <entry>add 1 (6)</entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>add 1 (6)</entry>
              </row>
              <row>
                <entry>write very_important_count (6)</entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>write very_important_count (6)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <sect1 id="race-condition">
          <title>Race Conditions and Critical Regions</title>
          <para>
      This overlap, where the result depends on the
      relative timing of multiple tasks, is called a <firstterm>race condition</firstterm>.
      The piece of code containing the concurrency issue is called a
      <firstterm>critical region</firstterm>.  And especially since Linux starting running
      on SMP machines, they became one of the major issues in kernel
      design and implementation.
    </para>
          <para>
      Preemption can have the same effect, even if there is only one
      CPU: by preempting one task during the critical region, we have
      exactly the same race condition.  In this case the thread which
      preempts might run the critical region itself.
    </para>
          <para>
      The solution is to recognize when these simultaneous accesses
      occur, and use locks to make sure that only one instance can
      enter the critical region at any time.  There are many
      friendly primitives in the Linux kernel to help you do this.
      And then there are the unfriendly primitives, but I'll pretend
      they don't exist.
    </para>
        </sect1>
      </chapter>
      <chapter id="locks">
        <title>Locking in the Linux Kernel</title>
        <para>
     If I could give you one piece of advice: never sleep with anyone
     crazier than yourself.  But if I had to give you advice on
     locking: <emphasis>keep it simple</emphasis>.
   </para>
        <para>
     Be reluctant to introduce new locks.
   </para>
        <para>
     Strangely enough, this last one is the exact reverse of my advice when
     you <emphasis>have</emphasis> slept with someone crazier than yourself.
     And you should think about getting a big dog.
   </para>
        <sect1 id="lock-intro">
          <title>Two Main Types of Kernel Locks: Spinlocks and Mutexes</title>
          <para>
     There are two main types of kernel locks.  The fundamental type
     is the spinlock 
     (<filename class="headerfile">include/asm/spinlock.h</filename>),
     which is a very simple single-holder lock: if you can't get the 
     spinlock, you keep trying (spinning) until you can.  Spinlocks are 
     very small and fast, and can be used anywhere.
   </para>
          <para>
     The second type is a mutex
     (<filename class="headerfile">include/linux/mutex.h</filename>): it
     is like a spinlock, but you may block holding a mutex.
     If you can't lock a mutex, your task will suspend itself, and be woken
     up when the mutex is released.  This means the CPU can do something
     else while you are waiting.  There are many cases when you simply
     can't sleep (see <xref linkend="sleeping-things" />), and so have to
     use a spinlock instead.
   </para>
          <para>
     Neither type of lock is recursive: see
     <xref linkend="deadlock" />.
   </para>
        </sect1>
        <sect1 id="uniprocessor">
          <title>Locks and Uniprocessor Kernels</title>
          <para>
      For kernels compiled without <symbol>CONFIG_SMP</symbol>, and
      without <symbol>CONFIG_PREEMPT</symbol> spinlocks do not exist at
      all.  This is an excellent design decision: when no-one else can
      run at the same time, there is no reason to have a lock.
    </para>
          <para>
      If the kernel is compiled without <symbol>CONFIG_SMP</symbol>,
      but <symbol>CONFIG_PREEMPT</symbol> is set, then spinlocks
      simply disable preemption, which is sufficient to prevent any
      races.  For most purposes, we can think of preemption as
      equivalent to SMP, and not worry about it separately.
    </para>
          <para>
      You should always test your locking code with <symbol>CONFIG_SMP</symbol>
      and <symbol>CONFIG_PREEMPT</symbol> enabled, even if you don't have an SMP test box, because it
      will still catch some kinds of locking bugs.
    </para>
          <para>
      Mutexes still exist, because they are required for
      synchronization between <firstterm linkend="gloss-usercontext">user 
      contexts</firstterm>, as we will see below.
    </para>
        </sect1>
        <sect1 id="usercontextlocking">
          <title>Locking Only In User Context</title>
          <para>
       If you have a data structure which is only ever accessed from
       user context, then you can use a simple mutex
       (<filename>include/linux/mutex.h</filename>) to protect it.  This
       is the most trivial case: you initialize the mutex.  Then you can
       call <function>mutex_lock_interruptible()</function> to grab the mutex,
       and <function>mutex_unlock()</function> to release it.  There is also a 
       <function>mutex_lock()</function>, which should be avoided, because it 
       will not return if a signal is received.
     </para>
          <para>
       Example: <filename>net/netfilter/nf_sockopt.c</filename> allows 
       registration of new <function>setsockopt()</function> and 
       <function>getsockopt()</function> calls, with
       <function>nf_register_sockopt()</function>.  Registration and 
       de-registration are only done on module load and unload (and boot 
       time, where there is no concurrency), and the list of registrations 
       is only consulted for an unknown <function>setsockopt()</function>
       or <function>getsockopt()</function> system call.  The 
       <varname>nf_sockopt_mutex</varname> is perfect to protect this,
       especially since the setsockopt and getsockopt calls may well
       sleep.
     </para>
        </sect1>
        <sect1 id="lock-user-bh">
          <title>Locking Between User Context and Softirqs</title>
          <para>
      If a <firstterm linkend="gloss-softirq">softirq</firstterm> shares
      data with user context, you have two problems.  Firstly, the current 
      user context can be interrupted by a softirq, and secondly, the
      critical region could be entered from another CPU.  This is where
      <function>spin_lock_bh()</function> 
      (<filename class="headerfile">include/linux/spinlock.h</filename>) is
      used.  It disables softirqs on that CPU, then grabs the lock.
      <function>spin_unlock_bh()</function> does the reverse.  (The
      '_bh' suffix is a historical reference to "Bottom Halves", the
      old name for software interrupts.  It should really be
      called spin_lock_softirq()' in a perfect world).
    </para>
          <para>
      Note that you can also use <function>spin_lock_irq()</function>
      or <function>spin_lock_irqsave()</function> here, which stop
      hardware interrupts as well: see <xref linkend="hardirq-context" />.
    </para>
          <para>
      This works perfectly for <firstterm linkend="gloss-up"><acronym>UP
      </acronym></firstterm> as well: the spin lock vanishes, and this macro 
      simply becomes <function>local_bh_disable()</function>
      (<filename class="headerfile">include/linux/interrupt.h</filename>), which
      protects you from the softirq being run.
    </para>
        </sect1>
        <sect1 id="lock-user-tasklet">
          <title>Locking Between User Context and Tasklets</title>
          <para>
      This is exactly the same as above, because <firstterm linkend="gloss-tasklet">tasklets</firstterm> are actually run
      from a softirq.
    </para>
        </sect1>
        <sect1 id="lock-user-timers">
          <title>Locking Between User Context and Timers</title>
          <para>
      This, too, is exactly the same as above, because <firstterm linkend="gloss-timers">timers</firstterm> are actually run from
      a softirq.  From a locking point of view, tasklets and timers
      are identical.
    </para>
        </sect1>
        <sect1 id="lock-tasklets">
          <title>Locking Between Tasklets/Timers</title>
          <para>
      Sometimes a tasklet or timer might want to share data with
      another tasklet or timer.
    </para>
          <sect2 id="lock-tasklets-same">
            <title>The Same Tasklet/Timer</title>
            <para>
       Since a tasklet is never run on two CPUs at once, you don't
       need to worry about your tasklet being reentrant (running
       twice at once), even on SMP.
     </para>
          </sect2>
          <sect2 id="lock-tasklets-different">
            <title>Different Tasklets/Timers</title>
            <para>
       If another tasklet/timer wants
       to share data with your tasklet or timer , you will both need to use
       <function>spin_lock()</function> and
       <function>spin_unlock()</function> calls.  
       <function>spin_lock_bh()</function> is
       unnecessary here, as you are already in a tasklet, and
       none will be run on the same CPU.
     </para>
          </sect2>
        </sect1>
        <sect1 id="lock-softirqs">
          <title>Locking Between Softirqs</title>
          <para>
      Often a softirq might
      want to share data with itself or a tasklet/timer.
    </para>
          <sect2 id="lock-softirqs-same">
            <title>The Same Softirq</title>
            <para>
       The same softirq can run on the other CPUs: you can use a
       per-CPU array (see <xref linkend="per-cpu" />) for better
       performance.  If you're going so far as to use a softirq,
       you probably care about scalable performance enough
       to justify the extra complexity.
     </para>
            <para>
       You'll need to use <function>spin_lock()</function> and 
       <function>spin_unlock()</function> for shared data.
     </para>
          </sect2>
          <sect2 id="lock-softirqs-different">
            <title>Different Softirqs</title>
            <para>
       You'll need to use <function>spin_lock()</function> and
       <function>spin_unlock()</function> for shared data, whether it
       be a timer, tasklet, different softirq or the same or another
       softirq: any of them could be running on a different CPU.
     </para>
          </sect2>
        </sect1>
      </chapter>
      <chapter id="hardirq-context">
        <title>Hard IRQ Context</title>
        <para>
     Hardware interrupts usually communicate with a
     tasklet or softirq.  Frequently this involves putting work in a
     queue, which the softirq will take out.
   </para>
        <sect1 id="hardirq-softirq">
          <title>Locking Between Hard IRQ and Softirqs/Tasklets</title>
          <para>
      If a hardware irq handler shares data with a softirq, you have
      two concerns.  Firstly, the softirq processing can be
      interrupted by a hardware interrupt, and secondly, the
      critical region could be entered by a hardware interrupt on
      another CPU.  This is where <function>spin_lock_irq()</function> is 
      used.  It is defined to disable interrupts on that cpu, then grab 
      the lock. <function>spin_unlock_irq()</function> does the reverse.
    </para>
          <para>
      The irq handler does not to use
      <function>spin_lock_irq()</function>, because the softirq cannot
      run while the irq handler is running: it can use
      <function>spin_lock()</function>, which is slightly faster.  The
      only exception would be if a different hardware irq handler uses
      the same lock: <function>spin_lock_irq()</function> will stop
      that from interrupting us.
    </para>
          <para>
      This works perfectly for UP as well: the spin lock vanishes,
      and this macro simply becomes <function>local_irq_disable()</function>
      (<filename class="headerfile">include/asm/smp.h</filename>), which
      protects you from the softirq/tasklet/BH being run.
    </para>
          <para>
            <function>spin_lock_irqsave()</function> 
      (<filename>include/linux/spinlock.h</filename>) is a variant
      which saves whether interrupts were on or off in a flags word,
      which is passed to <function>spin_unlock_irqrestore()</function>.  This
      means that the same code can be used inside an hard irq handler (where
      interrupts are already off) and in softirqs (where the irq
      disabling is required).
    </para>
          <para>
      Note that softirqs (and hence tasklets and timers) are run on
      return from hardware interrupts, so
      <function>spin_lock_irq()</function> also stops these.  In that
      sense, <function>spin_lock_irqsave()</function> is the most
      general and powerful locking function.
    </para>
        </sect1>
        <sect1 id="hardirq-hardirq">
          <title>Locking Between Two Hard IRQ Handlers</title>
          <para>
      It is rare to have to share data between two IRQ handlers, but
      if you do, <function>spin_lock_irqsave()</function> should be
      used: it is architecture-specific whether all interrupts are
      disabled inside irq handlers themselves.
    </para>
        </sect1>
      </chapter>
      <chapter id="cheatsheet">
        <title>Cheat Sheet For Locking</title>
        <para>
     Pete Zaitcev gives the following summary:
   </para>
        <itemizedlist>
          <listitem>
            <para>
          If you are in a process context (any syscall) and want to
	lock other process out, use a mutex.  You can take a mutex
	and sleep (<function>copy_from_user*(</function> or
	<function>kmalloc(x,GFP_KERNEL)</function>).
      </para>
          </listitem>
          <listitem>
            <para>
	Otherwise (== data can be touched in an interrupt), use
	<function>spin_lock_irqsave()</function> and
	<function>spin_unlock_irqrestore()</function>.
	</para>
          </listitem>
          <listitem>
            <para>
	Avoid holding spinlock for more than 5 lines of code and
	across any function call (except accessors like
	<function>readb</function>).
	</para>
          </listitem>
        </itemizedlist>
        <sect1 id="minimum-lock-reqirements">
          <title>Table of Minimum Requirements</title>
          <para> The following table lists the <emphasis>minimum</emphasis>
	locking requirements between various contexts.  In some cases,
	the same context can only be running on one CPU at a time, so
	no locking is required for that context (eg. a particular
	thread can only run on one CPU at a time, but if it needs
	shares data with another thread, locking is required).
   </para>
          <para>
	Remember the advice above: you can always use
	<function>spin_lock_irqsave()</function>, which is a superset
	of all other spinlock primitives.
   </para>
          <table>
            <title>Table of Locking Requirements</title>
            <tgroup cols="11">
              <tbody>
                <row>
                  <entry>
                  </entry>
                  <entry>IRQ Handler A</entry>
                  <entry>IRQ Handler B</entry>
                  <entry>Softirq A</entry>
                  <entry>Softirq B</entry>
                  <entry>Tasklet A</entry>
                  <entry>Tasklet B</entry>
                  <entry>Timer A</entry>
                  <entry>Timer B</entry>
                  <entry>User Context A</entry>
                  <entry>User Context B</entry>
                </row>
                <row>
                  <entry>IRQ Handler A</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>IRQ Handler B</entry>
                  <entry>SLIS</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>Softirq A</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SL</entry>
                </row>
                <row>
                  <entry>Softirq B</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                </row>
                <row>
                  <entry>Tasklet A</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>Tasklet B</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>Timer A</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>Timer B</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>SL</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>User Context A</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>None</entry>
                </row>
                <row>
                  <entry>User Context B</entry>
                  <entry>SLI</entry>
                  <entry>SLI</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>SLBH</entry>
                  <entry>MLI</entry>
                  <entry>None</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <table>
            <title>Legend for Locking Requirements Table</title>
            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>SLIS</entry>
                  <entry>spin_lock_irqsave</entry>
                </row>
                <row>
                  <entry>SLI</entry>
                  <entry>spin_lock_irq</entry>
                </row>
                <row>
                  <entry>SL</entry>
                  <entry>spin_lock</entry>
                </row>
                <row>
                  <entry>SLBH</entry>
                  <entry>spin_lock_bh</entry>
                </row>
                <row>
                  <entry>MLI</entry>
                  <entry>mutex_lock_interruptible</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </sect1>
      </chapter>
      <chapter id="trylock-functions">
        <title>The trylock Functions</title>
        <para>
   There are functions that try to acquire a lock only once and immediately
   return a value telling about success or failure to acquire the lock.
   They can be used if you need no access to the data protected with the lock
   when some other thread is holding the lock. You should acquire the lock
   later if you then need access to the data protected with the lock.
  </para>
        <para>
          <function>spin_trylock()</function> does not spin but returns non-zero if
    it acquires the spinlock on the first try or 0 if not. This function can
    be used in all contexts like <function>spin_lock</function>: you must have
    disabled the contexts that might interrupt you and acquire the spin lock.
  </para>
        <para>
          <function>mutex_trylock()</function> does not suspend your task
    but returns non-zero if it could lock the mutex on the first try
    or 0 if not. This function cannot be safely used in hardware or software
    interrupt contexts despite not sleeping.
  </para>
      </chapter>
      <chapter id="Examples">
        <title>Common Examples</title>
        <para>
Let's step through a simple example: a cache of number to name
mappings.  The cache keeps a count of how often each of the objects is
used, and when it gets full, throws out the least used one.

    </para>
        <sect1 id="examples-usercontext">
          <title>All In User Context</title>
          <para>
For our first example, we assume that all operations are in user
context (ie. from system calls), so we can sleep.  This means we can
use a mutex to protect the cache and all the objects within
it.  Here's the code:
    </para>
          <programlisting>
#include &lt;linux/list.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;asm/errno.h&gt;

struct object
{
        struct list_head list;
        int id;
        char name[32];
        int popularity;
};

/* Protects the cache, cache_num, and the objects within it */
static DEFINE_MUTEX(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
        struct object *i;

        list_for_each_entry(i, &amp;cache, list)
                if (i-&gt;id == id) {
                        i-&gt;popularity++;
                        return i;
                }
        return NULL;
}

/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
        BUG_ON(!obj);
        list_del(&amp;obj-&gt;list);
        kfree(obj);
        cache_num--;
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
        list_add(&amp;obj-&gt;list, &amp;cache);
        if (++cache_num &gt; MAX_CACHE_SIZE) {
                struct object *i, *outcast = NULL;
                list_for_each_entry(i, &amp;cache, list) {
                        if (!outcast || i-&gt;popularity &lt; outcast-&gt;popularity)
                                outcast = i;
                }
                __cache_delete(outcast);
        }
}

int cache_add(int id, const char *name)
{
        struct object *obj;

        if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                return -ENOMEM;

        strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
        obj-&gt;id = id;
        obj-&gt;popularity = 0;

        mutex_lock(&amp;cache_lock);
        __cache_add(obj);
        mutex_unlock(&amp;cache_lock);
        return 0;
}

void cache_delete(int id)
{
        mutex_lock(&amp;cache_lock);
        __cache_delete(__cache_find(id));
        mutex_unlock(&amp;cache_lock);
}

int cache_find(int id, char *name)
{
        struct object *obj;
        int ret = -ENOENT;

        mutex_lock(&amp;cache_lock);
        obj = __cache_find(id);
        if (obj) {
                ret = 0;
                strcpy(name, obj-&gt;name);
        }
        mutex_unlock(&amp;cache_lock);
        return ret;
}
</programlisting>
          <para>
Note that we always make sure we have the cache_lock when we add,
delete, or look up the cache: both the cache infrastructure itself and
the contents of the objects are protected by the lock.  In this case
it's easy, since we copy the data for the user, and never let them
access the objects directly.
    </para>
          <para>
There is a slight (and common) optimization here: in
<function>cache_add</function> we set up the fields of the object
before grabbing the lock.  This is safe, as no-one else can access it
until we put it in cache.
    </para>
        </sect1>
        <sect1 id="examples-interrupt">
          <title>Accessing From Interrupt Context</title>
          <para>
Now consider the case where <function>cache_find</function> can be
called from interrupt context: either a hardware interrupt or a
softirq.  An example would be a timer which deletes object from the
cache.
    </para>
          <para>
The change is shown below, in standard patch format: the
<symbol>-</symbol> are lines which are taken away, and the
<symbol>+</symbol> are lines which are added.
    </para>
          <programlisting>
--- cache.c.usercontext	2003-12-09 13:58:54.000000000 +1100
+++ cache.c.interrupt	2003-12-09 14:07:49.000000000 +1100
@@ -12,7 +12,7 @@
         int popularity;
 };

-static DEFINE_MUTEX(cache_lock);
+static DEFINE_SPINLOCK(cache_lock);
 static LIST_HEAD(cache);
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10
@@ -55,6 +55,7 @@
 int cache_add(int id, const char *name)
 {
         struct object *obj;
+        unsigned long flags;

         if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                 return -ENOMEM;
@@ -63,30 +64,33 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return 0;
 }

 void cache_delete(int id)
 {
-        mutex_lock(&amp;cache_lock);
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_delete(__cache_find(id));
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

 int cache_find(int id, char *name)
 {
         struct object *obj;
         int ret = -ENOENT;
+        unsigned long flags;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj) {
                 ret = 0;
                 strcpy(name, obj-&gt;name);
         }
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return ret;
 }
</programlisting>
          <para>
Note that the <function>spin_lock_irqsave</function> will turn off
interrupts if they are on, otherwise does nothing (if we are already
in an interrupt handler), hence these functions are safe to call from
any context.
    </para>
          <para>
Unfortunately, <function>cache_add</function> calls
<function>kmalloc</function> with the <symbol>GFP_KERNEL</symbol>
flag, which is only legal in user context.  I have assumed that
<function>cache_add</function> is still only called in user context,
otherwise this should become a parameter to
<function>cache_add</function>.
    </para>
        </sect1>
        <sect1 id="examples-refcnt">
          <title>Exposing Objects Outside This File</title>
          <para>
If our objects contained more information, it might not be sufficient
to copy the information in and out: other parts of the code might want
to keep pointers to these objects, for example, rather than looking up
the id every time.  This produces two problems.
    </para>
          <para>
The first problem is that we use the <symbol>cache_lock</symbol> to
protect objects: we'd need to make this non-static so the rest of the
code can use it.  This makes locking trickier, as it is no longer all
in one place.
    </para>
          <para>
The second problem is the lifetime problem: if another structure keeps
a pointer to an object, it presumably expects that pointer to remain
valid.  Unfortunately, this is only guaranteed while you hold the
lock, otherwise someone might call <function>cache_delete</function>
and even worse, add another object, re-using the same address.
    </para>
          <para>
As there is only one lock, you can't hold it forever: no-one else would
get any work done.
    </para>
          <para>
The solution to this problem is to use a reference count: everyone who
has a pointer to the object increases it when they first get the
object, and drops the reference count when they're finished with it.
Whoever drops it to zero knows it is unused, and can actually delete it.
    </para>
          <para>
Here is the code:
    </para>
          <programlisting>
--- cache.c.interrupt	2003-12-09 14:25:43.000000000 +1100
+++ cache.c.refcnt	2003-12-09 14:33:05.000000000 +1100
@@ -7,6 +7,7 @@
 struct object
 {
         struct list_head list;
+        unsigned int refcnt;
         int id;
         char name[32];
         int popularity;
@@ -17,6 +18,35 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

+static void __object_put(struct object *obj)
+{
+        if (--obj-&gt;refcnt == 0)
+                kfree(obj);
+}
+
+static void __object_get(struct object *obj)
+{
+        obj-&gt;refcnt++;
+}
+
+void object_put(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_put(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
+void object_get(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_get(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
 /* Must be holding cache_lock */
 static struct object *__cache_find(int id)
 {
@@ -35,6 +65,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
+        __object_put(obj);
         cache_num--;
 }

@@ -63,6 +94,7 @@
         strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
+        obj-&gt;refcnt = 1; /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -79,18 +111,15 @@
         spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

-int cache_find(int id, char *name)
+struct object *cache_find(int id)
 {
         struct object *obj;
-        int ret = -ENOENT;
         unsigned long flags;

         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
-        if (obj) {
-                ret = 0;
-                strcpy(name, obj-&gt;name);
-        }
+        if (obj)
+                __object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
-        return ret;
+        return obj;
 }
</programlisting>
          <para>
We encapsulate the reference counting in the standard 'get' and 'put'
functions.  Now we can return the object itself from
<function>cache_find</function> which has the advantage that the user
can now sleep holding the object (eg. to
<function>copy_to_user</function> to name to userspace).
</para>
          <para>
The other point to note is that I said a reference should be held for
every pointer to the object: thus the reference count is 1 when first
inserted into the cache.  In some versions the framework does not hold
a reference count, but they are more complicated.
</para>
          <sect2 id="examples-refcnt-atomic">
            <title>Using Atomic Operations For The Reference Count</title>
            <para>
In practice, <type>atomic_t</type> would usually be used for
<structfield>refcnt</structfield>.  There are a number of atomic
operations defined in

<filename class="headerfile">include/asm/atomic.h</filename>: these are
guaranteed to be seen atomically from all CPUs in the system, so no
lock is required.  In this case, it is simpler than using spinlocks,
although for anything non-trivial using spinlocks is clearer.  The
<function>atomic_inc</function> and
<function>atomic_dec_and_test</function> are used instead of the
standard increment and decrement operators, and the lock is no longer
used to protect the reference count itself.
</para>
            <programlisting>
--- cache.c.refcnt	2003-12-09 15:00:35.000000000 +1100
+++ cache.c.refcnt-atomic	2003-12-11 15:49:42.000000000 +1100
@@ -7,7 +7,7 @@
 struct object
 {
         struct list_head list;
-        unsigned int refcnt;
+        atomic_t refcnt;
         int id;
         char name[32];
         int popularity;
@@ -18,33 +18,15 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

-static void __object_put(struct object *obj)
-{
-        if (--obj-&gt;refcnt == 0)
-                kfree(obj);
-}
-
-static void __object_get(struct object *obj)
-{
-        obj-&gt;refcnt++;
-}
-
 void object_put(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_put(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        if (atomic_dec_and_test(&amp;obj-&gt;refcnt))
+                kfree(obj);
 }

 void object_get(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        atomic_inc(&amp;obj-&gt;refcnt);
 }

 /* Must be holding cache_lock */
@@ -65,7 +47,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
-        __object_put(obj);
+        object_put(obj);
         cache_num--;
 }

@@ -94,7 +76,7 @@
         strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
-        obj-&gt;refcnt = 1; /* The cache holds a reference */
+        atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -119,7 +101,7 @@
         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj)
-                __object_get(obj);
+                object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
         return obj;
 }
</programlisting>
          </sect2>
        </sect1>
        <sect1 id="examples-lock-per-obj">
          <title>Protecting The Objects Themselves</title>
          <para>
In these examples, we assumed that the objects (except the reference
counts) never changed once they are created.  If we wanted to allow
the name to change, there are three possibilities:
    </para>
          <itemizedlist>
            <listitem>
              <para>
You can make <symbol>cache_lock</symbol> non-static, and tell people
to grab that lock before changing the name in any object.
        </para>
            </listitem>
            <listitem>
              <para>
You can provide a <function>cache_obj_rename</function> which grabs
this lock and changes the name for the caller, and tell everyone to
use that function.
        </para>
            </listitem>
            <listitem>
              <para>
You can make the <symbol>cache_lock</symbol> protect only the cache
itself, and use another lock to protect the name.
        </para>
            </listitem>
          </itemizedlist>
          <para>
Theoretically, you can make the locks as fine-grained as one lock for
every field, for every object.  In practice, the most common variants
are:
</para>
          <itemizedlist>
            <listitem>
              <para>
One lock which protects the infrastructure (the <symbol>cache</symbol>
list in this example) and all the objects.  This is what we have done
so far.
	</para>
            </listitem>
            <listitem>
              <para>
One lock which protects the infrastructure (including the list
pointers inside the objects), and one lock inside the object which
protects the rest of that object.
        </para>
            </listitem>
            <listitem>
              <para>
Multiple locks to protect the infrastructure (eg. one lock per hash
chain), possibly with a separate per-object lock.
        </para>
            </listitem>
          </itemizedlist>
          <para>
Here is the "lock-per-object" implementation:
</para>
          <programlisting>
--- cache.c.refcnt-atomic	2003-12-11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock	2003-12-11 17:15:03.000000000 +1100
@@ -6,11 +6,17 @@

 struct object
 {
+        /* These two protected by cache_lock. */
         struct list_head list;
+        int popularity;
+
         atomic_t refcnt;
+
+        /* Doesn't change once created. */
         int id;
+
+        spinlock_t lock; /* Protects the name */
         char name[32];
-        int popularity;
 };

 static DEFINE_SPINLOCK(cache_lock);
@@ -77,6 +84,7 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
         atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */
+        spin_lock_init(&amp;obj-&gt;lock);

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
</programlisting>
          <para>
Note that I decide that the <structfield>popularity</structfield>
count should be protected by the <symbol>cache_lock</symbol> rather
than the per-object lock: this is because it (like the
<structname>struct list_head</structname> inside the object) is
logically part of the infrastructure.  This way, I don't need to grab
the lock of every object in <function>__cache_add</function> when
seeking the least popular.
</para>
          <para>
I also decided that the <structfield>id</structfield> member is
unchangeable, so I don't need to grab each object lock in
<function>__cache_find()</function> to examine the
<structfield>id</structfield>: the object lock is only used by a
caller who wants to read or write the <structfield>name</structfield>
field.
</para>
          <para>
Note also that I added a comment describing what data was protected by
which locks.  This is extremely important, as it describes the runtime
behavior of the code, and can be hard to gain from just reading.  And
as Alan Cox says, <quote>Lock data, not code</quote>.
</para>
        </sect1>
      </chapter>
      <chapter id="common-problems">
        <title>Common Problems</title>
        <sect1 id="deadlock">
          <title>Deadlock: Simple and Advanced</title>
          <para>
      There is a coding bug where a piece of code tries to grab a
      spinlock twice: it will spin forever, waiting for the lock to
      be released (spinlocks, rwlocks and mutexes are not
      recursive in Linux).  This is trivial to diagnose: not a
      stay-up-five-nights-talk-to-fluffy-code-bunnies kind of
      problem.
    </para>
          <para>
      For a slightly more complex case, imagine you have a region
      shared by a softirq and user context.  If you use a
      <function>spin_lock()</function> call to protect it, it is 
      possible that the user context will be interrupted by the softirq
      while it holds the lock, and the softirq will then spin
      forever trying to get the same lock.
    </para>
          <para>
      Both of these are called deadlock, and as shown above, it can
      occur even with a single CPU (although not on UP compiles,
      since spinlocks vanish on kernel compiles with 
      <symbol>CONFIG_SMP</symbol>=n. You'll still get data corruption 
      in the second example).
    </para>
          <para>
      This complete lockup is easy to diagnose: on SMP boxes the
      watchdog timer or compiling with <symbol>DEBUG_SPINLOCK</symbol> set
      (<filename>include/linux/spinlock.h</filename>) will show this up 
      immediately when it happens.
    </para>
          <para>
      A more complex problem is the so-called 'deadly embrace',
      involving two or more locks.  Say you have a hash table: each
      entry in the table is a spinlock, and a chain of hashed
      objects.  Inside a softirq handler, you sometimes want to
      alter an object from one place in the hash to another: you
      grab the spinlock of the old hash chain and the spinlock of
      the new hash chain, and delete the object from the old one,
      and insert it in the new one.
    </para>
          <para>
      There are two problems here.  First, if your code ever
      tries to move the object to the same chain, it will deadlock
      with itself as it tries to lock it twice.  Secondly, if the
      same softirq on another CPU is trying to move another object
      in the reverse direction, the following could happen:
    </para>
          <table>
            <title>Consequences</title>
            <tgroup cols="2" align="left">
              <thead>
                <row>
                  <entry>CPU 1</entry>
                  <entry>CPU 2</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Grab lock A -&gt; OK</entry>
                  <entry>Grab lock B -&gt; OK</entry>
                </row>
                <row>
                  <entry>Grab lock B -&gt; spin</entry>
                  <entry>Grab lock A -&gt; spin</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>
      The two CPUs will spin forever, waiting for the other to give up
      their lock.  It will look, smell, and feel like a crash.
    </para>
        </sect1>
        <sect1 id="techs-deadlock-prevent">
          <title>Preventing Deadlock</title>
          <para>
       Textbooks will tell you that if you always lock in the same
       order, you will never get this kind of deadlock.  Practice
       will tell you that this approach doesn't scale: when I
       create a new lock, I don't understand enough of the kernel
       to figure out where in the 5000 lock hierarchy it will fit.
     </para>
          <para>
       The best locks are encapsulated: they never get exposed in
       headers, and are never held around calls to non-trivial
       functions outside the same file.  You can read through this
       code and see that it will never deadlock, because it never
       tries to grab another lock while it has that one.  People
       using your code don't even need to know you are using a
       lock.
     </para>
          <para>
       A classic problem here is when you provide callbacks or
       hooks: if you call these with the lock held, you risk simple
       deadlock, or a deadly embrace (who knows what the callback
       will do?).  Remember, the other programmers are out to get
       you, so don't do this.
     </para>
          <sect2 id="techs-deadlock-overprevent">
            <title>Overzealous Prevention Of Deadlocks</title>
            <para>
       Deadlocks are problematic, but not as bad as data
       corruption.  Code which grabs a read lock, searches a list,
       fails to find what it wants, drops the read lock, grabs a
       write lock and inserts the object has a race condition.
     </para>
            <para>
       If you don't see why, please stay the fuck away from my code.
     </para>
          </sect2>
        </sect1>
        <sect1 id="racing-timers">
          <title>Racing Timers: A Kernel Pastime</title>
          <para>
      Timers can produce their own special problems with races.
      Consider a collection of objects (list, hash, etc) where each
      object has a timer which is due to destroy it.
    </para>
          <para>
      If you want to destroy the entire collection (say on module
      removal), you might do the following:
    </para>
          <programlisting>
        /* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE
           HUNGARIAN NOTATION */
        spin_lock_bh(&amp;list_lock);

        while (list) {
                struct foo *next = list-&gt;next;
                del_timer(&amp;list-&gt;timer);
                kfree(list);
                list = next;
        }

        spin_unlock_bh(&amp;list_lock);
    </programlisting>
          <para>
      Sooner or later, this will crash on SMP, because a timer can
      have just gone off before the <function>spin_lock_bh()</function>,
      and it will only get the lock after we
      <function>spin_unlock_bh()</function>, and then try to free
      the element (which has already been freed!).
    </para>
          <para>
      This can be avoided by checking the result of
      <function>del_timer()</function>: if it returns
      <returnvalue>1</returnvalue>, the timer has been deleted.
      If <returnvalue>0</returnvalue>, it means (in this
      case) that it is currently running, so we can do:
    </para>
          <programlisting>
        retry:
                spin_lock_bh(&amp;list_lock);

                while (list) {
                        struct foo *next = list-&gt;next;
                        if (!del_timer(&amp;list-&gt;timer)) {
                                /* Give timer a chance to delete this */
                                spin_unlock_bh(&amp;list_lock);
                                goto retry;
                        }
                        kfree(list);
                        list = next;
                }

                spin_unlock_bh(&amp;list_lock);
    </programlisting>
          <para>
      Another common problem is deleting timers which restart
      themselves (by calling <function>add_timer()</function> at the end
      of their timer function).  Because this is a fairly common case
      which is prone to races, you should use <function>del_timer_sync()</function>
      (<filename class="headerfile">include/linux/timer.h</filename>)
      to handle this case.  It returns the number of times the timer
      had to be deleted before we finally stopped it from adding itself back
      in.
    </para>
        </sect1>
      </chapter>
      <chapter id="Efficiency">
        <title>Locking Speed</title>
        <para>
There are three main things to worry about when considering speed of
some code which does locking.  First is concurrency: how many things
are going to be waiting while someone else is holding a lock.  Second
is the time taken to actually acquire and release an uncontended lock.
Third is using fewer, or smarter locks.  I'm assuming that the lock is
used fairly often: otherwise, you wouldn't be concerned about
efficiency.
</para>
        <para>
Concurrency depends on how long the lock is usually held: you should
hold the lock for as long as needed, but no longer.  In the cache
example, we always create the object without the lock held, and then
grab the lock only when we are ready to insert it in the list.
</para>
        <para>
Acquisition times depend on how much damage the lock operations do to
the pipeline (pipeline stalls) and how likely it is that this CPU was
the last one to grab the lock (ie. is the lock cache-hot for this
CPU): on a machine with more CPUs, this likelihood drops fast.
Consider a 700MHz Intel Pentium III: an instruction takes about 0.7ns,
an atomic increment takes about 58ns, a lock which is cache-hot on
this CPU takes 160ns, and a cacheline transfer from another CPU takes
an additional 170 to 360ns.  (These figures from Paul McKenney's
<ulink url="http://www.linuxjournal.com/article.php?sid=6993"> Linux
Journal RCU article</ulink>).
</para>
        <para>
These two aims conflict: holding a lock for a short time might be done
by splitting locks into parts (such as in our final per-object-lock
example), but this increases the number of lock acquisitions, and the
results are often slower than having a single lock.  This is another
reason to advocate locking simplicity.
</para>
        <para>
The third concern is addressed below: there are some methods to reduce
the amount of locking which needs to be done.
</para>
        <sect1 id="efficiency-rwlocks">
          <title>Read/Write Lock Variants</title>
          <para>
      Both spinlocks and mutexes have read/write variants:
      <type>rwlock_t</type> and <structname>struct rw_semaphore</structname>.
      These divide users into two classes: the readers and the writers.  If
      you are only reading the data, you can get a read lock, but to write to
      the data you need the write lock.  Many people can hold a read lock,
      but a writer must be sole holder.
    </para>
          <para>
      If your code divides neatly along reader/writer lines (as our
      cache code does), and the lock is held by readers for
      significant lengths of time, using these locks can help.  They
      are slightly slower than the normal locks though, so in practice
      <type>rwlock_t</type> is not usually worthwhile.
    </para>
        </sect1>
        <sect1 id="efficiency-read-copy-update">
          <title>Avoiding Locks: Read Copy Update</title>
          <para>
      There is a special method of read/write locking called Read Copy
      Update.  Using RCU, the readers can avoid taking a lock
      altogether: as we expect our cache to be read more often than
      updated (otherwise the cache is a waste of time), it is a
      candidate for this optimization.
    </para>
          <para>
      How do we get rid of read locks?  Getting rid of read locks
      means that writers may be changing the list underneath the
      readers.  That is actually quite simple: we can read a linked
      list while an element is being added if the writer adds the
      element very carefully.  For example, adding
      <symbol>new</symbol> to a single linked list called
      <symbol>list</symbol>:
    </para>
          <programlisting>
        new-&gt;next = list-&gt;next;
        wmb();
        list-&gt;next = new;
    </programlisting>
          <para>
      The <function>wmb()</function> is a write memory barrier.  It
      ensures that the first operation (setting the new element's
      <symbol>next</symbol> pointer) is complete and will be seen by
      all CPUs, before the second operation is (putting the new
      element into the list).  This is important, since modern
      compilers and modern CPUs can both reorder instructions unless
      told otherwise: we want a reader to either not see the new
      element at all, or see the new element with the
      <symbol>next</symbol> pointer correctly pointing at the rest of
      the list.
    </para>
          <para>
      Fortunately, there is a function to do this for standard
      <structname>struct list_head</structname> lists:
      <function>list_add_rcu()</function>
      (<filename>include/linux/list.h</filename>).
    </para>
          <para>
      Removing an element from the list is even simpler: we replace
      the pointer to the old element with a pointer to its successor,
      and readers will either see it, or skip over it.
    </para>
          <programlisting>
        list-&gt;next = old-&gt;next;
    </programlisting>
          <para>
      There is <function>list_del_rcu()</function>
      (<filename>include/linux/list.h</filename>) which does this (the
      normal version poisons the old object, which we don't want).
    </para>
          <para>
      The reader must also be careful: some CPUs can look through the
      <symbol>next</symbol> pointer to start reading the contents of
      the next element early, but don't realize that the pre-fetched
      contents is wrong when the <symbol>next</symbol> pointer changes
      underneath them.  Once again, there is a
      <function>list_for_each_entry_rcu()</function>
      (<filename>include/linux/list.h</filename>) to help you.  Of
      course, writers can just use
      <function>list_for_each_entry()</function>, since there cannot
      be two simultaneous writers.
    </para>
          <para>
      Our final dilemma is this: when can we actually destroy the
      removed element?  Remember, a reader might be stepping through
      this element in the list right now: if we free this element and
      the <symbol>next</symbol> pointer changes, the reader will jump
      off into garbage and crash.  We need to wait until we know that
      all the readers who were traversing the list when we deleted the
      element are finished.  We use <function>call_rcu()</function> to
      register a callback which will actually destroy the object once
      all pre-existing readers are finished.  Alternatively,
      <function>synchronize_rcu()</function> may be used to block until
      all pre-existing are finished.
    </para>
          <para>
      But how does Read Copy Update know when the readers are
      finished?  The method is this: firstly, the readers always
      traverse the list inside
      <function>rcu_read_lock()</function>/<function>rcu_read_unlock()</function>
      pairs: these simply disable preemption so the reader won't go to
      sleep while reading the list.
    </para>
          <para>
      RCU then waits until every other CPU has slept at least once:
      since readers cannot sleep, we know that any readers which were
      traversing the list during the deletion are finished, and the
      callback is triggered.  The real Read Copy Update code is a
      little more optimized than this, but this is the fundamental
      idea.
    </para>
          <programlisting>
--- cache.c.perobjectlock	2003-12-11 17:15:03.000000000 +1100
+++ cache.c.rcupdate	2003-12-11 17:55:14.000000000 +1100
@@ -1,15 +1,18 @@
 #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
+#include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;asm/errno.h&gt;

 struct object
 {
-        /* These two protected by cache_lock. */
+        /* This is protected by RCU */
         struct list_head list;
         int popularity;

+        struct rcu_head rcu;
+
         atomic_t refcnt;

         /* Doesn't change once created. */
@@ -40,7 +43,7 @@
 {
         struct object *i;

-        list_for_each_entry(i, &amp;cache, list) {
+        list_for_each_entry_rcu(i, &amp;cache, list) {
                 if (i-&gt;id == id) {
                         i-&gt;popularity++;
                         return i;
@@ -49,19 +52,25 @@
         return NULL;
 }

+/* Final discard done once we know no readers are looking. */
+static void cache_delete_rcu(void *arg)
+{
+        object_put(arg);
+}
+
 /* Must be holding cache_lock */
 static void __cache_delete(struct object *obj)
 {
         BUG_ON(!obj);
-        list_del(&amp;obj-&gt;list);
-        object_put(obj);
+        list_del_rcu(&amp;obj-&gt;list);
         cache_num--;
+        call_rcu(&amp;obj-&gt;rcu, cache_delete_rcu);
 }

 /* Must be holding cache_lock */
 static void __cache_add(struct object *obj)
 {
-        list_add(&amp;obj-&gt;list, &amp;cache);
+        list_add_rcu(&amp;obj-&gt;list, &amp;cache);
         if (++cache_num &gt; MAX_CACHE_SIZE) {
                 struct object *i, *outcast = NULL;
                 list_for_each_entry(i, &amp;cache, list) {
@@ -104,12 +114,11 @@
 struct object *cache_find(int id)
 {
         struct object *obj;
-        unsigned long flags;

-        spin_lock_irqsave(&amp;cache_lock, flags);
+        rcu_read_lock();
         obj = __cache_find(id);
         if (obj)
                 object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        rcu_read_unlock();
         return obj;
 }
</programlisting>
          <para>
Note that the reader will alter the
<structfield>popularity</structfield> member in
<function>__cache_find()</function>, and now it doesn't hold a lock.
One solution would be to make it an <type>atomic_t</type>, but for
this usage, we don't really care about races: an approximate result is
good enough, so I didn't change it.
</para>
          <para>
The result is that <function>cache_find()</function> requires no
synchronization with any other functions, so is almost as fast on SMP
as it would be on UP.
</para>
          <para>
There is a furthur optimization possible here: remember our original
cache code, where there were no reference counts and the caller simply
held the lock whenever using the object?  This is still possible: if
you hold the lock, no one can delete the object, so you don't need to
get and put the reference count.
</para>
          <para>
Now, because the 'read lock' in RCU is simply disabling preemption, a
caller which always has preemption disabled between calling
<function>cache_find()</function> and
<function>object_put()</function> does not need to actually get and
put the reference count: we could expose
<function>__cache_find()</function> by making it non-static, and
such callers could simply call that.
</para>
          <para>
The benefit here is that the reference count is not written to: the
object is not altered in any way, which is much faster on SMP
machines due to caching.
</para>
        </sect1>
        <sect1 id="per-cpu">
          <title>Per-CPU Data</title>
          <para>
      Another technique for avoiding locking which is used fairly
      widely is to duplicate information for each CPU.  For example,
      if you wanted to keep a count of a common condition, you could
      use a spin lock and a single counter.  Nice and simple.
    </para>
          <para>
      If that was too slow (it's usually not, but if you've got a
      really big machine to test on and can show that it is), you
      could instead use a counter for each CPU, then none of them need
      an exclusive lock.  See <function>DEFINE_PER_CPU()</function>,
      <function>get_cpu_var()</function> and
      <function>put_cpu_var()</function>
      (<filename class="headerfile">include/linux/percpu.h</filename>).
    </para>
          <para>
      Of particular use for simple per-cpu counters is the
      <type>local_t</type> type, and the
      <function>cpu_local_inc()</function> and related functions,
      which are more efficient than simple code on some architectures
      (<filename class="headerfile">include/asm/local.h</filename>).
    </para>
          <para>
      Note that there is no simple, reliable way of getting an exact
      value of such a counter, without introducing more locks.  This
      is not a problem for some uses.
    </para>
        </sect1>
        <sect1 id="mostly-hardirq">
          <title>Data Which Mostly Used By An IRQ Handler</title>
          <para>
      If data is always accessed from within the same IRQ handler, you
      don't need a lock at all: the kernel already guarantees that the
      irq handler will not run simultaneously on multiple CPUs.
    </para>
          <para>
      Manfred Spraul points out that you can still do this, even if
      the data is very occasionally accessed in user context or
      softirqs/tasklets.  The irq handler doesn't use a lock, and
      all other accesses are done as so:
    </para>
          <programlisting>
	spin_lock(&amp;lock);
	disable_irq(irq);
	...
	enable_irq(irq);
	spin_unlock(&amp;lock);
</programlisting>
          <para>
      The <function>disable_irq()</function> prevents the irq handler
      from running (and waits for it to finish if it's currently
      running on other CPUs).  The spinlock prevents any other
      accesses happening at the same time.  Naturally, this is slower
      than just a <function>spin_lock_irq()</function> call, so it
      only makes sense if this type of access happens extremely
      rarely.
    </para>
        </sect1>
      </chapter>
      <chapter id="sleeping-things">
        <title>What Functions Are Safe To Call From Interrupts?</title>
        <para>
      Many functions in the kernel sleep (ie. call schedule())
      directly or indirectly: you can never call them while holding a
      spinlock, or with preemption disabled.  This also means you need
      to be in user context: calling them from an interrupt is illegal.
    </para>
        <sect1 id="sleeping">
          <title>Some Functions Which Sleep</title>
          <para>
      The most common ones are listed below, but you usually have to
      read the code to find out if other calls are safe.  If everyone
      else who calls it can sleep, you probably need to be able to
      sleep, too.  In particular, registration and deregistration
      functions usually expect to be called from user context, and can
      sleep.
    </para>
          <itemizedlist>
            <listitem>
              <para>
        Accesses to 
        <firstterm linkend="gloss-userspace">userspace</firstterm>:
      </para>
              <itemizedlist>
                <listitem>
                  <para>
                    <function>copy_from_user()</function>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    <function>copy_to_user()</function>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    <function>get_user()</function>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    <function>put_user()</function>
                  </para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>
                <function>kmalloc(GFP_KERNEL)</function>
              </para>
            </listitem>
            <listitem>
              <para>
                <function>mutex_lock_interruptible()</function> and
      <function>mutex_lock()</function></para>
              <para>
       There is a <function>mutex_trylock()</function> which does not
       sleep.  Still, it must not be used inside interrupt context since
       its implementation is not safe for that.
       <function>mutex_unlock()</function> will also never sleep.
       It cannot be used in interrupt context either since a mutex
       must be released by the same task that acquired it.
      </para>
            </listitem>
          </itemizedlist>
        </sect1>
        <sect1 id="dont-sleep">
          <title>Some Functions Which Don't Sleep</title>
          <para>
     Some functions are safe to call from any context, or holding
     almost any lock.
    </para>
          <itemizedlist>
            <listitem>
              <para>
                <function>printk()</function>
              </para>
            </listitem>
            <listitem>
              <para>
                <function>kfree()</function>
              </para>
            </listitem>
            <listitem>
              <para>
                <function>add_timer()</function> and <function>del_timer()</function></para>
            </listitem>
          </itemizedlist>
        </sect1>
      </chapter>
      <chapter id="apiref-mutex">
        <title>Mutex API reference</title>
!Iinclude/linux/mutex.h
!Ekernel/locking/mutex.c
  </chapter>
      <chapter id="apiref-futex">
        <title>Futex API reference</title>
!Ikernel/futex.c
  </chapter>
      <chapter id="references">
        <title>Further reading</title>
        <itemizedlist>
          <listitem>
            <para>
              <filename>Documentation/spinlocks.txt</filename>: 
       Linus Torvalds' spinlocking tutorial in the kernel sources.
     </para>
          </listitem>
          <listitem>
            <para>
       Unix Systems for Modern Architectures: Symmetric
       Multiprocessing and Caching for Kernel Programmers:
     </para>
            <para>
       Curt Schimmel's very good introduction to kernel level
       locking (not written for Linux, but nearly everything
       applies).  The book is expensive, but really worth every
       penny to understand SMP locking. [ISBN: 0201633388]
     </para>
          </listitem>
        </itemizedlist>
      </chapter>
      <chapter id="thanks">
        <title>Thanks</title>
        <para>
      Thanks to Telsa Gwynne for DocBooking, neatening and adding
      style.
    </para>
        <para>
      Thanks to Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul
      Mackerras, Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim
      Waugh, Pete Zaitcev, James Morris, Robert Love, Paul McKenney,
      John Ashby for proofreading, correcting, flaming, commenting.
    </para>
        <para>
      Thanks to the cabal for having no influence on this document.
    </para>
      </chapter>
      <glossary id="glossary">
        <title>Glossary</title>
        <glossentry id="gloss-preemption">
          <glossterm>preemption</glossterm>
          <glossdef>
            <para>
        Prior to 2.5, or when <symbol>CONFIG_PREEMPT</symbol> is
        unset, processes in user context inside the kernel would not
        preempt each other (ie. you had that CPU until you gave it up,
        except for interrupts).  With the addition of
        <symbol>CONFIG_PREEMPT</symbol> in 2.5.4, this changed: when
        in user context, higher priority tasks can "cut in": spinlocks
        were changed to disable preemption, even on UP.
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-bh">
          <glossterm>bh</glossterm>
          <glossdef>
            <para>
        Bottom Half: for historical reasons, functions with
        '_bh' in them often now refer to any software interrupt, e.g.
        <function>spin_lock_bh()</function> blocks any software interrupt 
        on the current CPU.  Bottom halves are deprecated, and will 
        eventually be replaced by tasklets.  Only one bottom half will be 
        running at any time.
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-hwinterrupt">
          <glossterm>Hardware Interrupt / Hardware IRQ</glossterm>
          <glossdef>
            <para>
       Hardware interrupt request.  <function>in_irq()</function> returns 
       <returnvalue>true</returnvalue> in a hardware interrupt handler.
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-interruptcontext">
          <glossterm>Interrupt Context</glossterm>
          <glossdef>
            <para>
       Not user context: processing a hardware irq or software irq.
       Indicated by the <function>in_interrupt()</function> macro 
       returning <returnvalue>true</returnvalue>.
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-smp">
          <glossterm>
            <acronym>SMP</acronym>
          </glossterm>
          <glossdef>
            <para>
       Symmetric Multi-Processor: kernels compiled for multiple-CPU
       machines.  (CONFIG_SMP=y).
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-softirq">
          <glossterm>Software Interrupt / softirq</glossterm>
          <glossdef>
            <para>
       Software interrupt handler.  <function>in_irq()</function> returns
       <returnvalue>false</returnvalue>; <function>in_softirq()</function>
       returns <returnvalue>true</returnvalue>.  Tasklets and softirqs
	both fall into the category of 'software interrupts'.
     </para>
            <para>
       Strictly speaking a softirq is one of up to 32 enumerated software
       interrupts which can run on multiple CPUs at once.
       Sometimes used to refer to tasklets as
       well (ie. all software interrupts).
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-tasklet">
          <glossterm>tasklet</glossterm>
          <glossdef>
            <para>
       A dynamically-registrable software interrupt,
       which is guaranteed to only run on one CPU at a time.
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-timers">
          <glossterm>timer</glossterm>
          <glossdef>
            <para>
       A dynamically-registrable software interrupt, which is run at
       (or close to) a given time.  When running, it is just like a
       tasklet (in fact, they are called from the TIMER_SOFTIRQ).
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-up">
          <glossterm>
            <acronym>UP</acronym>
          </glossterm>
          <glossdef>
            <para>
       Uni-Processor: Non-SMP.  (CONFIG_SMP=n).
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-usercontext">
          <glossterm>User Context</glossterm>
          <glossdef>
            <para>
       The kernel executing on behalf of a particular process (ie. a
       system call or trap) or kernel thread.  You can tell which
       process with the <symbol>current</symbol> macro.)  Not to
       be confused with userspace.  Can be interrupted by software or
       hardware interrupts.
     </para>
          </glossdef>
        </glossentry>
        <glossentry id="gloss-userspace">
          <glossterm>Userspace</glossterm>
          <glossdef>
            <para>
       A process executing its own code outside the kernel.
     </para>
          </glossdef>
        </glossentry>
      </glossary>
    </book>
    <book id="kgdbOnLinux">
      <bookinfo>
        <title>Using kgdb, kdb and the kernel debugger internals</title>
        <authorgroup>
          <author>
            <firstname>Jason</firstname>
            <surname>Wessel</surname>
            <affiliation>
              <address>
                <email>jason.wessel@windriver.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2008,2010</year>
          <holder>Wind River Systems, Inc.</holder>
        </copyright>
        <copyright>
          <year>2004-2005</year>
          <holder>MontaVista Software, Inc.</holder>
        </copyright>
        <copyright>
          <year>2004</year>
          <holder>Amit S. Kale</holder>
        </copyright>
        <legalnotice>
          <para>
   This file is licensed under the terms of the GNU General Public License
   version 2. This program is licensed "as is" without any warranty of any
   kind, whether express or implied.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="Introduction">
        <title>Introduction</title>
        <para>
    The kernel has two different debugger front ends (kdb and kgdb)
    which interface to the debug core.  It is possible to use either
    of the debugger front ends and dynamically transition between them
    if you configure the kernel properly at compile and runtime.
    </para>
        <para>
    Kdb is simplistic shell-style interface which you can use on a
    system console with a keyboard or serial console.  You can use it
    to inspect memory, registers, process lists, dmesg, and even set
    breakpoints to stop in a certain location.  Kdb is not a source
    level debugger, although you can set breakpoints and execute some
    basic kernel run control.  Kdb is mainly aimed at doing some
    analysis to aid in development or diagnosing kernel problems.  You
    can access some symbols by name in kernel built-ins or in kernel
    modules if the code was built
    with <symbol>CONFIG_KALLSYMS</symbol>.
    </para>
        <para>
    Kgdb is intended to be used as a source level debugger for the
    Linux kernel. It is used along with gdb to debug a Linux kernel.
    The expectation is that gdb can be used to "break in" to the
    kernel to inspect memory, variables and look through call stack
    information similar to the way an application developer would use
    gdb to debug an application.  It is possible to place breakpoints
    in kernel code and perform some limited execution stepping.
    </para>
        <para>
    Two machines are required for using kgdb. One of these machines is
    a development machine and the other is the target machine.  The
    kernel to be debugged runs on the target machine. The development
    machine runs an instance of gdb against the vmlinux file which
    contains the symbols (not boot image such as bzImage, zImage,
    uImage...).  In gdb the developer specifies the connection
    parameters and connects to kgdb.  The type of connection a
    developer makes with gdb depends on the availability of kgdb I/O
    modules compiled as built-ins or loadable kernel modules in the test
    machine's kernel.
    </para>
      </chapter>
      <chapter id="CompilingAKernel">
        <title>Compiling a kernel</title>
        <para>
          <itemizedlist>
            <listitem>
              <para>In order to enable compilation of kdb, you must first enable kgdb.</para>
            </listitem>
            <listitem>
              <para>The kgdb test compile options are described in the kgdb test suite chapter.</para>
            </listitem>
          </itemizedlist>
        </para>
        <sect1 id="CompileKGDB">
          <title>Kernel config options for kgdb</title>
          <para>
    To enable <symbol>CONFIG_KGDB</symbol> you should look under
    "Kernel debugging" and select "KGDB: kernel debugger".
    </para>
          <para>
    While it is not a hard requirement that you have symbols in your
    vmlinux file, gdb tends not to be very useful without the symbolic
    data, so you will want to turn
    on <symbol>CONFIG_DEBUG_INFO</symbol> which is called "Compile the
    kernel with debug info" in the config menu.
    </para>
          <para>
    It is advised, but not required that you turn on the
    <symbol>CONFIG_FRAME_POINTER</symbol> kernel option which is called "Compile the
    kernel with frame pointers" in the config menu.  This option
    inserts code to into the compiled executable which saves the frame
    information in registers or on the stack at different points which
    allows a debugger such as gdb to more accurately construct
    stack back traces while debugging the kernel.
    </para>
          <para>
    If the architecture that you are using supports the kernel option
    CONFIG_DEBUG_RODATA, you should consider turning it off.  This
    option will prevent the use of software breakpoints because it
    marks certain regions of the kernel's memory space as read-only.
    If kgdb supports it for the architecture you are using, you can
    use hardware breakpoints if you desire to run with the
    CONFIG_DEBUG_RODATA option turned on, else you need to turn off
    this option.
    </para>
          <para>
    Next you should choose one of more I/O drivers to interconnect
    debugging host and debugged target.  Early boot debugging requires
    a KGDB I/O driver that supports early debugging and the driver
    must be built into the kernel directly. Kgdb I/O driver
    configuration takes place via kernel or module parameters which
    you can learn more about in the in the section that describes the
    parameter "kgdboc".
    </para>
          <para>Here is an example set of .config symbols to enable or
    disable for kgdb:
    <itemizedlist><listitem><para># CONFIG_DEBUG_RODATA is not set</para></listitem><listitem><para>CONFIG_FRAME_POINTER=y</para></listitem><listitem><para>CONFIG_KGDB=y</para></listitem><listitem><para>CONFIG_KGDB_SERIAL_CONSOLE=y</para></listitem></itemizedlist></para>
        </sect1>
        <sect1 id="CompileKDB">
          <title>Kernel config options for kdb</title>
          <para>Kdb is quite a bit more complex than the simple gdbstub
    sitting on top of the kernel's debug core.  Kdb must implement a
    shell, and also adds some helper functions in other parts of the
    kernel, responsible for printing out interesting data such as what
    you would see if you ran "lsmod", or "ps".  In order to build kdb
    into the kernel you follow the same steps as you would for kgdb.
    </para>
          <para>The main config option for kdb
    is <symbol>CONFIG_KGDB_KDB</symbol> which is called "KGDB_KDB:
    include kdb frontend for kgdb" in the config menu.  In theory you
    would have already also selected an I/O driver such as the
    CONFIG_KGDB_SERIAL_CONSOLE interface if you plan on using kdb on a
    serial port, when you were configuring kgdb.
    </para>
          <para>If you want to use a PS/2-style keyboard with kdb, you would
    select CONFIG_KDB_KEYBOARD which is called "KGDB_KDB: keyboard as
    input device" in the config menu.  The CONFIG_KDB_KEYBOARD option
    is not used for anything in the gdb interface to kgdb.  The
    CONFIG_KDB_KEYBOARD option only works with kdb.
    </para>
          <para>Here is an example set of .config symbols to enable/disable kdb:
    <itemizedlist><listitem><para># CONFIG_DEBUG_RODATA is not set</para></listitem><listitem><para>CONFIG_FRAME_POINTER=y</para></listitem><listitem><para>CONFIG_KGDB=y</para></listitem><listitem><para>CONFIG_KGDB_SERIAL_CONSOLE=y</para></listitem><listitem><para>CONFIG_KGDB_KDB=y</para></listitem><listitem><para>CONFIG_KDB_KEYBOARD=y</para></listitem></itemizedlist></para>
        </sect1>
      </chapter>
      <chapter id="kgdbKernelArgs">
        <title>Kernel Debugger Boot Arguments</title>
        <para>This section describes the various runtime kernel
  parameters that affect the configuration of the kernel debugger.
  The following chapter covers using kdb and kgdb as well as
  provides some examples of the configuration parameters.</para>
        <sect1 id="kgdboc">
          <title>Kernel parameter: kgdboc</title>
          <para>The kgdboc driver was originally an abbreviation meant to
   stand for "kgdb over console".  Today it is the primary mechanism
   to configure how to communicate from gdb to kgdb as well as the
   devices you want to use to interact with the kdb shell.
   </para>
          <para>For kgdb/gdb, kgdboc is designed to work with a single serial
   port. It is intended to cover the circumstance where you want to
   use a serial console as your primary console as well as using it to
   perform kernel debugging.  It is also possible to use kgdb on a
   serial port which is not designated as a system console.  Kgdboc
   may be configured as a kernel built-in or a kernel loadable module.
   You can only make use of <constant>kgdbwait</constant> and early
   debugging if you build kgdboc into the kernel as a built-in.
   <para>Optionally you can elect to activate kms (Kernel Mode
   Setting) integration.  When you use kms with kgdboc and you have a
   video driver that has atomic mode setting hooks, it is possible to
   enter the debugger on the graphics console.  When the kernel
   execution is resumed, the previous graphics mode will be restored.
   This integration can serve as a useful tool to aid in diagnosing
   crashes or doing analysis of memory with kdb while allowing the
   full graphics console applications to run.
   </para></para>
          <sect2 id="kgdbocArgs">
            <title>kgdboc arguments</title>
            <para>Usage: <constant>kgdboc=[kms][[,]kbd][[,]serial_device][,baud]</constant></para>
            <para>The order listed above must be observed if you use any of the
   optional configurations together.
   </para>
            <para>Abbreviations:
   <itemizedlist><listitem><para>kms = Kernel Mode Setting</para></listitem><listitem><para>kbd = Keyboard</para></listitem></itemizedlist></para>
            <para>You can configure kgdboc to use the keyboard, and or a serial
   device depending on if you are using kdb and or kgdb, in one of the
   following scenarios.  The order listed above must be observed if
   you use any of the optional configurations together.  Using kms +
   only gdb is generally not a useful combination.</para>
            <sect3 id="kgdbocArgs1">
              <title>Using loadable module or built-in</title>
              <para>
                <orderedlist>
                  <listitem>
                    <para>As a kernel built-in:</para>
                    <para>Use the kernel boot argument: <constant>kgdboc=&lt;tty-device&gt;,[baud]</constant></para>
                  </listitem>
                  <listitem>
                    <para>As a kernel loadable module:</para>
                    <para>Use the command: <constant>modprobe kgdboc kgdboc=&lt;tty-device&gt;,[baud]</constant></para>
                    <para>Here are two examples of how you might format the kgdboc
   string. The first is for an x86 target using the first serial port.
   The second example is for the ARM Versatile AB using the second
   serial port.
   <orderedlist><listitem><para><constant>kgdboc=ttyS0,115200</constant></para></listitem><listitem><para><constant>kgdboc=ttyAMA1,115200</constant></para></listitem></orderedlist></para>
                  </listitem>
                </orderedlist>
              </para>
            </sect3>
            <sect3 id="kgdbocArgs2">
              <title>Configure kgdboc at runtime with sysfs</title>
              <para>At run time you can enable or disable kgdboc by echoing a
   parameters into the sysfs.  Here are two examples:</para>
              <orderedlist>
                <listitem>
                  <para>Enable kgdboc on ttyS0</para>
                  <para>
                    <constant>echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</constant>
                  </para>
                </listitem>
                <listitem>
                  <para>Disable kgdboc</para>
                  <para>
                    <constant>echo "" &gt; /sys/module/kgdboc/parameters/kgdboc</constant>
                  </para>
                </listitem>
              </orderedlist>
              <para>NOTE: You do not need to specify the baud if you are
   configuring the console on tty which is already configured or
   open.</para>
            </sect3>
            <sect3 id="kgdbocArgs3">
              <title>More examples</title>
              <para>You can configure kgdboc to use the keyboard, and or a serial
   device depending on if you are using kdb and or kgdb, in one of the
   following scenarios.</para>
              <para>You can configure kgdboc to use the keyboard, and or a serial device
   depending on if you are using kdb and or kgdb, in one of the
   following scenarios.
   <orderedlist><listitem><para>kdb and kgdb over only a serial port</para><para><constant>kgdboc=&lt;serial_device&gt;[,baud]</constant></para><para>Example: <constant>kgdboc=ttyS0,115200</constant></para></listitem><listitem><para>kdb and kgdb with keyboard and a serial port</para><para><constant>kgdboc=kbd,&lt;serial_device&gt;[,baud]</constant></para><para>Example: <constant>kgdboc=kbd,ttyS0,115200</constant></para></listitem><listitem><para>kdb with a keyboard</para><para><constant>kgdboc=kbd</constant></para></listitem><listitem><para>kdb with kernel mode setting</para><para><constant>kgdboc=kms,kbd</constant></para></listitem><listitem><para>kdb with kernel mode setting and kgdb over a serial port</para><para><constant>kgdboc=kms,kbd,ttyS0,115200</constant></para></listitem></orderedlist></para>
            </sect3>
            <para>NOTE: Kgdboc does not support interrupting the target via the
   gdb remote protocol.  You must manually send a sysrq-g unless you
   have a proxy that splits console output to a terminal program.
   A console proxy has a separate TCP port for the debugger and a separate
   TCP port for the "human" console.  The proxy can take care of sending
   the sysrq-g for you.
   </para>
            <para>When using kgdboc with no debugger proxy, you can end up
    connecting the debugger at one of two entry points.  If an
    exception occurs after you have loaded kgdboc, a message should
    print on the console stating it is waiting for the debugger.  In
    this case you disconnect your terminal program and then connect the
    debugger in its place.  If you want to interrupt the target system
    and forcibly enter a debug session you have to issue a Sysrq
    sequence and then type the letter <constant>g</constant>.  Then
    you disconnect the terminal session and connect gdb.  Your options
    if you don't like this are to hack gdb to send the sysrq-g for you
    as well as on the initial connect, or to use a debugger proxy that
    allows an unmodified gdb to do the debugging.
   </para>
          </sect2>
        </sect1>
        <sect1 id="kgdbwait">
          <title>Kernel parameter: kgdbwait</title>
          <para>
   The Kernel command line option <constant>kgdbwait</constant> makes
   kgdb wait for a debugger connection during booting of a kernel.  You
   can only use this option you compiled a kgdb I/O driver into the
   kernel and you specified the I/O driver configuration as a kernel
   command line option.  The kgdbwait parameter should always follow the
   configuration parameter for the kgdb I/O driver in the kernel
   command line else the I/O driver will not be configured prior to
   asking the kernel to use it to wait.
   </para>
          <para>
   The kernel will stop and wait as early as the I/O driver and
   architecture allows when you use this option.  If you build the
   kgdb I/O driver as a loadable kernel module kgdbwait will not do
   anything.
   </para>
        </sect1>
        <sect1 id="kgdbcon">
          <title>Kernel parameter: kgdbcon</title>
          <para> The kgdbcon feature allows you to see printk() messages
   inside gdb while gdb is connected to the kernel.  Kdb does not make
    use of the kgdbcon feature.
   </para>
          <para>Kgdb supports using the gdb serial protocol to send console
   messages to the debugger when the debugger is connected and running.
   There are two ways to activate this feature.
   <orderedlist><listitem><para>Activate with the kernel command line option:</para><para><constant>kgdbcon</constant></para></listitem><listitem><para>Use sysfs before configuring an I/O driver</para><para><constant>echo 1 &gt; /sys/module/kgdb/parameters/kgdb_use_con</constant></para><para>
   NOTE: If you do this after you configure the kgdb I/O driver, the
   setting will not take effect until the next point the I/O is
   reconfigured.
   </para></listitem></orderedlist><para>IMPORTANT NOTE: You cannot use kgdboc + kgdbcon on a tty that is an
   active system console.  An example incorrect usage is <constant>console=ttyS0,115200 kgdboc=ttyS0 kgdbcon</constant></para><para>It is possible to use this option with kgdboc on a tty that is not a system console.
   </para></para>
        </sect1>
        <sect1 id="kgdbreboot">
          <title>Run time parameter: kgdbreboot</title>
          <para> The kgdbreboot feature allows you to change how the debugger
   deals with the reboot notification.  You have 3 choices for the
   behavior.  The default behavior is always set to 0.</para>
          <orderedlist>
            <listitem>
              <para>echo -1 &gt; /sys/module/debug_core/parameters/kgdbreboot</para>
              <para>Ignore the reboot notification entirely.</para>
            </listitem>
            <listitem>
              <para>echo 0 &gt; /sys/module/debug_core/parameters/kgdbreboot</para>
              <para>Send the detach message to any attached debugger client.</para>
            </listitem>
            <listitem>
              <para>echo 1 &gt; /sys/module/debug_core/parameters/kgdbreboot</para>
              <para>Enter the debugger on reboot notify.</para>
            </listitem>
          </orderedlist>
        </sect1>
      </chapter>
      <chapter id="usingKDB">
        <title>Using kdb</title>
        <para>
        </para>
        <sect1 id="quickKDBserial">
          <title>Quick start for kdb on a serial port</title>
          <para>This is a quick example of how to use kdb.</para>
          <para>
            <orderedlist>
              <listitem>
                <para>Boot kernel with arguments:
  <itemizedlist><listitem><para><constant>console=ttyS0,115200 kgdboc=ttyS0,115200</constant></para></listitem></itemizedlist></para>
                <para>OR</para>
                <para>Configure kgdboc after the kernel booted; assuming you are using a serial port console:
  <itemizedlist><listitem><para><constant>echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</constant></para></listitem></itemizedlist></para>
              </listitem>
              <listitem>
                <para>Enter the kernel debugger manually or by waiting for an oops or fault.  There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.</para>
                <itemizedlist>
                  <listitem>
                    <para>When logged in as root or with a super user session you can run:</para>
                    <para>
                      <constant>echo g &gt; /proc/sysrq-trigger</constant>
                    </para>
                  </listitem>
                  <listitem>
                    <para>Example using minicom 2.2</para>
                    <para>Press: <constant>Control-a</constant></para>
                    <para>Press: <constant>f</constant></para>
                    <para>Press: <constant>g</constant></para>
                  </listitem>
                  <listitem>
                    <para>When you have telneted to a terminal server that supports sending a remote break</para>
                    <para>Press: <constant>Control-]</constant></para>
                    <para>Type in:<constant>send break</constant></para>
                    <para>Press: <constant>Enter</constant></para>
                    <para>Press: <constant>g</constant></para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>From the kdb prompt you can run the "help" command to see a complete list of the commands that are available.</para>
                <para>Some useful commands in kdb include:
  <itemizedlist><listitem><para>lsmod  -- Shows where kernel modules are loaded</para></listitem><listitem><para>ps -- Displays only the active processes</para></listitem><listitem><para>ps A -- Shows all the processes</para></listitem><listitem><para>summary -- Shows kernel version info and memory usage</para></listitem><listitem><para>bt -- Get a backtrace of the current process using dump_stack()</para></listitem><listitem><para>dmesg -- View the kernel syslog buffer</para></listitem><listitem><para>go -- Continue the system</para></listitem></itemizedlist></para>
              </listitem>
              <listitem>
                <para>When you are done using kdb you need to consider rebooting the
  system or using the "go" command to resuming normal kernel
  execution.  If you have paused the kernel for a lengthy period of
  time, applications that rely on timely networking or anything to do
  with real wall clock time could be adversely affected, so you
  should take this into consideration when using the kernel
  debugger.</para>
              </listitem>
            </orderedlist>
          </para>
        </sect1>
        <sect1 id="quickKDBkeyboard">
          <title>Quick start for kdb using a keyboard connected console</title>
          <para>This is a quick example of how to use kdb with a keyboard.</para>
          <para>
            <orderedlist>
              <listitem>
                <para>Boot kernel with arguments:
  <itemizedlist><listitem><para><constant>kgdboc=kbd</constant></para></listitem></itemizedlist></para>
                <para>OR</para>
                <para>Configure kgdboc after the kernel booted:
  <itemizedlist><listitem><para><constant>echo kbd &gt; /sys/module/kgdboc/parameters/kgdboc</constant></para></listitem></itemizedlist></para>
              </listitem>
              <listitem>
                <para>Enter the kernel debugger manually or by waiting for an oops or fault.  There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g, which means you must have enabled CONFIG_MAGIC_SYSRQ=y in your kernel config.</para>
                <itemizedlist>
                  <listitem>
                    <para>When logged in as root or with a super user session you can run:</para>
                    <para>
                      <constant>echo g &gt; /proc/sysrq-trigger</constant>
                    </para>
                  </listitem>
                  <listitem>
                    <para>Example using a laptop keyboard</para>
                    <para>Press and hold down: <constant>Alt</constant></para>
                    <para>Press and hold down: <constant>Fn</constant></para>
                    <para>Press and release the key with the label: <constant>SysRq</constant></para>
                    <para>Release: <constant>Fn</constant></para>
                    <para>Press and release: <constant>g</constant></para>
                    <para>Release: <constant>Alt</constant></para>
                  </listitem>
                  <listitem>
                    <para>Example using a PS/2 101-key keyboard</para>
                    <para>Press and hold down: <constant>Alt</constant></para>
                    <para>Press and release the key with the label: <constant>SysRq</constant></para>
                    <para>Press and release: <constant>g</constant></para>
                    <para>Release: <constant>Alt</constant></para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>Now type in a kdb command such as "help", "dmesg", "bt" or "go" to continue kernel execution.</para>
              </listitem>
            </orderedlist>
          </para>
        </sect1>
      </chapter>
      <chapter id="EnableKGDB">
        <title>Using kgdb / gdb</title>
        <para>In order to use kgdb you must activate it by passing
   configuration information to one of the kgdb I/O drivers.  If you
   do not pass any configuration information kgdb will not do anything
   at all.  Kgdb will only actively hook up to the kernel trap hooks
   if a kgdb I/O driver is loaded and configured.  If you unconfigure
   a kgdb I/O driver, kgdb will unregister all the kernel hook points.
   </para>
        <para> All kgdb I/O drivers can be reconfigured at run time, if
   <symbol>CONFIG_SYSFS</symbol> and <symbol>CONFIG_MODULES</symbol>
   are enabled, by echo'ing a new config string to
   <constant>/sys/module/&lt;driver&gt;/parameter/&lt;option&gt;</constant>.
   The driver can be unconfigured by passing an empty string.  You cannot
   change the configuration while the debugger is attached.  Make sure
   to detach the debugger with the <constant>detach</constant> command
   prior to trying to unconfigure a kgdb I/O driver.
   </para>
        <sect1 id="ConnectingGDB">
          <title>Connecting with gdb to a serial port</title>
          <orderedlist>
            <listitem>
              <para>Configure kgdboc</para>
              <para>Boot kernel with arguments:
   <itemizedlist><listitem><para><constant>kgdboc=ttyS0,115200</constant></para></listitem></itemizedlist></para>
              <para>OR</para>
              <para>Configure kgdboc after the kernel booted:
   <itemizedlist><listitem><para><constant>echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</constant></para></listitem></itemizedlist></para>
            </listitem>
            <listitem>
              <para>Stop kernel execution (break into the debugger)</para>
              <para>In order to connect to gdb via kgdboc, the kernel must
  first be stopped.  There are several ways to stop the kernel which
  include using kgdbwait as a boot argument, via a sysrq-g, or running
  the kernel until it takes an exception where it waits for the
  debugger to attach.
  <itemizedlist><listitem><para>When logged in as root or with a super user session you can run:</para><para><constant>echo g &gt; /proc/sysrq-trigger</constant></para></listitem><listitem><para>Example using minicom 2.2</para><para>Press: <constant>Control-a</constant></para><para>Press: <constant>f</constant></para><para>Press: <constant>g</constant></para></listitem><listitem><para>When you have telneted to a terminal server that supports sending a remote break</para><para>Press: <constant>Control-]</constant></para><para>Type in:<constant>send break</constant></para><para>Press: <constant>Enter</constant></para><para>Press: <constant>g</constant></para></listitem></itemizedlist></para>
            </listitem>
            <listitem>
              <para>Connect from from gdb</para>
              <para>
    Example (using a directly connected port):
    </para>
              <programlisting>
    % gdb ./vmlinux
    (gdb) set remotebaud 115200
    (gdb) target remote /dev/ttyS0
    </programlisting>
              <para>
    Example (kgdb to a terminal server on TCP port 2012):
    </para>
              <programlisting>
    % gdb ./vmlinux
    (gdb) target remote 192.168.2.2:2012
    </programlisting>
              <para>
    Once connected, you can debug a kernel the way you would debug an
    application program.
    </para>
              <para>
    If you are having problems connecting or something is going
    seriously wrong while debugging, it will most often be the case
    that you want to enable gdb to be verbose about its target
    communications.  You do this prior to issuing the <constant>target
    remote</constant> command by typing in: <constant>set debug remote 1</constant></para>
            </listitem>
          </orderedlist>
          <para>Remember if you continue in gdb, and need to "break in" again,
  you need to issue an other sysrq-g.  It is easy to create a simple
  entry point by putting a breakpoint at <constant>sys_sync</constant>
  and then you can run "sync" from a shell or script to break into the
  debugger.</para>
        </sect1>
      </chapter>
      <chapter id="switchKdbKgdb">
        <title>kgdb and kdb interoperability</title>
        <para>It is possible to transition between kdb and kgdb dynamically.
  The debug core will remember which you used the last time and
  automatically start in the same mode.</para>
        <sect1>
          <title>Switching between kdb and kgdb</title>
          <sect2>
            <title>Switching from kgdb to kdb</title>
            <para>
  There are two ways to switch from kgdb to kdb: you can use gdb to
  issue a maintenance packet, or you can blindly type the command $3#33.
  Whenever kernel debugger stops in kgdb mode it will print the
  message <constant>KGDB or $3#33 for KDB</constant>.  It is important
  to note that you have to type the sequence correctly in one pass.
  You cannot type a backspace or delete because kgdb will interpret
  that as part of the debug stream.
  <orderedlist><listitem><para>Change from kgdb to kdb by blindly typing:</para><para><constant>$3#33</constant></para></listitem><listitem><para>Change from kgdb to kdb with gdb</para><para><constant>maintenance packet 3</constant></para><para>NOTE: Now you must kill gdb. Typically you press control-z and
  issue the command: kill -9 %</para></listitem></orderedlist></para>
          </sect2>
          <sect2>
            <title>Change from kdb to kgdb</title>
            <para>There are two ways you can change from kdb to kgdb.  You can
  manually enter kgdb mode by issuing the kgdb command from the kdb
  shell prompt, or you can connect gdb while the kdb shell prompt is
  active.  The kdb shell looks for the typical first commands that gdb
  would issue with the gdb remote protocol and if it sees one of those
  commands it automatically changes into kgdb mode.</para>
            <orderedlist>
              <listitem>
                <para>From kdb issue the command:</para>
                <para>
                  <constant>kgdb</constant>
                </para>
                <para>Now disconnect your terminal program and connect gdb in its place</para>
              </listitem>
              <listitem>
                <para>At the kdb prompt, disconnect the terminal program and connect gdb in its place.</para>
              </listitem>
            </orderedlist>
          </sect2>
        </sect1>
        <sect1>
          <title>Running kdb commands from gdb</title>
          <para>It is possible to run a limited set of kdb commands from gdb,
  using the gdb monitor command.  You don't want to execute any of the
  run control or breakpoint operations, because it can disrupt the
  state of the kernel debugger.  You should be using gdb for
  breakpoints and run control operations if you have gdb connected.
  The more useful commands to run are things like lsmod, dmesg, ps or
  possibly some of the memory information commands.  To see all the kdb
  commands you can run <constant>monitor help</constant>.</para>
          <para>Example:
  <informalexample><programlisting>
(gdb) monitor ps
1 idle process (state I) and
27 sleeping system daemon (state M) processes suppressed,
use 'ps A' to see all.
Task Addr       Pid   Parent [*] cpu State Thread     Command

0xc78291d0        1        0  0    0   S  0xc7829404  init
0xc7954150      942        1  0    0   S  0xc7954384  dropbear
0xc78789c0      944        1  0    0   S  0xc7878bf4  sh
(gdb)
  </programlisting></informalexample></para>
        </sect1>
      </chapter>
      <chapter id="KGDBTestSuite">
        <title>kgdb Test Suite</title>
        <para>
    When kgdb is enabled in the kernel config you can also elect to
    enable the config parameter KGDB_TESTS.  Turning this on will
    enable a special kgdb I/O module which is designed to test the
    kgdb internal functions.
    </para>
        <para>
    The kgdb tests are mainly intended for developers to test the kgdb
    internals as well as a tool for developing a new kgdb architecture
    specific implementation.  These tests are not really for end users
    of the Linux kernel.  The primary source of documentation would be
    to look in the drivers/misc/kgdbts.c file.
    </para>
        <para>
    The kgdb test suite can also be configured at compile time to run
    the core set of tests by setting the kernel config parameter
    KGDB_TESTS_ON_BOOT.  This particular option is aimed at automated
    regression testing and does not require modifying the kernel boot
    config arguments.  If this is turned on, the kgdb test suite can
    be disabled by specifying "kgdbts=" as a kernel boot argument.
    </para>
      </chapter>
      <chapter id="CommonBackEndReq">
        <title>Kernel Debugger Internals</title>
        <sect1 id="kgdbArchitecture">
          <title>Architecture Specifics</title>
          <para>
      The kernel debugger is organized into a number of components:
      <orderedlist><listitem><para>The debug core</para><para>
      The debug core is found in kernel/debugger/debug_core.c.  It contains:
      <itemizedlist><listitem><para>A generic OS exception handler which includes
      sync'ing the processors into a stopped state on an multi-CPU
      system.</para></listitem><listitem><para>The API to talk to the kgdb I/O drivers</para></listitem><listitem><para>The API to make calls to the arch-specific kgdb implementation</para></listitem><listitem><para>The logic to perform safe memory reads and writes to memory while using the debugger</para></listitem><listitem><para>A full implementation for software breakpoints unless overridden by the arch</para></listitem><listitem><para>The API to invoke either the kdb or kgdb frontend to the debug core.</para></listitem><listitem><para>The structures and callback API for atomic kernel mode setting.</para><para>NOTE: kgdboc is where the kms callbacks are invoked.</para></listitem></itemizedlist></para></listitem><listitem><para>kgdb arch-specific implementation</para><para>
      This implementation is generally found in arch/*/kernel/kgdb.c.
      As an example, arch/x86/kernel/kgdb.c contains the specifics to
      implement HW breakpoint as well as the initialization to
      dynamically register and unregister for the trap handlers on
      this architecture.  The arch-specific portion implements:
      <itemizedlist><listitem><para>contains an arch-specific trap catcher which
      invokes kgdb_handle_exception() to start kgdb about doing its
      work</para></listitem><listitem><para>translation to and from gdb specific packet format to pt_regs</para></listitem><listitem><para>Registration and unregistration of architecture specific trap hooks</para></listitem><listitem><para>Any special exception handling and cleanup</para></listitem><listitem><para>NMI exception handling and cleanup</para></listitem><listitem><para>(optional)HW breakpoints</para></listitem></itemizedlist></para></listitem><listitem><para>gdbstub frontend (aka kgdb)</para><para>The gdbstub is located in kernel/debug/gdbstub.c. It contains:</para><itemizedlist><listitem><para>All the logic to implement the gdb serial protocol</para></listitem></itemizedlist></listitem><listitem><para>kdb frontend</para><para>The kdb debugger shell is broken down into a number of
      components.  The kdb core is located in kernel/debug/kdb.  There
      are a number of helper functions in some of the other kernel
      components to make it possible for kdb to examine and report
      information about the kernel without taking locks that could
      cause a kernel deadlock.  The kdb core contains implements the following functionality.</para><itemizedlist><listitem><para>A simple shell</para></listitem><listitem><para>The kdb core command set</para></listitem><listitem><para>A registration API to register additional kdb shell commands.</para><itemizedlist><listitem><para>A good example of a self-contained kdb module
        is the "ftdump" command for dumping the ftrace buffer.  See:
        kernel/trace/trace_kdb.c</para></listitem><listitem><para>For an example of how to dynamically register
        a new kdb command you can build the kdb_hello.ko kernel module
        from samples/kdb/kdb_hello.c.  To build this example you can
        set CONFIG_SAMPLES=y and CONFIG_SAMPLE_KDB=m in your kernel
        config.  Later run "modprobe kdb_hello" and the next time you
        enter the kdb shell, you can run the "hello"
        command.</para></listitem></itemizedlist></listitem><listitem><para>The implementation for kdb_printf() which
        emits messages directly to I/O drivers, bypassing the kernel
        log.</para></listitem><listitem><para>SW / HW breakpoint management for the kdb shell</para></listitem></itemizedlist></listitem><listitem><para>kgdb I/O driver</para><para>
      Each kgdb I/O driver has to provide an implementation for the following:
      <itemizedlist><listitem><para>configuration via built-in or module</para></listitem><listitem><para>dynamic configuration and kgdb hook registration calls</para></listitem><listitem><para>read and write character interface</para></listitem><listitem><para>A cleanup handler for unconfiguring from the kgdb core</para></listitem><listitem><para>(optional) Early debug methodology</para></listitem></itemizedlist>
      Any given kgdb I/O driver has to operate very closely with the
      hardware and must do it in such a way that does not enable
      interrupts or change other parts of the system context without
      completely restoring them. The kgdb core will repeatedly "poll"
      a kgdb I/O driver for characters when it needs input.  The I/O
      driver is expected to return immediately if there is no data
      available.  Doing so allows for the future possibility to touch
      watch dog hardware in such a way as to have a target system not
      reset when these are enabled.
      </para></listitem></orderedlist></para>
          <para>
      If you are intent on adding kgdb architecture specific support
      for a new architecture, the architecture should define
      <constant>HAVE_ARCH_KGDB</constant> in the architecture specific
      Kconfig file.  This will enable kgdb for the architecture, and
      at that point you must create an architecture specific kgdb
      implementation.
      </para>
          <para>
      There are a few flags which must be set on every architecture in
      their &lt;asm/kgdb.h&gt; file.  These are:
      <itemizedlist><listitem><para>
	  NUMREGBYTES: The size in bytes of all of the registers, so
	  that we can ensure they will all fit into a packet.
	  </para><para>
	  BUFMAX: The size in bytes of the buffer GDB will read into.
	  This must be larger than NUMREGBYTES.
	  </para><para>
	  CACHE_FLUSH_IS_SAFE: Set to 1 if it is always safe to call
	  flush_cache_range or flush_icache_range.  On some architectures,
	  these functions may not be safe to call on SMP since we keep other
	  CPUs in a holding pattern.
	  </para></listitem></itemizedlist></para>
          <para>
      There are also the following functions for the common backend,
      found in kernel/kgdb.c, that must be supplied by the
      architecture-specific backend unless marked as (optional), in
      which case a default function maybe used if the architecture
      does not need to provide a specific implementation.
      </para>
!Iinclude/linux/kgdb.h
  </sect1>
        <sect1 id="kgdbocDesign">
          <title>kgdboc internals</title>
          <sect2>
            <title>kgdboc and uarts</title>
            <para>
  The kgdboc driver is actually a very thin driver that relies on the
  underlying low level to the hardware driver having "polling hooks"
  which the to which the tty driver is attached.  In the initial
  implementation of kgdboc it the serial_core was changed to expose a
  low level UART hook for doing polled mode reading and writing of a
  single character while in an atomic context.  When kgdb makes an I/O
  request to the debugger, kgdboc invokes a callback in the serial
  core which in turn uses the callback in the UART driver.</para>
            <para>
  When using kgdboc with a UART, the UART driver must implement two callbacks in the <constant>struct uart_ops</constant>. Example from drivers/8250.c:<programlisting>
#ifdef CONFIG_CONSOLE_POLL
	.poll_get_char = serial8250_get_poll_char,
	.poll_put_char = serial8250_put_poll_char,
#endif
  </programlisting>
  Any implementation specifics around creating a polling driver use the
  <constant>#ifdef CONFIG_CONSOLE_POLL</constant>, as shown above.
  Keep in mind that polling hooks have to be implemented in such a way
  that they can be called from an atomic context and have to restore
  the state of the UART chip on return such that the system can return
  to normal when the debugger detaches.  You need to be very careful
  with any kind of lock you consider, because failing here is most likely
  going to mean pressing the reset button.
  </para>
          </sect2>
          <sect2 id="kgdbocKbd">
            <title>kgdboc and keyboards</title>
            <para>The kgdboc driver contains logic to configure communications
  with an attached keyboard.  The keyboard infrastructure is only
  compiled into the kernel when CONFIG_KDB_KEYBOARD=y is set in the
  kernel configuration.</para>
            <para>The core polled keyboard driver driver for PS/2 type keyboards
  is in drivers/char/kdb_keyboard.c.  This driver is hooked into the
  debug core when kgdboc populates the callback in the array
  called <constant>kdb_poll_funcs[]</constant>.  The
  kdb_get_kbd_char() is the top-level function which polls hardware
  for single character input.
  </para>
          </sect2>
          <sect2 id="kgdbocKms">
            <title>kgdboc and kms</title>
            <para>The kgdboc driver contains logic to request the graphics
  display to switch to a text context when you are using
  "kgdboc=kms,kbd", provided that you have a video driver which has a
  frame buffer console and atomic kernel mode setting support.</para>
            <para>
  Every time the kernel
  debugger is entered it calls kgdboc_pre_exp_handler() which in turn
  calls con_debug_enter() in the virtual console layer.  On resuming kernel
  execution, the kernel debugger calls kgdboc_post_exp_handler() which
  in turn calls con_debug_leave().</para>
            <para>Any video driver that wants to be compatible with the kernel
  debugger and the atomic kms callbacks must implement the
  mode_set_base_atomic, fb_debug_enter and fb_debug_leave operations.
  For the fb_debug_enter and fb_debug_leave the option exists to use
  the generic drm fb helper functions or implement something custom for
  the hardware.  The following example shows the initialization of the
  .mode_set_base_atomic operation in
  drivers/gpu/drm/i915/intel_display.c:
  <informalexample><programlisting>
static const struct drm_crtc_helper_funcs intel_helper_funcs = {
[...]
        .mode_set_base_atomic = intel_pipe_set_base_atomic,
[...]
};
  </programlisting></informalexample></para>
            <para>Here is an example of how the i915 driver initializes the fb_debug_enter and fb_debug_leave functions to use the generic drm helpers in
  drivers/gpu/drm/i915/intel_fb.c:
  <informalexample><programlisting>
static struct fb_ops intelfb_ops = {
[...]
       .fb_debug_enter = drm_fb_helper_debug_enter,
       .fb_debug_leave = drm_fb_helper_debug_leave,
[...]
};
  </programlisting></informalexample></para>
          </sect2>
        </sect1>
      </chapter>
      <chapter id="credits">
        <title>Credits</title>
        <para>
		The following people have contributed to this document:
		<orderedlist><listitem><para>Amit Kale<email>amitkale@linsyssoft.com</email></para></listitem><listitem><para>Tom Rini<email>trini@kernel.crashing.org</email></para></listitem></orderedlist>
                In March 2008 this document was completely rewritten by:
		<itemizedlist><listitem><para>Jason Wessel<email>jason.wessel@windriver.com</email></para></listitem></itemizedlist>
                In Jan 2010 this document was updated to include kdb.
		<itemizedlist><listitem><para>Jason Wessel<email>jason.wessel@windriver.com</email></para></listitem></itemizedlist></para>
      </chapter>
    </book>
    <book id="libataDevGuide">
      <bookinfo>
        <title>libATA Developer's Guide</title>
        <authorgroup>
          <author>
            <firstname>Jeff</firstname>
            <surname>Garzik</surname>
          </author>
        </authorgroup>
        <copyright>
          <year>2003-2006</year>
          <holder>Jeff Garzik</holder>
        </copyright>
        <legalnotice>
          <para>
   The contents of this file are subject to the Open
   Software License version 1.1 that can be found at
   <ulink url="http://fedoraproject.org/wiki/Licensing:OSL1.1">http://fedoraproject.org/wiki/Licensing:OSL1.1</ulink>
   and is included herein by reference.
   </para>
          <para>
   Alternatively, the contents of this file may be used under the terms
   of the GNU General Public License version 2 (the "GPL") as distributed
   in the kernel source COPYING file, in which case the provisions of
   the GPL are applicable instead of the above.  If you wish to allow
   the use of your version of this file only under the terms of the
   GPL and not to allow others to use your version of this file under
   the OSL, indicate your decision by deleting the provisions above and
   replace them with the notice and other provisions required by the GPL.
   If you do not delete the provisions above, a recipient may use your
   version of this file under either the OSL or the GPL.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="libataIntroduction">
        <title>Introduction</title>
        <para>
  libATA is a library used inside the Linux kernel to support ATA host
  controllers and devices.  libATA provides an ATA driver API, class
  transports for ATA and ATAPI devices, and SCSI&lt;-&gt;ATA translation
  for ATA devices according to the T10 SAT specification.
  </para>
        <para>
  This Guide documents the libATA driver API, library functions, library
  internals, and a couple sample ATA low-level drivers.
  </para>
      </chapter>
      <chapter id="libataDriverApi">
        <title>libata Driver API</title>
        <para>
     struct ata_port_operations is defined for every low-level libata
     hardware driver, and it controls how the low-level driver
     interfaces with the ATA and SCSI layers.
     </para>
        <para>
     FIS-based drivers will hook into the system with -&gt;qc_prep() and
     -&gt;qc_issue() high-level hooks.  Hardware which behaves in a manner
     similar to PCI IDE hardware may utilize several generic helpers,
     defining at a bare minimum the bus I/O addresses of the ATA shadow
     register blocks.
     </para>
        <sect1>
          <title>struct ata_port_operations</title>
          <sect2>
            <title>Disable ATA port</title>
            <programlisting>
void (*port_disable) (struct ata_port *);
	</programlisting>
            <para>
	Called from ata_bus_probe() error path, as well as when
	unregistering from the SCSI module (rmmod, hot unplug).
	This function should do whatever needs to be done to take the
	port out of use.  In most cases, ata_port_disable() can be used
	as this hook.
	</para>
            <para>
	Called from ata_bus_probe() on a failed probe.
	Called from ata_scsi_release().
	</para>
          </sect2>
          <sect2>
            <title>Post-IDENTIFY device configuration</title>
            <programlisting>
void (*dev_config) (struct ata_port *, struct ata_device *);
	</programlisting>
            <para>
	Called after IDENTIFY [PACKET] DEVICE is issued to each device
	found.  Typically used to apply device-specific fixups prior to
	issue of SET FEATURES - XFER MODE, and prior to operation.
	</para>
            <para>
	This entry may be specified as NULL in ata_port_operations.
	</para>
          </sect2>
          <sect2>
            <title>Set PIO/DMA mode</title>
            <programlisting>
void (*set_piomode) (struct ata_port *, struct ata_device *);
void (*set_dmamode) (struct ata_port *, struct ata_device *);
void (*post_set_mode) (struct ata_port *);
unsigned int (*mode_filter) (struct ata_port *, struct ata_device *, unsigned int);
	</programlisting>
            <para>
	Hooks called prior to the issue of SET FEATURES - XFER MODE
	command.  The optional -&gt;mode_filter() hook is called when libata
	has built a mask of the possible modes. This is passed to the 
	-&gt;mode_filter() function which should return a mask of valid modes
	after filtering those unsuitable due to hardware limits. It is not
	valid to use this interface to add modes.
	</para>
            <para>
	dev-&gt;pio_mode and dev-&gt;dma_mode are guaranteed to be valid when
	-&gt;set_piomode() and when -&gt;set_dmamode() is called. The timings for
	any other drive sharing the cable will also be valid at this point.
	That is the library records the decisions for the modes of each
	drive on a channel before it attempts to set any of them.
	</para>
            <para>
	-&gt;post_set_mode() is
	called unconditionally, after the SET FEATURES - XFER MODE
	command completes successfully.
	</para>
            <para>
	-&gt;set_piomode() is always called (if present), but
	-&gt;set_dma_mode() is only called if DMA is possible.
	</para>
          </sect2>
          <sect2>
            <title>Taskfile read/write</title>
            <programlisting>
void (*sff_tf_load) (struct ata_port *ap, struct ata_taskfile *tf);
void (*sff_tf_read) (struct ata_port *ap, struct ata_taskfile *tf);
	</programlisting>
            <para>
	-&gt;tf_load() is called to load the given taskfile into hardware
	registers / DMA buffers.  -&gt;tf_read() is called to read the
	hardware registers / DMA buffers, to obtain the current set of
	taskfile register values.
	Most drivers for taskfile-based hardware (PIO or MMIO) use
	ata_sff_tf_load() and ata_sff_tf_read() for these hooks.
	</para>
          </sect2>
          <sect2>
            <title>PIO data read/write</title>
            <programlisting>
void (*sff_data_xfer) (struct ata_device *, unsigned char *, unsigned int, int);
	</programlisting>
            <para>
All bmdma-style drivers must implement this hook.  This is the low-level
operation that actually copies the data bytes during a PIO data
transfer.
Typically the driver will choose one of ata_sff_data_xfer_noirq(),
ata_sff_data_xfer(), or ata_sff_data_xfer32().
	</para>
          </sect2>
          <sect2>
            <title>ATA command execute</title>
            <programlisting>
void (*sff_exec_command)(struct ata_port *ap, struct ata_taskfile *tf);
	</programlisting>
            <para>
	causes an ATA command, previously loaded with
	-&gt;tf_load(), to be initiated in hardware.
	Most drivers for taskfile-based hardware use ata_sff_exec_command()
	for this hook.
	</para>
          </sect2>
          <sect2>
            <title>Per-cmd ATAPI DMA capabilities filter</title>
            <programlisting>
int (*check_atapi_dma) (struct ata_queued_cmd *qc);
	</programlisting>
            <para>
Allow low-level driver to filter ATA PACKET commands, returning a status
indicating whether or not it is OK to use DMA for the supplied PACKET
command.
	</para>
            <para>
	This hook may be specified as NULL, in which case libata will
	assume that atapi dma can be supported.
	</para>
          </sect2>
          <sect2>
            <title>Read specific ATA shadow registers</title>
            <programlisting>
u8   (*sff_check_status)(struct ata_port *ap);
u8   (*sff_check_altstatus)(struct ata_port *ap);
	</programlisting>
            <para>
	Reads the Status/AltStatus ATA shadow register from
	hardware.  On some hardware, reading the Status register has
	the side effect of clearing the interrupt condition.
	Most drivers for taskfile-based hardware use
	ata_sff_check_status() for this hook.
	</para>
          </sect2>
          <sect2>
            <title>Write specific ATA shadow register</title>
            <programlisting>
void (*sff_set_devctl)(struct ata_port *ap, u8 ctl);
	</programlisting>
            <para>
	Write the device control ATA shadow register to the hardware.
	Most drivers don't need to define this.
	</para>
          </sect2>
          <sect2>
            <title>Select ATA device on bus</title>
            <programlisting>
void (*sff_dev_select)(struct ata_port *ap, unsigned int device);
	</programlisting>
            <para>
	Issues the low-level hardware command(s) that causes one of N
	hardware devices to be considered 'selected' (active and
	available for use) on the ATA bus.  This generally has no
	meaning on FIS-based devices.
	</para>
            <para>
	Most drivers for taskfile-based hardware use
	ata_sff_dev_select() for this hook.
	</para>
          </sect2>
          <sect2>
            <title>Private tuning method</title>
            <programlisting>
void (*set_mode) (struct ata_port *ap);
	</programlisting>
            <para>
	By default libata performs drive and controller tuning in
	accordance with the ATA timing rules and also applies blacklists
	and cable limits. Some controllers need special handling and have
	custom tuning rules, typically raid controllers that use ATA
	commands but do not actually do drive timing.
	</para>
            <warning>
              <para>
	This hook should not be used to replace the standard controller
	tuning logic when a controller has quirks. Replacing the default
	tuning logic in that case would bypass handling for drive and
	bridge quirks that may be important to data reliability. If a
	controller needs to filter the mode selection it should use the
	mode_filter hook instead.
	</para>
            </warning>
          </sect2>
          <sect2>
            <title>Control PCI IDE BMDMA engine</title>
            <programlisting>
void (*bmdma_setup) (struct ata_queued_cmd *qc);
void (*bmdma_start) (struct ata_queued_cmd *qc);
void (*bmdma_stop) (struct ata_port *ap);
u8   (*bmdma_status) (struct ata_port *ap);
	</programlisting>
            <para>
When setting up an IDE BMDMA transaction, these hooks arm
(-&gt;bmdma_setup), fire (-&gt;bmdma_start), and halt (-&gt;bmdma_stop)
the hardware's DMA engine.  -&gt;bmdma_status is used to read the standard
PCI IDE DMA Status register.
	</para>
            <para>
These hooks are typically either no-ops, or simply not implemented, in
FIS-based drivers.
	</para>
            <para>
Most legacy IDE drivers use ata_bmdma_setup() for the bmdma_setup()
hook.  ata_bmdma_setup() will write the pointer to the PRD table to
the IDE PRD Table Address register, enable DMA in the DMA Command
register, and call exec_command() to begin the transfer.
	</para>
            <para>
Most legacy IDE drivers use ata_bmdma_start() for the bmdma_start()
hook.  ata_bmdma_start() will write the ATA_DMA_START flag to the DMA
Command register.
	</para>
            <para>
Many legacy IDE drivers use ata_bmdma_stop() for the bmdma_stop()
hook.  ata_bmdma_stop() clears the ATA_DMA_START flag in the DMA
command register.
	</para>
            <para>
Many legacy IDE drivers use ata_bmdma_status() as the bmdma_status() hook.
	</para>
          </sect2>
          <sect2>
            <title>High-level taskfile hooks</title>
            <programlisting>
void (*qc_prep) (struct ata_queued_cmd *qc);
int (*qc_issue) (struct ata_queued_cmd *qc);
	</programlisting>
            <para>
	Higher-level hooks, these two hooks can potentially supercede
	several of the above taskfile/DMA engine hooks.  -&gt;qc_prep is
	called after the buffers have been DMA-mapped, and is typically
	used to populate the hardware's DMA scatter-gather table.
	Most drivers use the standard ata_qc_prep() helper function, but
	more advanced drivers roll their own.
	</para>
            <para>
	-&gt;qc_issue is used to make a command active, once the hardware
	and S/G tables have been prepared.  IDE BMDMA drivers use the
	helper function ata_qc_issue_prot() for taskfile protocol-based
	dispatch.  More advanced drivers implement their own -&gt;qc_issue.
	</para>
            <para>
	ata_qc_issue_prot() calls -&gt;tf_load(), -&gt;bmdma_setup(), and
	-&gt;bmdma_start() as necessary to initiate a transfer.
	</para>
          </sect2>
          <sect2>
            <title>Exception and probe handling (EH)</title>
            <programlisting>
void (*eng_timeout) (struct ata_port *ap);
void (*phy_reset) (struct ata_port *ap);
	</programlisting>
            <para>
Deprecated.  Use -&gt;error_handler() instead.
	</para>
            <programlisting>
void (*freeze) (struct ata_port *ap);
void (*thaw) (struct ata_port *ap);
	</programlisting>
            <para>
ata_port_freeze() is called when HSM violations or some other
condition disrupts normal operation of the port.  A frozen port
is not allowed to perform any operation until the port is
thawed, which usually follows a successful reset.
	</para>
            <para>
The optional -&gt;freeze() callback can be used for freezing the port
hardware-wise (e.g. mask interrupt and stop DMA engine).  If a
port cannot be frozen hardware-wise, the interrupt handler
must ack and clear interrupts unconditionally while the port
is frozen.
	</para>
            <para>
The optional -&gt;thaw() callback is called to perform the opposite of -&gt;freeze():
prepare the port for normal operation once again.  Unmask interrupts,
start DMA engine, etc.
	</para>
            <programlisting>
void (*error_handler) (struct ata_port *ap);
	</programlisting>
            <para>
-&gt;error_handler() is a driver's hook into probe, hotplug, and recovery
and other exceptional conditions.  The primary responsibility of an
implementation is to call ata_do_eh() or ata_bmdma_drive_eh() with a set
of EH hooks as arguments:
	</para>
            <para>
'prereset' hook (may be NULL) is called during an EH reset, before any other actions
are taken.
	</para>
            <para>
'postreset' hook (may be NULL) is called after the EH reset is performed.  Based on
existing conditions, severity of the problem, and hardware capabilities,
	</para>
            <para>
Either 'softreset' (may be NULL) or 'hardreset' (may be NULL) will be
called to perform the low-level EH reset.
	</para>
            <programlisting>
void (*post_internal_cmd) (struct ata_queued_cmd *qc);
	</programlisting>
            <para>
Perform any hardware-specific actions necessary to finish processing
after executing a probe-time or EH-time command via ata_exec_internal().
	</para>
          </sect2>
          <sect2>
            <title>Hardware interrupt handling</title>
            <programlisting>
irqreturn_t (*irq_handler)(int, void *, struct pt_regs *);
void (*irq_clear) (struct ata_port *);
	</programlisting>
            <para>
	-&gt;irq_handler is the interrupt handling routine registered with
	the system, by libata.  -&gt;irq_clear is called during probe just
	before the interrupt handler is registered, to be sure hardware
	is quiet.
	</para>
            <para>
	The second argument, dev_instance, should be cast to a pointer
	to struct ata_host_set.
	</para>
            <para>
	Most legacy IDE drivers use ata_sff_interrupt() for the
	irq_handler hook, which scans all ports in the host_set,
	determines which queued command was active (if any), and calls
	ata_sff_host_intr(ap,qc).
	</para>
            <para>
	Most legacy IDE drivers use ata_sff_irq_clear() for the
	irq_clear() hook, which simply clears the interrupt and error
	flags in the DMA status register.
	</para>
          </sect2>
          <sect2>
            <title>SATA phy read/write</title>
            <programlisting>
int (*scr_read) (struct ata_port *ap, unsigned int sc_reg,
		 u32 *val);
int (*scr_write) (struct ata_port *ap, unsigned int sc_reg,
                   u32 val);
	</programlisting>
            <para>
	Read and write standard SATA phy registers.  Currently only used
	if -&gt;phy_reset hook called the sata_phy_reset() helper function.
	sc_reg is one of SCR_STATUS, SCR_CONTROL, SCR_ERROR, or SCR_ACTIVE.
	</para>
          </sect2>
          <sect2>
            <title>Init and shutdown</title>
            <programlisting>
int (*port_start) (struct ata_port *ap);
void (*port_stop) (struct ata_port *ap);
void (*host_stop) (struct ata_host_set *host_set);
	</programlisting>
            <para>
	-&gt;port_start() is called just after the data structures for each
	port are initialized.  Typically this is used to alloc per-port
	DMA buffers / tables / rings, enable DMA engines, and similar
	tasks.  Some drivers also use this entry point as a chance to
	allocate driver-private memory for ap-&gt;private_data.
	</para>
            <para>
	Many drivers use ata_port_start() as this hook or call
	it from their own port_start() hooks.  ata_port_start()
	allocates space for a legacy IDE PRD table and returns.
	</para>
            <para>
	-&gt;port_stop() is called after -&gt;host_stop().  Its sole function
	is to release DMA/memory resources, now that they are no longer
	actively being used.  Many drivers also free driver-private
	data from port at this time.
	</para>
            <para>
	-&gt;host_stop() is called after all -&gt;port_stop() calls
have completed.  The hook must finalize hardware shutdown, release DMA
and other resources, etc.
	This hook may be specified as NULL, in which case it is not called.
	</para>
          </sect2>
        </sect1>
      </chapter>
      <chapter id="libataEH">
        <title>Error handling</title>
        <para>
	This chapter describes how errors are handled under libata.
	Readers are advised to read SCSI EH
	(Documentation/scsi/scsi_eh.txt) and ATA exceptions doc first.
	</para>
        <sect1>
          <title>Origins of commands</title>
          <para>
	In libata, a command is represented with struct ata_queued_cmd
	or qc.  qc's are preallocated during port initialization and
	repetitively used for command executions.  Currently only one
	qc is allocated per port but yet-to-be-merged NCQ branch
	allocates one for each tag and maps each qc to NCQ tag 1-to-1.
	</para>
          <para>
	libata commands can originate from two sources - libata itself
	and SCSI midlayer.  libata internal commands are used for
	initialization and error handling.  All normal blk requests
	and commands for SCSI emulation are passed as SCSI commands
	through queuecommand callback of SCSI host template.
	</para>
        </sect1>
        <sect1>
          <title>How commands are issued</title>
          <variablelist>
            <varlistentry>
              <term>Internal commands</term>
              <listitem>
                <para>
	First, qc is allocated and initialized using
	ata_qc_new_init().  Although ata_qc_new_init() doesn't
	implement any wait or retry mechanism when qc is not
	available, internal commands are currently issued only during
	initialization and error recovery, so no other command is
	active and allocation is guaranteed to succeed.
	</para>
                <para>
	Once allocated qc's taskfile is initialized for the command to
	be executed.  qc currently has two mechanisms to notify
	completion.  One is via qc-&gt;complete_fn() callback and the
	other is completion qc-&gt;waiting.  qc-&gt;complete_fn() callback
	is the asynchronous path used by normal SCSI translated
	commands and qc-&gt;waiting is the synchronous (issuer sleeps in
	process context) path used by internal commands.
	</para>
                <para>
	Once initialization is complete, host_set lock is acquired
	and the qc is issued.
	</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>SCSI commands</term>
              <listitem>
                <para>
	All libata drivers use ata_scsi_queuecmd() as
	hostt-&gt;queuecommand callback.  scmds can either be simulated
	or translated.  No qc is involved in processing a simulated
	scmd.  The result is computed right away and the scmd is
	completed.
	</para>
                <para>
	For a translated scmd, ata_qc_new_init() is invoked to
	allocate a qc and the scmd is translated into the qc.  SCSI
	midlayer's completion notification function pointer is stored
	into qc-&gt;scsidone.
	</para>
                <para>
	qc-&gt;complete_fn() callback is used for completion
	notification.  ATA commands use ata_scsi_qc_complete() while
	ATAPI commands use atapi_qc_complete().  Both functions end up
	calling qc-&gt;scsidone to notify upper layer when the qc is
	finished.  After translation is completed, the qc is issued
	with ata_qc_issue().
	</para>
                <para>
	Note that SCSI midlayer invokes hostt-&gt;queuecommand while
	holding host_set lock, so all above occur while holding
	host_set lock.
	</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect1>
        <sect1>
          <title>How commands are processed</title>
          <para>
	Depending on which protocol and which controller are used,
	commands are processed differently.  For the purpose of
	discussion, a controller which uses taskfile interface and all
	standard callbacks is assumed.
	</para>
          <para>
	Currently 6 ATA command protocols are used.  They can be
	sorted into the following four categories according to how
	they are processed.
	</para>
          <variablelist>
            <varlistentry>
              <term>ATA NO DATA or DMA</term>
              <listitem>
                <para>
	   ATA_PROT_NODATA and ATA_PROT_DMA fall into this category.
	   These types of commands don't require any software
	   intervention once issued.  Device will raise interrupt on
	   completion.
	   </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>ATA PIO</term>
              <listitem>
                <para>
	   ATA_PROT_PIO is in this category.  libata currently
	   implements PIO with polling.  ATA_NIEN bit is set to turn
	   off interrupt and pio_task on ata_wq performs polling and
	   IO.
	   </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>ATAPI NODATA or DMA</term>
              <listitem>
                <para>
	   ATA_PROT_ATAPI_NODATA and ATA_PROT_ATAPI_DMA are in this
	   category.  packet_task is used to poll BSY bit after
	   issuing PACKET command.  Once BSY is turned off by the
	   device, packet_task transfers CDB and hands off processing
	   to interrupt handler.
	   </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>ATAPI PIO</term>
              <listitem>
                <para>
	   ATA_PROT_ATAPI is in this category.  ATA_NIEN bit is set
	   and, as in ATAPI NODATA or DMA, packet_task submits cdb.
	   However, after submitting cdb, further processing (data
	   transfer) is handed off to pio_task.
	   </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect1>
        <sect1>
          <title>How commands are completed</title>
          <para>
	Once issued, all qc's are either completed with
	ata_qc_complete() or time out.  For commands which are handled
	by interrupts, ata_host_intr() invokes ata_qc_complete(), and,
	for PIO tasks, pio_task invokes ata_qc_complete().  In error
	cases, packet_task may also complete commands.
	</para>
          <para>
	ata_qc_complete() does the following.
	</para>
          <orderedlist>
            <listitem>
              <para>
	DMA memory is unmapped.
	</para>
            </listitem>
            <listitem>
              <para>
	ATA_QCFLAG_ACTIVE is clared from qc-&gt;flags.
	</para>
            </listitem>
            <listitem>
              <para>
	qc-&gt;complete_fn() callback is invoked.  If the return value of
	the callback is not zero.  Completion is short circuited and
	ata_qc_complete() returns.
	</para>
            </listitem>
            <listitem>
              <para>
	__ata_qc_complete() is called, which does
	   <orderedlist><listitem><para>
	   qc-&gt;flags is cleared to zero.
	   </para></listitem><listitem><para>
	   ap-&gt;active_tag and qc-&gt;tag are poisoned.
	   </para></listitem><listitem><para>
	   qc-&gt;waiting is claread &amp; completed (in that order).
	   </para></listitem><listitem><para>
	   qc is deallocated by clearing appropriate bit in ap-&gt;qactive.
	   </para></listitem></orderedlist></para>
            </listitem>
          </orderedlist>
          <para>
	So, it basically notifies upper layer and deallocates qc.  One
	exception is short-circuit path in #3 which is used by
	atapi_qc_complete().
	</para>
          <para>
	For all non-ATAPI commands, whether it fails or not, almost
	the same code path is taken and very little error handling
	takes place.  A qc is completed with success status if it
	succeeded, with failed status otherwise.
	</para>
          <para>
	However, failed ATAPI commands require more handling as
	REQUEST SENSE is needed to acquire sense data.  If an ATAPI
	command fails, ata_qc_complete() is invoked with error status,
	which in turn invokes atapi_qc_complete() via
	qc-&gt;complete_fn() callback.
	</para>
          <para>
	This makes atapi_qc_complete() set scmd-&gt;result to
	SAM_STAT_CHECK_CONDITION, complete the scmd and return 1.  As
	the sense data is empty but scmd-&gt;result is CHECK CONDITION,
	SCSI midlayer will invoke EH for the scmd, and returning 1
	makes ata_qc_complete() to return without deallocating the qc.
	This leads us to ata_scsi_error() with partially completed qc.
	</para>
        </sect1>
        <sect1>
          <title>ata_scsi_error()</title>
          <para>
	ata_scsi_error() is the current transportt-&gt;eh_strategy_handler()
	for libata.  As discussed above, this will be entered in two
	cases - timeout and ATAPI error completion.  This function
	calls low level libata driver's eng_timeout() callback, the
	standard callback for which is ata_eng_timeout().  It checks
	if a qc is active and calls ata_qc_timeout() on the qc if so.
	Actual error handling occurs in ata_qc_timeout().
	</para>
          <para>
	If EH is invoked for timeout, ata_qc_timeout() stops BMDMA and
	completes the qc.  Note that as we're currently in EH, we
	cannot call scsi_done.  As described in SCSI EH doc, a
	recovered scmd should be either retried with
	scsi_queue_insert() or finished with scsi_finish_command().
	Here, we override qc-&gt;scsidone with scsi_finish_command() and
	calls ata_qc_complete().
	</para>
          <para>
	If EH is invoked due to a failed ATAPI qc, the qc here is
	completed but not deallocated.  The purpose of this
	half-completion is to use the qc as place holder to make EH
	code reach this place.  This is a bit hackish, but it works.
	</para>
          <para>
	Once control reaches here, the qc is deallocated by invoking
	__ata_qc_complete() explicitly.  Then, internal qc for REQUEST
	SENSE is issued.  Once sense data is acquired, scmd is
	finished by directly invoking scsi_finish_command() on the
	scmd.  Note that as we already have completed and deallocated
	the qc which was associated with the scmd, we don't need
	to/cannot call ata_qc_complete() again.
	</para>
        </sect1>
        <sect1>
          <title>Problems with the current EH</title>
          <itemizedlist>
            <listitem>
              <para>
	Error representation is too crude.  Currently any and all
	error conditions are represented with ATA STATUS and ERROR
	registers.  Errors which aren't ATA device errors are treated
	as ATA device errors by setting ATA_ERR bit.  Better error
	descriptor which can properly represent ATA and other
	errors/exceptions is needed.
	</para>
            </listitem>
            <listitem>
              <para>
	When handling timeouts, no action is taken to make device
	forget about the timed out command and ready for new commands.
	</para>
            </listitem>
            <listitem>
              <para>
	EH handling via ata_scsi_error() is not properly protected
	from usual command processing.  On EH entrance, the device is
	not in quiescent state.  Timed out commands may succeed or
	fail any time.  pio_task and atapi_task may still be running.
	</para>
            </listitem>
            <listitem>
              <para>
	Too weak error recovery.  Devices / controllers causing HSM
	mismatch errors and other errors quite often require reset to
	return to known state.  Also, advanced error handling is
	necessary to support features like NCQ and hotplug.
	</para>
            </listitem>
            <listitem>
              <para>
	ATA errors are directly handled in the interrupt handler and
	PIO errors in pio_task.  This is problematic for advanced
	error handling for the following reasons.
	</para>
              <para>
	First, advanced error handling often requires context and
	internal qc execution.
	</para>
              <para>
	Second, even a simple failure (say, CRC error) needs
	information gathering and could trigger complex error handling
	(say, resetting &amp; reconfiguring).  Having multiple code
	paths to gather information, enter EH and trigger actions
	makes life painful.
	</para>
              <para>
	Third, scattered EH code makes implementing low level drivers
	difficult.  Low level drivers override libata callbacks.  If
	EH is scattered over several places, each affected callbacks
	should perform its part of error handling.  This can be error
	prone and painful.
	</para>
            </listitem>
          </itemizedlist>
        </sect1>
      </chapter>
      <chapter id="libataExt">
        <title>libata Library</title>
!Edrivers/ata/libata-core.c
  </chapter>
      <chapter id="libataInt">
        <title>libata Core Internals</title>
!Idrivers/ata/libata-core.c
  </chapter>
      <chapter id="libataScsiInt">
        <title>libata SCSI translation/emulation</title>
!Edrivers/ata/libata-scsi.c
!Idrivers/ata/libata-scsi.c
  </chapter>
      <chapter id="ataExceptions">
        <title>ATA errors and exceptions</title>
        <para>
  This chapter tries to identify what error/exception conditions exist
  for ATA/ATAPI devices and describe how they should be handled in
  implementation-neutral way.
  </para>
        <para>
  The term 'error' is used to describe conditions where either an
  explicit error condition is reported from device or a command has
  timed out.
  </para>
        <para>
  The term 'exception' is either used to describe exceptional
  conditions which are not errors (say, power or hotplug events), or
  to describe both errors and non-error exceptional conditions.  Where
  explicit distinction between error and exception is necessary, the
  term 'non-error exception' is used.
  </para>
        <sect1 id="excat">
          <title>Exception categories</title>
          <para>
     Exceptions are described primarily with respect to legacy
     taskfile + bus master IDE interface.  If a controller provides
     other better mechanism for error reporting, mapping those into
     categories described below shouldn't be difficult.
     </para>
          <para>
     In the following sections, two recovery actions - reset and
     reconfiguring transport - are mentioned.  These are described
     further in <xref linkend="exrec" />.
     </para>
          <sect2 id="excatHSMviolation">
            <title>HSM violation</title>
            <para>
        This error is indicated when STATUS value doesn't match HSM
        requirement during issuing or execution any ATA/ATAPI command.
        </para>
            <itemizedlist>
              <title>Examples</title>
              <listitem>
                <para>
	ATA_STATUS doesn't contain !BSY &amp;&amp; DRDY &amp;&amp; !DRQ while trying
	to issue a command.
        </para>
              </listitem>
              <listitem>
                <para>
	!BSY &amp;&amp; !DRQ during PIO data transfer.
        </para>
              </listitem>
              <listitem>
                <para>
	DRQ on command completion.
        </para>
              </listitem>
              <listitem>
                <para>
	!BSY &amp;&amp; ERR after CDB transfer starts but before the
        last byte of CDB is transferred.  ATA/ATAPI standard states
        that "The device shall not terminate the PACKET command
        with an error before the last byte of the command packet has
        been written" in the error outputs description of PACKET
        command and the state diagram doesn't include such
        transitions.
	</para>
              </listitem>
            </itemizedlist>
            <para>
	In these cases, HSM is violated and not much information
	regarding the error can be acquired from STATUS or ERROR
	register.  IOW, this error can be anything - driver bug,
	faulty device, controller and/or cable.
	</para>
            <para>
	As HSM is violated, reset is necessary to restore known state.
	Reconfiguring transport for lower speed might be helpful too
	as transmission errors sometimes cause this kind of errors.
	</para>
          </sect2>
          <sect2 id="excatDevErr">
            <title>ATA/ATAPI device error (non-NCQ / non-CHECK CONDITION)</title>
            <para>
	These are errors detected and reported by ATA/ATAPI devices
	indicating device problems.  For this type of errors, STATUS
	and ERROR register values are valid and describe error
	condition.  Note that some of ATA bus errors are detected by
	ATA/ATAPI devices and reported using the same mechanism as
	device errors.  Those cases are described later in this
	section.
	</para>
            <para>
	For ATA commands, this type of errors are indicated by !BSY
	&amp;&amp; ERR during command execution and on completion.
	</para>
            <para>For ATAPI commands,</para>
            <itemizedlist>
              <listitem>
                <para>
	!BSY &amp;&amp; ERR &amp;&amp; ABRT right after issuing PACKET
	indicates that PACKET command is not supported and falls in
	this category.
	</para>
              </listitem>
              <listitem>
                <para>
	!BSY &amp;&amp; ERR(==CHK) &amp;&amp; !ABRT after the last
	byte of CDB is transferred indicates CHECK CONDITION and
	doesn't fall in this category.
	</para>
              </listitem>
              <listitem>
                <para>
	!BSY &amp;&amp; ERR(==CHK) &amp;&amp; ABRT after the last byte
        of CDB is transferred *probably* indicates CHECK CONDITION and
        doesn't fall in this category.
	</para>
              </listitem>
            </itemizedlist>
            <para>
	Of errors detected as above, the followings are not ATA/ATAPI
	device errors but ATA bus errors and should be handled
	according to <xref linkend="excatATAbusErr" />.
	</para>
            <variablelist>
              <varlistentry>
                <term>CRC error during data transfer</term>
                <listitem>
                  <para>
	   This is indicated by ICRC bit in the ERROR register and
	   means that corruption occurred during data transfer.  Up to
	   ATA/ATAPI-7, the standard specifies that this bit is only
	   applicable to UDMA transfers but ATA/ATAPI-8 draft revision
	   1f says that the bit may be applicable to multiword DMA and
	   PIO.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>ABRT error during data transfer or on completion</term>
                <listitem>
                  <para>
	   Up to ATA/ATAPI-7, the standard specifies that ABRT could be
	   set on ICRC errors and on cases where a device is not able
	   to complete a command.  Combined with the fact that MWDMA
	   and PIO transfer errors aren't allowed to use ICRC bit up to
	   ATA/ATAPI-7, it seems to imply that ABRT bit alone could
	   indicate transfer errors.
	   </para>
                  <para>
	   However, ATA/ATAPI-8 draft revision 1f removes the part
	   that ICRC errors can turn on ABRT.  So, this is kind of
	   gray area.  Some heuristics are needed here.
	   </para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>
	ATA/ATAPI device errors can be further categorized as follows.
	</para>
            <variablelist>
              <varlistentry>
                <term>Media errors</term>
                <listitem>
                  <para>
	   This is indicated by UNC bit in the ERROR register.  ATA
	   devices reports UNC error only after certain number of
	   retries cannot recover the data, so there's nothing much
	   else to do other than notifying upper layer.
	   </para>
                  <para>
	   READ and WRITE commands report CHS or LBA of the first
	   failed sector but ATA/ATAPI standard specifies that the
	   amount of transferred data on error completion is
	   indeterminate, so we cannot assume that sectors preceding
	   the failed sector have been transferred and thus cannot
	   complete those sectors successfully as SCSI does.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Media changed / media change requested error</term>
                <listitem>
                  <para>
	   &lt;&lt;TODO: fill here&gt;&gt;
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Address error</term>
                <listitem>
                  <para>
	   This is indicated by IDNF bit in the ERROR register.
	   Report to upper layer.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Other errors</term>
                <listitem>
                  <para>
	   This can be invalid command or parameter indicated by ABRT
	   ERROR bit or some other error condition.  Note that ABRT
	   bit can indicate a lot of things including ICRC and Address
	   errors.  Heuristics needed.
	   </para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>
	Depending on commands, not all STATUS/ERROR bits are
	applicable.  These non-applicable bits are marked with
	"na" in the output descriptions but up to ATA/ATAPI-7
	no definition of "na" can be found.  However,
	ATA/ATAPI-8 draft revision 1f describes "N/A" as
	follows.
	</para>
            <blockquote>
              <variablelist>
                <varlistentry>
                  <term>3.2.3.3a N/A</term>
                  <listitem>
                    <para>
	   A keyword the indicates a field has no defined value in
	   this standard and should not be checked by the host or
	   device. N/A fields should be cleared to zero.
	   </para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </blockquote>
            <para>
	So, it seems reasonable to assume that "na" bits are
	cleared to zero by devices and thus need no explicit masking.
	</para>
          </sect2>
          <sect2 id="excatATAPIcc">
            <title>ATAPI device CHECK CONDITION</title>
            <para>
	ATAPI device CHECK CONDITION error is indicated by set CHK bit
	(ERR bit) in the STATUS register after the last byte of CDB is
	transferred for a PACKET command.  For this kind of errors,
	sense data should be acquired to gather information regarding
	the errors.  REQUEST SENSE packet command should be used to
	acquire sense data.
	</para>
            <para>
	Once sense data is acquired, this type of errors can be
	handled similary to other SCSI errors.  Note that sense data
	may indicate ATA bus error (e.g. Sense Key 04h HARDWARE ERROR
	&amp;&amp; ASC/ASCQ 47h/00h SCSI PARITY ERROR).  In such
	cases, the error should be considered as an ATA bus error and
	handled according to <xref linkend="excatATAbusErr" />.
	</para>
          </sect2>
          <sect2 id="excatNCQerr">
            <title>ATA device error (NCQ)</title>
            <para>
	NCQ command error is indicated by cleared BSY and set ERR bit
	during NCQ command phase (one or more NCQ commands
	outstanding).  Although STATUS and ERROR registers will
	contain valid values describing the error, READ LOG EXT is
	required to clear the error condition, determine which command
	has failed and acquire more information.
	</para>
            <para>
	READ LOG EXT Log Page 10h reports which tag has failed and
	taskfile register values describing the error.  With this
	information the failed command can be handled as a normal ATA
	command error as in <xref linkend="excatDevErr" /> and all
	other in-flight commands must be retried.  Note that this
	retry should not be counted - it's likely that commands
	retried this way would have completed normally if it were not
	for the failed command.
	</para>
            <para>
	Note that ATA bus errors can be reported as ATA device NCQ
	errors.  This should be handled as described in <xref linkend="excatATAbusErr" />.
	</para>
            <para>
	If READ LOG EXT Log Page 10h fails or reports NQ, we're
	thoroughly screwed.  This condition should be treated
	according to <xref linkend="excatHSMviolation" />.
	</para>
          </sect2>
          <sect2 id="excatATAbusErr">
            <title>ATA bus error</title>
            <para>
	ATA bus error means that data corruption occurred during
	transmission over ATA bus (SATA or PATA).  This type of errors
	can be indicated by
	</para>
            <itemizedlist>
              <listitem>
                <para>
	ICRC or ABRT error as described in <xref linkend="excatDevErr" />.
	</para>
              </listitem>
              <listitem>
                <para>
	Controller-specific error completion with error information
	indicating transmission error.
	</para>
              </listitem>
              <listitem>
                <para>
	On some controllers, command timeout.  In this case, there may
	be a mechanism to determine that the timeout is due to
	transmission error.
	</para>
              </listitem>
              <listitem>
                <para>
	Unknown/random errors, timeouts and all sorts of weirdities.
	</para>
              </listitem>
            </itemizedlist>
            <para>
	As described above, transmission errors can cause wide variety
	of symptoms ranging from device ICRC error to random device
	lockup, and, for many cases, there is no way to tell if an
	error condition is due to transmission error or not;
	therefore, it's necessary to employ some kind of heuristic
	when dealing with errors and timeouts.  For example,
	encountering repetitive ABRT errors for known supported
	command is likely to indicate ATA bus error.
	</para>
            <para>
	Once it's determined that ATA bus errors have possibly
	occurred, lowering ATA bus transmission speed is one of
	actions which may alleviate the problem.  See <xref linkend="exrecReconf" /> for more information.
	</para>
          </sect2>
          <sect2 id="excatPCIbusErr">
            <title>PCI bus error</title>
            <para>
	Data corruption or other failures during transmission over PCI
	(or other system bus).  For standard BMDMA, this is indicated
	by Error bit in the BMDMA Status register.  This type of
	errors must be logged as it indicates something is very wrong
	with the system.  Resetting host controller is recommended.
	</para>
          </sect2>
          <sect2 id="excatLateCompletion">
            <title>Late completion</title>
            <para>
	This occurs when timeout occurs and the timeout handler finds
	out that the timed out command has completed successfully or
	with error.  This is usually caused by lost interrupts.  This
	type of errors must be logged.  Resetting host controller is
	recommended.
	</para>
          </sect2>
          <sect2 id="excatUnknown">
            <title>Unknown error (timeout)</title>
            <para>
	This is when timeout occurs and the command is still
	processing or the host and device are in unknown state.  When
	this occurs, HSM could be in any valid or invalid state.  To
	bring the device to known state and make it forget about the
	timed out command, resetting is necessary.  The timed out
	command may be retried.
	</para>
            <para>
	Timeouts can also be caused by transmission errors.  Refer to
	<xref linkend="excatATAbusErr" /> for more details.
	</para>
          </sect2>
          <sect2 id="excatHoplugPM">
            <title>Hotplug and power management exceptions</title>
            <para>
	&lt;&lt;TODO: fill here&gt;&gt;
	</para>
          </sect2>
        </sect1>
        <sect1 id="exrec">
          <title>EH recovery actions</title>
          <para>
     This section discusses several important recovery actions.
     </para>
          <sect2 id="exrecClr">
            <title>Clearing error condition</title>
            <para>
	Many controllers require its error registers to be cleared by
	error handler.  Different controllers may have different
	requirements.
	</para>
            <para>
	For SATA, it's strongly recommended to clear at least SError
	register during error handling.
	</para>
          </sect2>
          <sect2 id="exrecRst">
            <title>Reset</title>
            <para>
	During EH, resetting is necessary in the following cases.
	</para>
            <itemizedlist>
              <listitem>
                <para>
	HSM is in unknown or invalid state
	</para>
              </listitem>
              <listitem>
                <para>
	HBA is in unknown or invalid state
	</para>
              </listitem>
              <listitem>
                <para>
	EH needs to make HBA/device forget about in-flight commands
	</para>
              </listitem>
              <listitem>
                <para>
	HBA/device behaves weirdly
	</para>
              </listitem>
            </itemizedlist>
            <para>
	Resetting during EH might be a good idea regardless of error
	condition to improve EH robustness.  Whether to reset both or
	either one of HBA and device depends on situation but the
	following scheme is recommended.
	</para>
            <itemizedlist>
              <listitem>
                <para>
	When it's known that HBA is in ready state but ATA/ATAPI
	device is in unknown state, reset only device.
	</para>
              </listitem>
              <listitem>
                <para>
	If HBA is in unknown state, reset both HBA and device.
	</para>
              </listitem>
            </itemizedlist>
            <para>
	HBA resetting is implementation specific.  For a controller
	complying to taskfile/BMDMA PCI IDE, stopping active DMA
	transaction may be sufficient iff BMDMA state is the only HBA
	context.  But even mostly taskfile/BMDMA PCI IDE complying
	controllers may have implementation specific requirements and
	mechanism to reset themselves.  This must be addressed by
	specific drivers.
	</para>
            <para>
	OTOH, ATA/ATAPI standard describes in detail ways to reset
	ATA/ATAPI devices.
	</para>
            <variablelist>
              <varlistentry>
                <term>PATA hardware reset</term>
                <listitem>
                  <para>
	   This is hardware initiated device reset signalled with
	   asserted PATA RESET- signal.  There is no standard way to
	   initiate hardware reset from software although some
	   hardware provides registers that allow driver to directly
	   tweak the RESET- signal.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Software reset</term>
                <listitem>
                  <para>
	   This is achieved by turning CONTROL SRST bit on for at
	   least 5us.  Both PATA and SATA support it but, in case of
	   SATA, this may require controller-specific support as the
	   second Register FIS to clear SRST should be transmitted
	   while BSY bit is still set.  Note that on PATA, this resets
	   both master and slave devices on a channel.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>EXECUTE DEVICE DIAGNOSTIC command</term>
                <listitem>
                  <para>
	   Although ATA/ATAPI standard doesn't describe exactly, EDD
	   implies some level of resetting, possibly similar level
	   with software reset.  Host-side EDD protocol can be handled
	   with normal command processing and most SATA controllers
	   should be able to handle EDD's just like other commands.
	   As in software reset, EDD affects both devices on a PATA
	   bus.
	   </para>
                  <para>
	   Although EDD does reset devices, this doesn't suit error
	   handling as EDD cannot be issued while BSY is set and it's
	   unclear how it will act when device is in unknown/weird
	   state.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>ATAPI DEVICE RESET command</term>
                <listitem>
                  <para>
	   This is very similar to software reset except that reset
	   can be restricted to the selected device without affecting
	   the other device sharing the cable.
	   </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>SATA phy reset</term>
                <listitem>
                  <para>
	   This is the preferred way of resetting a SATA device.  In
	   effect, it's identical to PATA hardware reset.  Note that
	   this can be done with the standard SCR Control register.
	   As such, it's usually easier to implement than software
	   reset.
	   </para>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>
	One more thing to consider when resetting devices is that
	resetting clears certain configuration parameters and they
	need to be set to their previous or newly adjusted values
	after reset.
	</para>
            <para>
	Parameters affected are.
	</para>
            <itemizedlist>
              <listitem>
                <para>
	CHS set up with INITIALIZE DEVICE PARAMETERS (seldom used)
	</para>
              </listitem>
              <listitem>
                <para>
	Parameters set with SET FEATURES including transfer mode setting
	</para>
              </listitem>
              <listitem>
                <para>
	Block count set with SET MULTIPLE MODE
	</para>
              </listitem>
              <listitem>
                <para>
	Other parameters (SET MAX, MEDIA LOCK...)
	</para>
              </listitem>
            </itemizedlist>
            <para>
	ATA/ATAPI standard specifies that some parameters must be
	maintained across hardware or software reset, but doesn't
	strictly specify all of them.  Always reconfiguring needed
	parameters after reset is required for robustness.  Note that
	this also applies when resuming from deep sleep (power-off).
	</para>
            <para>
	Also, ATA/ATAPI standard requires that IDENTIFY DEVICE /
	IDENTIFY PACKET DEVICE is issued after any configuration
	parameter is updated or a hardware reset and the result used
	for further operation.  OS driver is required to implement
	revalidation mechanism to support this.
	</para>
          </sect2>
          <sect2 id="exrecReconf">
            <title>Reconfigure transport</title>
            <para>
	For both PATA and SATA, a lot of corners are cut for cheap
	connectors, cables or controllers and it's quite common to see
	high transmission error rate.  This can be mitigated by
	lowering transmission speed.
	</para>
            <para>
	The following is a possible scheme Jeff Garzik suggested.
	</para>
            <blockquote>
              <para>
	If more than $N (3?) transmission errors happen in 15 minutes,
	</para>
              <itemizedlist>
                <listitem>
                  <para>
	if SATA, decrease SATA PHY speed.  if speed cannot be decreased,
	</para>
                </listitem>
                <listitem>
                  <para>
	decrease UDMA xfer speed.  if at UDMA0, switch to PIO4,
	</para>
                </listitem>
                <listitem>
                  <para>
	decrease PIO xfer speed.  if at PIO3, complain, but continue
	</para>
                </listitem>
              </itemizedlist>
            </blockquote>
          </sect2>
        </sect1>
      </chapter>
      <chapter id="PiixInt">
        <title>ata_piix Internals</title>
!Idrivers/ata/ata_piix.c
  </chapter>
      <chapter id="SILInt">
        <title>sata_sil Internals</title>
!Idrivers/ata/sata_sil.c
  </chapter>
      <chapter id="libataThanks">
        <title>Thanks</title>
        <para>
  The bulk of the ATA knowledge comes thanks to long conversations with
  Andre Hedrick (www.linux-ide.org), and long hours pondering the ATA
  and SCSI specifications.
  </para>
        <para>
  Thanks to Alan Cox for pointing out similarities 
  between SATA and SCSI, and in general for motivation to hack on
  libata.
  </para>
        <para>
  libata's device detection
  method, ata_pio_devchk, and in general all the early probing was
  based on extensive study of Hale Landis's probe/reset code in his
  ATADRVR driver (www.ata-atapi.com).
  </para>
      </chapter>
    </book>
    <book id="Reed-Solomon-Library-Guide">
      <bookinfo>
        <title>Reed-Solomon Library Programming Interface</title>
        <authorgroup>
          <author>
            <firstname>Thomas</firstname>
            <surname>Gleixner</surname>
            <affiliation>
              <address>
                <email>tglx@linutronix.de</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2004</year>
          <holder>Thomas Gleixner</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
  	The generic Reed-Solomon Library provides encoding, decoding
	and error correction functions.
  </para>
        <para>
  	Reed-Solomon codes are used in communication and storage
	applications to ensure data integrity. 
  </para>
        <para>
  	This documentation is provided for developers who want to utilize
	the functions provided by the library.
  </para>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs And Assumptions</title>
        <para>
	None.	
  </para>
      </chapter>
      <chapter id="usage">
        <title>Usage</title>
        <para>
		This chapter provides examples of how to use the library.
	</para>
        <sect1>
          <title>Initializing</title>
          <para>
			The init function init_rs returns a pointer to an
			rs decoder structure, which holds the necessary
			information for encoding, decoding and error correction
			with the given polynomial. It either uses an existing
			matching decoder or creates a new one. On creation all
			the lookup tables for fast en/decoding are created.
			The function may take a while, so make sure not to 
			call it in critical code paths.
		</para>
          <programlisting>
/* the Reed Solomon control structure */
static struct rs_control *rs_decoder;

/* Symbolsize is 10 (bits)
 * Primitive polynomial is x^10+x^3+1
 * first consecutive root is 0
 * primitive element to generate roots = 1
 * generator polynomial degree (number of roots) = 6
 */
rs_decoder = init_rs (10, 0x409, 0, 1, 6);
		</programlisting>
        </sect1>
        <sect1>
          <title>Encoding</title>
          <para>
			The encoder calculates the Reed-Solomon code over
			the given data length and stores the result in 
			the parity buffer. Note that the parity buffer must
			be initialized before calling the encoder.
		</para>
          <para>
			The expanded data can be inverted on the fly by
			providing a non-zero inversion mask. The expanded data is
			XOR'ed with the mask. This is used e.g. for FLASH
			ECC, where the all 0xFF is inverted to an all 0x00.
			The Reed-Solomon code for all 0x00 is all 0x00. The
			code is inverted before storing to FLASH so it is 0xFF
			too. This prevents that reading from an erased FLASH
			results in ECC errors.
		</para>
          <para>
			The databytes are expanded to the given symbol size
			on the fly. There is no support for encoding continuous
			bitstreams with a symbol size != 8 at the moment. If
			it is necessary it should be not a big deal to implement
			such functionality.
		</para>
          <programlisting>
/* Parity buffer. Size = number of roots */
uint16_t par[6];
/* Initialize the parity buffer */
memset(par, 0, sizeof(par));
/* Encode 512 byte in data8. Store parity in buffer par */
encode_rs8 (rs_decoder, data8, 512, par, 0);
		</programlisting>
        </sect1>
        <sect1>
          <title>Decoding</title>
          <para>
			The decoder calculates the syndrome over
			the given data length and the received parity symbols
			and corrects errors in the data.
		</para>
          <para>
			If a syndrome is available from a hardware decoder
			then the syndrome calculation is skipped.
		</para>
          <para>
			The correction of the data buffer can be suppressed
			by providing a correction pattern buffer and an error
			location buffer to the decoder. The decoder stores the
			calculated error location and the correction bitmask
			in the given buffers. This is useful for hardware
			decoders which use a weird bit ordering scheme.
		</para>
          <para>
			The databytes are expanded to the given symbol size
			on the fly. There is no support for decoding continuous
			bitstreams with a symbolsize != 8 at the moment. If
			it is necessary it should be not a big deal to implement
			such functionality.
		</para>
          <sect2>
            <title>
			Decoding with syndrome calculation, direct data correction
		</title>
            <programlisting>
/* Parity buffer. Size = number of roots */
uint16_t par[6];
uint8_t  data[512];
int numerr;
/* Receive data */
.....
/* Receive parity */
.....
/* Decode 512 byte in data8.*/
numerr = decode_rs8 (rs_decoder, data8, par, 512, NULL, 0, NULL, 0, NULL);
		</programlisting>
          </sect2>
          <sect2>
            <title>
			Decoding with syndrome given by hardware decoder, direct data correction
		</title>
            <programlisting>
/* Parity buffer. Size = number of roots */
uint16_t par[6], syn[6];
uint8_t  data[512];
int numerr;
/* Receive data */
.....
/* Receive parity */
.....
/* Get syndrome from hardware decoder */
.....
/* Decode 512 byte in data8.*/
numerr = decode_rs8 (rs_decoder, data8, par, 512, syn, 0, NULL, 0, NULL);
		</programlisting>
          </sect2>
          <sect2>
            <title>
			Decoding with syndrome given by hardware decoder, no direct data correction.
		</title>
            <para>
			Note: It's not necessary to give data and received parity to the decoder.
		</para>
            <programlisting>
/* Parity buffer. Size = number of roots */
uint16_t par[6], syn[6], corr[8];
uint8_t  data[512];
int numerr, errpos[8];
/* Receive data */
.....
/* Receive parity */
.....
/* Get syndrome from hardware decoder */
.....
/* Decode 512 byte in data8.*/
numerr = decode_rs8 (rs_decoder, NULL, NULL, 512, syn, 0, errpos, 0, corr);
for (i = 0; i &lt; numerr; i++) {
	do_error_correction_in_your_buffer(errpos[i], corr[i]);
}
		</programlisting>
          </sect2>
        </sect1>
        <sect1>
          <title>Cleanup</title>
          <para>
			The function free_rs frees the allocated resources,
			if the caller is the last user of the decoder.
		</para>
          <programlisting>
/* Release resources */
free_rs(rs_decoder);
		</programlisting>
        </sect1>
      </chapter>
      <chapter id="structs">
        <title>Structures</title>
        <para>
     This chapter contains the autogenerated documentation of the structures which are
     used in the Reed-Solomon Library and are relevant for a developer.
     </para>
!Iinclude/linux/rslib.h
  </chapter>
      <chapter id="pubfunctions">
        <title>Public Functions Provided</title>
        <para>
     This chapter contains the autogenerated documentation of the Reed-Solomon functions
     which are exported.
     </para>
!Elib/reed_solomon/reed_solomon.c
  </chapter>
      <chapter id="credits">
        <title>Credits</title>
        <para>
		The library code for encoding and decoding was written by Phil Karn.
	</para>
        <programlisting>
		Copyright 2002, Phil Karn, KA9Q
 		May be used under the terms of the GNU General Public License (GPL)
	</programlisting>
        <para>
		The wrapper functions and interfaces are written by Thomas Gleixner.
	</para>
        <para>
		Many users have provided bugfixes, improvements and helping hands for testing.
		Thanks a lot.
	</para>
        <para>
		The following people have contributed to this document:
	</para>
        <para>
		Thomas Gleixner<email>tglx@linutronix.de</email></para>
      </chapter>
    </book>
    <article class="whitepaper" id="LinuxSecurityModule" lang="en">
      <articleinfo>
        <title>Linux Security Modules:  General Security Hooks for Linux</title>
        <authorgroup>
          <author>
            <firstname>Stephen</firstname>
            <surname>Smalley</surname>
            <affiliation>
              <orgname>NAI Labs</orgname>
              <address>
                <email>ssmalley@nai.com</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>Timothy</firstname>
            <surname>Fraser</surname>
            <affiliation>
              <orgname>NAI Labs</orgname>
              <address>
                <email>tfraser@nai.com</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>Chris</firstname>
            <surname>Vance</surname>
            <affiliation>
              <orgname>NAI Labs</orgname>
              <address>
                <email>cvance@nai.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
      </articleinfo>
      <sect1 id="Introduction">
        <title>Introduction</title>
        <para>
In March 2001, the National Security Agency (NSA) gave a presentation
about Security-Enhanced Linux (SELinux) at the 2.5 Linux Kernel
Summit.  SELinux is an implementation of flexible and fine-grained
nondiscretionary access controls in the Linux kernel, originally
implemented as its own particular kernel patch.  Several other
security projects (e.g. RSBAC, Medusa) have also developed flexible
access control architectures for the Linux kernel, and various
projects have developed particular access control models for Linux
(e.g. LIDS, DTE, SubDomain).  Each project has developed and
maintained its own kernel patch to support its security needs.
</para>
        <para>
In response to the NSA presentation, Linus Torvalds made a set of
remarks that described a security framework he would be willing to
consider for inclusion in the mainstream Linux kernel.  He described a
general framework that would provide a set of security hooks to
control operations on kernel objects and a set of opaque security
fields in kernel data structures for maintaining security attributes.
This framework could then be used by loadable kernel modules to
implement any desired model of security.  Linus also suggested the
possibility of migrating the Linux capabilities code into such a
module.
</para>
        <para>
The Linux Security Modules (LSM) project was started by WireX to
develop such a framework.  LSM is a joint development effort by
several security projects, including Immunix, SELinux, SGI and Janus,
and several individuals, including Greg Kroah-Hartman and James
Morris, to develop a Linux kernel patch that implements this
framework.  The patch is currently tracking the 2.4 series and is
targeted for integration into the 2.5 development series.  This
technical report provides an overview of the framework and the example
capabilities security module provided by the LSM kernel patch.
</para>
      </sect1>
      <sect1 id="framework">
        <title>LSM Framework</title>
        <para>
The LSM kernel patch provides a general kernel framework to support
security modules.  In particular, the LSM framework is primarily
focused on supporting access control modules, although future
development is likely to address other security needs such as
auditing.  By itself, the framework does not provide any additional
security; it merely provides the infrastructure to support security
modules.  The LSM kernel patch also moves most of the capabilities
logic into an optional security module, with the system defaulting
to the traditional superuser logic.  This capabilities module
is discussed further in <xref linkend="cap" />.
</para>
        <para>
The LSM kernel patch adds security fields to kernel data structures
and inserts calls to hook functions at critical points in the kernel
code to manage the security fields and to perform access control.  It
also adds functions for registering and unregistering security
modules, and adds a general <function>security</function> system call
to support new system calls for security-aware applications.
</para>
        <para>
The LSM security fields are simply <type>void*</type> pointers.  For
process and program execution security information, security fields
were added to <structname>struct task_struct</structname> and 
<structname>struct linux_binprm</structname>.  For filesystem security
information, a security field was added to 
<structname>struct super_block</structname>.  For pipe, file, and socket
security information, security fields were added to 
<structname>struct inode</structname> and 
<structname>struct file</structname>.  For packet and network device security
information, security fields were added to
<structname>struct sk_buff</structname> and
<structname>struct net_device</structname>.  For System V IPC security
information, security fields were added to
<structname>struct kern_ipc_perm</structname> and
<structname>struct msg_msg</structname>; additionally, the definitions
for <structname>struct msg_msg</structname>, <structname>struct 
msg_queue</structname>, and <structname>struct 
shmid_kernel</structname> were moved to header files
(<filename>include/linux/msg.h</filename> and
<filename>include/linux/shm.h</filename> as appropriate) to allow
the security modules to use these definitions.
</para>
        <para>
Each LSM hook is a function pointer in a global table,
security_ops. This table is a
<structname>security_operations</structname> structure as defined by
<filename>include/linux/security.h</filename>.  Detailed documentation
for each hook is included in this header file.  At present, this
structure consists of a collection of substructures that group related
hooks based on the kernel object (e.g. task, inode, file, sk_buff,
etc) as well as some top-level hook function pointers for system
operations.  This structure is likely to be flattened in the future
for performance.  The placement of the hook calls in the kernel code
is described by the "called:" lines in the per-hook documentation in
the header file.  The hook calls can also be easily found in the
kernel code by looking for the string "security_ops-&gt;".

</para>
        <para>
Linus mentioned per-process security hooks in his original remarks as a
possible alternative to global security hooks.  However, if LSM were
to start from the perspective of per-process hooks, then the base
framework would have to deal with how to handle operations that
involve multiple processes (e.g. kill), since each process might have
its own hook for controlling the operation.  This would require a
general mechanism for composing hooks in the base framework.
Additionally, LSM would still need global hooks for operations that
have no process context (e.g. network input operations).
Consequently, LSM provides global security hooks, but a security
module is free to implement per-process hooks (where that makes sense)
by storing a security_ops table in each process' security field and
then invoking these per-process hooks from the global hooks.
The problem of composition is thus deferred to the module.
</para>
        <para>
The global security_ops table is initialized to a set of hook
functions provided by a dummy security module that provides
traditional superuser logic.  A <function>register_security</function>
function (in <filename>security/security.c</filename>) is provided to
allow a security module to set security_ops to refer to its own hook
functions, and an <function>unregister_security</function> function is
provided to revert security_ops to the dummy module hooks.  This
mechanism is used to set the primary security module, which is
responsible for making the final decision for each hook.
</para>
        <para>
LSM also provides a simple mechanism for stacking additional security
modules with the primary security module.  It defines
<function>register_security</function> and
<function>unregister_security</function> hooks in the
<structname>security_operations</structname> structure and provides
<function>mod_reg_security</function> and
<function>mod_unreg_security</function> functions that invoke these
hooks after performing some sanity checking.  A security module can
call these functions in order to stack with other modules.  However,
the actual details of how this stacking is handled are deferred to the
module, which can implement these hooks in any way it wishes
(including always returning an error if it does not wish to support
stacking).  In this manner, LSM again defers the problem of
composition to the module.
</para>
        <para>
Although the LSM hooks are organized into substructures based on
kernel object, all of the hooks can be viewed as falling into two
major categories: hooks that are used to manage the security fields
and hooks that are used to perform access control.  Examples of the
first category of hooks include the
<function>alloc_security</function> and
<function>free_security</function> hooks defined for each kernel data
structure that has a security field.  These hooks are used to allocate
and free security structures for kernel objects.  The first category
of hooks also includes hooks that set information in the security
field after allocation, such as the <function>post_lookup</function>
hook in <structname>struct inode_security_ops</structname>.  This hook
is used to set security information for inodes after successful lookup
operations.  An example of the second category of hooks is the
<function>permission</function> hook in 
<structname>struct inode_security_ops</structname>.  This hook checks
permission when accessing an inode.
</para>
      </sect1>
      <sect1 id="cap">
        <title>LSM Capabilities Module</title>
        <para>
The LSM kernel patch moves most of the existing POSIX.1e capabilities
logic into an optional security module stored in the file
<filename>security/capability.c</filename>.  This change allows
users who do not want to use capabilities to omit this code entirely
from their kernel, instead using the dummy module for traditional
superuser logic or any other module that they desire.  This change
also allows the developers of the capabilities logic to maintain and
enhance their code more freely, without needing to integrate patches
back into the base kernel.
</para>
        <para>
In addition to moving the capabilities logic, the LSM kernel patch
could move the capability-related fields from the kernel data
structures into the new security fields managed by the security
modules.  However, at present, the LSM kernel patch leaves the
capability fields in the kernel data structures.  In his original
remarks, Linus suggested that this might be preferable so that other
security modules can be easily stacked with the capabilities module
without needing to chain multiple security structures on the security field.
It also avoids imposing extra overhead on the capabilities module
to manage the security fields.  However, the LSM framework could
certainly support such a move if it is determined to be desirable,
with only a few additional changes described below.
</para>
        <para>
At present, the capabilities logic for computing process capabilities
on <function>execve</function> and <function>set*uid</function>,
checking capabilities for a particular process, saving and checking
capabilities for netlink messages, and handling the
<function>capget</function> and <function>capset</function> system
calls have been moved into the capabilities module.  There are still a
few locations in the base kernel where capability-related fields are
directly examined or modified, but the current version of the LSM
patch does allow a security module to completely replace the
assignment and testing of capabilities.  These few locations would
need to be changed if the capability-related fields were moved into
the security field.  The following is a list of known locations that
still perform such direct examination or modification of
capability-related fields:
<itemizedlist><listitem><para><filename>fs/open.c</filename>:<function>sys_access</function></para></listitem><listitem><para><filename>fs/lockd/host.c</filename>:<function>nlm_bind_host</function></para></listitem><listitem><para><filename>fs/nfsd/auth.c</filename>:<function>nfsd_setuser</function></para></listitem><listitem><para><filename>fs/proc/array.c</filename>:<function>task_cap</function></para></listitem></itemizedlist></para>
      </sect1>
    </article>
    <book id="media_api">
      <bookinfo>
        <title>LINUX MEDIA INFRASTRUCTURE API</title>
        <copyright>
          <year>2009-2012</year>
          <holder>LinuxTV Developers</holder>
        </copyright>
        <legalnotice>
          <para>Permission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation License,
Version 1.1 or any later version published by the Free Software
Foundation. A copy of the license is included in the chapter entitled
"GNU Free Documentation License"</para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <!-- autogenerated -->
      <preface>
        <title>Introduction</title>
        <para>This document covers the Linux Kernel to Userspace API's used by
		video and radio straming devices, including video cameras,
		analog and digital TV receiver cards, AM/FM receiver cards,
		streaming capture devices.</para>
        <para>It is divided into four parts.</para>
        <para>The first part covers radio, capture,
		cameras and analog TV devices.</para>
        <para>The second part covers the
		API used for digital TV and Internet reception via one of the
		several digital tv standards. While it is called as DVB API,
		in fact it covers several different video standards including
		DVB-T, DVB-S, DVB-C and ATSC. The API is currently being updated
		to documment support also for DVB-S2, ISDB-T and ISDB-S.</para>
        <para>The third part covers the Remote Controller API.</para>
        <para>The fourth part covers the Media Controller API.</para>
        <para>For additional information and for the latest development code,
		see: <ulink url="http://linuxtv.org">http://linuxtv.org</ulink>.</para>
        <para>For discussing improvements, reporting troubles, sending new drivers, etc, please mail to: <ulink url="http://vger.kernel.org/vger-lists.html#linux-media">Linux Media Mailing List (LMML).</ulink>.</para>
      </preface>
      <part id="v4l2spec">
      </part>
      <part id="dvbapi">
      </part>
      <part id="v4ldvb_common">
        <partinfo>
          <authorgroup>
            <author>
              <firstname>Mauro</firstname>
              <surname>Chehab</surname>
              <othername role="mi">Carvalho</othername>
              <affiliation>
                <address>
                  <email>mchehab@redhat.com</email>
                </address>
              </affiliation>
              <contrib>Initial version.</contrib>
            </author>
          </authorgroup>
          <copyright>
            <year>2009-2012</year>
            <holder>Mauro Carvalho Chehab</holder>
          </copyright>
          <revhistory>
            <!-- Put document revisions here, newest first. -->
            <revision>
              <revnumber>1.0.0</revnumber>
              <date>2009-09-06</date>
              <authorinitials>mcc</authorinitials>
              <revremark>Initial revision</revremark>
            </revision>
          </revhistory>
        </partinfo>
        <title>Remote Controller API</title>
        <chapter id="remote_controllers">
        </chapter>
      </part>
      <part id="media_common">
      </part>
      <chapter id="gen_errors">
      </chapter>
    </book>
    <book id="MTD-NAND-Guide">
      <bookinfo>
        <title>MTD NAND Driver Programming Interface</title>
        <authorgroup>
          <author>
            <firstname>Thomas</firstname>
            <surname>Gleixner</surname>
            <affiliation>
              <address>
                <email>tglx@linutronix.de</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2004</year>
          <holder>Thomas Gleixner</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
  	The generic NAND driver supports almost all NAND and AG-AND based
	chips and connects them to the Memory Technology Devices (MTD)
	subsystem of the Linux Kernel.
  </para>
        <para>
  	This documentation is provided for developers who want to implement
	board drivers or filesystem drivers suitable for NAND devices.
  </para>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs And Assumptions</title>
        <para>
	None.	
  </para>
      </chapter>
      <chapter id="dochints">
        <title>Documentation hints</title>
        <para>
     The function and structure docs are autogenerated. Each function and 
     struct member has a short description which is marked with an [XXX] identifier.
     The following chapters explain the meaning of those identifiers.
     </para>
        <sect1 id="Function_identifiers_XXX">
          <title>Function identifiers [XXX]</title>
          <para>
	The functions are marked with [XXX] identifiers in the short
	comment. The identifiers explain the usage and scope of the
	functions. Following identifiers are used:
     	</para>
          <itemizedlist>
            <listitem>
              <para>
	  	[MTD Interface]</para>
              <para>
		These functions provide the interface to the MTD kernel API. 
		They are not replacable and provide functionality
		which is complete hardware independent.
		</para>
            </listitem>
            <listitem>
              <para>
	  	[NAND Interface]</para>
              <para>
		These functions are exported and provide the interface to the NAND kernel API. 
		</para>
            </listitem>
            <listitem>
              <para>
	  	[GENERIC]</para>
              <para>
		Generic functions are not replacable and provide functionality
		which is complete hardware independent.
		</para>
            </listitem>
            <listitem>
              <para>
	  	[DEFAULT]</para>
              <para>
		Default functions provide hardware related functionality which is suitable
		for most of the implementations. These functions can be replaced by the
		board driver if neccecary. Those functions are called via pointers in the
		NAND chip description structure. The board driver can set the functions which
		should be replaced by board dependent functions before calling nand_scan().
		If the function pointer is NULL on entry to nand_scan() then the pointer
		is set to the default function which is suitable for the detected chip type.
		</para>
            </listitem>
          </itemizedlist>
        </sect1>
        <sect1 id="Struct_member_identifiers_XXX">
          <title>Struct member identifiers [XXX]</title>
          <para>
	The struct members are marked with [XXX] identifiers in the 
	comment. The identifiers explain the usage and scope of the
	members. Following identifiers are used:
     	</para>
          <itemizedlist>
            <listitem>
              <para>
	  	[INTERN]</para>
              <para>
		These members are for NAND driver internal use only and must not be
		modified. Most of these values are calculated from the chip geometry
		information which is evaluated during nand_scan().
		</para>
            </listitem>
            <listitem>
              <para>
	  	[REPLACEABLE]</para>
              <para>
		Replaceable members hold hardware related functions which can be 
		provided by the board driver. The board driver can set the functions which
		should be replaced by board dependent functions before calling nand_scan().
		If the function pointer is NULL on entry to nand_scan() then the pointer
		is set to the default function which is suitable for the detected chip type.
		</para>
            </listitem>
            <listitem>
              <para>
	  	[BOARDSPECIFIC]</para>
              <para>
		Board specific members hold hardware related information which must
		be provided by the board driver. The board driver must set the function
		pointers and datafields before calling nand_scan().
		</para>
            </listitem>
            <listitem>
              <para>
	  	[OPTIONAL]</para>
              <para>
		Optional members can hold information relevant for the board driver. The
		generic NAND driver code does not use this information.
		</para>
            </listitem>
          </itemizedlist>
        </sect1>
      </chapter>
      <chapter id="basicboarddriver">
        <title>Basic board driver</title>
        <para>
		For most boards it will be sufficient to provide just the
		basic functions and fill out some really board dependent
		members in the nand chip description structure.
	</para>
        <sect1 id="Basic_defines">
          <title>Basic defines</title>
          <para>
			At least you have to provide a mtd structure and
			a storage for the ioremap'ed chip address.
			You can allocate the mtd structure using kmalloc
			or you can allocate it statically.
			In case of static allocation you have to allocate
			a nand_chip structure too.
		</para>
          <para>
			Kmalloc based example
		</para>
          <programlisting>
static struct mtd_info *board_mtd;
static void __iomem *baseaddr;
		</programlisting>
          <para>
			Static example
		</para>
          <programlisting>
static struct mtd_info board_mtd;
static struct nand_chip board_chip;
static void __iomem *baseaddr;
		</programlisting>
        </sect1>
        <sect1 id="Partition_defines">
          <title>Partition defines</title>
          <para>
			If you want to divide your device into partitions, then
			define a partitioning scheme suitable to your board.
		</para>
          <programlisting>
#define NUM_PARTITIONS 2
static struct mtd_partition partition_info[] = {
	{ .name = "Flash partition 1",
	  .offset =  0,
	  .size =    8 * 1024 * 1024 },
	{ .name = "Flash partition 2",
	  .offset =  MTDPART_OFS_NEXT,
	  .size =    MTDPART_SIZ_FULL },
};
		</programlisting>
        </sect1>
        <sect1 id="Hardware_control_functions">
          <title>Hardware control function</title>
          <para>
			The hardware control function provides access to the 
			control pins of the NAND chip(s). 
			The access can be done by GPIO pins or by address lines.
			If you use address lines, make sure that the timing
			requirements are met.
		</para>
          <para>
            <emphasis>GPIO based example</emphasis>
          </para>
          <programlisting>
static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
	switch(cmd){
		case NAND_CTL_SETCLE: /* Set CLE pin high */ break;
		case NAND_CTL_CLRCLE: /* Set CLE pin low */ break;
		case NAND_CTL_SETALE: /* Set ALE pin high */ break;
		case NAND_CTL_CLRALE: /* Set ALE pin low */ break;
		case NAND_CTL_SETNCE: /* Set nCE pin low */ break;
		case NAND_CTL_CLRNCE: /* Set nCE pin high */ break;
	}
}
		</programlisting>
          <para>
            <emphasis>Address lines based example.</emphasis> It's assumed that the
			nCE pin is driven by a chip select decoder.
		</para>
          <programlisting>
static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
	struct nand_chip *this = (struct nand_chip *) mtd-&gt;priv;
	switch(cmd){
		case NAND_CTL_SETCLE: this-&gt;IO_ADDR_W |= CLE_ADRR_BIT;  break;
		case NAND_CTL_CLRCLE: this-&gt;IO_ADDR_W &amp;= ~CLE_ADRR_BIT; break;
		case NAND_CTL_SETALE: this-&gt;IO_ADDR_W |= ALE_ADRR_BIT;  break;
		case NAND_CTL_CLRALE: this-&gt;IO_ADDR_W &amp;= ~ALE_ADRR_BIT; break;
	}
}
		</programlisting>
        </sect1>
        <sect1 id="Device_ready_function">
          <title>Device ready function</title>
          <para>
			If the hardware interface has the ready busy pin of the NAND chip connected to a
			GPIO or other accessible I/O pin, this function is used to read back the state of the
			pin. The function has no arguments and should return 0, if the device is busy (R/B pin 
			is low) and 1, if the device is ready (R/B pin is high).
			If the hardware interface does not give access to the ready busy pin, then
			the function must not be defined and the function pointer this-&gt;dev_ready is set to NULL.		
		</para>
        </sect1>
        <sect1 id="Init_function">
          <title>Init function</title>
          <para>
			The init function allocates memory and sets up all the board
			specific parameters and function pointers. When everything
			is set up nand_scan() is called. This function tries to
			detect and identify then chip. If a chip is found all the
			internal data fields are initialized accordingly.
			The structure(s) have to be zeroed out first and then filled with the neccecary 
			information about the device.
		</para>
          <programlisting>
static int __init board_init (void)
{
	struct nand_chip *this;
	int err = 0;

	/* Allocate memory for MTD device structure and private data */
	board_mtd = kzalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
	if (!board_mtd) {
		printk ("Unable to allocate NAND MTD device structure.\n");
		err = -ENOMEM;
		goto out;
	}

	/* map physical address */
	baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024);
	if (!baseaddr) {
		printk("Ioremap to access NAND chip failed\n");
		err = -EIO;
		goto out_mtd;
	}

	/* Get pointer to private data */
	this = (struct nand_chip *) ();
	/* Link the private data with the MTD structure */
	board_mtd-&gt;priv = this;

	/* Set address of NAND IO lines */
	this-&gt;IO_ADDR_R = baseaddr;
	this-&gt;IO_ADDR_W = baseaddr;
	/* Reference hardware control function */
	this-&gt;hwcontrol = board_hwcontrol;
	/* Set command delay time, see datasheet for correct value */
	this-&gt;chip_delay = CHIP_DEPENDEND_COMMAND_DELAY;
	/* Assign the device ready function, if available */
	this-&gt;dev_ready = board_dev_ready;
	this-&gt;eccmode = NAND_ECC_SOFT;

	/* Scan to find existence of the device */
	if (nand_scan (board_mtd, 1)) {
		err = -ENXIO;
		goto out_ior;
	}
	
	add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS);
	goto out;

out_ior:
	iounmap(baseaddr);
out_mtd:
	kfree (board_mtd);
out:
	return err;
}
module_init(board_init);
		</programlisting>
        </sect1>
        <sect1 id="Exit_function">
          <title>Exit function</title>
          <para>
			The exit function is only neccecary if the driver is
			compiled as a module. It releases all resources which
			are held by the chip driver and unregisters the partitions
			in the MTD layer.
		</para>
          <programlisting>
#ifdef MODULE
static void __exit board_cleanup (void)
{
	/* Release resources, unregister device */
	nand_release (board_mtd);

	/* unmap physical address */
	iounmap(baseaddr);
	
	/* Free the MTD device structure */
	kfree (board_mtd);
}
module_exit(board_cleanup);
#endif
		</programlisting>
        </sect1>
      </chapter>
      <chapter id="boarddriversadvanced">
        <title>Advanced board driver functions</title>
        <para>
		This chapter describes the advanced functionality of the NAND
		driver. For a list of functions which can be overridden by the board
		driver see the documentation of the nand_chip structure.
	</para>
        <sect1 id="Multiple_chip_control">
          <title>Multiple chip control</title>
          <para>
			The nand driver can control chip arrays. Therefore the
			board driver must provide an own select_chip function. This
			function must (de)select the requested chip.
			The function pointer in the nand_chip structure must
			be set before calling nand_scan(). The maxchip parameter
			of nand_scan() defines the maximum number of chips to
			scan for. Make sure that the select_chip function can
			handle the requested number of chips.
		</para>
          <para>
			The nand driver concatenates the chips to one virtual
			chip and provides this virtual chip to the MTD layer.
		</para>
          <para>
            <emphasis>Note: The driver can only handle linear chip arrays
			of equally sized chips. There is no support for
			parallel arrays which extend the buswidth.</emphasis>
          </para>
          <para>
            <emphasis>GPIO based example</emphasis>
          </para>
          <programlisting>
static void board_select_chip (struct mtd_info *mtd, int chip)
{
	/* Deselect all chips, set all nCE pins high */
	GPIO(BOARD_NAND_NCE) |= 0xff;	
	if (chip &gt;= 0)
		GPIO(BOARD_NAND_NCE) &amp;= ~ (1 &lt;&lt; chip);
}
		</programlisting>
          <para>
            <emphasis>Address lines based example.</emphasis>
			Its assumed that the nCE pins are connected to an
			address decoder.
		</para>
          <programlisting>
static void board_select_chip (struct mtd_info *mtd, int chip)
{
	struct nand_chip *this = (struct nand_chip *) mtd-&gt;priv;
	
	/* Deselect all chips */
	this-&gt;IO_ADDR_R &amp;= ~BOARD_NAND_ADDR_MASK;
	this-&gt;IO_ADDR_W &amp;= ~BOARD_NAND_ADDR_MASK;
	switch (chip) {
	case 0:
		this-&gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0;
		this-&gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0;
		break;
	....	
	case n:
		this-&gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn;
		this-&gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn;
		break;
	}	
}
		</programlisting>
        </sect1>
        <sect1 id="Hardware_ECC_support">
          <title>Hardware ECC support</title>
          <sect2 id="Functions_and_constants">
            <title>Functions and constants</title>
            <para>
				The nand driver supports three different types of
				hardware ECC.
				<itemizedlist><listitem><para>NAND_ECC_HW3_256</para><para>
				Hardware ECC generator providing 3 bytes ECC per
				256 byte.
				</para></listitem><listitem><para>NAND_ECC_HW3_512</para><para>
				Hardware ECC generator providing 3 bytes ECC per
				512 byte.
				</para></listitem><listitem><para>NAND_ECC_HW6_512</para><para>
				Hardware ECC generator providing 6 bytes ECC per
				512 byte.
				</para></listitem><listitem><para>NAND_ECC_HW8_512</para><para>
				Hardware ECC generator providing 6 bytes ECC per
				512 byte.
				</para></listitem></itemizedlist>
				If your hardware generator has a different functionality
				add it at the appropriate place in nand_base.c
			</para>
            <para>
				The board driver must provide following functions:
				<itemizedlist><listitem><para>enable_hwecc</para><para>
				This function is called before reading / writing to
				the chip. Reset or initialize the hardware generator
				in this function. The function is called with an
				argument which let you distinguish between read 
				and write operations.
				</para></listitem><listitem><para>calculate_ecc</para><para>
				This function is called after read / write from / to
				the chip. Transfer the ECC from the hardware to
				the buffer. If the option NAND_HWECC_SYNDROME is set
				then the function is only called on write. See below.
				</para></listitem><listitem><para>correct_data</para><para>
				In case of an ECC error this function is called for
				error detection and correction. Return 1 respectively 2
				in case the error can be corrected. If the error is
				not correctable return -1. If your hardware generator
				matches the default algorithm of the nand_ecc software
				generator then use the correction function provided
				by nand_ecc instead of implementing duplicated code.
				</para></listitem></itemizedlist></para>
          </sect2>
          <sect2 id="Hardware_ECC_with_syndrome_calculation">
            <title>Hardware ECC with syndrome calculation</title>
            <para>
				Many hardware ECC implementations provide Reed-Solomon
				codes and calculate an error syndrome on read. The syndrome
				must be converted to a standard Reed-Solomon syndrome
				before calling the error correction code in the generic
				Reed-Solomon library.
			</para>
            <para>
				The ECC bytes must be placed immediately after the data
				bytes in order to make the syndrome generator work. This
				is contrary to the usual layout used by software ECC. The
				separation of data and out of band area is not longer
				possible. The nand driver code handles this layout and
				the remaining free bytes in the oob area are managed by 
				the autoplacement code. Provide a matching oob-layout
				in this case. See rts_from4.c and diskonchip.c for 
				implementation reference. In those cases we must also
				use bad block tables on FLASH, because the ECC layout is
				interferring with the bad block marker positions.
				See bad block table support for details.
			</para>
          </sect2>
        </sect1>
        <sect1 id="Bad_Block_table_support">
          <title>Bad block table support</title>
          <para>
			Most NAND chips mark the bad blocks at a defined
			position in the spare area. Those blocks must 
			not be erased under any circumstances as the bad 
			block information would be lost.
			It is possible to check the bad block mark each
			time when the blocks are accessed by reading the
			spare area of the first page in the block. This
			is time consuming so a bad block table is used.
		</para>
          <para>
			The nand driver supports various types of bad block
			tables.
			<itemizedlist><listitem><para>Per device</para><para>
			The bad block table contains all bad block information
			of the device which can consist of multiple chips.
			</para></listitem><listitem><para>Per chip</para><para>
			A bad block table is used per chip and contains the
			bad block information for this particular chip.
			</para></listitem><listitem><para>Fixed offset</para><para>
			The bad block table is located at a fixed offset
			in the chip (device). This applies to various
			DiskOnChip devices.
			</para></listitem><listitem><para>Automatic placed</para><para>
			The bad block table is automatically placed and
			detected either at the end or at the beginning
			of a chip (device)
			</para></listitem><listitem><para>Mirrored tables</para><para>
			The bad block table is mirrored on the chip (device) to
			allow updates of the bad block table without data loss.
			</para></listitem></itemizedlist></para>
          <para>	
			nand_scan() calls the function nand_default_bbt(). 
			nand_default_bbt() selects appropriate default
			bad block table desriptors depending on the chip information
			which was retrieved by nand_scan().
		</para>
          <para>
			The standard policy is scanning the device for bad 
			blocks and build a ram based bad block table which
			allows faster access than always checking the
			bad block information on the flash chip itself.
		</para>
          <sect2 id="Flash_based_tables">
            <title>Flash based tables</title>
            <para>
				It may be desired or neccecary to keep a bad block table in FLASH. 
				For AG-AND chips this is mandatory, as they have no factory marked
				bad blocks. They have factory marked good blocks. The marker pattern
				is erased when the block is erased to be reused. So in case of
				powerloss before writing the pattern back to the chip this block 
				would be lost and added to the bad blocks. Therefore we scan the 
				chip(s) when we detect them the first time for good blocks and 
				store this information in a bad block table before erasing any 
				of the blocks.
			</para>
            <para>
				The blocks in which the tables are stored are procteted against
				accidental access by marking them bad in the memory bad block
				table. The bad block table management functions are allowed
				to circumvernt this protection.
			</para>
            <para>
				The simplest way to activate the FLASH based bad block table support 
				is to set the option NAND_BBT_USE_FLASH in the bbt_option field of
				the nand chip structure before calling nand_scan(). For AG-AND
				chips is this done by default.
				This activates the default FLASH based bad block table functionality 
				of the NAND driver. The default bad block table options are
				<itemizedlist><listitem><para>Store bad block table per chip</para></listitem><listitem><para>Use 2 bits per block</para></listitem><listitem><para>Automatic placement at the end of the chip</para></listitem><listitem><para>Use mirrored tables with version numbers</para></listitem><listitem><para>Reserve 4 blocks at the end of the chip</para></listitem></itemizedlist></para>
          </sect2>
          <sect2 id="User_defined_tables">
            <title>User defined tables</title>
            <para>
				User defined tables are created by filling out a 
				nand_bbt_descr structure and storing the pointer in the
				nand_chip structure member bbt_td before calling nand_scan(). 
				If a mirror table is neccecary a second structure must be
				created and a pointer to this structure must be stored
				in bbt_md inside the nand_chip structure. If the bbt_md 
				member is set to NULL then only the main table is used
				and no scan for the mirrored table is performed.
			</para>
            <para>
				The most important field in the nand_bbt_descr structure
				is the options field. The options define most of the 
				table properties. Use the predefined constants from
				nand.h to define the options.
				<itemizedlist><listitem><para>Number of bits per block</para><para>The supported number of bits is 1, 2, 4, 8.</para></listitem><listitem><para>Table per chip</para><para>Setting the constant NAND_BBT_PERCHIP selects that
				a bad block table is managed for each chip in a chip array.
				If this option is not set then a per device bad block table
				is used.</para></listitem><listitem><para>Table location is absolute</para><para>Use the option constant NAND_BBT_ABSPAGE and
				define the absolute page number where the bad block
				table starts in the field pages. If you have selected bad block
				tables per chip and you have a multi chip array then the start page
				must be given for each chip in the chip array. Note: there is no scan
				for a table ident pattern performed, so the fields 
				pattern, veroffs, offs, len can be left uninitialized</para></listitem><listitem><para>Table location is automatically detected</para><para>The table can either be located in the first or the last good
				blocks of the chip (device). Set NAND_BBT_LASTBLOCK to place
				the bad block table at the end of the chip (device). The
				bad block tables are marked and identified by a pattern which
				is stored in the spare area of the first page in the block which
				holds the bad block table. Store a pointer to the pattern  
				in the pattern field. Further the length of the pattern has to be 
				stored in len and the offset in the spare area must be given
				in the offs member of the nand_bbt_descr structure. For mirrored
				bad block tables different patterns are mandatory.</para></listitem><listitem><para>Table creation</para><para>Set the option NAND_BBT_CREATE to enable the table creation
				if no table can be found during the scan. Usually this is done only 
				once if a new chip is found. </para></listitem><listitem><para>Table write support</para><para>Set the option NAND_BBT_WRITE to enable the table write support.
				This allows the update of the bad block table(s) in case a block has
				to be marked bad due to wear. The MTD interface function block_markbad
				is calling the update function of the bad block table. If the write
				support is enabled then the table is updated on FLASH.</para><para>
				Note: Write support should only be enabled for mirrored tables with
				version control.
				</para></listitem><listitem><para>Table version control</para><para>Set the option NAND_BBT_VERSION to enable the table version control.
				It's highly recommended to enable this for mirrored tables with write
				support. It makes sure that the risk of losing the bad block
				table information is reduced to the loss of the information about the
				one worn out block which should be marked bad. The version is stored in
				4 consecutive bytes in the spare area of the device. The position of
				the version number is defined by the member veroffs in the bad block table
				descriptor.</para></listitem><listitem><para>Save block contents on write</para><para>
				In case that the block which holds the bad block table does contain
				other useful information, set the option NAND_BBT_SAVECONTENT. When
				the bad block table is written then the whole block is read the bad
				block table is updated and the block is erased and everything is 
				written back. If this option is not set only the bad block table
				is written and everything else in the block is ignored and erased.
				</para></listitem><listitem><para>Number of reserved blocks</para><para>
				For automatic placement some blocks must be reserved for
				bad block table storage. The number of reserved blocks is defined 
				in the maxblocks member of the babd block table description structure.
				Reserving 4 blocks for mirrored tables should be a reasonable number. 
				This also limits the number of blocks which are scanned for the bad
				block table ident pattern.
				</para></listitem></itemizedlist></para>
          </sect2>
        </sect1>
        <sect1 id="Spare_area_placement">
          <title>Spare area (auto)placement</title>
          <para>
			The nand driver implements different possibilities for
			placement of filesystem data in the spare area, 
			<itemizedlist><listitem><para>Placement defined by fs driver</para></listitem><listitem><para>Automatic placement</para></listitem></itemizedlist>
			The default placement function is automatic placement. The
			nand driver has built in default placement schemes for the
			various chiptypes. If due to hardware ECC functionality the
			default placement does not fit then the board driver can
			provide a own placement scheme.
		</para>
          <para>
			File system drivers can provide a own placement scheme which
			is used instead of the default placement scheme.
		</para>
          <para>
			Placement schemes are defined by a nand_oobinfo structure
	     		<programlisting>
struct nand_oobinfo {
	int	useecc;
	int	eccbytes;
	int	eccpos[24];
	int	oobfree[8][2];
};
	     		</programlisting><itemizedlist><listitem><para>useecc</para><para>
				The useecc member controls the ecc and placement function. The header
				file include/mtd/mtd-abi.h contains constants to select ecc and
				placement. MTD_NANDECC_OFF switches off the ecc complete. This is
				not recommended and available for testing and diagnosis only.
				MTD_NANDECC_PLACE selects caller defined placement, MTD_NANDECC_AUTOPLACE
				selects automatic placement.
			</para></listitem><listitem><para>eccbytes</para><para>
				The eccbytes member defines the number of ecc bytes per page.
			</para></listitem><listitem><para>eccpos</para><para>
				The eccpos array holds the byte offsets in the spare area where
				the ecc codes are placed.
			</para></listitem><listitem><para>oobfree</para><para>
				The oobfree array defines the areas in the spare area which can be
				used for automatic placement. The information is given in the format
				{offset, size}. offset defines the start of the usable area, size the
				length in bytes. More than one area can be defined. The list is terminated
				by an {0, 0} entry.
			</para></listitem></itemizedlist></para>
          <sect2 id="Placement_defined_by_fs_driver">
            <title>Placement defined by fs driver</title>
            <para>
				The calling function provides a pointer to a nand_oobinfo
				structure which defines the ecc placement. For writes the
				caller must provide a spare area buffer along with the
				data buffer. The spare area buffer size is (number of pages) *
				(size of spare area). For reads the buffer size is
				(number of pages) * ((size of spare area) + (number of ecc
				steps per page) * sizeof (int)). The driver stores the
				result of the ecc check for each tuple in the spare buffer.
				The storage sequence is 
			</para>
            <para>
				&lt;spare data page 0&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;
			</para>
            <para>
				...
			</para>
            <para>
				&lt;spare data page n&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;
			</para>
            <para>
				This is a legacy mode used by YAFFS1.
			</para>
            <para>
				If the spare area buffer is NULL then only the ECC placement is
				done according to the given scheme in the nand_oobinfo structure.
			</para>
          </sect2>
          <sect2 id="Automatic_placement">
            <title>Automatic placement</title>
            <para>
				Automatic placement uses the built in defaults to place the
				ecc bytes in the spare area. If filesystem data have to be stored /
				read into the spare area then the calling function must provide a
				buffer. The buffer size per page is determined by the oobfree array in
				the nand_oobinfo structure.
			</para>
            <para>
				If the spare area buffer is NULL then only the ECC placement is
				done according to the default builtin scheme.
			</para>
          </sect2>
        </sect1>
        <sect1 id="Spare_area_autoplacement_default">
          <title>Spare area autoplacement default schemes</title>
          <sect2 id="pagesize_256">
            <title>256 byte pagesize</title>
            <informaltable>
              <tgroup cols="3">
                <tbody>
                  <row>
                    <entry>Offset</entry>
                    <entry>Content</entry>
                    <entry>Comment</entry>
                  </row>
                  <row>
                    <entry>0x00</entry>
                    <entry>ECC byte 0</entry>
                    <entry>Error correction code byte 0</entry>
                  </row>
                  <row>
                    <entry>0x01</entry>
                    <entry>ECC byte 1</entry>
                    <entry>Error correction code byte 1</entry>
                  </row>
                  <row>
                    <entry>0x02</entry>
                    <entry>ECC byte 2</entry>
                    <entry>Error correction code byte 2</entry>
                  </row>
                  <row>
                    <entry>0x03</entry>
                    <entry>Autoplace 0</entry>
                    <entry>
                    </entry>
                  </row>
                  <row>
                    <entry>0x04</entry>
                    <entry>Autoplace 1</entry>
                    <entry>
                    </entry>
                  </row>
                  <row>
                    <entry>0x05</entry>
                    <entry>Bad block marker</entry>
                    <entry>If any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved</entry>
                  </row>
                  <row>
                    <entry>0x06</entry>
                    <entry>Autoplace 2</entry>
                    <entry>
                    </entry>
                  </row>
                  <row>
                    <entry>0x07</entry>
                    <entry>Autoplace 3</entry>
                    <entry>
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </sect2>
          <sect2 id="pagesize_512">
            <title>512 byte pagesize</title>
            <informaltable>
              <tgroup cols="3">
                <tbody>
                  <row>
                    <entry>Offset</entry>
                    <entry>Content</entry>
                    <entry>Comment</entry>
                  </row>
                  <row>
                    <entry>0x00</entry>
                    <entry>ECC byte 0</entry>
                    <entry>Error correction code byte 0 of the lower 256 Byte data in
this page</entry>
                  </row>
                  <row>
                    <entry>0x01</entry>
                    <entry>ECC byte 1</entry>
                    <entry>Error correction code byte 1 of the lower 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x02</entry>
                    <entry>ECC byte 2</entry>
                    <entry>Error correction code byte 2 of the lower 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x03</entry>
                    <entry>ECC byte 3</entry>
                    <entry>Error correction code byte 0 of the upper 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x04</entry>
                    <entry>reserved</entry>
                    <entry>reserved</entry>
                  </row>
                  <row>
                    <entry>0x05</entry>
                    <entry>Bad block marker</entry>
                    <entry>If any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved</entry>
                  </row>
                  <row>
                    <entry>0x06</entry>
                    <entry>ECC byte 4</entry>
                    <entry>Error correction code byte 1 of the upper 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x07</entry>
                    <entry>ECC byte 5</entry>
                    <entry>Error correction code byte 2 of the upper 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x08 - 0x0F</entry>
                    <entry>Autoplace 0 - 7</entry>
                    <entry>
                    </entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </sect2>
          <sect2 id="pagesize_2048">
            <title>2048 byte pagesize</title>
            <informaltable>
              <tgroup cols="3">
                <tbody>
                  <row>
                    <entry>Offset</entry>
                    <entry>Content</entry>
                    <entry>Comment</entry>
                  </row>
                  <row>
                    <entry>0x00</entry>
                    <entry>Bad block marker</entry>
                    <entry>If any bit in this byte is zero, then this block is bad.
This applies only to the first page in a block. In the remaining
pages this byte is reserved</entry>
                  </row>
                  <row>
                    <entry>0x01</entry>
                    <entry>Reserved</entry>
                    <entry>Reserved</entry>
                  </row>
                  <row>
                    <entry>0x02-0x27</entry>
                    <entry>Autoplace 0 - 37</entry>
                    <entry>
                    </entry>
                  </row>
                  <row>
                    <entry>0x28</entry>
                    <entry>ECC byte 0</entry>
                    <entry>Error correction code byte 0 of the first 256 Byte data in
this page</entry>
                  </row>
                  <row>
                    <entry>0x29</entry>
                    <entry>ECC byte 1</entry>
                    <entry>Error correction code byte 1 of the first 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x2A</entry>
                    <entry>ECC byte 2</entry>
                    <entry>Error correction code byte 2 of the first 256 Bytes data in
this page</entry>
                  </row>
                  <row>
                    <entry>0x2B</entry>
                    <entry>ECC byte 3</entry>
                    <entry>Error correction code byte 0 of the second 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x2C</entry>
                    <entry>ECC byte 4</entry>
                    <entry>Error correction code byte 1 of the second 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x2D</entry>
                    <entry>ECC byte 5</entry>
                    <entry>Error correction code byte 2 of the second 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x2E</entry>
                    <entry>ECC byte 6</entry>
                    <entry>Error correction code byte 0 of the third 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x2F</entry>
                    <entry>ECC byte 7</entry>
                    <entry>Error correction code byte 1 of the third 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x30</entry>
                    <entry>ECC byte 8</entry>
                    <entry>Error correction code byte 2 of the third 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x31</entry>
                    <entry>ECC byte 9</entry>
                    <entry>Error correction code byte 0 of the fourth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x32</entry>
                    <entry>ECC byte 10</entry>
                    <entry>Error correction code byte 1 of the fourth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x33</entry>
                    <entry>ECC byte 11</entry>
                    <entry>Error correction code byte 2 of the fourth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x34</entry>
                    <entry>ECC byte 12</entry>
                    <entry>Error correction code byte 0 of the fifth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x35</entry>
                    <entry>ECC byte 13</entry>
                    <entry>Error correction code byte 1 of the fifth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x36</entry>
                    <entry>ECC byte 14</entry>
                    <entry>Error correction code byte 2 of the fifth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x37</entry>
                    <entry>ECC byte 15</entry>
                    <entry>Error correction code byte 0 of the sixt 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x38</entry>
                    <entry>ECC byte 16</entry>
                    <entry>Error correction code byte 1 of the sixt 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x39</entry>
                    <entry>ECC byte 17</entry>
                    <entry>Error correction code byte 2 of the sixt 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x3A</entry>
                    <entry>ECC byte 18</entry>
                    <entry>Error correction code byte 0 of the seventh 256 Bytes of
data in this page</entry>
                  </row>
                  <row>
                    <entry>0x3B</entry>
                    <entry>ECC byte 19</entry>
                    <entry>Error correction code byte 1 of the seventh 256 Bytes of
data in this page</entry>
                  </row>
                  <row>
                    <entry>0x3C</entry>
                    <entry>ECC byte 20</entry>
                    <entry>Error correction code byte 2 of the seventh 256 Bytes of
data in this page</entry>
                  </row>
                  <row>
                    <entry>0x3D</entry>
                    <entry>ECC byte 21</entry>
                    <entry>Error correction code byte 0 of the eighth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x3E</entry>
                    <entry>ECC byte 22</entry>
                    <entry>Error correction code byte 1 of the eighth 256 Bytes of data
in this page</entry>
                  </row>
                  <row>
                    <entry>0x3F</entry>
                    <entry>ECC byte 23</entry>
                    <entry>Error correction code byte 2 of the eighth 256 Bytes of data
in this page</entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </sect2>
        </sect1>
      </chapter>
      <chapter id="filesystems">
        <title>Filesystem support</title>
        <para>
		The NAND driver provides all neccecary functions for a
		filesystem via the MTD interface.
	</para>
        <para>
		Filesystems must be aware of the NAND pecularities and
		restrictions. One major restrictions of NAND Flash is, that you cannot 
		write as often as you want to a page. The consecutive writes to a page, 
		before erasing it again, are restricted to 1-3 writes, depending on the 
		manufacturers specifications. This applies similar to the spare area. 
	</para>
        <para>
		Therefore NAND aware filesystems must either write in page size chunks
		or hold a writebuffer to collect smaller writes until they sum up to 
		pagesize. Available NAND aware filesystems: JFFS2, YAFFS. 		
	</para>
        <para>
		The spare area usage to store filesystem data is controlled by
		the spare area placement functionality which is described in one
		of the earlier chapters.
	</para>
      </chapter>
      <chapter id="tools">
        <title>Tools</title>
        <para>
		The MTD project provides a couple of helpful tools to handle NAND Flash.
		<itemizedlist><listitem><para>flasherase, flasheraseall: Erase and format FLASH partitions</para></listitem><listitem><para>nandwrite: write filesystem images to NAND FLASH</para></listitem><listitem><para>nanddump: dump the contents of a NAND FLASH partitions</para></listitem></itemizedlist></para>
        <para>
		These tools are aware of the NAND restrictions. Please use those tools
		instead of complaining about errors which are caused by non NAND aware
		access methods.
	</para>
      </chapter>
      <chapter id="defines">
        <title>Constants</title>
        <para>
     This chapter describes the constants which might be relevant for a driver developer.
     </para>
        <sect1 id="Chip_option_constants">
          <title>Chip option constants</title>
          <sect2 id="Constants_for_chip_id_table">
            <title>Constants for chip id table</title>
            <para>
		These constants are defined in nand.h. They are ored together to describe
		the chip functionality.
     		<programlisting>
/* Buswitdh is 16 bit */
#define NAND_BUSWIDTH_16	0x00000002
/* Device supports partial programming without padding */
#define NAND_NO_PADDING		0x00000004
/* Chip has cache program function */
#define NAND_CACHEPRG		0x00000008
/* Chip has copy back function */
#define NAND_COPYBACK		0x00000010
/* AND Chip which has 4 banks and a confusing page / block 
 * assignment. See Renesas datasheet for further information */
#define NAND_IS_AND		0x00000020
/* Chip has a array of 4 pages which can be read without
 * additional ready /busy waits */
#define NAND_4PAGE_ARRAY	0x00000040 
		</programlisting></para>
          </sect2>
          <sect2 id="Constants_for_runtime_options">
            <title>Constants for runtime options</title>
            <para>
		These constants are defined in nand.h. They are ored together to describe
		the functionality.
     		<programlisting>
/* The hw ecc generator provides a syndrome instead a ecc value on read 
 * This can only work if we have the ecc bytes directly behind the 
 * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
#define NAND_HWECC_SYNDROME	0x00020000
		</programlisting></para>
          </sect2>
        </sect1>
        <sect1 id="EEC_selection_constants">
          <title>ECC selection constants</title>
          <para>
	Use these constants to select the ECC algorithm.
  	<programlisting>
/* No ECC. Usage is not recommended ! */
#define NAND_ECC_NONE		0
/* Software ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_SOFT		1
/* Hardware ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_HW3_256	2
/* Hardware ECC 3 byte ECC per 512 Byte data */
#define NAND_ECC_HW3_512	3
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW6_512	4
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW8_512	6
	</programlisting></para>
        </sect1>
        <sect1 id="Hardware_control_related_constants">
          <title>Hardware control related constants</title>
          <para>
	These constants describe the requested hardware access function when
	the boardspecific hardware control function is called
  	<programlisting>
/* Select the chip by setting nCE to low */
#define NAND_CTL_SETNCE 	1
/* Deselect the chip by setting nCE to high */
#define NAND_CTL_CLRNCE		2
/* Select the command latch by setting CLE to high */
#define NAND_CTL_SETCLE		3
/* Deselect the command latch by setting CLE to low */
#define NAND_CTL_CLRCLE		4
/* Select the address latch by setting ALE to high */
#define NAND_CTL_SETALE		5
/* Deselect the address latch by setting ALE to low */
#define NAND_CTL_CLRALE		6
/* Set write protection by setting WP to high. Not used! */
#define NAND_CTL_SETWP		7
/* Clear write protection by setting WP to low. Not used! */
#define NAND_CTL_CLRWP		8
	</programlisting></para>
        </sect1>
        <sect1 id="Bad_block_table_constants">
          <title>Bad block table related constants</title>
          <para>
	These constants describe the options used for bad block
	table descriptors.
  	<programlisting>
/* Options for the bad block table descriptors */

/* The number of bits used per block in the bbt on the device */
#define NAND_BBT_NRBITS_MSK	0x0000000F
#define NAND_BBT_1BIT		0x00000001
#define NAND_BBT_2BIT		0x00000002
#define NAND_BBT_4BIT		0x00000004
#define NAND_BBT_8BIT		0x00000008
/* The bad block table is in the last good block of the device */
#define	NAND_BBT_LASTBLOCK	0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_ABSPAGE	0x00000020
/* bbt is stored per chip on multichip devices */
#define NAND_BBT_PERCHIP	0x00000080
/* bbt has a version counter at offset veroffs */
#define NAND_BBT_VERSION	0x00000100
/* Create a bbt if none axists */
#define NAND_BBT_CREATE		0x00000200
/* Write bbt if neccecary */
#define NAND_BBT_WRITE		0x00001000
/* Read and write back block contents when writing bbt */
#define NAND_BBT_SAVECONTENT	0x00002000
	</programlisting></para>
        </sect1>
      </chapter>
      <chapter id="structs">
        <title>Structures</title>
        <para>
     This chapter contains the autogenerated documentation of the structures which are
     used in the NAND driver and might be relevant for a driver developer. Each  
     struct member has a short description which is marked with an [XXX] identifier.
     See the chapter "Documentation hints" for an explanation.
     </para>
!Iinclude/linux/mtd/nand.h
  </chapter>
      <chapter id="pubfunctions">
        <title>Public Functions Provided</title>
        <para>
     This chapter contains the autogenerated documentation of the NAND kernel API functions
      which are exported. Each function has a short description which is marked with an [XXX] identifier.
     See the chapter "Documentation hints" for an explanation.
     </para>
!Edrivers/mtd/nand/nand_base.c
!Edrivers/mtd/nand/nand_bbt.c
!Edrivers/mtd/nand/nand_ecc.c
  </chapter>
      <chapter id="intfunctions">
        <title>Internal Functions Provided</title>
        <para>
     This chapter contains the autogenerated documentation of the NAND driver internal functions.
     Each function has a short description which is marked with an [XXX] identifier.
     See the chapter "Documentation hints" for an explanation.
     The functions marked with [DEFAULT] might be relevant for a board driver developer.
     </para>
!Idrivers/mtd/nand/nand_base.c
!Idrivers/mtd/nand/nand_bbt.c
<!-- No internal functions for kernel-doc:
X!Idrivers/mtd/nand/nand_ecc.c
--></chapter>
      <chapter id="credits">
        <title>Credits</title>
        <para>
		The following people have contributed to the NAND driver:
		<orderedlist><listitem><para>Steven J. Hill<email>sjhill@realitydiluted.com</email></para></listitem><listitem><para>David Woodhouse<email>dwmw2@infradead.org</email></para></listitem><listitem><para>Thomas Gleixner<email>tglx@linutronix.de</email></para></listitem></orderedlist>
		A lot of users have provided bugfixes, improvements and helping hands for testing.
		Thanks a lot.
	</para>
        <para>
		The following people have contributed to this document:
		<orderedlist><listitem><para>Thomas Gleixner<email>tglx@linutronix.de</email></para></listitem></orderedlist></para>
      </chapter>
    </book>
    <book id="LinuxNetworking">
      <bookinfo>
        <title>Linux Networking and Network Devices APIs</title>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="netcore">
        <title>Linux Networking</title>
        <sect1>
          <title>Networking Base Types</title>
!Iinclude/linux/net.h
     </sect1>
        <sect1>
          <title>Socket Buffer Functions</title>
!Iinclude/linux/skbuff.h
!Iinclude/net/sock.h
!Enet/socket.c
!Enet/core/skbuff.c
!Enet/core/sock.c
!Enet/core/datagram.c
!Enet/core/stream.c
     </sect1>
        <sect1>
          <title>Socket Filter</title>
!Enet/core/filter.c
     </sect1>
        <sect1>
          <title>Generic Network Statistics</title>
!Iinclude/uapi/linux/gen_stats.h
!Enet/core/gen_stats.c
!Enet/core/gen_estimator.c
     </sect1>
        <sect1>
          <title>SUN RPC subsystem</title>
          <!-- The !D functionality is not perfect, garbage has to be protected by comments
!Dnet/sunrpc/sunrpc_syms.c
-->
!Enet/sunrpc/xdr.c
!Enet/sunrpc/svc_xprt.c
!Enet/sunrpc/xprt.c
!Enet/sunrpc/sched.c
!Enet/sunrpc/socklib.c
!Enet/sunrpc/stats.c
!Enet/sunrpc/rpc_pipe.c
!Enet/sunrpc/rpcb_clnt.c
!Enet/sunrpc/clnt.c
     </sect1>
        <sect1>
          <title>WiMAX</title>
!Enet/wimax/op-msg.c
!Enet/wimax/op-reset.c
!Enet/wimax/op-rfkill.c
!Enet/wimax/stack.c
!Iinclude/net/wimax.h
!Iinclude/uapi/linux/wimax.h
     </sect1>
      </chapter>
      <chapter id="netdev">
        <title>Network device support</title>
        <sect1>
          <title>Driver Support</title>
!Enet/core/dev.c
!Enet/ethernet/eth.c
!Enet/sched/sch_generic.c
!Iinclude/linux/etherdevice.h
!Iinclude/linux/netdevice.h
     </sect1>
        <sect1>
          <title>PHY Support</title>
!Edrivers/net/phy/phy.c
!Idrivers/net/phy/phy.c
!Edrivers/net/phy/phy_device.c
!Idrivers/net/phy/phy_device.c
!Edrivers/net/phy/mdio_bus.c
!Idrivers/net/phy/mdio_bus.c
     </sect1>
        <!-- FIXME: Removed for now since no structured comments in source
     <sect1><title>Wireless</title>
X!Enet/core/wireless.c
     </sect1>
-->
      </chapter>
    </book>
    <book id="RapidIO-Guide">
      <bookinfo>
        <title>RapidIO Subsystem Guide</title>
        <authorgroup>
          <author>
            <firstname>Matt</firstname>
            <surname>Porter</surname>
            <affiliation>
              <address>
                <email>mporter@kernel.crashing.org</email>
                <email>mporter@mvista.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2005</year>
          <holder>MontaVista Software, Inc.</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
	RapidIO is a high speed switched fabric interconnect with
	features aimed at the embedded market.  RapidIO provides
	support for memory-mapped I/O as well as message-based
	transactions over the switched fabric network. RapidIO has
	a standardized discovery mechanism not unlike the PCI bus
	standard that allows simple detection of devices in a
	network.
  </para>
        <para>
  	This documentation is provided for developers intending
	to support RapidIO on new architectures, write new drivers,
	or to understand the subsystem internals.
  </para>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs and Limitations</title>
        <sect1 id="known_bugs">
          <title>Bugs</title>
          <para>None. ;)</para>
        </sect1>
        <sect1 id="Limitations">
          <title>Limitations</title>
          <para>
            <orderedlist>
              <listitem>
                <para>Access/management of RapidIO memory regions is not supported</para>
              </listitem>
              <listitem>
                <para>Multiple host enumeration is not supported</para>
              </listitem>
            </orderedlist>
          </para>
        </sect1>
      </chapter>
      <chapter id="drivers">
        <title>RapidIO driver interface</title>
        <para>
		Drivers are provided a set of calls in order
		to interface with the subsystem to gather info
		on devices, request/map memory region resources,
		and manage mailboxes/doorbells.
	</para>
        <sect1 id="Functions">
          <title>Functions</title>
!Iinclude/linux/rio_drv.h
!Edrivers/rapidio/rio-driver.c
!Edrivers/rapidio/rio.c
	</sect1>
      </chapter>
      <chapter id="internals">
        <title>Internals</title>
        <para>
     This chapter contains the autogenerated documentation of the RapidIO
     subsystem.
     </para>
        <sect1 id="Structures">
          <title>Structures</title>
!Iinclude/linux/rio.h
     </sect1>
        <sect1 id="Enumeration_and_Discovery">
          <title>Enumeration and Discovery</title>
!Idrivers/rapidio/rio-scan.c
     </sect1>
        <sect1 id="Driver_functionality">
          <title>Driver functionality</title>
!Idrivers/rapidio/rio.c
!Idrivers/rapidio/rio-access.c
     </sect1>
        <sect1 id="Device_model_support">
          <title>Device model support</title>
!Idrivers/rapidio/rio-driver.c
     </sect1>
        <sect1 id="Sysfs_support">
          <title>Sysfs support</title>
!Idrivers/rapidio/rio-sysfs.c
     </sect1>
        <sect1 id="PPC32_support">
          <title>PPC32 support</title>
!Iarch/powerpc/sysdev/fsl_rio.c
     </sect1>
      </chapter>
      <chapter id="credits">
        <title>Credits</title>
        <para>
		The following people have contributed to the RapidIO
		subsystem directly or indirectly:
		<orderedlist><listitem><para>Matt Porter<email>mporter@kernel.crashing.org</email></para></listitem><listitem><para>Randy Vinson<email>rvinson@mvista.com</email></para></listitem><listitem><para>Dan Malek<email>dan@embeddedalley.com</email></para></listitem></orderedlist></para>
        <para>
		The following people have contributed to this document:
		<orderedlist><listitem><para>Matt Porter<email>mporter@kernel.crashing.org</email></para></listitem></orderedlist></para>
      </chapter>
    </book>
    <book id="regulator-api">
      <bookinfo>
        <title>Voltage and current regulator API</title>
        <authorgroup>
          <author>
            <firstname>Liam</firstname>
            <surname>Girdwood</surname>
            <affiliation>
              <address>
                <email>lrg@slimlogic.co.uk</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>Mark</firstname>
            <surname>Brown</surname>
            <affiliation>
              <orgname>Wolfson Microelectronics</orgname>
              <address>
                <email>broonie@opensource.wolfsonmicro.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2007-2008</year>
          <holder>Wolfson Microelectronics</holder>
        </copyright>
        <copyright>
          <year>2008</year>
          <holder>Liam Girdwood</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
	This framework is designed to provide a standard kernel
	interface to control voltage and current regulators.
    </para>
        <para>
	The intention is to allow systems to dynamically control
	regulator power output in order to save power and prolong
	battery life.  This applies to both voltage regulators (where
	voltage output is controllable) and current sinks (where current
	limit is controllable).
    </para>
        <para>
	Note that additional (and currently more complete) documentation
	is available in the Linux kernel source under
	<filename>Documentation/power/regulator</filename>.
    </para>
        <sect1 id="glossary">
          <title>Glossary</title>
          <para>
	The regulator API uses a number of terms which may not be
	familiar:
       </para>
          <glossary>
            <glossentry>
              <glossterm>Regulator</glossterm>
              <glossdef>
                <para>
	Electronic device that supplies power to other devices.  Most
	regulators can enable and disable their output and some can also
	control their output voltage or current.
	     </para>
              </glossdef>
            </glossentry>
            <glossentry>
              <glossterm>Consumer</glossterm>
              <glossdef>
                <para>
	Electronic device which consumes power provided by a regulator.
	These may either be static, requiring only a fixed supply, or
	dynamic, requiring active management of the regulator at
	runtime.
	     </para>
              </glossdef>
            </glossentry>
            <glossentry>
              <glossterm>Power Domain</glossterm>
              <glossdef>
                <para>
	The electronic circuit supplied by a given regulator, including
	the regulator and all consumer devices.  The configuration of
	the regulator is shared between all the components in the
	circuit.
	     </para>
              </glossdef>
            </glossentry>
            <glossentry>
              <glossterm>Power Management Integrated Circuit</glossterm>
              <acronym>PMIC</acronym>
              <glossdef>
                <para>
	An IC which contains numerous regulators and often also other
	subsystems.  In an embedded system the primary PMIC is often
	equivalent to a combination of the PSU and southbridge in a
	desktop system.
	     </para>
              </glossdef>
            </glossentry>
          </glossary>
        </sect1>
      </chapter>
      <chapter id="consumer">
        <title>Consumer driver interface</title>
        <para>
       This offers a similar API to the kernel clock framework.
       Consumer drivers use <link linkend="API-regulator-get">get</link> and <link linkend="API-regulator-put">put</link> operations to acquire and
       release regulators.  Functions are
       provided to <link linkend="API-regulator-enable">enable</link>
       and <link linkend="API-regulator-disable">disable</link> the
       reguator and to get and set the runtime parameters of the
       regulator.
     </para>
        <para>
       When requesting regulators consumers use symbolic names for their
       supplies, such as "Vcc", which are mapped into actual regulator
       devices by the machine interface.
     </para>
        <para>
	A stub version of this API is provided when the regulator
	framework is not in use in order to minimise the need to use
	ifdefs.
     </para>
        <sect1 id="consumer-enable">
          <title>Enabling and disabling</title>
          <para>
         The regulator API provides reference counted enabling and
	 disabling of regulators. Consumer devices use the <function><link linkend="API-regulator-enable">regulator_enable</link></function>
	 and <function><link linkend="API-regulator-disable">regulator_disable</link></function> functions to enable and disable regulators.  Calls
	 to the two functions must be balanced.
       </para>
          <para>
         Note that since multiple consumers may be using a regulator and
	 machine constraints may not allow the regulator to be disabled
	 there is no guarantee that calling
	 <function>regulator_disable</function> will actually cause the
	 supply provided by the regulator to be disabled. Consumer
	 drivers should assume that the regulator may be enabled at all
	 times.
       </para>
        </sect1>
        <sect1 id="consumer-config">
          <title>Configuration</title>
          <para>
         Some consumer devices may need to be able to dynamically
	 configure their supplies.  For example, MMC drivers may need to
	 select the correct operating voltage for their cards.  This may
	 be done while the regulator is enabled or disabled.
       </para>
          <para>
	 The <function><link linkend="API-regulator-set-voltage">regulator_set_voltage</link></function> and <function><link linkend="API-regulator-set-current-limit">regulator_set_current_limit</link></function> functions provide the primary interface for this.
	 Both take ranges of voltages and currents, supporting drivers
	 that do not require a specific value (eg, CPU frequency scaling
	 normally permits the CPU to use a wider range of supply
	 voltages at lower frequencies but does not require that the
	 supply voltage be lowered).  Where an exact value is required
	 both minimum and maximum values should be identical.
       </para>
        </sect1>
        <sect1 id="consumer-callback">
          <title>Callbacks</title>
          <para>
	  Callbacks may also be <link linkend="API-regulator-register-notifier">registered</link>
	  for events such as regulation failures.
       </para>
        </sect1>
      </chapter>
      <chapter id="driver">
        <title>Regulator driver interface</title>
        <para>
       Drivers for regulator chips <link linkend="API-regulator-register">register</link> the regulators
       with the regulator core, providing operations structures to the
       core.  A <link linkend="API-regulator-notifier-call-chain">notifier</link> interface
       allows error conditions to be reported to the core.
     </para>
        <para>
       Registration should be triggered by explicit setup done by the
       platform, supplying a <link linkend="API-struct-regulator-init-data">struct
       regulator_init_data</link> for the regulator containing
       <link linkend="machine-constraint">constraint</link> and
       <link linkend="machine-supply">supply</link> information.
     </para>
      </chapter>
      <chapter id="machine">
        <title>Machine interface</title>
        <para>
       This interface provides a way to define how regulators are
       connected to consumers on a given system and what the valid
       operating parameters are for the system.
     </para>
        <sect1 id="machine-supply">
          <title>Supplies</title>
          <para>
         Regulator supplies are specified using <link linkend="API-struct-regulator-consumer-supply">struct
	 regulator_consumer_supply</link>.  This is done at
	 <link linkend="driver">driver registration
	 time</link> as part of the machine constraints.
       </para>
        </sect1>
        <sect1 id="machine-constraint">
          <title>Constraints</title>
          <para>
	 As well as defining the connections the machine interface
	 also provides constraints defining the operations that
	 clients are allowed to perform and the parameters that may be
	 set.  This is required since generally regulator devices will
	 offer more flexibility than it is safe to use on a given
	 system, for example supporting higher supply voltages than the
	 consumers are rated for.
       </para>
          <para>
	 This is done at <link linkend="driver">driver
	 registration time</link> by providing a <link linkend="API-struct-regulation-constraints">struct
	 regulation_constraints</link>.
       </para>
          <para>
         The constraints may also specify an initial configuration for the
         regulator in the constraints, which is particularly useful for
         use with static consumers.
       </para>
        </sect1>
      </chapter>
      <chapter id="api">
        <title>API reference</title>
        <para>
      Due to limitations of the kernel documentation framework and the
      existing layout of the source code the entire regulator API is
      documented here.
    </para>
!Iinclude/linux/regulator/consumer.h
!Iinclude/linux/regulator/machine.h
!Iinclude/linux/regulator/driver.h
!Edrivers/regulator/core.c
  </chapter>
    </book>
    <book id="s390drivers">
      <bookinfo>
        <title>Writing s390 channel device drivers</title>
        <authorgroup>
          <author>
            <firstname>Cornelia</firstname>
            <surname>Huck</surname>
            <affiliation>
              <address>
                <email>cornelia.huck@de.ibm.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2007</year>
          <holder>IBM Corp.</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
    This document describes the interfaces available for device drivers that
    drive s390 based channel attached I/O devices. This includes interfaces for
    interaction with the hardware and interfaces for interacting with the
    common driver core. Those interfaces are provided by the s390 common I/O
    layer.
  </para>
        <para>
    The document assumes a familarity with the technical terms associated
    with the s390 channel I/O architecture. For a description of this
    architecture, please refer to the "z/Architecture: Principles of
    Operation", IBM publication no. SA22-7832.
  </para>
        <para>
    While most I/O devices on a s390 system are typically driven through the
    channel I/O mechanism described here, there are various other methods
    (like the diag interface). These are out of the scope of this document.
  </para>
        <para>
    Some additional information can also be found in the kernel source
    under Documentation/s390/driver-model.txt.
  </para>
      </chapter>
      <chapter id="ccw">
        <title>The ccw bus</title>
        <para>
	The ccw bus typically contains the majority of devices available to
	a s390 system. Named after the channel command word (ccw), the basic
	command structure used to address its devices, the ccw bus contains
	so-called channel attached devices. They are addressed via I/O
	subchannels, visible on the css bus. A device driver for
	channel-attached devices, however, will never interact	with the
	subchannel directly, but only via the I/O device on the ccw bus,
	the ccw device.
  </para>
        <sect1 id="channelIO">
          <title>I/O functions for channel-attached devices</title>
          <para>
      Some hardware structures have been translated into C structures for use
      by the common I/O layer and device drivers. For more information on
      the hardware structures represented here, please consult the Principles
      of Operation.
    </para>
!Iarch/s390/include/asm/cio.h
    </sect1>
        <sect1 id="ccwdev">
          <title>ccw devices</title>
          <para>
      Devices that want to initiate channel I/O need to attach to the ccw bus.
      Interaction with the driver core is done via the common I/O layer, which
      provides the abstractions of ccw devices and ccw device drivers.
    </para>
          <para>
      The functions that initiate or terminate channel I/O all act upon a
      ccw device structure. Device drivers must not bypass those functions
      or strange side effects may happen.
    </para>
!Iarch/s390/include/asm/ccwdev.h
!Edrivers/s390/cio/device.c
!Edrivers/s390/cio/device_ops.c
    </sect1>
        <sect1 id="cmf">
          <title>The channel-measurement facility</title>
          <para>
	The channel-measurement facility provides a means to collect
	measurement data which is made available by the channel subsystem
	for each channel attached device.
  </para>
!Iarch/s390/include/asm/cmb.h
!Edrivers/s390/cio/cmf.c
    </sect1>
      </chapter>
      <chapter id="ccwgroup">
        <title>The ccwgroup bus</title>
        <para>
	The ccwgroup bus only contains artificial devices, created by the user.
	Many networking devices (e.g. qeth) are in fact composed of several
	ccw devices (like read, write and data channel for qeth). The
	ccwgroup bus provides a mechanism to create a meta-device which
	contains those ccw devices as slave devices and can be associated
	with the netdevice.
  </para>
        <sect1 id="ccwgroupdevices">
          <title>ccw group devices</title>
!Iarch/s390/include/asm/ccwgroup.h
!Edrivers/s390/cio/ccwgroup.c
   </sect1>
      </chapter>
      <chapter id="genericinterfaces">
        <title>Generic interfaces</title>
        <para>
	Some interfaces are available to other drivers that do not necessarily
	have anything to do with the busses described above, but still are
	indirectly using basic infrastructure in the common I/O layer.
	One example is the support for adapter interrupts.
  </para>
!Edrivers/s390/cio/airq.c
  </chapter>
    </book>
    <book id="scsimid">
      <bookinfo>
        <title>SCSI Interfaces Guide</title>
        <authorgroup>
          <author>
            <firstname>James</firstname>
            <surname>Bottomley</surname>
            <affiliation>
              <address>
                <email>James.Bottomley@hansenpartnership.com</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>Rob</firstname>
            <surname>Landley</surname>
            <affiliation>
              <address>
                <email>rob@landley.net</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2007</year>
          <holder>Linux Foundation</holder>
        </copyright>
        <legalnotice>
          <para>
        This documentation is free software; you can redistribute
        it and/or modify it under the terms of the GNU General Public
        License version 2.
      </para>
          <para>
        This program is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY; without even the implied
        warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
        For more details see the file COPYING in the source
        distribution of Linux.
      </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <sect1 id="protocol_vs_bus">
          <title>Protocol vs bus</title>
          <para>
        Once upon a time, the Small Computer Systems Interface defined both
        a parallel I/O bus and a data protocol to connect a wide variety of
        peripherals (disk drives, tape drives, modems, printers, scanners,
        optical drives, test equipment, and medical devices) to a host
        computer.
      </para>
          <para>
        Although the old parallel (fast/wide/ultra) SCSI bus has largely
        fallen out of use, the SCSI command set is more widely used than ever
        to communicate with devices over a number of different busses.
      </para>
          <para>
        The <ulink url="http://www.t10.org/scsi-3.htm">SCSI protocol</ulink>
        is a big-endian peer-to-peer packet based protocol.  SCSI commands
        are 6, 10, 12, or 16 bytes long, often followed by an associated data
        payload.
      </para>
          <para>
        SCSI commands can be transported over just about any kind of bus, and
        are the default protocol for storage devices attached to USB, SATA,
        SAS, Fibre Channel, FireWire, and ATAPI devices.  SCSI packets are
        also commonly exchanged over Infiniband,
        <ulink url="http://i2o.shadowconnect.com/faq.php">I20</ulink>, TCP/IP
        (<ulink url="http://en.wikipedia.org/wiki/ISCSI">iSCSI</ulink>), even
        <ulink url="http://cyberelk.net/tim/parport/parscsi.html">Parallel
        ports</ulink>.
      </para>
        </sect1>
        <sect1 id="subsystem_design">
          <title>Design of the Linux SCSI subsystem</title>
          <para>
        The SCSI subsystem uses a three layer design, with upper, mid, and low
        layers.  Every operation involving the SCSI subsystem (such as reading
        a sector from a disk) uses one driver at each of the 3 levels: one
        upper layer driver, one lower layer driver, and the SCSI midlayer.
      </para>
          <para>
        The SCSI upper layer provides the interface between userspace and the
        kernel, in the form of block and char device nodes for I/O and
        ioctl().  The SCSI lower layer contains drivers for specific hardware
        devices.
      </para>
          <para>
        In between is the SCSI mid-layer, analogous to a network routing
        layer such as the IPv4 stack.  The SCSI mid-layer routes a packet
        based data protocol between the upper layer's /dev nodes and the
        corresponding devices in the lower layer.  It manages command queues,
        provides error handling and power management functions, and responds
        to ioctl() requests.
      </para>
        </sect1>
      </chapter>
      <chapter id="upper_layer">
        <title>SCSI upper layer</title>
        <para>
      The upper layer supports the user-kernel interface by providing
      device nodes.
    </para>
        <sect1 id="sd">
          <title>sd (SCSI Disk)</title>
          <para>sd (sd_mod.o)</para>
          <!-- !Idrivers/scsi/sd.c -->
        </sect1>
        <sect1 id="sr">
          <title>sr (SCSI CD-ROM)</title>
          <para>sr (sr_mod.o)</para>
        </sect1>
        <sect1 id="st">
          <title>st (SCSI Tape)</title>
          <para>st (st.o)</para>
        </sect1>
        <sect1 id="sg">
          <title>sg (SCSI Generic)</title>
          <para>sg (sg.o)</para>
        </sect1>
        <sect1 id="ch">
          <title>ch (SCSI Media Changer)</title>
          <para>ch (ch.c)</para>
        </sect1>
      </chapter>
      <chapter id="mid_layer">
        <title>SCSI mid layer</title>
        <sect1 id="midlayer_implementation">
          <title>SCSI midlayer implementation</title>
          <sect2 id="scsi_device.h">
            <title>include/scsi/scsi_device.h</title>
            <para>
            </para>
!Iinclude/scsi/scsi_device.h
      </sect2>
          <sect2 id="scsi.c">
            <title>drivers/scsi/scsi.c</title>
            <para>Main file for the SCSI midlayer.</para>
!Edrivers/scsi/scsi.c
      </sect2>
          <sect2 id="scsicam.c">
            <title>drivers/scsi/scsicam.c</title>
            <para>
              <ulink url="http://www.t10.org/ftp/t10/drafts/cam/cam-r12b.pdf">SCSI
          Common Access Method</ulink> support functions, for use with
          HDIO_GETGEO, etc.
        </para>
!Edrivers/scsi/scsicam.c
      </sect2>
          <sect2 id="scsi_error.c">
            <title>drivers/scsi/scsi_error.c</title>
            <para>Common SCSI error/timeout handling routines.</para>
!Edrivers/scsi/scsi_error.c
      </sect2>
          <sect2 id="scsi_devinfo.c">
            <title>drivers/scsi/scsi_devinfo.c</title>
            <para>
          Manage scsi_dev_info_list, which tracks blacklisted and whitelisted
          devices.
        </para>
!Idrivers/scsi/scsi_devinfo.c
      </sect2>
          <sect2 id="scsi_ioctl.c">
            <title>drivers/scsi/scsi_ioctl.c</title>
            <para>
          Handle ioctl() calls for SCSI devices.
        </para>
!Edrivers/scsi/scsi_ioctl.c
      </sect2>
          <sect2 id="scsi_lib.c">
            <title>drivers/scsi/scsi_lib.c</title>
            <para>
          SCSI queuing library.
        </para>
!Edrivers/scsi/scsi_lib.c
      </sect2>
          <sect2 id="scsi_lib_dma.c">
            <title>drivers/scsi/scsi_lib_dma.c</title>
            <para>
          SCSI library functions depending on DMA
          (map and unmap scatter-gather lists).
        </para>
!Edrivers/scsi/scsi_lib_dma.c
      </sect2>
          <sect2 id="scsi_module.c">
            <title>drivers/scsi/scsi_module.c</title>
            <para>
          The file drivers/scsi/scsi_module.c contains legacy support for
          old-style host templates.  It should never be used by any new driver.
        </para>
          </sect2>
          <sect2 id="scsi_proc.c">
            <title>drivers/scsi/scsi_proc.c</title>
            <para>
          The functions in this file provide an interface between
          the PROC file system and the SCSI device drivers
          It is mainly used for debugging, statistics and to pass
          information directly to the lowlevel driver.

          I.E. plumbing to manage /proc/scsi/*
        </para>
!Idrivers/scsi/scsi_proc.c
      </sect2>
          <sect2 id="scsi_netlink.c">
            <title>drivers/scsi/scsi_netlink.c</title>
            <para>
          Infrastructure to provide async events from transports to userspace
          via netlink, using a single NETLINK_SCSITRANSPORT protocol for all
          transports.

          See <ulink url="http://marc.info/?l=linux-scsi&amp;m=115507374832500&amp;w=2">the
          original patch submission</ulink> for more details.
        </para>
!Idrivers/scsi/scsi_netlink.c
      </sect2>
          <sect2 id="scsi_scan.c">
            <title>drivers/scsi/scsi_scan.c</title>
            <para>
          Scan a host to determine which (if any) devices are attached.

          The general scanning/probing algorithm is as follows, exceptions are
          made to it depending on device specific flags, compilation options,
          and global variable (boot or module load time) settings.

          A specific LUN is scanned via an INQUIRY command; if the LUN has a
          device attached, a scsi_device is allocated and setup for it.

          For every id of every channel on the given host, start by scanning
          LUN 0.  Skip hosts that don't respond at all to a scan of LUN 0.
          Otherwise, if LUN 0 has a device attached, allocate and setup a
          scsi_device for it.  If target is SCSI-3 or up, issue a REPORT LUN,
          and scan all of the LUNs returned by the REPORT LUN; else,
          sequentially scan LUNs up until some maximum is reached, or a LUN is
          seen that cannot have a device attached to it.
        </para>
!Idrivers/scsi/scsi_scan.c
      </sect2>
          <sect2 id="scsi_sysctl.c">
            <title>drivers/scsi/scsi_sysctl.c</title>
            <para>
          Set up the sysctl entry: "/dev/scsi/logging_level"
          (DEV_SCSI_LOGGING_LEVEL) which sets/returns scsi_logging_level.
        </para>
          </sect2>
          <sect2 id="scsi_sysfs.c">
            <title>drivers/scsi/scsi_sysfs.c</title>
            <para>
          SCSI sysfs interface routines.
        </para>
!Edrivers/scsi/scsi_sysfs.c
      </sect2>
          <sect2 id="hosts.c">
            <title>drivers/scsi/hosts.c</title>
            <para>
          mid to lowlevel SCSI driver interface
        </para>
!Edrivers/scsi/hosts.c
      </sect2>
          <sect2 id="constants.c">
            <title>drivers/scsi/constants.c</title>
            <para>
          mid to lowlevel SCSI driver interface
        </para>
!Edrivers/scsi/constants.c
      </sect2>
        </sect1>
        <sect1 id="Transport_classes">
          <title>Transport classes</title>
          <para>
        Transport classes are service libraries for drivers in the SCSI
        lower layer, which expose transport attributes in sysfs.
      </para>
          <sect2 id="Fibre_Channel_transport">
            <title>Fibre Channel transport</title>
            <para>
          The file drivers/scsi/scsi_transport_fc.c defines transport attributes
          for Fibre Channel.
        </para>
!Edrivers/scsi/scsi_transport_fc.c
      </sect2>
          <sect2 id="iSCSI_transport">
            <title>iSCSI transport class</title>
            <para>
          The file drivers/scsi/scsi_transport_iscsi.c defines transport
          attributes for the iSCSI class, which sends SCSI packets over TCP/IP
          connections.
        </para>
!Edrivers/scsi/scsi_transport_iscsi.c
      </sect2>
          <sect2 id="SAS_transport">
            <title>Serial Attached SCSI (SAS) transport class</title>
            <para>
          The file drivers/scsi/scsi_transport_sas.c defines transport
          attributes for Serial Attached SCSI, a variant of SATA aimed at
          large high-end systems.
        </para>
            <para>
          The SAS transport class contains common code to deal with SAS HBAs,
          an aproximated representation of SAS topologies in the driver model,
          and various sysfs attributes to expose these topologies and management
          interfaces to userspace.
        </para>
            <para>
          In addition to the basic SCSI core objects this transport class
          introduces two additional intermediate objects:  The SAS PHY
          as represented by struct sas_phy defines an "outgoing" PHY on
          a SAS HBA or Expander, and the SAS remote PHY represented by
          struct sas_rphy defines an "incoming" PHY on a SAS Expander or
          end device.  Note that this is purely a software concept, the
          underlying hardware for a PHY and a remote PHY is the exactly
          the same.
        </para>
            <para>
          There is no concept of a SAS port in this code, users can see
          what PHYs form a wide port based on the port_identifier attribute,
          which is the same for all PHYs in a port.
        </para>
!Edrivers/scsi/scsi_transport_sas.c
      </sect2>
          <sect2 id="SATA_transport">
            <title>SATA transport class</title>
            <para>
          The SATA transport is handled by libata, which has its own book of
          documentation in this directory.
        </para>
          </sect2>
          <sect2 id="SPI_transport">
            <title>Parallel SCSI (SPI) transport class</title>
            <para>
          The file drivers/scsi/scsi_transport_spi.c defines transport
          attributes for traditional (fast/wide/ultra) SCSI busses.
        </para>
!Edrivers/scsi/scsi_transport_spi.c
      </sect2>
          <sect2 id="SRP_transport">
            <title>SCSI RDMA (SRP) transport class</title>
            <para>
          The file drivers/scsi/scsi_transport_srp.c defines transport
          attributes for SCSI over Remote Direct Memory Access.
        </para>
!Edrivers/scsi/scsi_transport_srp.c
      </sect2>
        </sect1>
      </chapter>
      <chapter id="lower_layer">
        <title>SCSI lower layer</title>
        <sect1 id="hba_drivers">
          <title>Host Bus Adapter transport types</title>
          <para>
        Many modern device controllers use the SCSI command set as a protocol to
        communicate with their devices through many different types of physical
        connections.
      </para>
          <para>
        In SCSI language a bus capable of carrying SCSI commands is
        called a "transport", and a controller connecting to such a bus is
        called a "host bus adapter" (HBA).
      </para>
          <sect2 id="scsi_debug.c">
            <title>Debug transport</title>
            <para>
          The file drivers/scsi/scsi_debug.c simulates a host adapter with a
          variable number of disks (or disk like devices) attached, sharing a
          common amount of RAM.  Does a lot of checking to make sure that we are
          not getting blocks mixed up, and panics the kernel if anything out of
          the ordinary is seen.
        </para>
            <para>
          To be more realistic, the simulated devices have the transport
          attributes of SAS disks.
        </para>
            <para>
          For documentation see
          <ulink url="http://sg.danny.cz/sg/sdebug26.html">http://sg.danny.cz/sg/sdebug26.html</ulink></para>
            <!-- !Edrivers/scsi/scsi_debug.c -->
          </sect2>
          <sect2 id="todo">
            <title>todo</title>
            <para>Parallel (fast/wide/ultra) SCSI, USB, SATA,
        SAS, Fibre Channel, FireWire, ATAPI devices, Infiniband,
        I20, iSCSI, Parallel ports, netlink...
        </para>
          </sect2>
        </sect1>
      </chapter>
    </book>
    <book id="sh-drivers">
      <bookinfo>
        <title>SuperH Interfaces Guide</title>
        <authorgroup>
          <author>
            <firstname>Paul</firstname>
            <surname>Mundt</surname>
            <affiliation>
              <address>
                <email>lethal@linux-sh.org</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2008-2010</year>
          <holder>Paul Mundt</holder>
        </copyright>
        <copyright>
          <year>2008-2010</year>
          <holder>Renesas Technology Corp.</holder>
        </copyright>
        <copyright>
          <year>2010</year>
          <holder>Renesas Electronics Corp.</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License version 2 as published by the Free Software Foundation.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="mm">
        <title>Memory Management</title>
        <sect1 id="sh4">
          <title>SH-4</title>
          <sect2 id="sq">
            <title>Store Queue API</title>
!Earch/sh/kernel/cpu/sh4/sq.c
      </sect2>
        </sect1>
        <sect1 id="sh5">
          <title>SH-5</title>
          <sect2 id="tlb">
            <title>TLB Interfaces</title>
!Iarch/sh/mm/tlb-sh5.c
!Iarch/sh/include/asm/tlb_64.h
      </sect2>
        </sect1>
      </chapter>
      <chapter id="mach">
        <title>Machine Specific Interfaces</title>
        <sect1 id="dreamcast">
          <title>mach-dreamcast</title>
!Iarch/sh/boards/mach-dreamcast/rtc.c
    </sect1>
        <sect1 id="x3proto">
          <title>mach-x3proto</title>
!Earch/sh/boards/mach-x3proto/ilsel.c
    </sect1>
      </chapter>
      <chapter id="busses">
        <title>Busses</title>
        <sect1 id="superhyway">
          <title>SuperHyway</title>
!Edrivers/sh/superhyway/superhyway.c
    </sect1>
        <sect1 id="maple">
          <title>Maple</title>
!Edrivers/sh/maple/maple.c
    </sect1>
      </chapter>
    </book>
    <book id="Tracepoints">
      <bookinfo>
        <title>The Linux Kernel Tracepoint API</title>
        <authorgroup>
          <author>
            <firstname>Jason</firstname>
            <surname>Baron</surname>
            <affiliation>
              <address>
                <email>jbaron@redhat.com</email>
              </address>
            </affiliation>
          </author>
          <author>
            <firstname>William</firstname>
            <surname>Cohen</surname>
            <affiliation>
              <address>
                <email>wcohen@redhat.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
     Tracepoints are static probe points that are located in strategic points
     throughout the kernel. 'Probes' register/unregister with tracepoints
     via a callback mechanism. The 'probes' are strictly typed functions that
     are passed a unique set of parameters defined by each tracepoint.
   </para>
        <para>
     From this simple callback mechanism, 'probes' can be used to profile, debug,
     and understand kernel behavior. There are a number of tools that provide a
     framework for using 'probes'. These tools include Systemtap, ftrace, and
     LTTng.
   </para>
        <para>
     Tracepoints are defined in a number of header files via various macros. Thus,
     the purpose of this document is to provide a clear accounting of the available
     tracepoints. The intention is to understand not only what tracepoints are
     available but also to understand where future tracepoints might be added.
   </para>
        <para>
     The API presented has functions of the form:
     <function>trace_tracepointname(function parameters)</function>. These are the
     tracepoints callbacks that are found throughout the code. Registering and
     unregistering probes with these callback sites is covered in the
     <filename>Documentation/trace/*</filename> directory.
   </para>
      </chapter>
      <chapter id="irq">
        <title>IRQ</title>
!Iinclude/trace/events/irq.h
  </chapter>
      <chapter id="signal">
        <title>SIGNAL</title>
!Iinclude/trace/events/signal.h
  </chapter>
      <chapter id="block">
        <title>Block IO</title>
!Iinclude/trace/events/block.h
  </chapter>
      <chapter id="workqueue">
        <title>Workqueue</title>
!Iinclude/trace/events/workqueue.h
  </chapter>
    </book>
    <book id="index">
      <bookinfo>
        <title>The Userspace I/O HOWTO</title>
        <author>
          <firstname>Hans-Jürgen</firstname>
          <surname>Koch</surname>
          <authorblurb>
            <para>Linux developer, Linutronix</para>
          </authorblurb>
          <affiliation>
            <orgname>
              <ulink url="http://www.linutronix.de">Linutronix</ulink>
            </orgname>
            <address>
              <email>hjk@hansjkoch.de</email>
            </address>
          </affiliation>
        </author>
        <copyright>
          <year>2006-2008</year>
          <holder>Hans-Jürgen Koch.</holder>
        </copyright>
        <copyright>
          <year>2009</year>
          <holder>Red Hat Inc, Michael S. Tsirkin (mst@redhat.com)</holder>
        </copyright>
        <legalnotice>
          <para>
This documentation is Free Software licensed under the terms of the
GPL version 2.
</para>
        </legalnotice>
        <pubdate>2006-12-11</pubdate>
        <abstract>
          <para>This HOWTO describes concept and usage of Linux kernel's
		Userspace I/O system.</para>
        </abstract>
        <revhistory>
          <revision>
            <revnumber>0.9</revnumber>
            <date>2009-07-16</date>
            <authorinitials>mst</authorinitials>
            <revremark>Added generic pci driver
		</revremark>
          </revision>
          <revision>
            <revnumber>0.8</revnumber>
            <date>2008-12-24</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Added name attributes in mem and portio sysfs directories.
		</revremark>
          </revision>
          <revision>
            <revnumber>0.7</revnumber>
            <date>2008-12-23</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Added generic platform drivers and offset attribute.</revremark>
          </revision>
          <revision>
            <revnumber>0.6</revnumber>
            <date>2008-12-05</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Added description of portio sysfs attributes.</revremark>
          </revision>
          <revision>
            <revnumber>0.5</revnumber>
            <date>2008-05-22</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Added description of write() function.</revremark>
          </revision>
          <revision>
            <revnumber>0.4</revnumber>
            <date>2007-11-26</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Removed section about uio_dummy.</revremark>
          </revision>
          <revision>
            <revnumber>0.3</revnumber>
            <date>2007-04-29</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Added section about userspace drivers.</revremark>
          </revision>
          <revision>
            <revnumber>0.2</revnumber>
            <date>2007-02-13</date>
            <authorinitials>hjk</authorinitials>
            <revremark>Update after multiple mappings were added.</revremark>
          </revision>
          <revision>
            <revnumber>0.1</revnumber>
            <date>2006-12-11</date>
            <authorinitials>hjk</authorinitials>
            <revremark>First draft.</revremark>
          </revision>
        </revhistory>
      </bookinfo>
      <chapter id="aboutthisdoc">
        <?dbhtml filename="aboutthis.html"?>
        <title>About this document</title>
        <sect1 id="translations">
          <?dbhtml filename="translations.html"?>
          <title>Translations</title>
          <para>If you know of any translations for this document, or you are
interested in translating it, please email me
<email>hjk@hansjkoch.de</email>.
</para>
        </sect1>
        <sect1 id="preface">
          <title>Preface</title>
          <para>
	For many types of devices, creating a Linux kernel driver is
	overkill.  All that is really needed is some way to handle an
	interrupt and provide access to the memory space of the
	device.  The logic of controlling the device does not
	necessarily have to be within the kernel, as the device does
	not need to take advantage of any of other resources that the
	kernel provides.  One such common class of devices that are
	like this are for industrial I/O cards.
	</para>
          <para>
	To address this situation, the userspace I/O system (UIO) was
	designed.  For typical industrial I/O cards, only a very small
	kernel module is needed. The main part of the driver will run in
	user space. This simplifies development and reduces the risk of
	serious bugs within a kernel module.
	</para>
          <para>
	Please note that UIO is not an universal driver interface. Devices
	that are already handled well by other kernel subsystems (like
	networking or serial or USB) are no candidates for an UIO driver.
	Hardware that is ideally suited for an UIO driver fulfills all of
	the following:
	</para>
          <itemizedlist>
            <listitem>
              <para>The device has memory that can be mapped. The device can be
	controlled completely by writing to this memory.</para>
            </listitem>
            <listitem>
              <para>The device usually generates interrupts.</para>
            </listitem>
            <listitem>
              <para>The device does not fit into one of the standard kernel
	subsystems.</para>
            </listitem>
          </itemizedlist>
        </sect1>
        <sect1 id="thanks">
          <title>Acknowledgments</title>
          <para>I'd like to thank Thomas Gleixner and Benedikt Spranger of
	Linutronix, who have not only written most of the UIO code, but also
	helped greatly writing this HOWTO by giving me all kinds of background
	information.</para>
        </sect1>
        <sect1 id="feedback">
          <title>Feedback</title>
          <para>Find something wrong with this document? (Or perhaps something
	right?) I would love to hear from you. Please email me at
	<email>hjk@hansjkoch.de</email>.</para>
        </sect1>
      </chapter>
      <chapter id="about">
        <?dbhtml filename="about.html"?>
        <title>About UIO</title>
        <para>If you use UIO for your card's driver, here's what you get:</para>
        <itemizedlist>
          <listitem>
            <para>only one small kernel module to write and maintain.</para>
          </listitem>
          <listitem>
            <para>develop the main part of your driver in user space,
	with all the tools and libraries you're used to.</para>
          </listitem>
          <listitem>
            <para>bugs in your driver won't crash the kernel.</para>
          </listitem>
          <listitem>
            <para>updates of your driver can take place without recompiling
	the kernel.</para>
          </listitem>
        </itemizedlist>
        <sect1 id="how_uio_works">
          <title>How UIO works</title>
          <para>
	Each UIO device is accessed through a device file and several
	sysfs attribute files. The device file will be called
	<filename>/dev/uio0</filename> for the first device, and
	<filename>/dev/uio1</filename>, <filename>/dev/uio2</filename>
	and so on for subsequent devices.
	</para>
          <para>
            <filename>/dev/uioX</filename> is used to access the
	address space of the card. Just use
	<function>mmap()</function> to access registers or RAM
	locations of your card.
	</para>
          <para>
	Interrupts are handled by reading from
	<filename>/dev/uioX</filename>. A blocking
	<function>read()</function> from
	<filename>/dev/uioX</filename> will return as soon as an
	interrupt occurs. You can also use
	<function>select()</function> on
	<filename>/dev/uioX</filename> to wait for an interrupt. The
	integer value read from <filename>/dev/uioX</filename>
	represents the total interrupt count. You can use this number
	to figure out if you missed some interrupts.
	</para>
          <para>
	For some hardware that has more than one interrupt source internally,
	but not separate IRQ mask and status registers, there might be
	situations where userspace cannot determine what the interrupt source
	was if the kernel handler disables them by writing to the chip's IRQ
	register. In such a case, the kernel has to disable the IRQ completely
	to leave the chip's register untouched. Now the userspace part can
	determine the cause of the interrupt, but it cannot re-enable
	interrupts. Another cornercase is chips where re-enabling interrupts
	is a read-modify-write operation to a combined IRQ status/acknowledge
	register. This would be racy if a new interrupt occurred
	simultaneously.
	</para>
          <para>
	To address these problems, UIO also implements a write() function. It
	is normally not used and can be ignored for hardware that has only a
	single interrupt source or has separate IRQ mask and status registers.
	If you need it, however, a write to <filename>/dev/uioX</filename>
	will call the <function>irqcontrol()</function> function implemented
	by the driver. You have to write a 32-bit value that is usually either
	0 or 1 to disable or enable interrupts. If a driver does not implement
	<function>irqcontrol()</function>, <function>write()</function> will
	return with <varname>-ENOSYS</varname>.
	</para>
          <para>
	To handle interrupts properly, your custom kernel module can
	provide its own interrupt handler. It will automatically be
	called by the built-in handler.
	</para>
          <para>
	For cards that don't generate interrupts but need to be
	polled, there is the possibility to set up a timer that
	triggers the interrupt handler at configurable time intervals.
	This interrupt simulation is done by calling
	<function>uio_event_notify()</function>
	from the timer's event handler.
	</para>
          <para>
	Each driver provides attributes that are used to read or write
	variables. These attributes are accessible through sysfs
	files.  A custom kernel driver module can add its own
	attributes to the device owned by the uio driver, but not added
	to the UIO device itself at this time.  This might change in the
	future if it would be found to be useful.
	</para>
          <para>
	The following standard attributes are provided by the UIO
	framework:
	</para>
          <itemizedlist>
            <listitem>
              <para>
                <filename>name</filename>: The name of your device. It is
	recommended to use the name of your kernel module for this.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>version</filename>: A version string defined by your
	driver. This allows the user space part of your driver to deal
	with different versions of the kernel module.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>event</filename>: The total number of interrupts
	handled by the driver since the last time the device node was
	read.
	</para>
            </listitem>
          </itemizedlist>
          <para>
	These attributes appear under the
	<filename>/sys/class/uio/uioX</filename> directory.  Please
	note that this directory might be a symlink, and not a real
	directory.  Any userspace code that accesses it must be able
	to handle this.
</para>
          <para>
	Each UIO device can make one or more memory regions available for
	memory mapping. This is necessary because some industrial I/O cards
	require access to more than one PCI memory region in a driver.
</para>
          <para>
	Each mapping has its own directory in sysfs, the first mapping
	appears as <filename>/sys/class/uio/uioX/maps/map0/</filename>.
	Subsequent mappings create directories <filename>map1/</filename>,
	<filename>map2/</filename>, and so on. These directories will only
	appear if the size of the mapping is not 0.
</para>
          <para>
	Each <filename>mapX/</filename> directory contains four read-only files
	that show attributes of the memory:
</para>
          <itemizedlist>
            <listitem>
              <para>
                <filename>name</filename>: A string identifier for this mapping. This
	is optional, the string can be empty. Drivers can set this to make it
	easier for userspace to find the correct mapping.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>addr</filename>: The address of memory that can be mapped.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>size</filename>: The size, in bytes, of the memory
	pointed to by addr.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>offset</filename>: The offset, in bytes, that has to be
	added to the pointer returned by <function>mmap()</function> to get
	to the actual device memory. This is important if the device's memory
	is not page aligned. Remember that pointers returned by
	<function>mmap()</function> are always page aligned, so it is good
	style to always add this offset.
	</para>
            </listitem>
          </itemizedlist>
          <para>
	From userspace, the different mappings are distinguished by adjusting
	the <varname>offset</varname> parameter of the
	<function>mmap()</function> call. To map the memory of mapping N, you
	have to use N times the page size as your offset:
</para>
          <programlisting format="linespecific">
offset = N * getpagesize();
</programlisting>
          <para>
	Sometimes there is hardware with memory-like regions that can not be
	mapped with the technique described here, but there are still ways to
	access them from userspace. The most common example are x86 ioports.
	On x86 systems, userspace can access these ioports using
	<function>ioperm()</function>, <function>iopl()</function>,
	<function>inb()</function>, <function>outb()</function>, and similar
	functions.
</para>
          <para>
	Since these ioport regions can not be mapped, they will not appear under
	<filename>/sys/class/uio/uioX/maps/</filename> like the normal memory
	described above. Without information about the port regions a hardware
	has to offer, it becomes difficult for the userspace part of the
	driver to find out which ports belong to which UIO device.
</para>
          <para>
	To address this situation, the new directory
	<filename>/sys/class/uio/uioX/portio/</filename> was added. It only
	exists if the driver wants to pass information about one or more port
	regions to userspace. If that is the case, subdirectories named
	<filename>port0</filename>, <filename>port1</filename>, and so on,
	will appear underneath
	<filename>/sys/class/uio/uioX/portio/</filename>.
</para>
          <para>
	Each <filename>portX/</filename> directory contains four read-only
	files that show name, start, size, and type of the port region:
</para>
          <itemizedlist>
            <listitem>
              <para>
                <filename>name</filename>: A string identifier for this port region.
	The string is optional and can be empty. Drivers can set it to make it
	easier for userspace to find a certain port region.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>start</filename>: The first port of this region.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>size</filename>: The number of ports in this region.
	</para>
            </listitem>
            <listitem>
              <para>
                <filename>porttype</filename>: A string describing the type of port.
	</para>
            </listitem>
          </itemizedlist>
        </sect1>
      </chapter>
      <chapter id="custom_kernel_module" xreflabel="Writing your own kernel module">
        <?dbhtml filename="custom_kernel_module.html"?>
        <title>Writing your own kernel module</title>
        <para>
	Please have a look at <filename>uio_cif.c</filename> as an
	example. The following paragraphs explain the different
	sections of this file.
	</para>
        <sect1 id="uio_info">
          <title>struct uio_info</title>
          <para>
	This structure tells the framework the details of your driver,
	Some of the members are required, others are optional.
	</para>
          <itemizedlist>
            <listitem>
              <para>
                <varname>const char *name</varname>: Required. The name of your driver as
it will appear in sysfs. I recommend using the name of your module for this.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>const char *version</varname>: Required. This string appears in
<filename>/sys/class/uio/uioX/version</filename>.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>struct uio_mem mem[ MAX_UIO_MAPS ]</varname>: Required if you
have memory that can be mapped with <function>mmap()</function>. For each
mapping you need to fill one of the <varname>uio_mem</varname> structures.
See the description below for details.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>struct uio_port port[ MAX_UIO_PORTS_REGIONS ]</varname>: Required
if you want to pass information about ioports to userspace. For each port
region you need to fill one of the <varname>uio_port</varname> structures.
See the description below for details.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>long irq</varname>: Required. If your hardware generates an
interrupt, it's your modules task to determine the irq number during
initialization. If you don't have a hardware generated interrupt but
want to trigger the interrupt handler in some other way, set
<varname>irq</varname> to <varname>UIO_IRQ_CUSTOM</varname>.
If you had no interrupt at all, you could set
<varname>irq</varname> to <varname>UIO_IRQ_NONE</varname>, though this
rarely makes sense.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>unsigned long irq_flags</varname>: Required if you've set
<varname>irq</varname> to a hardware interrupt number. The flags given
here will be used in the call to <function>request_irq()</function>.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>int (*mmap)(struct uio_info *info, struct vm_area_struct
*vma)</varname>: Optional. If you need a special
<function>mmap()</function> function, you can set it here. If this
pointer is not NULL, your <function>mmap()</function> will be called
instead of the built-in one.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>int (*open)(struct uio_info *info, struct inode *inode)
</varname>: Optional. You might want to have your own
<function>open()</function>, e.g. to enable interrupts only when your
device is actually used.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>int (*release)(struct uio_info *info, struct inode *inode)
</varname>: Optional. If you define your own
<function>open()</function>, you will probably also want a custom
<function>release()</function> function.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>int (*irqcontrol)(struct uio_info *info, s32 irq_on)
</varname>: Optional. If you need to be able to enable or disable
interrupts from userspace by writing to <filename>/dev/uioX</filename>,
you can implement this function. The parameter <varname>irq_on</varname>
will be 0 to disable interrupts and 1 to enable them.
</para>
            </listitem>
          </itemizedlist>
          <para>
Usually, your device will have one or more memory regions that can be mapped
to user space. For each region, you have to set up a
<varname>struct uio_mem</varname> in the <varname>mem[]</varname> array.
Here's a description of the fields of <varname>struct uio_mem</varname>:
</para>
          <itemizedlist>
            <listitem>
              <para>
                <varname>const char *name</varname>: Optional. Set this to help identify
the memory region, it will show up in the corresponding sysfs node.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>int memtype</varname>: Required if the mapping is used. Set this to
<varname>UIO_MEM_PHYS</varname> if you you have physical memory on your
card to be mapped. Use <varname>UIO_MEM_LOGICAL</varname> for logical
memory (e.g. allocated with <function>kmalloc()</function>). There's also
<varname>UIO_MEM_VIRTUAL</varname> for virtual memory.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>phys_addr_t addr</varname>: Required if the mapping is used.
Fill in the address of your memory block. This address is the one that
appears in sysfs.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>unsigned long size</varname>: Fill in the size of the
memory block that <varname>addr</varname> points to. If <varname>size</varname>
is zero, the mapping is considered unused. Note that you
<emphasis>must</emphasis> initialize <varname>size</varname> with zero for
all unused mappings.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>void *internal_addr</varname>: If you have to access this memory
region from within your kernel module, you will want to map it internally by
using something like <function>ioremap()</function>. Addresses
returned by this function cannot be mapped to user space, so you must not
store it in <varname>addr</varname>. Use <varname>internal_addr</varname>
instead to remember such an address.
</para>
            </listitem>
          </itemizedlist>
          <para>
Please do not touch the <varname>map</varname> element of
<varname>struct uio_mem</varname>! It is used by the UIO framework
to set up sysfs files for this mapping. Simply leave it alone.
</para>
          <para>
Sometimes, your device can have one or more port regions which can not be
mapped to userspace. But if there are other possibilities for userspace to
access these ports, it makes sense to make information about the ports
available in sysfs. For each region, you have to set up a
<varname>struct uio_port</varname> in the <varname>port[]</varname> array.
Here's a description of the fields of <varname>struct uio_port</varname>:
</para>
          <itemizedlist>
            <listitem>
              <para>
                <varname>char *porttype</varname>: Required. Set this to one of the predefined
constants. Use <varname>UIO_PORT_X86</varname> for the ioports found in x86
architectures.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>unsigned long start</varname>: Required if the port region is used.
Fill in the number of the first port of this region.
</para>
            </listitem>
            <listitem>
              <para>
                <varname>unsigned long size</varname>: Fill in the number of ports in this
region. If <varname>size</varname> is zero, the region is considered unused.
Note that you <emphasis>must</emphasis> initialize <varname>size</varname>
with zero for all unused regions.
</para>
            </listitem>
          </itemizedlist>
          <para>
Please do not touch the <varname>portio</varname> element of
<varname>struct uio_port</varname>! It is used internally by the UIO
framework to set up sysfs files for this region. Simply leave it alone.
</para>
        </sect1>
        <sect1 id="adding_irq_handler">
          <title>Adding an interrupt handler</title>
          <para>
	What you need to do in your interrupt handler depends on your
	hardware and on how you want to	handle it. You should try to
	keep the amount of code in your kernel interrupt handler low.
	If your hardware requires no action that you
	<emphasis>have</emphasis> to perform after each interrupt,
	then your handler can be empty.</para>
          <para>If, on the other
	hand, your hardware <emphasis>needs</emphasis> some action to
	be performed after each interrupt, then you
	<emphasis>must</emphasis> do it in your kernel module. Note
	that you cannot rely on the userspace part of your driver. Your
	userspace program can terminate at any time, possibly leaving
	your hardware in a state where proper interrupt handling is
	still required.
	</para>
          <para>
	There might also be applications where you want to read data
	from your hardware at each interrupt and buffer it in a piece
	of kernel memory you've allocated for that purpose.  With this
	technique you could avoid loss of data if your userspace
	program misses an interrupt.
	</para>
          <para>
	A note on shared interrupts: Your driver should support
	interrupt sharing whenever this is possible. It is possible if
	and only if your driver can detect whether your hardware has
	triggered the interrupt or not. This is usually done by looking
	at an interrupt status register. If your driver sees that the
	IRQ bit is actually set, it will perform its actions, and the
	handler returns IRQ_HANDLED. If the driver detects that it was
	not your hardware that caused the interrupt, it will do nothing
	and return IRQ_NONE, allowing the kernel to call the next
	possible interrupt handler.
	</para>
          <para>
	If you decide not to support shared interrupts, your card
	won't work in computers with no free interrupts. As this
	frequently happens on the PC platform, you can save yourself a
	lot of trouble by supporting interrupt sharing.
	</para>
        </sect1>
        <sect1 id="using_uio_pdrv">
          <title>Using uio_pdrv for platform devices</title>
          <para>
	In many cases, UIO drivers for platform devices can be handled in a
	generic way. In the same place where you define your
	<varname>struct platform_device</varname>, you simply also implement
	your interrupt handler and fill your
	<varname>struct uio_info</varname>. A pointer to this
	<varname>struct uio_info</varname> is then used as
	<varname>platform_data</varname> for your platform device.
	</para>
          <para>
	You also need to set up an array of <varname>struct resource</varname>
	containing addresses and sizes of your memory mappings. This
	information is passed to the driver using the
	<varname>.resource</varname> and <varname>.num_resources</varname>
	elements of <varname>struct platform_device</varname>.
	</para>
          <para>
	You now have to set the <varname>.name</varname> element of
	<varname>struct platform_device</varname> to
	<varname>"uio_pdrv"</varname> to use the generic UIO platform device
	driver. This driver will fill the <varname>mem[]</varname> array
	according to the resources given, and register the device.
	</para>
          <para>
	The advantage of this approach is that you only have to edit a file
	you need to edit anyway. You do not have to create an extra driver.
	</para>
        </sect1>
        <sect1 id="using_uio_pdrv_genirq">
          <title>Using uio_pdrv_genirq for platform devices</title>
          <para>
	Especially in embedded devices, you frequently find chips where the
	irq pin is tied to its own dedicated interrupt line. In such cases,
	where you can be really sure the interrupt is not shared, we can take
	the concept of <varname>uio_pdrv</varname> one step further and use a
	generic interrupt handler. That's what
	<varname>uio_pdrv_genirq</varname> does.
	</para>
          <para>
	The setup for this driver is the same as described above for
	<varname>uio_pdrv</varname>, except that you do not implement an
	interrupt handler. The <varname>.handler</varname> element of
	<varname>struct uio_info</varname> must remain
	<varname>NULL</varname>. The  <varname>.irq_flags</varname> element
	must not contain <varname>IRQF_SHARED</varname>.
	</para>
          <para>
	You will set the <varname>.name</varname> element of
	<varname>struct platform_device</varname> to
	<varname>"uio_pdrv_genirq"</varname> to use this driver.
	</para>
          <para>
	The generic interrupt handler of <varname>uio_pdrv_genirq</varname>
	will simply disable the interrupt line using
	<function>disable_irq_nosync()</function>. After doing its work,
	userspace can reenable the interrupt by writing 0x00000001 to the UIO
	device file. The driver already implements an
	<function>irq_control()</function> to make this possible, you must not
	implement your own.
	</para>
          <para>
	Using <varname>uio_pdrv_genirq</varname> not only saves a few lines of
	interrupt handler code. You also do not need to know anything about
	the chip's internal registers to create the kernel part of the driver.
	All you need to know is the irq number of the pin the chip is
	connected to.
	</para>
        </sect1>
        <sect1 id="using uio_dmem_genirq">
          <title>Using uio_dmem_genirq for platform devices</title>
          <para>
	In addition to statically allocated memory ranges, they may also be
	a desire to use dynamically allocated regions in a user space driver.
	In particular, being able to access memory made available through the
	dma-mapping API, may be particularly useful.  The
	<varname>uio_dmem_genirq</varname> driver provides a way to accomplish
	this.
	</para>
          <para>
	This driver is used in a similar manner to the
	<varname>"uio_pdrv_genirq"</varname> driver with respect to interrupt
	configuration and handling.
	</para>
          <para>
	Set the <varname>.name</varname> element of
	<varname>struct platform_device</varname> to
	<varname>"uio_dmem_genirq"</varname> to use this driver.
	</para>
          <para>
	When using this driver, fill in the <varname>.platform_data</varname>
	element of <varname>struct platform_device</varname>, which is of type
	<varname>struct uio_dmem_genirq_pdata</varname> and which contains the
	following elements:
	</para>
          <itemizedlist>
            <listitem>
              <varname>struct uio_info uioinfo</varname>: The same
	structure used as the  <varname>uio_pdrv_genirq</varname> platform
	data</listitem>
            <listitem>
              <varname>unsigned int *dynamic_region_sizes</varname>:
	Pointer to list of sizes of dynamic memory regions to be mapped into
	user space.
	</listitem>
            <listitem>
              <varname>unsigned int num_dynamic_regions</varname>:
	Number of elements in <varname>dynamic_region_sizes</varname> array.
	</listitem>
          </itemizedlist>
          <para>
	The dynamic regions defined in the platform data will be appended to
	the <varname> mem[] </varname> array after the platform device
	resources, which implies that the total number of static and dynamic
	memory regions cannot exceed <varname>MAX_UIO_MAPS</varname>.
	</para>
          <para>
	The dynamic memory regions will be allocated when the UIO device file,
	<varname>/dev/uioX</varname> is opened.
	Simiar to static memory resources, the memory region information for
	dynamic regions is then visible via sysfs at
	<varname>/sys/class/uio/uioX/maps/mapY/*</varname>.
	The dynmaic memory regions will be freed when the UIO device file is
	closed. When no processes are holding the device file open, the address
	returned to userspace is ~0.
	</para>
        </sect1>
      </chapter>
      <chapter id="userspace_driver" xreflabel="Writing a driver in user space">
        <?dbhtml filename="userspace_driver.html"?>
        <title>Writing a driver in userspace</title>
        <para>
	Once you have a working kernel module for your hardware, you can
	write the userspace part of your driver. You don't need any special
	libraries, your driver can be written in any reasonable language,
	you can use floating point numbers and so on. In short, you can
	use all the tools and libraries you'd normally use for writing a
	userspace application.
	</para>
        <sect1 id="getting_uio_information">
          <title>Getting information about your UIO device</title>
          <para>
	Information about all UIO devices is available in sysfs. The
	first thing you should do in your driver is check
	<varname>name</varname> and <varname>version</varname> to
	make sure your talking to the right device and that its kernel
	driver has the version you expect.
	</para>
          <para>
	You should also make sure that the memory mapping you need
	exists and has the size you expect.
	</para>
          <para>
	There is a tool called <varname>lsuio</varname> that lists
	UIO devices and their attributes. It is available here:
	</para>
          <para>
            <ulink url="http://www.osadl.org/projects/downloads/UIO/user/">
		http://www.osadl.org/projects/downloads/UIO/user/</ulink>
          </para>
          <para>
	With <varname>lsuio</varname> you can quickly check if your
	kernel module is loaded and which attributes it exports.
	Have a look at the manpage for details.
	</para>
          <para>
	The source code of <varname>lsuio</varname> can serve as an
	example for getting information about an UIO device.
	The file <filename>uio_helper.c</filename> contains a lot of
	functions you could use in your userspace driver code.
	</para>
        </sect1>
        <sect1 id="mmap_device_memory">
          <title>mmap() device memory</title>
          <para>
	After you made sure you've got the right device with the
	memory mappings you need, all you have to do is to call
	<function>mmap()</function> to map the device's memory
	to userspace.
	</para>
          <para>
	The parameter <varname>offset</varname> of the
	<function>mmap()</function> call has a special meaning
	for UIO devices: It is used to select which mapping of
	your device you want to map. To map the memory of
	mapping N, you have to use N times the page size as
	your offset:
	</para>
          <programlisting format="linespecific">
	offset = N * getpagesize();
</programlisting>
          <para>
	N starts from zero, so if you've got only one memory
	range to map, set <varname>offset = 0</varname>.
	A drawback of this technique is that memory is always
	mapped beginning with its start address.
	</para>
        </sect1>
        <sect1 id="wait_for_interrupts">
          <title>Waiting for interrupts</title>
          <para>
	After you successfully mapped your devices memory, you
	can access it like an ordinary array. Usually, you will
	perform some initialization. After that, your hardware
	starts working and will generate an interrupt as soon
	as it's finished, has some data available, or needs your
	attention because an error occurred.
	</para>
          <para>
            <filename>/dev/uioX</filename> is a read-only file. A
	<function>read()</function> will always block until an
	interrupt occurs. There is only one legal value for the
	<varname>count</varname> parameter of
	<function>read()</function>, and that is the size of a
	signed 32 bit integer (4). Any other value for
	<varname>count</varname> causes <function>read()</function>
	to fail. The signed 32 bit integer read is the interrupt
	count of your device. If the value is one more than the value
	you read the last time, everything is OK. If the difference
	is greater than one, you missed interrupts.
	</para>
          <para>
	You can also use <function>select()</function> on
	<filename>/dev/uioX</filename>.
	</para>
        </sect1>
      </chapter>
      <chapter id="uio_pci_generic" xreflabel="Using Generic driver for PCI cards">
        <?dbhtml filename="uio_pci_generic.html"?>
        <title>Generic PCI UIO driver</title>
        <para>
	The generic driver is a kernel module named uio_pci_generic.
	It can work with any device compliant to PCI 2.3 (circa 2002) and
	any compliant PCI Express device. Using this, you only need to
        write the userspace driver, removing the need to write
        a hardware-specific kernel module.
	</para>
        <sect1 id="uio_pci_generic_binding">
          <title>Making the driver recognize the device</title>
          <para>
Since the driver does not declare any device ids, it will not get loaded
automatically and will not automatically bind to any devices, you must load it
and allocate id to the driver yourself. For example:
	<programlisting>
 modprobe uio_pci_generic
 echo "8086 10f5" &gt; /sys/bus/pci/drivers/uio_pci_generic/new_id
	</programlisting></para>
          <para>
If there already is a hardware specific kernel driver for your device, the
generic driver still won't bind to it, in this case if you want to use the
generic driver (why would you?) you'll have to manually unbind the hardware
specific driver and bind the generic driver, like this:
	<programlisting>
    echo -n 0000:00:19.0 &gt; /sys/bus/pci/drivers/e1000e/unbind
    echo -n 0000:00:19.0 &gt; /sys/bus/pci/drivers/uio_pci_generic/bind
	</programlisting></para>
          <para>
You can verify that the device has been bound to the driver
by looking for it in sysfs, for example like the following:
	<programlisting>
    ls -l /sys/bus/pci/devices/0000:00:19.0/driver
	</programlisting>
Which if successful should print
	<programlisting>
  .../0000:00:19.0/driver -&gt; ../../../bus/pci/drivers/uio_pci_generic
	</programlisting>
Note that the generic driver will not bind to old PCI 2.2 devices.
If binding the device failed, run the following command:
	<programlisting>
  dmesg
	</programlisting>
and look in the output for failure reasons
	</para>
        </sect1>
        <sect1 id="uio_pci_generic_internals">
          <title>Things to know about uio_pci_generic</title>
          <para>
Interrupts are handled using the Interrupt Disable bit in the PCI command
register and Interrupt Status bit in the PCI status register.  All devices
compliant to PCI 2.3 (circa 2002) and all compliant PCI Express devices should
support these bits.  uio_pci_generic detects this support, and won't bind to
devices which do not support the Interrupt Disable Bit in the command register.
	</para>
          <para>
On each interrupt, uio_pci_generic sets the Interrupt Disable bit.
This prevents the device from generating further interrupts
until the bit is cleared. The userspace driver should clear this
bit before blocking and waiting for more interrupts.
	</para>
        </sect1>
        <sect1 id="uio_pci_generic_userspace">
          <title>Writing userspace driver using uio_pci_generic</title>
          <para>
Userspace driver can use pci sysfs interface, or the
libpci libray that wraps it, to talk to the device and to
re-enable interrupts by writing to the command register.
	</para>
        </sect1>
        <sect1 id="uio_pci_generic_example">
          <title>Example code using uio_pci_generic</title>
          <para>
Here is some sample userspace driver code using uio_pci_generic:
<programlisting>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;

int main()
{
	int uiofd;
	int configfd;
	int err;
	int i;
	unsigned icount;
	unsigned char command_high;

	uiofd = open("/dev/uio0", O_RDONLY);
	if (uiofd &lt; 0) {
		perror("uio open:");
		return errno;
	}
	configfd = open("/sys/class/uio/uio0/device/config", O_RDWR);
	if (configfd &lt; 0) {
		perror("config open:");
		return errno;
	}

	/* Read and cache command value */
	err = pread(configfd, &amp;command_high, 1, 5);
	if (err != 1) {
		perror("command config read:");
		return errno;
	}
	command_high &amp;= ~0x4;

	for(i = 0;; ++i) {
		/* Print out a message, for debugging. */
		if (i == 0)
			fprintf(stderr, "Started uio test driver.\n");
		else
			fprintf(stderr, "Interrupts: %d\n", icount);

		/****************************************/
		/* Here we got an interrupt from the
		   device. Do something to it. */
		/****************************************/

		/* Re-enable interrupts. */
		err = pwrite(configfd, &amp;command_high, 1, 5);
		if (err != 1) {
			perror("config write:");
			break;
		}

		/* Wait for next interrupt. */
		err = read(uiofd, &amp;icount, 4);
		if (err != 4) {
			perror("uio read:");
			break;
		}

	}
	return errno;
}

</programlisting></para>
        </sect1>
      </chapter>
      <appendix id="app1">
        <title>Further information</title>
        <itemizedlist>
          <listitem>
            <para>
              <ulink url="http://www.osadl.org">
				OSADL homepage.</ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.linutronix.de">
		 Linutronix homepage.</ulink>
            </para>
          </listitem>
        </itemizedlist>
      </appendix>
    </book>
    <book id="Linux-USB-API">
      <bookinfo>
        <title>The Linux-USB Host Side API</title>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction to USB on Linux</title>
        <para>A Universal Serial Bus (USB) is used to connect a host,
    such as a PC or workstation, to a number of peripheral
    devices.  USB uses a tree structure, with the host as the
    root (the system's master), hubs as interior nodes, and
    peripherals as leaves (and slaves).
    Modern PCs support several such trees of USB devices, usually
    one USB 2.0 tree (480 Mbit/sec each) with
    a few USB 1.1 trees (12 Mbit/sec each) that are used when you
    connect a USB 1.1 device directly to the machine's "root hub".
    </para>
        <para>That master/slave asymmetry was designed-in for a number of
    reasons, one being ease of use.  It is not physically possible to
    assemble (legal) USB cables incorrectly:  all upstream "to the host"
    connectors are the rectangular type (matching the sockets on
    root hubs), and all downstream connectors are the squarish type
    (or they are built into the peripheral).
    Also, the host software doesn't need to deal with distributed
    auto-configuration since the pre-designated master node manages all that.
    And finally, at the electrical level, bus protocol overhead is reduced by
    eliminating arbitration and moving scheduling into the host software.
    </para>
        <para>USB 1.0 was announced in January 1996 and was revised
    as USB 1.1 (with improvements in hub specification and
    support for interrupt-out transfers) in September 1998.
    USB 2.0 was released in April 2000, adding high-speed
    transfers and transaction-translating hubs (used for USB 1.1
    and 1.0 backward compatibility).
    </para>
        <para>Kernel developers added USB support to Linux early in the 2.2 kernel
    series, shortly before 2.3 development forked.  Updates from 2.3 were
    regularly folded back into 2.2 releases, which improved reliability and
    brought <filename>/sbin/hotplug</filename> support as well more drivers.
    Such improvements were continued in the 2.5 kernel series, where they added
    USB 2.0 support, improved performance, and made the host controller drivers
    (HCDs) more consistent.  They also simplified the API (to make bugs less
    likely) and added internal "kerneldoc" documentation.
    </para>
        <para>Linux can run inside USB devices as well as on
    the hosts that control the devices.
    But USB device drivers running inside those peripherals
    don't do the same things as the ones running inside hosts,
    so they've been given a different name:
    <emphasis>gadget drivers</emphasis>.
    This document does not cover gadget drivers.
    </para>
      </chapter>
      <chapter id="host">
        <title>USB Host-Side API Model</title>
        <para>Host-side drivers for USB devices talk to the "usbcore" APIs.
    There are two.  One is intended for
    <emphasis>general-purpose</emphasis> drivers (exposed through
    driver frameworks), and the other is for drivers that are
    <emphasis>part of the core</emphasis>.
    Such core drivers include the <emphasis>hub</emphasis> driver
    (which manages trees of USB devices) and several different kinds
    of <emphasis>host controller drivers</emphasis>,
    which control individual busses.
    </para>
        <para>The device model seen by USB drivers is relatively complex.
    </para>
        <itemizedlist>
          <listitem>
            <para>USB supports four kinds of data transfers
	(control, bulk, interrupt, and isochronous).  Two of them (control
	and bulk) use bandwidth as it's available,
	while the other two (interrupt and isochronous)
	are scheduled to provide guaranteed bandwidth.
	</para>
          </listitem>
          <listitem>
            <para>The device description model includes one or more
	"configurations" per device, only one of which is active at a time.
	Devices that are capable of high-speed operation must also support
	full-speed configurations, along with a way to ask about the
	"other speed" configurations which might be used.
	</para>
          </listitem>
          <listitem>
            <para>Configurations have one or more "interfaces", each
	of which may have "alternate settings".  Interfaces may be
	standardized by USB "Class" specifications, or may be specific to
	a vendor or device.</para>
            <para>USB device drivers actually bind to interfaces, not devices.
	Think of them as "interface drivers", though you
	may not see many devices where the distinction is important.
	<emphasis>Most USB devices are simple, with only one configuration,
	one interface, and one alternate setting.</emphasis></para>
          </listitem>
          <listitem>
            <para>Interfaces have one or more "endpoints", each of
	which supports one type and direction of data transfer such as
	"bulk out" or "interrupt in".  The entire configuration may have
	up to sixteen endpoints in each direction, allocated as needed
	among all the interfaces.
	</para>
          </listitem>
          <listitem>
            <para>Data transfer on USB is packetized; each endpoint
	has a maximum packet size.
	Drivers must often be aware of conventions such as flagging the end
	of bulk transfers using "short" (including zero length) packets.
	</para>
          </listitem>
          <listitem>
            <para>The Linux USB API supports synchronous calls for
	control and bulk messages.
	It also supports asynchnous calls for all kinds of data transfer,
	using request structures called "URBs" (USB Request Blocks).
	</para>
          </listitem>
        </itemizedlist>
        <para>Accordingly, the USB Core API exposed to device drivers
    covers quite a lot of territory.  You'll probably need to consult
    the USB 2.0 specification, available online from www.usb.org at
    no cost, as well as class or device specifications.
    </para>
        <para>The only host-side drivers that actually touch hardware
    (reading/writing registers, handling IRQs, and so on) are the HCDs.
    In theory, all HCDs provide the same functionality through the same
    API.  In practice, that's becoming more true on the 2.5 kernels,
    but there are still differences that crop up especially with
    fault handling.  Different controllers don't necessarily report
    the same aspects of failures, and recovery from faults (including
    software-induced ones like unlinking an URB) isn't yet fully
    consistent.
    Device driver authors should make a point of doing disconnect
    testing (while the device is active) with each different host
    controller driver, to make sure drivers don't have bugs of
    their own as well as to make sure they aren't relying on some
    HCD-specific behavior.
    (You will need external USB 1.1 and/or
    USB 2.0 hubs to perform all those tests.)
    </para>
      </chapter>
      <chapter id="types">
        <title>USB-Standard Types</title>
        <para>In <filename>&lt;linux/usb/ch9.h&gt;</filename> you will find
    the USB data types defined in chapter 9 of the USB specification.
    These data types are used throughout USB, and in APIs including
    this host side API, gadget APIs, and usbfs.
    </para>

!Iinclude/linux/usb/ch9.h

    </chapter>
      <chapter id="hostside">
        <title>Host-Side Data Types and Macros</title>
        <para>The host side API exposes several layers to drivers, some of
    which are more necessary than others.
    These support lifecycle models for host side drivers
    and devices, and support passing buffers through usbcore to
    some HCD that performs the I/O for the device driver.
    </para>


!Iinclude/linux/usb.h

    </chapter>
      <chapter id="usbcore">
        <title>USB Core APIs</title>
        <para>There are two basic I/O models in the USB API.
    The most elemental one is asynchronous:  drivers submit requests
    in the form of an URB, and the URB's completion callback
    handle the next step.
    All USB transfer types support that model, although there
    are special cases for control URBs (which always have setup
    and status stages, but may not have a data stage) and
    isochronous URBs (which allow large packets and include
    per-packet fault reports).
    Built on top of that is synchronous API support, where a
    driver calls a routine that allocates one or more URBs,
    submits them, and waits until they complete.
    There are synchronous wrappers for single-buffer control
    and bulk transfers (which are awkward to use in some
    driver disconnect scenarios), and for scatterlist based
    streaming i/o (bulk or interrupt).
    </para>
        <para>USB drivers need to provide buffers that can be
    used for DMA, although they don't necessarily need to
    provide the DMA mapping themselves.
    There are APIs to use used when allocating DMA buffers,
    which can prevent use of bounce buffers on some systems.
    In some cases, drivers may be able to rely on 64bit DMA
    to eliminate another kind of bounce buffer.
    </para>

!Edrivers/usb/core/urb.c
!Edrivers/usb/core/message.c
!Edrivers/usb/core/file.c
!Edrivers/usb/core/driver.c
!Edrivers/usb/core/usb.c
!Edrivers/usb/core/hub.c
    </chapter>
      <chapter id="hcd">
        <title>Host Controller APIs</title>
        <para>These APIs are only for use by host controller drivers,
    most of which implement standard register interfaces such as
    EHCI, OHCI, or UHCI.
    UHCI was one of the first interfaces, designed by Intel and
    also used by VIA; it doesn't do much in hardware.
    OHCI was designed later, to have the hardware do more work
    (bigger transfers, tracking protocol state, and so on).
    EHCI was designed with USB 2.0; its design has features that
    resemble OHCI (hardware does much more work) as well as
    UHCI (some parts of ISO support, TD list processing).
    </para>
        <para>There are host controllers other than the "big three",
    although most PCI based controllers (and a few non-PCI based
    ones) use one of those interfaces.
    Not all host controllers use DMA; some use PIO, and there
    is also a simulator.
    </para>
        <para>The same basic APIs are available to drivers for all
    those controllers.  
    For historical reasons they are in two layers:
    <structname>struct usb_bus</structname> is a rather thin
    layer that became available in the 2.2 kernels, while
    <structname>struct usb_hcd</structname> is a more featureful
    layer (available in later 2.4 kernels and in 2.5) that
    lets HCDs share common code, to shrink driver size
    and significantly reduce hcd-specific behaviors.
    </para>

!Edrivers/usb/core/hcd.c
!Edrivers/usb/core/hcd-pci.c
!Idrivers/usb/core/buffer.c
    </chapter>
      <chapter id="usbfs">
        <title>The USB Filesystem (usbfs)</title>
        <para>This chapter presents the Linux <emphasis>usbfs</emphasis>.
	You may prefer to avoid writing new kernel code for your
	USB driver; that's the problem that usbfs set out to solve.
	User mode device drivers are usually packaged as applications
	or libraries, and may use usbfs through some programming library
	that wraps it.  Such libraries include
	<ulink url="http://libusb.sourceforge.net">libusb</ulink>
	for C/C++, and
	<ulink url="http://jUSB.sourceforge.net">jUSB</ulink> for Java.
	</para>
        <note>
          <title>Unfinished</title>
          <para>This particular documentation is incomplete,
	    especially with respect to the asynchronous mode.
	    As of kernel 2.5.66 the code and this (new) documentation
	    need to be cross-reviewed.
	    </para>
        </note>
        <para>Configure usbfs into Linux kernels by enabling the
	<emphasis>USB filesystem</emphasis> option (CONFIG_USB_DEVICEFS),
	and you get basic support for user mode USB device drivers.
	Until relatively recently it was often (confusingly) called
	<emphasis>usbdevfs</emphasis> although it wasn't solving what
	<emphasis>devfs</emphasis> was.
	Every USB device will appear in usbfs, regardless of whether or
	not it has a kernel driver.
	</para>
        <sect1 id="usbfs-files">
          <title>What files are in "usbfs"?</title>
          <para>Conventionally mounted at
	    <filename>/proc/bus/usb</filename>, usbfs 
	    features include:
	    <itemizedlist><listitem><para><filename>/proc/bus/usb/devices</filename>
		    ... a text file
		    showing each of the USB devices on known to the kernel,
		    and their configuration descriptors.
		    You can also poll() this to learn about new devices.
		    </para></listitem><listitem><para><filename>/proc/bus/usb/BBB/DDD</filename>
		    ... magic files
		    exposing the each device's configuration descriptors, and
		    supporting a series of ioctls for making device requests,
		    including I/O to devices.  (Purely for access by programs.)
		    </para></listitem></itemizedlist></para>
          <para> Each bus is given a number (BBB) based on when it was
	    enumerated; within each bus, each device is given a similar
	    number (DDD).
	    Those BBB/DDD paths are not "stable" identifiers;
	    expect them to change even if you always leave the devices
	    plugged in to the same hub port.
	    <emphasis>Don't even think of saving these in application
	    configuration files.</emphasis>
	    Stable identifiers are available, for user mode applications
	    that want to use them.  HID and networking devices expose
	    these stable IDs, so that for example you can be sure that
	    you told the right UPS to power down its second server.
	    "usbfs" doesn't (yet) expose those IDs.
	    </para>
        </sect1>
        <sect1 id="usbfs-fstab">
          <title>Mounting and Access Control</title>
          <para>There are a number of mount options for usbfs, which will
	    be of most interest to you if you need to override the default
	    access control policy.
	    That policy is that only root may read or write device files
	    (<filename>/proc/bus/BBB/DDD</filename>) although anyone may read
	    the <filename>devices</filename>
	    or <filename>drivers</filename> files.
	    I/O requests to the device also need the CAP_SYS_RAWIO capability,
	    </para>
          <para>The significance of that is that by default, all user mode
	    device drivers need super-user privileges.
	    You can change modes or ownership in a driver setup
	    when the device hotplugs, or maye just start the
	    driver right then, as a privileged server (or some activity
	    within one).
	    That's the most secure approach for multi-user systems,
	    but for single user systems ("trusted" by that user)
	    it's more convenient just to grant everyone all access
	    (using the <emphasis>devmode=0666</emphasis> option)
	    so the driver can start whenever it's needed.
	    </para>
          <para>The mount options for usbfs, usable in /etc/fstab or
	    in command line invocations of <emphasis>mount</emphasis>, are:

	    <variablelist><varlistentry><term><emphasis>busgid</emphasis>=NNNNN</term><listitem><para>Controls the GID used for the
		    /proc/bus/usb/BBB
		    directories.  (Default: 0)</para></listitem></varlistentry><varlistentry><term><emphasis>busmode</emphasis>=MMM</term><listitem><para>Controls the file mode used for the
		    /proc/bus/usb/BBB
		    directories.  (Default: 0555)
		    </para></listitem></varlistentry><varlistentry><term><emphasis>busuid</emphasis>=NNNNN</term><listitem><para>Controls the UID used for the
		    /proc/bus/usb/BBB
		    directories.  (Default: 0)</para></listitem></varlistentry><varlistentry><term><emphasis>devgid</emphasis>=NNNNN</term><listitem><para>Controls the GID used for the
		    /proc/bus/usb/BBB/DDD
		    files.  (Default: 0)</para></listitem></varlistentry><varlistentry><term><emphasis>devmode</emphasis>=MMM</term><listitem><para>Controls the file mode used for the
		    /proc/bus/usb/BBB/DDD
		    files.  (Default: 0644)</para></listitem></varlistentry><varlistentry><term><emphasis>devuid</emphasis>=NNNNN</term><listitem><para>Controls the UID used for the
		    /proc/bus/usb/BBB/DDD
		    files.  (Default: 0)</para></listitem></varlistentry><varlistentry><term><emphasis>listgid</emphasis>=NNNNN</term><listitem><para>Controls the GID used for the
		    /proc/bus/usb/devices and drivers files.
		    (Default: 0)</para></listitem></varlistentry><varlistentry><term><emphasis>listmode</emphasis>=MMM</term><listitem><para>Controls the file mode used for the
		    /proc/bus/usb/devices and drivers files.
		    (Default: 0444)</para></listitem></varlistentry><varlistentry><term><emphasis>listuid</emphasis>=NNNNN</term><listitem><para>Controls the UID used for the
		    /proc/bus/usb/devices and drivers files.
		    (Default: 0)</para></listitem></varlistentry></variablelist></para>
          <para>Note that many Linux distributions hard-wire the mount options
	    for usbfs in their init scripts, such as
	    <filename>/etc/rc.d/rc.sysinit</filename>,
	    rather than making it easy to set this per-system
	    policy in <filename>/etc/fstab</filename>.
	    </para>
        </sect1>
        <sect1 id="usbfs-devices">
          <title>/proc/bus/usb/devices</title>
          <para>This file is handy for status viewing tools in user
	    mode, which can scan the text format and ignore most of it.
	    More detailed device status (including class and vendor
	    status) is available from device-specific files.
	    For information about the current format of this file,
	    see the
	    <filename>Documentation/usb/proc_usb_info.txt</filename>
	    file in your Linux kernel sources.
	    </para>
          <para>This file, in combination with the poll() system call, can
	    also be used to detect when devices are added or removed:
<programlisting>int fd;
struct pollfd pfd;

fd = open("/proc/bus/usb/devices", O_RDONLY);
pfd = { fd, POLLIN, 0 };
for (;;) {
	/* The first time through, this call will return immediately. */
	poll(&amp;pfd, 1, -1);

	/* To see what's changed, compare the file's previous and current
	   contents or scan the filesystem.  (Scanning is more precise.) */
}</programlisting>
	    Note that this behavior is intended to be used for informational
	    and debug purposes.  It would be more appropriate to use programs
	    such as udev or HAL to initialize a device or start a user-mode
	    helper program, for instance.
	    </para>
        </sect1>
        <sect1 id="usbfs-bbbddd">
          <title>/proc/bus/usb/BBB/DDD</title>
          <para>Use these files in one of these basic ways:
	    </para>
          <para>
            <emphasis>They can be read,</emphasis>
	    producing first the device descriptor
	    (18 bytes) and then the descriptors for the current configuration.
	    See the USB 2.0 spec for details about those binary data formats.
	    You'll need to convert most multibyte values from little endian
	    format to your native host byte order, although a few of the
	    fields in the device descriptor (both of the BCD-encoded fields,
	    and the vendor and product IDs) will be byteswapped for you.
	    Note that configuration descriptors include descriptors for
	    interfaces, altsettings, endpoints, and maybe additional
	    class descriptors.
	    </para>
          <para>
            <emphasis>Perform USB operations</emphasis> using 
	    <emphasis>ioctl()</emphasis> requests to make endpoint I/O
	    requests (synchronously or asynchronously) or manage
	    the device.
	    These requests need the CAP_SYS_RAWIO capability,
	    as well as filesystem access permissions.
	    Only one ioctl request can be made on one of these
	    device files at a time.
	    This means that if you are synchronously reading an endpoint
	    from one thread, you won't be able to write to a different
	    endpoint from another thread until the read completes.
	    This works for <emphasis>half duplex</emphasis> protocols,
	    but otherwise you'd use asynchronous i/o requests. 
	    </para>
        </sect1>
        <sect1 id="usbfs-lifecycle">
          <title>Life Cycle of User Mode Drivers</title>
          <para>Such a driver first needs to find a device file
	    for a device it knows how to handle.
	    Maybe it was told about it because a
	    <filename>/sbin/hotplug</filename> event handling agent
	    chose that driver to handle the new device.
	    Or maybe it's an application that scans all the
	    /proc/bus/usb device files, and ignores most devices.
	    In either case, it should <function>read()</function> all
	    the descriptors from the device file,
	    and check them against what it knows how to handle.
	    It might just reject everything except a particular
	    vendor and product ID, or need a more complex policy.
	    </para>
          <para>Never assume there will only be one such device
	    on the system at a time!
	    If your code can't handle more than one device at
	    a time, at least detect when there's more than one, and
	    have your users choose which device to use.
	    </para>
          <para>Once your user mode driver knows what device to use,
	    it interacts with it in either of two styles.
	    The simple style is to make only control requests; some
	    devices don't need more complex interactions than those.
	    (An example might be software using vendor-specific control
	    requests for some initialization or configuration tasks,
	    with a kernel driver for the rest.)
	    </para>
          <para>More likely, you need a more complex style driver:
	    one using non-control endpoints, reading or writing data
	    and claiming exclusive use of an interface.
	    <emphasis>Bulk</emphasis> transfers are easiest to use,
	    but only their sibling <emphasis>interrupt</emphasis> transfers 
	    work with low speed devices.
	    Both interrupt and <emphasis>isochronous</emphasis> transfers
	    offer service guarantees because their bandwidth is reserved.
	    Such "periodic" transfers are awkward to use through usbfs,
	    unless you're using the asynchronous calls.  However, interrupt
	    transfers can also be used in a synchronous "one shot" style.
	    </para>
          <para>Your user-mode driver should never need to worry
	    about cleaning up request state when the device is
	    disconnected, although it should close its open file
	    descriptors as soon as it starts seeing the ENODEV
	    errors.
	    </para>
        </sect1>
        <sect1 id="usbfs-ioctl">
          <title>The ioctl() Requests</title>
          <para>To use these ioctls, you need to include the following
	    headers in your userspace program:
<programlisting>#include &lt;linux/usb.h&gt;
#include &lt;linux/usbdevice_fs.h&gt;
#include &lt;asm/byteorder.h&gt;</programlisting>
	    The standard USB device model requests, from "Chapter 9" of
	    the USB 2.0 specification, are automatically included from
	    the <filename>&lt;linux/usb/ch9.h&gt;</filename> header.
	    </para>
          <para>Unless noted otherwise, the ioctl requests
	    described here will
	    update the modification time on the usbfs file to which
	    they are applied (unless they fail).
	    A return of zero indicates success; otherwise, a
	    standard USB error code is returned.  (These are
	    documented in
	    <filename>Documentation/usb/error-codes.txt</filename>
	    in your kernel sources.)
	    </para>
          <para>Each of these files multiplexes access to several
	    I/O streams, one per endpoint.
	    Each device has one control endpoint (endpoint zero)
	    which supports a limited RPC style RPC access.
	    Devices are configured
	    by khubd (in the kernel) setting a device-wide
	    <emphasis>configuration</emphasis> that affects things
	    like power consumption and basic functionality.
	    The endpoints are part of USB <emphasis>interfaces</emphasis>,
	    which may have <emphasis>altsettings</emphasis>
	    affecting things like which endpoints are available.
	    Many devices only have a single configuration and interface,
	    so drivers for them will ignore configurations and altsettings.
	    </para>
          <sect2 id="usbfs-mgmt">
            <title>Management/Status Requests</title>
            <para>A number of usbfs requests don't deal very directly
		with device I/O.
		They mostly relate to device management and status.
		These are all synchronous requests.
		</para>
            <variablelist>
              <varlistentry>
                <term>USBDEVFS_CLAIMINTERFACE</term>
                <listitem>
                  <para>This is used to force usbfs to
		    claim a specific interface,
		    which has not previously been claimed by usbfs or any other
		    kernel driver.
		    The ioctl parameter is an integer holding the number of
		    the interface (bInterfaceNumber from descriptor).
		    </para>
                  <para>
		    Note that if your driver doesn't claim an interface
		    before trying to use one of its endpoints, and no
		    other driver has bound to it, then the interface is
		    automatically claimed by usbfs.
		    </para>
                  <para>
		    This claim will be released by a RELEASEINTERFACE ioctl,
		    or by closing the file descriptor.
		    File modification time is not updated by this request.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_CONNECTINFO</term>
                <listitem>
                  <para>Says whether the device is lowspeed.
		    The ioctl parameter points to a structure like this:
<programlisting>struct usbdevfs_connectinfo {
        unsigned int   devnum;
        unsigned char  slow;
}; </programlisting>
		    File modification time is not updated by this request.
		    </para>
                  <para>
                    <emphasis>You can't tell whether a "not slow"
		    device is connected at high speed (480 MBit/sec)
		    or just full speed (12 MBit/sec).</emphasis>
		    You should know the devnum value already,
		    it's the DDD value of the device file name.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_GETDRIVER</term>
                <listitem>
                  <para>Returns the name of the kernel driver
		    bound to a given interface (a string).  Parameter
		    is a pointer to this structure, which is modified:
<programlisting>struct usbdevfs_getdriver {
        unsigned int  interface;
        char          driver[USBDEVFS_MAXDRIVERNAME + 1];
};</programlisting>
		    File modification time is not updated by this request.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_IOCTL</term>
                <listitem>
                  <para>Passes a request from userspace through
		    to a kernel driver that has an ioctl entry in the
		    <emphasis>struct usb_driver</emphasis> it registered.
<programlisting>struct usbdevfs_ioctl {
        int     ifno;
        int     ioctl_code;
        void    *data;
};

/* user mode call looks like this.
 * 'request' becomes the driver-&gt;ioctl() 'code' parameter.
 * the size of 'param' is encoded in 'request', and that data
 * is copied to or from the driver-&gt;ioctl() 'buf' parameter.
 */
static int
usbdev_ioctl (int fd, int ifno, unsigned request, void *param)
{
        struct usbdevfs_ioctl	wrapper;

        wrapper.ifno = ifno;
        wrapper.ioctl_code = request;
        wrapper.data = param;

        return ioctl (fd, USBDEVFS_IOCTL, &amp;wrapper);
} </programlisting>
		    File modification time is not updated by this request.
		    </para>
                  <para>
		    This request lets kernel drivers talk to user mode code
		    through filesystem operations even when they don't create
		    a character or block special device.
		    It's also been used to do things like ask devices what
		    device special file should be used.
		    Two pre-defined ioctls are used
		    to disconnect and reconnect kernel drivers, so
		    that user mode code can completely manage binding
		    and configuration of devices.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_RELEASEINTERFACE</term>
                <listitem>
                  <para>This is used to release the claim usbfs
		    made on interface, either implicitly or because of a
		    USBDEVFS_CLAIMINTERFACE call, before the file
		    descriptor is closed.
		    The ioctl parameter is an integer holding the number of
		    the interface (bInterfaceNumber from descriptor);
		    File modification time is not updated by this request.
		    </para>
                  <warning>
                    <para>
                      <emphasis>No security check is made to ensure
		    that the task which made the claim is the one
		    which is releasing it.
		    This means that user mode driver may interfere
		    other ones.  </emphasis>
                    </para>
                  </warning>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_RESETEP</term>
                <listitem>
                  <para>Resets the data toggle value for an endpoint
		    (bulk or interrupt) to DATA0.
		    The ioctl parameter is an integer endpoint number
		    (1 to 15, as identified in the endpoint descriptor),
		    with USB_DIR_IN added if the device's endpoint sends
		    data to the host.
		    </para>
                  <warning>
                    <para>
                      <emphasis>Avoid using this request.
		    It should probably be removed.</emphasis>
		    Using it typically means the device and driver will lose
		    toggle synchronization.  If you really lost synchronization,
		    you likely need to completely handshake with the device,
		    using a request like CLEAR_HALT
		    or SET_INTERFACE.
		    </para>
                  </warning>
                </listitem>
              </varlistentry>
            </variablelist>
          </sect2>
          <sect2 id="usbfs-sync">
            <title>Synchronous I/O Support</title>
            <para>Synchronous requests involve the kernel blocking
		until the user mode request completes, either by
		finishing successfully or by reporting an error.
		In most cases this is the simplest way to use usbfs,
		although as noted above it does prevent performing I/O
		to more than one endpoint at a time.
		</para>
            <variablelist>
              <varlistentry>
                <term>USBDEVFS_BULK</term>
                <listitem>
                  <para>Issues a bulk read or write request to the
		    device.
		    The ioctl parameter is a pointer to this structure:
<programlisting>struct usbdevfs_bulktransfer {
        unsigned int  ep;
        unsigned int  len;
        unsigned int  timeout; /* in milliseconds */
        void          *data;
};</programlisting></para>
                  <para>The "ep" value identifies a
		    bulk endpoint number (1 to 15, as identified in an endpoint
		    descriptor),
		    masked with USB_DIR_IN when referring to an endpoint which
		    sends data to the host from the device.
		    The length of the data buffer is identified by "len";
		    Recent kernels support requests up to about 128KBytes.
		    <emphasis>FIXME say how read length is returned,
		    and how short reads are handled.</emphasis>.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_CLEAR_HALT</term>
                <listitem>
                  <para>Clears endpoint halt (stall) and
		    resets the endpoint toggle.  This is only
		    meaningful for bulk or interrupt endpoints.
		    The ioctl parameter is an integer endpoint number
		    (1 to 15, as identified in an endpoint descriptor),
		    masked with USB_DIR_IN when referring to an endpoint which
		    sends data to the host from the device.
		    </para>
                  <para>
		    Use this on bulk or interrupt endpoints which have
		    stalled, returning <emphasis>-EPIPE</emphasis> status
		    to a data transfer request.
		    Do not issue the control request directly, since
		    that could invalidate the host's record of the
		    data toggle.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_CONTROL</term>
                <listitem>
                  <para>Issues a control request to the device.
		    The ioctl parameter points to a structure like this:
<programlisting>struct usbdevfs_ctrltransfer {
        __u8   bRequestType;
        __u8   bRequest;
        __u16  wValue;
        __u16  wIndex;
        __u16  wLength;
        __u32  timeout;  /* in milliseconds */
        void   *data;
};</programlisting></para>
                  <para>
		    The first eight bytes of this structure are the contents
		    of the SETUP packet to be sent to the device; see the
		    USB 2.0 specification for details.
		    The bRequestType value is composed by combining a
		    USB_TYPE_* value, a USB_DIR_* value, and a
		    USB_RECIP_* value (from
		    <emphasis>&lt;linux/usb.h&gt;</emphasis>).
		    If wLength is nonzero, it describes the length of the data
		    buffer, which is either written to the device
		    (USB_DIR_OUT) or read from the device (USB_DIR_IN).
		    </para>
                  <para>
		    At this writing, you can't transfer more than 4 KBytes
		    of data to or from a device; usbfs has a limit, and
		    some host controller drivers have a limit.
		    (That's not usually a problem.)
		    <emphasis>Also</emphasis> there's no way to say it's
		    not OK to get a short read back from the device.
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_RESET</term>
                <listitem>
                  <para>Does a USB level device reset.
		    The ioctl parameter is ignored.
		    After the reset, this rebinds all device interfaces.
		    File modification time is not updated by this request.
		    </para>
                  <warning>
                    <para>
                      <emphasis>Avoid using this call</emphasis>
		    until some usbcore bugs get fixed,
		    since it does not fully synchronize device, interface,
		    and driver (not just usbfs) state.
		    </para>
                  </warning>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_SETINTERFACE</term>
                <listitem>
                  <para>Sets the alternate setting for an
		    interface.  The ioctl parameter is a pointer to a
		    structure like this:
<programlisting>struct usbdevfs_setinterface {
        unsigned int  interface;
        unsigned int  altsetting;
}; </programlisting>
		    File modification time is not updated by this request.
		    </para>
                  <para>
		    Those struct members are from some interface descriptor
		    applying to the current configuration.
		    The interface number is the bInterfaceNumber value, and
		    the altsetting number is the bAlternateSetting value.
		    (This resets each endpoint in the interface.)
		    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_SETCONFIGURATION</term>
                <listitem>
                  <para>Issues the
		    <function>usb_set_configuration</function> call
		    for the device.
		    The parameter is an integer holding the number of
		    a configuration (bConfigurationValue from descriptor).
		    File modification time is not updated by this request.
		    </para>
                  <warning>
                    <para>
                      <emphasis>Avoid using this call</emphasis>
		    until some usbcore bugs get fixed,
		    since it does not fully synchronize device, interface,
		    and driver (not just usbfs) state.
		    </para>
                  </warning>
                </listitem>
              </varlistentry>
            </variablelist>
          </sect2>
          <sect2 id="usbfs-async">
            <title>Asynchronous I/O Support</title>
            <para>As mentioned above, there are situations where it may be
		important to initiate concurrent operations from user mode code.
		This is particularly important for periodic transfers
		(interrupt and isochronous), but it can be used for other
		kinds of USB requests too.
		In such cases, the asynchronous requests described here
		are essential.  Rather than submitting one request and having
		the kernel block until it completes, the blocking is separate.
		</para>
            <para>These requests are packaged into a structure that
		resembles the URB used by kernel device drivers.
		(No POSIX Async I/O support here, sorry.)
		It identifies the endpoint type (USBDEVFS_URB_TYPE_*),
		endpoint (number, masked with USB_DIR_IN as appropriate),
		buffer and length, and a user "context" value serving to
		uniquely identify each request.
		(It's usually a pointer to per-request data.)
		Flags can modify requests (not as many as supported for
		kernel drivers).
		</para>
            <para>Each request can specify a realtime signal number
		(between SIGRTMIN and SIGRTMAX, inclusive) to request a
		signal be sent when the request completes.
		</para>
            <para>When usbfs returns these urbs, the status value
		is updated, and the buffer may have been modified.
		Except for isochronous transfers, the actual_length is
		updated to say how many bytes were transferred; if the
		USBDEVFS_URB_DISABLE_SPD flag is set
		("short packets are not OK"), if fewer bytes were read
		than were requested then you get an error report.
		</para>
            <programlisting>struct usbdevfs_iso_packet_desc {
        unsigned int                     length;
        unsigned int                     actual_length;
        unsigned int                     status;
};

struct usbdevfs_urb {
        unsigned char                    type;
        unsigned char                    endpoint;
        int                              status;
        unsigned int                     flags;
        void                             *buffer;
        int                              buffer_length;
        int                              actual_length;
        int                              start_frame;
        int                              number_of_packets;
        int                              error_count;
        unsigned int                     signr;
        void                             *usercontext;
        struct usbdevfs_iso_packet_desc  iso_frame_desc[];
};</programlisting>
            <para> For these asynchronous requests, the file modification
		time reflects when the request was initiated.
		This contrasts with their use with the synchronous requests,
		where it reflects when requests complete.
		</para>
            <variablelist>
              <varlistentry>
                <term>USBDEVFS_DISCARDURB</term>
                <listitem>
                  <para>
                    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para>
                  <para>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_DISCSIGNAL</term>
                <listitem>
                  <para>
                    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para>
                  <para>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_REAPURB</term>
                <listitem>
                  <para>
                    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para>
                  <para>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_REAPURBNDELAY</term>
                <listitem>
                  <para>
                    <emphasis>TBS</emphasis>
		    File modification time is not updated by this request.
		    </para>
                  <para>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>USBDEVFS_SUBMITURB</term>
                <listitem>
                  <para>
                    <emphasis>TBS</emphasis>
                  </para>
                  <para>
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </sect2>
        </sect1>
      </chapter>
    </book>
    <!-- vim:syntax=sgml:sw=4
-->
    <!-- ****************************************************** -->
    <!-- Header  -->
    <!-- ****************************************************** -->
    <book id="Writing-an-ALSA-Driver">
      <bookinfo>
        <title>Writing an ALSA Driver</title>
        <author>
          <firstname>Takashi</firstname>
          <surname>Iwai</surname>
          <affiliation>
            <address>
              <email>tiwai@suse.de</email>
            </address>
          </affiliation>
        </author>
        <date>Oct 15, 2007</date>
        <edition>0.3.7</edition>
        <abstract>
          <para>
        This document describes how to write an ALSA (Advanced Linux
        Sound Architecture) driver.
      </para>
        </abstract>
        <legalnotice>
          <para>
    Copyright (c) 2002-2005  Takashi Iwai <email>tiwai@suse.de</email></para>
          <para>
    This document is free; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version. 
    </para>
          <para>
    This document is distributed in the hope that it will be useful,
    but <emphasis>WITHOUT ANY WARRANTY</emphasis>; without even the
    implied warranty of <emphasis>MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE</emphasis>. See the GNU General Public License
    for more details.
    </para>
          <para>
    You should have received a copy of the GNU General Public
    License along with this program; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
    MA 02111-1307 USA
    </para>
        </legalnotice>
      </bookinfo>
      <!-- ****************************************************** -->
      <!-- Preface  -->
      <!-- ****************************************************** -->
      <preface id="preface">
        <title>Preface</title>
        <para>
      This document describes how to write an
      <ulink url="http://www.alsa-project.org/"><citetitle>
      ALSA (Advanced Linux Sound Architecture)</citetitle></ulink>
      driver. The document focuses mainly on PCI soundcards.
      In the case of other device types, the API might
      be different, too. However, at least the ALSA kernel API is
      consistent, and therefore it would be still a bit help for
      writing them.
    </para>
        <para>
    This document targets people who already have enough
    C language skills and have basic linux kernel programming
    knowledge.  This document doesn't explain the general
    topic of linux kernel coding and doesn't cover low-level
    driver implementation details. It only describes
    the standard way to write a PCI sound driver on ALSA.
    </para>
        <para>
      If you are already familiar with the older ALSA ver.0.5.x API, you
    can check the drivers such as <filename>sound/pci/es1938.c</filename> or
    <filename>sound/pci/maestro3.c</filename> which have also almost the same
    code-base in the ALSA 0.5.x tree, so you can compare the differences.
    </para>
        <para>
      This document is still a draft version. Any feedback and
    corrections, please!!
    </para>
      </preface>
      <!-- ****************************************************** -->
      <!-- File Tree Structure  -->
      <!-- ****************************************************** -->
      <chapter id="file-tree">
        <title>File Tree Structure</title>
        <section id="file-tree-general">
          <title>General</title>
          <para>
        The ALSA drivers are provided in two ways.
      </para>
          <para>
        One is the trees provided as a tarball or via cvs from the
      ALSA's ftp site, and another is the 2.6 (or later) Linux kernel
      tree. To synchronize both, the ALSA driver tree is split into
      two different trees: alsa-kernel and alsa-driver. The former
      contains purely the source code for the Linux 2.6 (or later)
      tree. This tree is designed only for compilation on 2.6 or
      later environment. The latter, alsa-driver, contains many subtle
      files for compiling ALSA drivers outside of the Linux kernel tree,
      wrapper functions for older 2.2 and 2.4 kernels, to adapt the latest kernel API,
      and additional drivers which are still in development or in
      tests.  The drivers in alsa-driver tree will be moved to
      alsa-kernel (and eventually to the 2.6 kernel tree) when they are
      finished and confirmed to work fine.
      </para>
          <para>
        The file tree structure of ALSA driver is depicted below. Both
        alsa-kernel and alsa-driver have almost the same file
        structure, except for <quote>core</quote> directory. It's
        named as <quote>acore</quote> in alsa-driver tree. 

        <example><title>ALSA File Tree Structure</title><literallayout>
        sound
                /core
                        /oss
                        /seq
                                /oss
                                /instr
                /ioctl32
                /include
                /drivers
                        /mpu401
                        /opl3
                /i2c
                        /l3
                /synth
                        /emux
                /pci
                        /(cards)
                /isa
                        /(cards)
                /arm
                /ppc
                /sparc
                /usb
                /pcmcia /(cards)
                /oss
          </literallayout></example></para>
        </section>
        <section id="file-tree-core-directory">
          <title>core directory</title>
          <para>
        This directory contains the middle layer which is the heart
      of ALSA drivers. In this directory, the native ALSA modules are
      stored. The sub-directories contain different modules and are
      dependent upon the kernel config. 
      </para>
          <section id="file-tree-core-directory-oss">
            <title>core/oss</title>
            <para>
          The codes for PCM and mixer OSS emulation modules are stored
        in this directory. The rawmidi OSS emulation is included in
        the ALSA rawmidi code since it's quite small. The sequencer
        code is stored in <filename>core/seq/oss</filename> directory (see
        <link linkend="file-tree-core-directory-seq-oss"><citetitle>
        below</citetitle></link>).
        </para>
          </section>
          <section id="file-tree-core-directory-ioctl32">
            <title>core/ioctl32</title>
            <para>
          This directory contains the 32bit-ioctl wrappers for 64bit
        architectures such like x86-64, ppc64 and sparc64. For 32bit
        and alpha architectures, these are not compiled. 
        </para>
          </section>
          <section id="file-tree-core-directory-seq">
            <title>core/seq</title>
            <para>
          This directory and its sub-directories are for the ALSA
        sequencer. This directory contains the sequencer core and
        primary sequencer modules such like snd-seq-midi,
        snd-seq-virmidi, etc. They are compiled only when
        <constant>CONFIG_SND_SEQUENCER</constant> is set in the kernel
        config. 
        </para>
          </section>
          <section id="file-tree-core-directory-seq-oss">
            <title>core/seq/oss</title>
            <para>
          This contains the OSS sequencer emulation codes.
        </para>
          </section>
          <section id="file-tree-core-directory-deq-instr">
            <title>core/seq/instr</title>
            <para>
          This directory contains the modules for the sequencer
        instrument layer. 
        </para>
          </section>
        </section>
        <section id="file-tree-include-directory">
          <title>include directory</title>
          <para>
        This is the place for the public header files of ALSA drivers,
      which are to be exported to user-space, or included by
      several files at different directories. Basically, the private
      header files should not be placed in this directory, but you may
      still find files there, due to historical reasons :) 
      </para>
        </section>
        <section id="file-tree-drivers-directory">
          <title>drivers directory</title>
          <para>
        This directory contains code shared among different drivers
      on different architectures.  They are hence supposed not to be
      architecture-specific.
      For example, the dummy pcm driver and the serial MIDI
      driver are found in this directory. In the sub-directories,
      there is code for components which are independent from
      bus and cpu architectures. 
      </para>
          <section id="file-tree-drivers-directory-mpu401">
            <title>drivers/mpu401</title>
            <para>
          The MPU401 and MPU401-UART modules are stored here.
        </para>
          </section>
          <section id="file-tree-drivers-directory-opl3">
            <title>drivers/opl3 and opl4</title>
            <para>
          The OPL3 and OPL4 FM-synth stuff is found here.
        </para>
          </section>
        </section>
        <section id="file-tree-i2c-directory">
          <title>i2c directory</title>
          <para>
        This contains the ALSA i2c components.
      </para>
          <para>
        Although there is a standard i2c layer on Linux, ALSA has its
      own i2c code for some cards, because the soundcard needs only a
      simple operation and the standard i2c API is too complicated for
      such a purpose. 
      </para>
          <section id="file-tree-i2c-directory-l3">
            <title>i2c/l3</title>
            <para>
          This is a sub-directory for ARM L3 i2c.
        </para>
          </section>
        </section>
        <section id="file-tree-synth-directory">
          <title>synth directory</title>
          <para>
          This contains the synth middle-level modules.
        </para>
          <para>
          So far, there is only Emu8000/Emu10k1 synth driver under
        the <filename>synth/emux</filename> sub-directory. 
        </para>
        </section>
        <section id="file-tree-pci-directory">
          <title>pci directory</title>
          <para>
        This directory and its sub-directories hold the top-level card modules
      for PCI soundcards and the code specific to the PCI BUS.
      </para>
          <para>
        The drivers compiled from a single file are stored directly
      in the pci directory, while the drivers with several source files are
      stored on their own sub-directory (e.g. emu10k1, ice1712). 
      </para>
        </section>
        <section id="file-tree-isa-directory">
          <title>isa directory</title>
          <para>
        This directory and its sub-directories hold the top-level card modules
      for ISA soundcards. 
      </para>
        </section>
        <section id="file-tree-arm-ppc-sparc-directories">
          <title>arm, ppc, and sparc directories</title>
          <para>
        They are used for top-level card modules which are
      specific to one of these architectures. 
      </para>
        </section>
        <section id="file-tree-usb-directory">
          <title>usb directory</title>
          <para>
        This directory contains the USB-audio driver. In the latest version, the
      USB MIDI driver is integrated in the usb-audio driver. 
      </para>
        </section>
        <section id="file-tree-pcmcia-directory">
          <title>pcmcia directory</title>
          <para>
        The PCMCIA, especially PCCard drivers will go here. CardBus
      drivers will be in the pci directory, because their API is identical
      to that of standard PCI cards. 
      </para>
        </section>
        <section id="file-tree-oss-directory">
          <title>oss directory</title>
          <para>
        The OSS/Lite source files are stored here in Linux 2.6 (or
      later) tree. In the ALSA driver tarball, this directory is empty,
      of course :) 
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Basic Flow for PCI Drivers  -->
      <!-- ****************************************************** -->
      <chapter id="basic-flow">
        <title>Basic Flow for PCI Drivers</title>
        <section id="basic-flow-outline">
          <title>Outline</title>
          <para>
        The minimum flow for PCI soundcards is as follows:

        <itemizedlist><listitem><para>define the PCI ID table (see the section
          <link linkend="pci-resource-entries"><citetitle>PCI Entries
          </citetitle></link>).</para></listitem><listitem><para>create <function>probe()</function> callback.</para></listitem><listitem><para>create <function>remove()</function> callback.</para></listitem><listitem><para>create a <structname>pci_driver</structname> structure
	  containing the three pointers above.</para></listitem><listitem><para>create an <function>init()</function> function just calling
	  the <function>pci_register_driver()</function> to register the pci_driver table
	  defined above.</para></listitem><listitem><para>create an <function>exit()</function> function to call
	  the <function>pci_unregister_driver()</function> function.</para></listitem></itemizedlist></para>
        </section>
        <section id="basic-flow-example">
          <title>Full Code Example</title>
          <para>
        The code example is shown below. Some parts are kept
      unimplemented at this moment but will be filled in the
      next sections. The numbers in the comment lines of the
      <function>snd_mychip_probe()</function> function
      refer to details explained in the following section. 

        <example><title>Basic Flow for PCI Drivers - Example</title><programlisting><![CDATA[
  #include <linux/init.h>
  #include <linux/pci.h>
  #include <linux/slab.h>
  #include <sound/core.h>
  #include <sound/initval.h>

  /* module parameters (see "Module Parameters") */
  /* SNDRV_CARDS: maximum number of cards supported by this module */
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
  static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;

  /* definition of the chip-specific record */
  struct mychip {
          struct snd_card *card;
          /* the rest of the implementation will be in section
           * "PCI Resource Management"
           */
  };

  /* chip-specific destructor
   * (see "PCI Resource Management")
   */
  static int snd_mychip_free(struct mychip *chip)
  {
          .... /* will be implemented later... */
  }

  /* component-destructor
   * (see "Management of Cards and Components")
   */
  static int snd_mychip_dev_free(struct snd_device *device)
  {
          return snd_mychip_free(device->device_data);
  }

  /* chip-specific constructor
   * (see "Management of Cards and Components")
   */
  static int snd_mychip_create(struct snd_card *card,
                               struct pci_dev *pci,
                               struct mychip **rchip)
  {
          struct mychip *chip;
          int err;
          static struct snd_device_ops ops = {
                 .dev_free = snd_mychip_dev_free,
          };

          *rchip = NULL;

          /* check PCI availability here
           * (see "PCI Resource Management")
           */
          ....

          /* allocate a chip-specific data with zero filled */
          chip = kzalloc(sizeof(*chip), GFP_KERNEL);
          if (chip == NULL)
                  return -ENOMEM;

          chip->card = card;

          /* rest of initialization here; will be implemented
           * later, see "PCI Resource Management"
           */
          ....

          err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
          if (err < 0) {
                  snd_mychip_free(chip);
                  return err;
          }

          snd_card_set_dev(card, &pci->dev);

          *rchip = chip;
          return 0;
  }

  /* constructor -- see "Constructor" sub-section */
  static int snd_mychip_probe(struct pci_dev *pci,
                              const struct pci_device_id *pci_id)
  {
          static int dev;
          struct snd_card *card;
          struct mychip *chip;
          int err;

          /* (1) */
          if (dev >= SNDRV_CARDS)
                  return -ENODEV;
          if (!enable[dev]) {
                  dev++;
                  return -ENOENT;
          }

          /* (2) */
          err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
          if (err < 0)
                  return err;

          /* (3) */
          err = snd_mychip_create(card, pci, &chip);
          if (err < 0) {
                  snd_card_free(card);
                  return err;
          }

          /* (4) */
          strcpy(card->driver, "My Chip");
          strcpy(card->shortname, "My Own Chip 123");
          sprintf(card->longname, "%s at 0x%lx irq %i",
                  card->shortname, chip->ioport, chip->irq);

          /* (5) */
          .... /* implemented later */

          /* (6) */
          err = snd_card_register(card);
          if (err < 0) {
                  snd_card_free(card);
                  return err;
          }

          /* (7) */
          pci_set_drvdata(pci, card);
          dev++;
          return 0;
  }

  /* destructor -- see the "Destructor" sub-section */
  static void snd_mychip_remove(struct pci_dev *pci)
  {
          snd_card_free(pci_get_drvdata(pci));
          pci_set_drvdata(pci, NULL);
  }
]]></programlisting></example></para>
        </section>
        <section id="basic-flow-constructor">
          <title>Constructor</title>
          <para>
        The real constructor of PCI drivers is the <function>probe</function> callback.
      The <function>probe</function> callback and other component-constructors which are called
      from the <function>probe</function> callback cannot be used with
      the <parameter>__init</parameter> prefix
      because any PCI device could be a hotplug device. 
      </para>
          <para>
        In the <function>probe</function> callback, the following scheme is often used.
      </para>
          <section id="basic-flow-constructor-device-index">
            <title>1) Check and increment the device index.</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int dev;
  ....
  if (dev >= SNDRV_CARDS)
          return -ENODEV;
  if (!enable[dev]) {
          dev++;
          return -ENOENT;
  }
]]></programlisting>
              </informalexample>

        where enable[dev] is the module option.
        </para>
            <para>
          Each time the <function>probe</function> callback is called, check the
        availability of the device. If not available, simply increment
        the device index and returns. dev will be incremented also
        later (<link linkend="basic-flow-constructor-set-pci"><citetitle>step
        7</citetitle></link>). 
        </para>
          </section>
          <section id="basic-flow-constructor-create-card">
            <title>2) Create a card instance</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  struct snd_card *card;
  int err;
  ....
  err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
]]></programlisting>
              </informalexample>
            </para>
            <para>
          The details will be explained in the section
          <link linkend="card-management-card-instance"><citetitle>
          Management of Cards and Components</citetitle></link>.
        </para>
          </section>
          <section id="basic-flow-constructor-create-main">
            <title>3) Create a main component</title>
            <para>
          In this part, the PCI resources are allocated.

          <informalexample><programlisting><![CDATA[
  struct mychip *chip;
  ....
  err = snd_mychip_create(card, pci, &chip);
  if (err < 0) {
          snd_card_free(card);
          return err;
  }
]]></programlisting></informalexample>

          The details will be explained in the section <link linkend="pci-resource"><citetitle>PCI Resource
        Management</citetitle></link>.
        </para>
          </section>
          <section id="basic-flow-constructor-main-component">
            <title>4) Set the driver ID and name strings.</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  strcpy(card->driver, "My Chip");
  strcpy(card->shortname, "My Own Chip 123");
  sprintf(card->longname, "%s at 0x%lx irq %i",
          card->shortname, chip->ioport, chip->irq);
]]></programlisting>
              </informalexample>

          The driver field holds the minimal ID string of the
        chip. This is used by alsa-lib's configurator, so keep it
        simple but unique. 
          Even the same driver can have different driver IDs to
        distinguish the functionality of each chip type. 
        </para>
            <para>
          The shortname field is a string shown as more verbose
        name. The longname field contains the information
        shown in <filename>/proc/asound/cards</filename>. 
        </para>
          </section>
          <section id="basic-flow-constructor-create-other">
            <title>5) Create other components, such as mixer, MIDI, etc.</title>
            <para>
          Here you define the basic components such as
          <link linkend="pcm-interface"><citetitle>PCM</citetitle></link>,
          mixer (e.g. <link linkend="api-ac97"><citetitle>AC97</citetitle></link>),
          MIDI (e.g. <link linkend="midi-interface"><citetitle>MPU-401</citetitle></link>),
          and other interfaces.
          Also, if you want a <link linkend="proc-interface"><citetitle>proc
        file</citetitle></link>, define it here, too.
        </para>
          </section>
          <section id="basic-flow-constructor-register-card">
            <title>6) Register the card instance.</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  err = snd_card_register(card);
  if (err < 0) {
          snd_card_free(card);
          return err;
  }
]]></programlisting>
              </informalexample>
            </para>
            <para>
          Will be explained in the section <link linkend="card-management-registration"><citetitle>Management
        of Cards and Components</citetitle></link>, too. 
        </para>
          </section>
          <section id="basic-flow-constructor-set-pci">
            <title>7) Set the PCI driver data and return zero.</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
        pci_set_drvdata(pci, card);
        dev++;
        return 0;
]]></programlisting>
              </informalexample>

          In the above, the card record is stored. This pointer is
        used in the remove callback and power-management
        callbacks, too. 
        </para>
          </section>
        </section>
        <section id="basic-flow-destructor">
          <title>Destructor</title>
          <para>
        The destructor, remove callback, simply releases the card
      instance. Then the ALSA middle layer will release all the
      attached components automatically. 
      </para>
          <para>
        It would be typically like the following:

        <informalexample><programlisting><![CDATA[
  static void snd_mychip_remove(struct pci_dev *pci)
  {
          snd_card_free(pci_get_drvdata(pci));
          pci_set_drvdata(pci, NULL);
  }
]]></programlisting></informalexample>

        The above code assumes that the card pointer is set to the PCI
	driver data.
      </para>
        </section>
        <section id="basic-flow-header-files">
          <title>Header Files</title>
          <para>
        For the above example, at least the following include files
      are necessary. 

        <informalexample><programlisting><![CDATA[
  #include <linux/init.h>
  #include <linux/pci.h>
  #include <linux/slab.h>
  #include <sound/core.h>
  #include <sound/initval.h>
]]></programlisting></informalexample>

	where the last one is necessary only when module options are
      defined in the source file.  If the code is split into several
      files, the files without module options don't need them.
      </para>
          <para>
        In addition to these headers, you'll need
      <filename>&lt;linux/interrupt.h&gt;</filename> for interrupt
      handling, and <filename>&lt;asm/io.h&gt;</filename> for I/O
      access. If you use the <function>mdelay()</function> or
      <function>udelay()</function> functions, you'll need to include
      <filename>&lt;linux/delay.h&gt;</filename> too. 
      </para>
          <para>
      The ALSA interfaces like the PCM and control APIs are defined in other
      <filename>&lt;sound/xxx.h&gt;</filename> header files.
      They have to be included after
      <filename>&lt;sound/core.h&gt;</filename>.
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Management of Cards and Components  -->
      <!-- ****************************************************** -->
      <chapter id="card-management">
        <title>Management of Cards and Components</title>
        <section id="card-management-card-instance">
          <title>Card Instance</title>
          <para>
      For each soundcard, a <quote>card</quote> record must be allocated.
      </para>
          <para>
      A card record is the headquarters of the soundcard.  It manages
      the whole list of devices (components) on the soundcard, such as
      PCM, mixers, MIDI, synthesizer, and so on.  Also, the card
      record holds the ID and the name strings of the card, manages
      the root of proc files, and controls the power-management states
      and hotplug disconnections.  The component list on the card
      record is used to manage the correct release of resources at
      destruction. 
      </para>
          <para>
        As mentioned above, to create a card instance, call
      <function>snd_card_create()</function>.

        <informalexample><programlisting><![CDATA[
  struct snd_card *card;
  int err;
  err = snd_card_create(index, id, module, extra_size, &card);
]]></programlisting></informalexample></para>
          <para>
        The function takes five arguments, the card-index number, the
        id string, the module pointer (usually
        <constant>THIS_MODULE</constant>),
        the size of extra-data space, and the pointer to return the
        card instance.  The extra_size argument is used to
        allocate card-&gt;private_data for the
        chip-specific data.  Note that these data
        are allocated by <function>snd_card_create()</function>.
      </para>
        </section>
        <section id="card-management-component">
          <title>Components</title>
          <para>
        After the card is created, you can attach the components
      (devices) to the card instance. In an ALSA driver, a component is
      represented as a struct <structname>snd_device</structname> object.
      A component can be a PCM instance, a control interface, a raw
      MIDI interface, etc.  Each such instance has one component
      entry.
      </para>
          <para>
        A component can be created via
        <function>snd_device_new()</function> function. 

        <informalexample><programlisting><![CDATA[
  snd_device_new(card, SNDRV_DEV_XXX, chip, &ops);
]]></programlisting></informalexample></para>
          <para>
        This takes the card pointer, the device-level
      (<constant>SNDRV_DEV_XXX</constant>), the data pointer, and the
      callback pointers (<parameter>&amp;ops</parameter>). The
      device-level defines the type of components and the order of
      registration and de-registration.  For most components, the
      device-level is already defined.  For a user-defined component,
      you can use <constant>SNDRV_DEV_LOWLEVEL</constant>.
      </para>
          <para>
      This function itself doesn't allocate the data space. The data
      must be allocated manually beforehand, and its pointer is passed
      as the argument. This pointer (<parameter>chip</parameter> in the
      above example) is used as the identifier for the instance.
      </para>
          <para>
        Each pre-defined ALSA component such as ac97 and pcm calls
      <function>snd_device_new()</function> inside its
      constructor. The destructor for each component is defined in the
      callback pointers.  Hence, you don't need to take care of
      calling a destructor for such a component.
      </para>
          <para>
        If you wish to create your own component, you need to
      set the destructor function to the dev_free callback in
      the <parameter>ops</parameter>, so that it can be released
      automatically via <function>snd_card_free()</function>.
      The next example will show an implementation of chip-specific
      data.
      </para>
        </section>
        <section id="card-management-chip-specific">
          <title>Chip-Specific Data</title>
          <para>
      Chip-specific information, e.g. the I/O port address, its
      resource pointer, or the irq number, is stored in the
      chip-specific record.

        <informalexample><programlisting><![CDATA[
  struct mychip {
          ....
  };
]]></programlisting></informalexample></para>
          <para>
        In general, there are two ways of allocating the chip record.
      </para>
          <section id="card-management-chip-specific-snd-card-new">
            <title>1. Allocating via <function>snd_card_create()</function>.</title>
            <para>
          As mentioned above, you can pass the extra-data-length
	  to the 4th argument of <function>snd_card_create()</function>, i.e.

          <informalexample><programlisting><![CDATA[
  err = snd_card_create(index[dev], id[dev], THIS_MODULE,
                        sizeof(struct mychip), &card);
]]></programlisting></informalexample>

          struct <structname>mychip</structname> is the type of the chip record.
        </para>
            <para>
          In return, the allocated record can be accessed as

          <informalexample><programlisting><![CDATA[
  struct mychip *chip = card->private_data;
]]></programlisting></informalexample>

          With this method, you don't have to allocate twice.
          The record is released together with the card instance.
        </para>
          </section>
          <section id="card-management-chip-specific-allocate-extra">
            <title>2. Allocating an extra device.</title>
            <para>
          After allocating a card instance via
          <function>snd_card_create()</function> (with
          <constant>0</constant> on the 4th arg), call
          <function>kzalloc()</function>. 

          <informalexample><programlisting><![CDATA[
  struct snd_card *card;
  struct mychip *chip;
  err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
  .....
  chip = kzalloc(sizeof(*chip), GFP_KERNEL);
]]></programlisting></informalexample></para>
            <para>
          The chip record should have the field to hold the card
          pointer at least, 

          <informalexample><programlisting><![CDATA[
  struct mychip {
          struct snd_card *card;
          ....
  };
]]></programlisting></informalexample></para>
            <para>
          Then, set the card pointer in the returned chip instance.

          <informalexample><programlisting><![CDATA[
  chip->card = card;
]]></programlisting></informalexample></para>
            <para>
          Next, initialize the fields, and register this chip
          record as a low-level device with a specified
          <parameter>ops</parameter>, 

          <informalexample><programlisting><![CDATA[
  static struct snd_device_ops ops = {
          .dev_free =        snd_mychip_dev_free,
  };
  ....
  snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
]]></programlisting></informalexample><function>snd_mychip_dev_free()</function> is the
        device-destructor function, which will call the real
        destructor. 
        </para>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_mychip_dev_free(struct snd_device *device)
  {
          return snd_mychip_free(device->device_data);
  }
]]></programlisting>
              </informalexample>

          where <function>snd_mychip_free()</function> is the real destructor.
        </para>
          </section>
        </section>
        <section id="card-management-registration">
          <title>Registration and Release</title>
          <para>
        After all components are assigned, register the card instance
      by calling <function>snd_card_register()</function>. Access
      to the device files is enabled at this point. That is, before
      <function>snd_card_register()</function> is called, the
      components are safely inaccessible from external side. If this
      call fails, exit the probe function after releasing the card via
      <function>snd_card_free()</function>. 
      </para>
          <para>
        For releasing the card instance, you can call simply
      <function>snd_card_free()</function>. As mentioned earlier, all
      components are released automatically by this call. 
      </para>
          <para>
      For a device which allows hotplugging, you can use
      <function>snd_card_free_when_closed</function>.  This one will
      postpone the destruction until all devices are closed.
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- PCI Resource Management  -->
      <!-- ****************************************************** -->
      <chapter id="pci-resource">
        <title>PCI Resource Management</title>
        <section id="pci-resource-example">
          <title>Full Code Example</title>
          <para>
        In this section, we'll complete the chip-specific constructor,
      destructor and PCI entries. Example code is shown first,
      below. 

        <example><title>PCI Resource Management Example</title><programlisting><![CDATA[
  struct mychip {
          struct snd_card *card;
          struct pci_dev *pci;

          unsigned long port;
          int irq;
  };

  static int snd_mychip_free(struct mychip *chip)
  {
          /* disable hardware here if any */
          .... /* (not implemented in this document) */

          /* release the irq */
          if (chip->irq >= 0)
                  free_irq(chip->irq, chip);
          /* release the I/O ports & memory */
          pci_release_regions(chip->pci);
          /* disable the PCI entry */
          pci_disable_device(chip->pci);
          /* release the data */
          kfree(chip);
          return 0;
  }

  /* chip-specific constructor */
  static int snd_mychip_create(struct snd_card *card,
                               struct pci_dev *pci,
                               struct mychip **rchip)
  {
          struct mychip *chip;
          int err;
          static struct snd_device_ops ops = {
                 .dev_free = snd_mychip_dev_free,
          };

          *rchip = NULL;

          /* initialize the PCI entry */
          err = pci_enable_device(pci);
          if (err < 0)
                  return err;
          /* check PCI availability (28bit DMA) */
          if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
              pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
                  printk(KERN_ERR "error to set 28bit mask DMA\n");
                  pci_disable_device(pci);
                  return -ENXIO;
          }

          chip = kzalloc(sizeof(*chip), GFP_KERNEL);
          if (chip == NULL) {
                  pci_disable_device(pci);
                  return -ENOMEM;
          }

          /* initialize the stuff */
          chip->card = card;
          chip->pci = pci;
          chip->irq = -1;

          /* (1) PCI resource allocation */
          err = pci_request_regions(pci, "My Chip");
          if (err < 0) {
                  kfree(chip);
                  pci_disable_device(pci);
                  return err;
          }
          chip->port = pci_resource_start(pci, 0);
          if (request_irq(pci->irq, snd_mychip_interrupt,
                          IRQF_SHARED, KBUILD_MODNAME, chip)) {
                  printk(KERN_ERR "cannot grab irq %d\n", pci->irq);
                  snd_mychip_free(chip);
                  return -EBUSY;
          }
          chip->irq = pci->irq;

          /* (2) initialization of the chip hardware */
          .... /*   (not implemented in this document) */

          err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);
          if (err < 0) {
                  snd_mychip_free(chip);
                  return err;
          }

          snd_card_set_dev(card, &pci->dev);

          *rchip = chip;
          return 0;
  }        

  /* PCI IDs */
  static struct pci_device_id snd_mychip_ids[] = {
          { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
            PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
          ....
          { 0, }
  };
  MODULE_DEVICE_TABLE(pci, snd_mychip_ids);

  /* pci_driver definition */
  static struct pci_driver driver = {
          .name = KBUILD_MODNAME,
          .id_table = snd_mychip_ids,
          .probe = snd_mychip_probe,
          .remove = snd_mychip_remove,
  };

  /* module initialization */
  static int __init alsa_card_mychip_init(void)
  {
          return pci_register_driver(&driver);
  }

  /* module clean up */
  static void __exit alsa_card_mychip_exit(void)
  {
          pci_unregister_driver(&driver);
  }

  module_init(alsa_card_mychip_init)
  module_exit(alsa_card_mychip_exit)

  EXPORT_NO_SYMBOLS; /* for old kernels only */
]]></programlisting></example></para>
        </section>
        <section id="pci-resource-some-haftas">
          <title>Some Hafta's</title>
          <para>
        The allocation of PCI resources is done in the
      <function>probe()</function> function, and usually an extra
      <function>xxx_create()</function> function is written for this
      purpose.
      </para>
          <para>
        In the case of PCI devices, you first have to call
      the <function>pci_enable_device()</function> function before
      allocating resources. Also, you need to set the proper PCI DMA
      mask to limit the accessed I/O range. In some cases, you might
      need to call <function>pci_set_master()</function> function,
      too.
      </para>
          <para>
        Suppose the 28bit mask, and the code to be added would be like:

        <informalexample><programlisting><![CDATA[
  err = pci_enable_device(pci);
  if (err < 0)
          return err;
  if (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||
      pci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {
          printk(KERN_ERR "error to set 28bit mask DMA\n");
          pci_disable_device(pci);
          return -ENXIO;
  }
  
]]></programlisting></informalexample></para>
        </section>
        <section id="pci-resource-resource-allocation">
          <title>Resource Allocation</title>
          <para>
        The allocation of I/O ports and irqs is done via standard kernel
      functions. Unlike ALSA ver.0.5.x., there are no helpers for
      that. And these resources must be released in the destructor
      function (see below). Also, on ALSA 0.9.x, you don't need to
      allocate (pseudo-)DMA for PCI like in ALSA 0.5.x.
      </para>
          <para>
        Now assume that the PCI device has an I/O port with 8 bytes
        and an interrupt. Then struct <structname>mychip</structname> will have the
        following fields:

        <informalexample><programlisting><![CDATA[
  struct mychip {
          struct snd_card *card;

          unsigned long port;
          int irq;
  };
]]></programlisting></informalexample></para>
          <para>
        For an I/O port (and also a memory region), you need to have
      the resource pointer for the standard resource management. For
      an irq, you have to keep only the irq number (integer). But you
      need to initialize this number as -1 before actual allocation,
      since irq 0 is valid. The port address and its resource pointer
      can be initialized as null by
      <function>kzalloc()</function> automatically, so you
      don't have to take care of resetting them. 
      </para>
          <para>
        The allocation of an I/O port is done like this:

        <informalexample><programlisting><![CDATA[
  err = pci_request_regions(pci, "My Chip");
  if (err < 0) { 
          kfree(chip);
          pci_disable_device(pci);
          return err;
  }
  chip->port = pci_resource_start(pci, 0);
]]></programlisting></informalexample></para>
          <para>
            <!-- obsolete -->
        It will reserve the I/O port region of 8 bytes of the given
      PCI device. The returned value, chip-&gt;res_port, is allocated
      via <function>kmalloc()</function> by
      <function>request_region()</function>. The pointer must be
      released via <function>kfree()</function>, but there is a
      problem with this. This issue will be explained later.
      </para>
          <para>
        The allocation of an interrupt source is done like this:

        <informalexample><programlisting><![CDATA[
  if (request_irq(pci->irq, snd_mychip_interrupt,
                  IRQF_SHARED, KBUILD_MODNAME, chip)) {
          printk(KERN_ERR "cannot grab irq %d\n", pci->irq);
          snd_mychip_free(chip);
          return -EBUSY;
  }
  chip->irq = pci->irq;
]]></programlisting></informalexample>

        where <function>snd_mychip_interrupt()</function> is the
      interrupt handler defined <link linkend="pcm-interface-interrupt-handler"><citetitle>later</citetitle></link>.
      Note that chip-&gt;irq should be defined
      only when <function>request_irq()</function> succeeded.
      </para>
          <para>
      On the PCI bus, interrupts can be shared. Thus,
      <constant>IRQF_SHARED</constant> is used as the interrupt flag of
      <function>request_irq()</function>. 
      </para>
          <para>
        The last argument of <function>request_irq()</function> is the
      data pointer passed to the interrupt handler. Usually, the
      chip-specific record is used for that, but you can use what you
      like, too. 
      </para>
          <para>
        I won't give details about the interrupt handler at this
        point, but at least its appearance can be explained now. The
        interrupt handler looks usually like the following: 

        <informalexample><programlisting><![CDATA[
  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
  {
          struct mychip *chip = dev_id;
          ....
          return IRQ_HANDLED;
  }
]]></programlisting></informalexample></para>
          <para>
        Now let's write the corresponding destructor for the resources
      above. The role of destructor is simple: disable the hardware
      (if already activated) and release the resources. So far, we
      have no hardware part, so the disabling code is not written here. 
      </para>
          <para>
        To release the resources, the <quote>check-and-release</quote>
        method is a safer way. For the interrupt, do like this: 

        <informalexample><programlisting><![CDATA[
  if (chip->irq >= 0)
          free_irq(chip->irq, chip);
]]></programlisting></informalexample>

        Since the irq number can start from 0, you should initialize
        chip-&gt;irq with a negative value (e.g. -1), so that you can
        check the validity of the irq number as above.
      </para>
          <para>
        When you requested I/O ports or memory regions via
	<function>pci_request_region()</function> or
	<function>pci_request_regions()</function> like in this example,
	release the resource(s) using the corresponding function,
	<function>pci_release_region()</function> or
	<function>pci_release_regions()</function>.

        <informalexample><programlisting><![CDATA[
  pci_release_regions(chip->pci);
]]></programlisting></informalexample></para>
          <para>
	When you requested manually via <function>request_region()</function>
	or <function>request_mem_region</function>, you can release it via
	<function>release_resource()</function>.  Suppose that you keep
	the resource pointer returned from <function>request_region()</function>
	in chip-&gt;res_port, the release procedure looks like:

        <informalexample><programlisting><![CDATA[
  release_and_free_resource(chip->res_port);
]]></programlisting></informalexample></para>
          <para>
      Don't forget to call <function>pci_disable_device()</function>
      before the end.
      </para>
          <para>
        And finally, release the chip-specific record.

        <informalexample><programlisting><![CDATA[
  kfree(chip);
]]></programlisting></informalexample></para>
          <para>
      We didn't implement the hardware disabling part in the above.
      If you need to do this, please note that the destructor may be
      called even before the initialization of the chip is completed.
      It would be better to have a flag to skip hardware disabling
      if the hardware was not initialized yet.
      </para>
          <para>
      When the chip-data is assigned to the card using
      <function>snd_device_new()</function> with
      <constant>SNDRV_DEV_LOWLELVEL</constant> , its destructor is 
      called at the last.  That is, it is assured that all other
      components like PCMs and controls have already been released.
      You don't have to stop PCMs, etc. explicitly, but just
      call low-level hardware stopping.
      </para>
          <para>
        The management of a memory-mapped region is almost as same as
        the management of an I/O port. You'll need three fields like
        the following: 

        <informalexample><programlisting><![CDATA[
  struct mychip {
          ....
          unsigned long iobase_phys;
          void __iomem *iobase_virt;
  };
]]></programlisting></informalexample>

        and the allocation would be like below:

        <informalexample><programlisting><![CDATA[
  if ((err = pci_request_regions(pci, "My Chip")) < 0) {
          kfree(chip);
          return err;
  }
  chip->iobase_phys = pci_resource_start(pci, 0);
  chip->iobase_virt = ioremap_nocache(chip->iobase_phys,
                                      pci_resource_len(pci, 0));
]]></programlisting></informalexample>
        
        and the corresponding destructor would be:

        <informalexample><programlisting><![CDATA[
  static int snd_mychip_free(struct mychip *chip)
  {
          ....
          if (chip->iobase_virt)
                  iounmap(chip->iobase_virt);
          ....
          pci_release_regions(chip->pci);
          ....
  }
]]></programlisting></informalexample></para>
        </section>
        <section id="pci-resource-device-struct">
          <title>Registration of Device Struct</title>
          <para>
	At some point, typically after calling <function>snd_device_new()</function>,
	you need to register the struct <structname>device</structname> of the chip
	you're handling for udev and co.  ALSA provides a macro for compatibility with
	older kernels.  Simply call like the following:
        <informalexample><programlisting><![CDATA[
  snd_card_set_dev(card, &pci->dev);
]]></programlisting></informalexample>
	so that it stores the PCI's device pointer to the card.  This will be
	referred by ALSA core functions later when the devices are registered.
      </para>
          <para>
	In the case of non-PCI, pass the proper device struct pointer of the BUS
	instead.  (In the case of legacy ISA without PnP, you don't have to do
	anything.)
      </para>
        </section>
        <section id="pci-resource-entries">
          <title>PCI Entries</title>
          <para>
        So far, so good. Let's finish the missing PCI
      stuff. At first, we need a
      <structname>pci_device_id</structname> table for this
      chipset. It's a table of PCI vendor/device ID number, and some
      masks. 
      </para>
          <para>
        For example,

        <informalexample><programlisting><![CDATA[
  static struct pci_device_id snd_mychip_ids[] = {
          { PCI_VENDOR_ID_FOO, PCI_DEVICE_ID_BAR,
            PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0, },
          ....
          { 0, }
  };
  MODULE_DEVICE_TABLE(pci, snd_mychip_ids);
]]></programlisting></informalexample></para>
          <para>
        The first and second fields of
      the <structname>pci_device_id</structname> structure are the vendor and
      device IDs. If you have no reason to filter the matching
      devices, you can leave the remaining fields as above. The last
      field of the <structname>pci_device_id</structname> struct contains
      private data for this entry. You can specify any value here, for
      example, to define specific operations for supported device IDs.
      Such an example is found in the intel8x0 driver. 
      </para>
          <para>
        The last entry of this list is the terminator. You must
      specify this all-zero entry. 
      </para>
          <para>
        Then, prepare the <structname>pci_driver</structname> record:

        <informalexample><programlisting><![CDATA[
  static struct pci_driver driver = {
          .name = KBUILD_MODNAME,
          .id_table = snd_mychip_ids,
          .probe = snd_mychip_probe,
          .remove = snd_mychip_remove,
  };
]]></programlisting></informalexample></para>
          <para>
        The <structfield>probe</structfield> and
      <structfield>remove</structfield> functions have already
      been defined in the previous sections.
      The <structfield>name</structfield>
      field is the name string of this device. Note that you must not
      use a slash <quote>/</quote> in this string. 
      </para>
          <para>
        And at last, the module entries:

        <informalexample><programlisting><![CDATA[
  static int __init alsa_card_mychip_init(void)
  {
          return pci_register_driver(&driver);
  }

  static void __exit alsa_card_mychip_exit(void)
  {
          pci_unregister_driver(&driver);
  }

  module_init(alsa_card_mychip_init)
  module_exit(alsa_card_mychip_exit)
]]></programlisting></informalexample></para>
          <para>
        Note that these module entries are tagged with
      <parameter>__init</parameter> and 
      <parameter>__exit</parameter> prefixes.
      </para>
          <para>
        Oh, one thing was forgotten. If you have no exported symbols,
        you need to declare it in 2.2 or 2.4 kernels (it's not necessary in 2.6 kernels).

        <informalexample><programlisting><![CDATA[
  EXPORT_NO_SYMBOLS;
]]></programlisting></informalexample>

        That's all!
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- PCM Interface  -->
      <!-- ****************************************************** -->
      <chapter id="pcm-interface">
        <title>PCM Interface</title>
        <section id="pcm-interface-general">
          <title>General</title>
          <para>
        The PCM middle layer of ALSA is quite powerful and it is only
      necessary for each driver to implement the low-level functions
      to access its hardware.
      </para>
          <para>
        For accessing to the PCM layer, you need to include
      <filename>&lt;sound/pcm.h&gt;</filename> first. In addition,
      <filename>&lt;sound/pcm_params.h&gt;</filename> might be needed
      if you access to some functions related with hw_param. 
      </para>
          <para>
        Each card device can have up to four pcm instances. A pcm
      instance corresponds to a pcm device file. The limitation of
      number of instances comes only from the available bit size of
      the Linux's device numbers. Once when 64bit device number is
      used, we'll have more pcm instances available. 
      </para>
          <para>
        A pcm instance consists of pcm playback and capture streams,
      and each pcm stream consists of one or more pcm substreams. Some
      soundcards support multiple playback functions. For example,
      emu10k1 has a PCM playback of 32 stereo substreams. In this case, at
      each open, a free substream is (usually) automatically chosen
      and opened. Meanwhile, when only one substream exists and it was
      already opened, the successful open will either block
      or error with <constant>EAGAIN</constant> according to the
      file open mode. But you don't have to care about such details in your
      driver. The PCM middle layer will take care of such work.
      </para>
        </section>
        <section id="pcm-interface-example">
          <title>Full Code Example</title>
          <para>
      The example code below does not include any hardware access
      routines but shows only the skeleton, how to build up the PCM
      interfaces.

        <example><title>PCM Example Code</title><programlisting><![CDATA[
  #include <sound/pcm.h>
  ....

  /* hardware definition */
  static struct snd_pcm_hardware snd_mychip_playback_hw = {
          .info = (SNDRV_PCM_INFO_MMAP |
                   SNDRV_PCM_INFO_INTERLEAVED |
                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
                   SNDRV_PCM_INFO_MMAP_VALID),
          .formats =          SNDRV_PCM_FMTBIT_S16_LE,
          .rates =            SNDRV_PCM_RATE_8000_48000,
          .rate_min =         8000,
          .rate_max =         48000,
          .channels_min =     2,
          .channels_max =     2,
          .buffer_bytes_max = 32768,
          .period_bytes_min = 4096,
          .period_bytes_max = 32768,
          .periods_min =      1,
          .periods_max =      1024,
  };

  /* hardware definition */
  static struct snd_pcm_hardware snd_mychip_capture_hw = {
          .info = (SNDRV_PCM_INFO_MMAP |
                   SNDRV_PCM_INFO_INTERLEAVED |
                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
                   SNDRV_PCM_INFO_MMAP_VALID),
          .formats =          SNDRV_PCM_FMTBIT_S16_LE,
          .rates =            SNDRV_PCM_RATE_8000_48000,
          .rate_min =         8000,
          .rate_max =         48000,
          .channels_min =     2,
          .channels_max =     2,
          .buffer_bytes_max = 32768,
          .period_bytes_min = 4096,
          .period_bytes_max = 32768,
          .periods_min =      1,
          .periods_max =      1024,
  };

  /* open callback */
  static int snd_mychip_playback_open(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          struct snd_pcm_runtime *runtime = substream->runtime;

          runtime->hw = snd_mychip_playback_hw;
          /* more hardware-initialization will be done here */
          ....
          return 0;
  }

  /* close callback */
  static int snd_mychip_playback_close(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          /* the hardware-specific codes will be here */
          ....
          return 0;

  }

  /* open callback */
  static int snd_mychip_capture_open(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          struct snd_pcm_runtime *runtime = substream->runtime;

          runtime->hw = snd_mychip_capture_hw;
          /* more hardware-initialization will be done here */
          ....
          return 0;
  }

  /* close callback */
  static int snd_mychip_capture_close(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          /* the hardware-specific codes will be here */
          ....
          return 0;

  }

  /* hw_params callback */
  static int snd_mychip_pcm_hw_params(struct snd_pcm_substream *substream,
                               struct snd_pcm_hw_params *hw_params)
  {
          return snd_pcm_lib_malloc_pages(substream,
                                     params_buffer_bytes(hw_params));
  }

  /* hw_free callback */
  static int snd_mychip_pcm_hw_free(struct snd_pcm_substream *substream)
  {
          return snd_pcm_lib_free_pages(substream);
  }

  /* prepare callback */
  static int snd_mychip_pcm_prepare(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          struct snd_pcm_runtime *runtime = substream->runtime;

          /* set up the hardware with the current configuration
           * for example...
           */
          mychip_set_sample_format(chip, runtime->format);
          mychip_set_sample_rate(chip, runtime->rate);
          mychip_set_channels(chip, runtime->channels);
          mychip_set_dma_setup(chip, runtime->dma_addr,
                               chip->buffer_size,
                               chip->period_size);
          return 0;
  }

  /* trigger callback */
  static int snd_mychip_pcm_trigger(struct snd_pcm_substream *substream,
                                    int cmd)
  {
          switch (cmd) {
          case SNDRV_PCM_TRIGGER_START:
                  /* do something to start the PCM engine */
                  ....
                  break;
          case SNDRV_PCM_TRIGGER_STOP:
                  /* do something to stop the PCM engine */
                  ....
                  break;
          default:
                  return -EINVAL;
          }
  }

  /* pointer callback */
  static snd_pcm_uframes_t
  snd_mychip_pcm_pointer(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          unsigned int current_ptr;

          /* get the current hardware pointer */
          current_ptr = mychip_get_hw_pointer(chip);
          return current_ptr;
  }

  /* operators */
  static struct snd_pcm_ops snd_mychip_playback_ops = {
          .open =        snd_mychip_playback_open,
          .close =       snd_mychip_playback_close,
          .ioctl =       snd_pcm_lib_ioctl,
          .hw_params =   snd_mychip_pcm_hw_params,
          .hw_free =     snd_mychip_pcm_hw_free,
          .prepare =     snd_mychip_pcm_prepare,
          .trigger =     snd_mychip_pcm_trigger,
          .pointer =     snd_mychip_pcm_pointer,
  };

  /* operators */
  static struct snd_pcm_ops snd_mychip_capture_ops = {
          .open =        snd_mychip_capture_open,
          .close =       snd_mychip_capture_close,
          .ioctl =       snd_pcm_lib_ioctl,
          .hw_params =   snd_mychip_pcm_hw_params,
          .hw_free =     snd_mychip_pcm_hw_free,
          .prepare =     snd_mychip_pcm_prepare,
          .trigger =     snd_mychip_pcm_trigger,
          .pointer =     snd_mychip_pcm_pointer,
  };

  /*
   *  definitions of capture are omitted here...
   */

  /* create a pcm device */
  static int snd_mychip_new_pcm(struct mychip *chip)
  {
          struct snd_pcm *pcm;
          int err;

          err = snd_pcm_new(chip->card, "My Chip", 0, 1, 1, &pcm);
          if (err < 0) 
                  return err;
          pcm->private_data = chip;
          strcpy(pcm->name, "My Chip");
          chip->pcm = pcm;
          /* set operators */
          snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                          &snd_mychip_playback_ops);
          snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                          &snd_mychip_capture_ops);
          /* pre-allocation of buffers */
          /* NOTE: this may fail */
          snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                                snd_dma_pci_data(chip->pci),
                                                64*1024, 64*1024);
          return 0;
  }
]]></programlisting></example></para>
        </section>
        <section id="pcm-interface-constructor">
          <title>Constructor</title>
          <para>
        A pcm instance is allocated by the <function>snd_pcm_new()</function>
      function. It would be better to create a constructor for pcm,
      namely, 

        <informalexample><programlisting><![CDATA[
  static int snd_mychip_new_pcm(struct mychip *chip)
  {
          struct snd_pcm *pcm;
          int err;

          err = snd_pcm_new(chip->card, "My Chip", 0, 1, 1, &pcm);
          if (err < 0) 
                  return err;
          pcm->private_data = chip;
          strcpy(pcm->name, "My Chip");
          chip->pcm = pcm;
	  ....
          return 0;
  }
]]></programlisting></informalexample></para>
          <para>
        The <function>snd_pcm_new()</function> function takes four
      arguments. The first argument is the card pointer to which this
      pcm is assigned, and the second is the ID string. 
      </para>
          <para>
        The third argument (<parameter>index</parameter>, 0 in the
      above) is the index of this new pcm. It begins from zero. If
      you create more than one pcm instances, specify the
      different numbers in this argument. For example,
      <parameter>index</parameter> = 1 for the second PCM device.  
      </para>
          <para>
        The fourth and fifth arguments are the number of substreams
      for playback and capture, respectively. Here 1 is used for
      both arguments. When no playback or capture substreams are available,
      pass 0 to the corresponding argument.
      </para>
          <para>
        If a chip supports multiple playbacks or captures, you can
      specify more numbers, but they must be handled properly in
      open/close, etc. callbacks.  When you need to know which
      substream you are referring to, then it can be obtained from
      struct <structname>snd_pcm_substream</structname> data passed to each callback
      as follows: 

        <informalexample><programlisting><![CDATA[
  struct snd_pcm_substream *substream;
  int index = substream->number;
]]></programlisting></informalexample></para>
          <para>
        After the pcm is created, you need to set operators for each
        pcm stream. 

        <informalexample><programlisting><![CDATA[
  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
                  &snd_mychip_playback_ops);
  snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
                  &snd_mychip_capture_ops);
]]></programlisting></informalexample></para>
          <para>
        The operators are defined typically like this:

        <informalexample><programlisting><![CDATA[
  static struct snd_pcm_ops snd_mychip_playback_ops = {
          .open =        snd_mychip_pcm_open,
          .close =       snd_mychip_pcm_close,
          .ioctl =       snd_pcm_lib_ioctl,
          .hw_params =   snd_mychip_pcm_hw_params,
          .hw_free =     snd_mychip_pcm_hw_free,
          .prepare =     snd_mychip_pcm_prepare,
          .trigger =     snd_mychip_pcm_trigger,
          .pointer =     snd_mychip_pcm_pointer,
  };
]]></programlisting></informalexample>

        All the callbacks are described in the
        <link linkend="pcm-interface-operators"><citetitle>
        Operators</citetitle></link> subsection.
      </para>
          <para>
        After setting the operators, you probably will want to
        pre-allocate the buffer. For the pre-allocation, simply call
        the following: 

        <informalexample><programlisting><![CDATA[
  snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                        snd_dma_pci_data(chip->pci),
                                        64*1024, 64*1024);
]]></programlisting></informalexample>

        It will allocate a buffer up to 64kB as default.
      Buffer management details will be described in the later section <link linkend="buffer-and-memory"><citetitle>Buffer and Memory
      Management</citetitle></link>. 
      </para>
          <para>
        Additionally, you can set some extra information for this pcm
        in pcm-&gt;info_flags.
        The available values are defined as
        <constant>SNDRV_PCM_INFO_XXX</constant> in
        <filename>&lt;sound/asound.h&gt;</filename>, which is used for
        the hardware definition (described later). When your soundchip
        supports only half-duplex, specify like this: 

        <informalexample><programlisting><![CDATA[
  pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;
]]></programlisting></informalexample></para>
        </section>
        <section id="pcm-interface-destructor">
          <title>... And the Destructor?</title>
          <para>
        The destructor for a pcm instance is not always
      necessary. Since the pcm device will be released by the middle
      layer code automatically, you don't have to call the destructor
      explicitly.
      </para>
          <para>
        The destructor would be necessary if you created
        special records internally and needed to release them. In such a
        case, set the destructor function to
        pcm-&gt;private_free: 

        <example><title>PCM Instance with a Destructor</title><programlisting><![CDATA[
  static void mychip_pcm_free(struct snd_pcm *pcm)
  {
          struct mychip *chip = snd_pcm_chip(pcm);
          /* free your own data */
          kfree(chip->my_private_pcm_data);
          /* do what you like else */
          ....
  }

  static int snd_mychip_new_pcm(struct mychip *chip)
  {
          struct snd_pcm *pcm;
          ....
          /* allocate your own data */
          chip->my_private_pcm_data = kmalloc(...);
          /* set the destructor */
          pcm->private_data = chip;
          pcm->private_free = mychip_pcm_free;
          ....
  }
]]></programlisting></example></para>
        </section>
        <section id="pcm-interface-runtime">
          <title>Runtime Pointer - The Chest of PCM Information</title>
          <para>
	  When the PCM substream is opened, a PCM runtime instance is
	allocated and assigned to the substream. This pointer is
	accessible via <constant>substream-&gt;runtime</constant>.
	This runtime pointer holds most information you need
	to control the PCM: the copy of hw_params and sw_params configurations, the buffer
	pointers, mmap records, spinlocks, etc.
	</para>
          <para>
	The definition of runtime instance is found in
	<filename>&lt;sound/pcm.h&gt;</filename>.  Here are
       the contents of this file:
          <informalexample><programlisting><![CDATA[
struct _snd_pcm_runtime {
	/* -- Status -- */
	struct snd_pcm_substream *trigger_master;
	snd_timestamp_t trigger_tstamp;	/* trigger timestamp */
	int overrange;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t hw_ptr_base;	/* Position at buffer restart */
	snd_pcm_uframes_t hw_ptr_interrupt; /* Position at interrupt time*/

	/* -- HW params -- */
	snd_pcm_access_t access;	/* access mode */
	snd_pcm_format_t format;	/* SNDRV_PCM_FORMAT_* */
	snd_pcm_subformat_t subformat;	/* subformat */
	unsigned int rate;		/* rate in Hz */
	unsigned int channels;		/* channels */
	snd_pcm_uframes_t period_size;	/* period size */
	unsigned int periods;		/* periods */
	snd_pcm_uframes_t buffer_size;	/* buffer size */
	unsigned int tick_time;		/* tick time */
	snd_pcm_uframes_t min_align;	/* Min alignment for the format */
	size_t byte_align;
	unsigned int frame_bits;
	unsigned int sample_bits;
	unsigned int info;
	unsigned int rate_num;
	unsigned int rate_den;

	/* -- SW params -- */
	struct timespec tstamp_mode;	/* mmap timestamp is updated */
  	unsigned int period_step;
	unsigned int sleep_min;		/* min ticks to sleep */
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold; /* Silence filling happens when
						noise is nearest than this */
	snd_pcm_uframes_t silence_size;	/* Silence filling size */
	snd_pcm_uframes_t boundary;	/* pointers wrap point */

	snd_pcm_uframes_t silenced_start;
	snd_pcm_uframes_t silenced_size;

	snd_pcm_sync_id_t sync;		/* hardware synchronization ID */

	/* -- mmap -- */
	volatile struct snd_pcm_mmap_status *status;
	volatile struct snd_pcm_mmap_control *control;
	atomic_t mmap_count;

	/* -- locking / scheduling -- */
	spinlock_t lock;
	wait_queue_head_t sleep;
	struct timer_list tick_timer;
	struct fasync_struct *fasync;

	/* -- private section -- */
	void *private_data;
	void (*private_free)(struct snd_pcm_runtime *runtime);

	/* -- hardware description -- */
	struct snd_pcm_hardware hw;
	struct snd_pcm_hw_constraints hw_constraints;

	/* -- interrupt callbacks -- */
	void (*transfer_ack_begin)(struct snd_pcm_substream *substream);
	void (*transfer_ack_end)(struct snd_pcm_substream *substream);

	/* -- timer -- */
	unsigned int timer_resolution;	/* timer resolution */

	/* -- DMA -- */           
	unsigned char *dma_area;	/* DMA area */
	dma_addr_t dma_addr;		/* physical bus address (not accessible from main CPU) */
	size_t dma_bytes;		/* size of DMA area */

	struct snd_dma_buffer *dma_buffer_p;	/* allocated buffer */

#if defined(CONFIG_SND_PCM_OSS) || defined(CONFIG_SND_PCM_OSS_MODULE)
	/* -- OSS things -- */
	struct snd_pcm_oss_runtime oss;
#endif
};
]]></programlisting></informalexample></para>
          <para>
	  For the operators (callbacks) of each sound driver, most of
	these records are supposed to be read-only.  Only the PCM
	middle-layer changes / updates them.  The exceptions are
	the hardware description (hw), interrupt callbacks
	(transfer_ack_xxx), DMA buffer information, and the private
	data.  Besides, if you use the standard buffer allocation
	method via <function>snd_pcm_lib_malloc_pages()</function>,
	you don't need to set the DMA buffer information by yourself.
	</para>
          <para>
	In the sections below, important records are explained.
	</para>
          <section id="pcm-interface-runtime-hw">
            <title>Hardware Description</title>
            <para>
	  The hardware descriptor (struct <structname>snd_pcm_hardware</structname>)
	contains the definitions of the fundamental hardware
	configuration.  Above all, you'll need to define this in
	<link linkend="pcm-interface-operators-open-callback"><citetitle>
	the open callback</citetitle></link>.
	Note that the runtime instance holds the copy of the
	descriptor, not the pointer to the existing descriptor.  That
	is, in the open callback, you can modify the copied descriptor
	(<constant>runtime-&gt;hw</constant>) as you need.  For example, if the maximum
	number of channels is 1 only on some chip models, you can
	still use the same hardware descriptor and change the
	channels_max later:
          <informalexample><programlisting><![CDATA[
          struct snd_pcm_runtime *runtime = substream->runtime;
          ...
          runtime->hw = snd_mychip_playback_hw; /* common definition */
          if (chip->model == VERY_OLD_ONE)
                  runtime->hw.channels_max = 1;
]]></programlisting></informalexample></para>
            <para>
	  Typically, you'll have a hardware descriptor as below:
          <informalexample><programlisting><![CDATA[
  static struct snd_pcm_hardware snd_mychip_playback_hw = {
          .info = (SNDRV_PCM_INFO_MMAP |
                   SNDRV_PCM_INFO_INTERLEAVED |
                   SNDRV_PCM_INFO_BLOCK_TRANSFER |
                   SNDRV_PCM_INFO_MMAP_VALID),
          .formats =          SNDRV_PCM_FMTBIT_S16_LE,
          .rates =            SNDRV_PCM_RATE_8000_48000,
          .rate_min =         8000,
          .rate_max =         48000,
          .channels_min =     2,
          .channels_max =     2,
          .buffer_bytes_max = 32768,
          .period_bytes_min = 4096,
          .period_bytes_max = 32768,
          .periods_min =      1,
          .periods_max =      1024,
  };
]]></programlisting></informalexample></para>
            <para>
              <itemizedlist>
                <listitem>
                  <para>
          The <structfield>info</structfield> field contains the type and
        capabilities of this pcm. The bit flags are defined in
        <filename>&lt;sound/asound.h&gt;</filename> as
        <constant>SNDRV_PCM_INFO_XXX</constant>. Here, at least, you
        have to specify whether the mmap is supported and which
        interleaved format is supported.
        When the hardware supports mmap, add the
        <constant>SNDRV_PCM_INFO_MMAP</constant> flag here. When the
        hardware supports the interleaved or the non-interleaved
        formats, <constant>SNDRV_PCM_INFO_INTERLEAVED</constant> or
        <constant>SNDRV_PCM_INFO_NONINTERLEAVED</constant> flag must
        be set, respectively. If both are supported, you can set both,
        too. 
        </para>
                  <para>
          In the above example, <constant>MMAP_VALID</constant> and
        <constant>BLOCK_TRANSFER</constant> are specified for the OSS mmap
        mode. Usually both are set. Of course,
        <constant>MMAP_VALID</constant> is set only if the mmap is
        really supported. 
        </para>
                  <para>
          The other possible flags are
        <constant>SNDRV_PCM_INFO_PAUSE</constant> and
        <constant>SNDRV_PCM_INFO_RESUME</constant>. The
        <constant>PAUSE</constant> bit means that the pcm supports the
        <quote>pause</quote> operation, while the
        <constant>RESUME</constant> bit means that the pcm supports
        the full <quote>suspend/resume</quote> operation.
	If the <constant>PAUSE</constant> flag is set,
	the <structfield>trigger</structfield> callback below
        must handle the corresponding (pause push/release) commands.
	The suspend/resume trigger commands can be defined even without
	the <constant>RESUME</constant> flag.  See <link linkend="power-management"><citetitle>
	Power Management</citetitle></link> section for details.
        </para>
                  <para>
	  When the PCM substreams can be synchronized (typically,
	synchronized start/stop of a playback and a capture streams),
	you can give <constant>SNDRV_PCM_INFO_SYNC_START</constant>,
	too.  In this case, you'll need to check the linked-list of
	PCM substreams in the trigger callback.  This will be
	described in the later section.
	</para>
                </listitem>
                <listitem>
                  <para>
                    <structfield>formats</structfield> field contains the bit-flags
        of supported formats (<constant>SNDRV_PCM_FMTBIT_XXX</constant>).
        If the hardware supports more than one format, give all or'ed
        bits.  In the example above, the signed 16bit little-endian
        format is specified.
        </para>
                </listitem>
                <listitem>
                  <para>
                    <structfield>rates</structfield> field contains the bit-flags of
        supported rates (<constant>SNDRV_PCM_RATE_XXX</constant>).
        When the chip supports continuous rates, pass
        <constant>CONTINUOUS</constant> bit additionally.
        The pre-defined rate bits are provided only for typical
	rates. If your chip supports unconventional rates, you need to add
        the <constant>KNOT</constant> bit and set up the hardware
        constraint manually (explained later).
        </para>
                </listitem>
                <listitem>
                  <para>
                    <structfield>rate_min</structfield> and
	<structfield>rate_max</structfield> define the minimum and
	maximum sample rate.  This should correspond somehow to
	<structfield>rates</structfield> bits.
	</para>
                </listitem>
                <listitem>
                  <para>
                    <structfield>channel_min</structfield> and
	<structfield>channel_max</structfield> 
	define, as you might already expected, the minimum and maximum
	number of channels.
	</para>
                </listitem>
                <listitem>
                  <para>
                    <structfield>buffer_bytes_max</structfield> defines the
	maximum buffer size in bytes.  There is no
	<structfield>buffer_bytes_min</structfield> field, since
	it can be calculated from the minimum period size and the
	minimum number of periods.
	Meanwhile, <structfield>period_bytes_min</structfield> and
	define the minimum and maximum size of the period in bytes.
	<structfield>periods_max</structfield> and
	<structfield>periods_min</structfield> define the maximum and
	minimum number of periods in the buffer.
        </para>
                  <para>
	The <quote>period</quote> is a term that corresponds to
	a fragment in the OSS world. The period defines the size at
	which a PCM interrupt is generated. This size strongly
	depends on the hardware. 
	Generally, the smaller period size will give you more
	interrupts, that is, more controls. 
	In the case of capture, this size defines the input latency.
	On the other hand, the whole buffer size defines the
	output latency for the playback direction.
	</para>
                </listitem>
                <listitem>
                  <para>
	There is also a field <structfield>fifo_size</structfield>.
	This specifies the size of the hardware FIFO, but currently it
	is neither used in the driver nor in the alsa-lib.  So, you
	can ignore this field.
	</para>
                </listitem>
              </itemizedlist>
            </para>
          </section>
          <section id="pcm-interface-runtime-config">
            <title>PCM Configurations</title>
            <para>
	Ok, let's go back again to the PCM runtime records.
	The most frequently referred records in the runtime instance are
	the PCM configurations.
	The PCM configurations are stored in the runtime instance
	after the application sends <type>hw_params</type> data via
	alsa-lib.  There are many fields copied from hw_params and
	sw_params structs.  For example,
	<structfield>format</structfield> holds the format type
	chosen by the application.  This field contains the enum value
	<constant>SNDRV_PCM_FORMAT_XXX</constant>.
	</para>
            <para>
	One thing to be noted is that the configured buffer and period
	sizes are stored in <quote>frames</quote> in the runtime.
        In the ALSA world, 1 frame = channels * samples-size.
	For conversion between frames and bytes, you can use the
	<function>frames_to_bytes()</function> and
          <function>bytes_to_frames()</function> helper functions. 
          <informalexample><programlisting><![CDATA[
  period_bytes = frames_to_bytes(runtime, runtime->period_size);
]]></programlisting></informalexample></para>
            <para>
	Also, many software parameters (sw_params) are
	stored in frames, too.  Please check the type of the field.
	<type>snd_pcm_uframes_t</type> is for the frames as unsigned
	integer while <type>snd_pcm_sframes_t</type> is for the frames
	as signed integer.
	</para>
          </section>
          <section id="pcm-interface-runtime-dma">
            <title>DMA Buffer Information</title>
            <para>
	The DMA buffer is defined by the following four fields,
	<structfield>dma_area</structfield>,
	<structfield>dma_addr</structfield>,
	<structfield>dma_bytes</structfield> and
	<structfield>dma_private</structfield>.
	The <structfield>dma_area</structfield> holds the buffer
	pointer (the logical address).  You can call
	<function>memcpy</function> from/to 
	this pointer.  Meanwhile, <structfield>dma_addr</structfield>
	holds the physical address of the buffer.  This field is
	specified only when the buffer is a linear buffer.
	<structfield>dma_bytes</structfield> holds the size of buffer
	in bytes.  <structfield>dma_private</structfield> is used for
	the ALSA DMA allocator.
	</para>
            <para>
	If you use a standard ALSA function,
	<function>snd_pcm_lib_malloc_pages()</function>, for
	allocating the buffer, these fields are set by the ALSA middle
	layer, and you should <emphasis>not</emphasis> change them by
	yourself.  You can read them but not write them.
	On the other hand, if you want to allocate the buffer by
	yourself, you'll need to manage it in hw_params callback.
	At least, <structfield>dma_bytes</structfield> is mandatory.
	<structfield>dma_area</structfield> is necessary when the
	buffer is mmapped.  If your driver doesn't support mmap, this
	field is not necessary.  <structfield>dma_addr</structfield>
	is also optional.  You can use
	<structfield>dma_private</structfield> as you like, too.
	</para>
          </section>
          <section id="pcm-interface-runtime-status">
            <title>Running Status</title>
            <para>
	The running status can be referred via <constant>runtime-&gt;status</constant>.
	This is the pointer to the struct <structname>snd_pcm_mmap_status</structname>
	record.  For example, you can get the current DMA hardware
	pointer via <constant>runtime-&gt;status-&gt;hw_ptr</constant>.
	</para>
            <para>
	The DMA application pointer can be referred via
	<constant>runtime-&gt;control</constant>, which points to the
	struct <structname>snd_pcm_mmap_control</structname> record.
	However, accessing directly to this value is not recommended.
	</para>
          </section>
          <section id="pcm-interface-runtime-private">
            <title>Private Data</title>
            <para>
	You can allocate a record for the substream and store it in
	<constant>runtime-&gt;private_data</constant>.  Usually, this
	is done in
	<link linkend="pcm-interface-operators-open-callback"><citetitle>
	the open callback</citetitle></link>.
	Don't mix this with <constant>pcm-&gt;private_data</constant>.
	The <constant>pcm-&gt;private_data</constant> usually points to the
	chip instance assigned statically at the creation of PCM, while the 
	<constant>runtime-&gt;private_data</constant> points to a dynamic
	data structure created at the PCM open callback.

          <informalexample><programlisting><![CDATA[
  static int snd_xxx_open(struct snd_pcm_substream *substream)
  {
          struct my_pcm_data *data;
          ....
          data = kmalloc(sizeof(*data), GFP_KERNEL);
          substream->runtime->private_data = data;
          ....
  }
]]></programlisting></informalexample></para>
            <para>
          The allocated object must be released in
	<link linkend="pcm-interface-operators-open-callback"><citetitle>
	the close callback</citetitle></link>.
        </para>
          </section>
          <section id="pcm-interface-runtime-intr">
            <title>Interrupt Callbacks</title>
            <para>
	The field <structfield>transfer_ack_begin</structfield> and
	<structfield>transfer_ack_end</structfield> are called at
	the beginning and at the end of
	<function>snd_pcm_period_elapsed()</function>, respectively. 
	</para>
          </section>
        </section>
        <section id="pcm-interface-operators">
          <title>Operators</title>
          <para>
        OK, now let me give details about each pcm callback
      (<parameter>ops</parameter>). In general, every callback must
      return 0 if successful, or a negative error number
      such as <constant>-EINVAL</constant>. To choose an appropriate
      error number, it is advised to check what value other parts of
      the kernel return when the same kind of request fails.
      </para>
          <para>
        The callback function takes at least the argument with
        <structname>snd_pcm_substream</structname> pointer. To retrieve
        the chip record from the given substream instance, you can use the
        following macro. 

        <informalexample><programlisting><![CDATA[
  int xxx() {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          ....
  }
]]></programlisting></informalexample>

	The macro reads <constant>substream-&gt;private_data</constant>,
	which is a copy of <constant>pcm-&gt;private_data</constant>.
	You can override the former if you need to assign different data
	records per PCM substream.  For example, the cmi8330 driver assigns
	different private_data for playback and capture directions,
	because it uses two different codecs (SB- and AD-compatible) for
	different directions.
      </para>
          <section id="pcm-interface-operators-open-callback">
            <title>open callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_xxx_open(struct snd_pcm_substream *substream);
]]></programlisting>
              </informalexample>

          This is called when a pcm substream is opened.
        </para>
            <para>
          At least, here you have to initialize the runtime-&gt;hw
          record. Typically, this is done by like this: 

          <informalexample><programlisting><![CDATA[
  static int snd_xxx_open(struct snd_pcm_substream *substream)
  {
          struct mychip *chip = snd_pcm_substream_chip(substream);
          struct snd_pcm_runtime *runtime = substream->runtime;

          runtime->hw = snd_mychip_playback_hw;
          return 0;
  }
]]></programlisting></informalexample>

          where <parameter>snd_mychip_playback_hw</parameter> is the
          pre-defined hardware description.
	</para>
            <para>
	You can allocate a private data in this callback, as described
	in <link linkend="pcm-interface-runtime-private"><citetitle>
	Private Data</citetitle></link> section.
	</para>
            <para>
	If the hardware configuration needs more constraints, set the
	hardware constraints here, too.
	See <link linkend="pcm-interface-constraints"><citetitle>
	Constraints</citetitle></link> for more details.
	</para>
          </section>
          <section id="pcm-interface-operators-close-callback">
            <title>close callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_xxx_close(struct snd_pcm_substream *substream);
]]></programlisting>
              </informalexample>

          Obviously, this is called when a pcm substream is closed.
        </para>
            <para>
          Any private instance for a pcm substream allocated in the
          open callback will be released here. 

          <informalexample><programlisting><![CDATA[
  static int snd_xxx_close(struct snd_pcm_substream *substream)
  {
          ....
          kfree(substream->runtime->private_data);
          ....
  }
]]></programlisting></informalexample></para>
          </section>
          <section id="pcm-interface-operators-ioctl-callback">
            <title>ioctl callback</title>
            <para>
          This is used for any special call to pcm ioctls. But
        usually you can pass a generic ioctl callback, 
        <function>snd_pcm_lib_ioctl</function>.
        </para>
          </section>
          <section id="pcm-interface-operators-hw-params-callback">
            <title>hw_params callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_xxx_hw_params(struct snd_pcm_substream *substream,
                               struct snd_pcm_hw_params *hw_params);
]]></programlisting>
              </informalexample>
            </para>
            <para>
          This is called when the hardware parameter
        (<structfield>hw_params</structfield>) is set
        up by the application, 
        that is, once when the buffer size, the period size, the
        format, etc. are defined for the pcm substream. 
        </para>
            <para>
          Many hardware setups should be done in this callback,
        including the allocation of buffers. 
        </para>
            <para>
          Parameters to be initialized are retrieved by
          <function>params_xxx()</function> macros. To allocate
          buffer, you can call a helper function, 

          <informalexample><programlisting><![CDATA[
  snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
]]></programlisting></informalexample><function>snd_pcm_lib_malloc_pages()</function> is available
	  only when the DMA buffers have been pre-allocated.
	  See the section <link linkend="buffer-and-memory-buffer-types"><citetitle>
	  Buffer Types</citetitle></link> for more details.
        </para>
            <para>
          Note that this and <structfield>prepare</structfield> callbacks
        may be called multiple times per initialization.
        For example, the OSS emulation may
        call these callbacks at each change via its ioctl. 
        </para>
            <para>
          Thus, you need to be careful not to allocate the same buffers
        many times, which will lead to memory leaks!  Calling the
        helper function above many times is OK. It will release the
        previous buffer automatically when it was already allocated. 
        </para>
            <para>
          Another note is that this callback is non-atomic
        (schedulable). This is important, because the
        <structfield>trigger</structfield> callback 
        is atomic (non-schedulable). That is, mutexes or any
        schedule-related functions are not available in
        <structfield>trigger</structfield> callback.
	Please see the subsection
	<link linkend="pcm-interface-atomicity"><citetitle>
	Atomicity</citetitle></link> for details.
        </para>
          </section>
          <section id="pcm-interface-operators-hw-free-callback">
            <title>hw_free callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_xxx_hw_free(struct snd_pcm_substream *substream);
]]></programlisting>
              </informalexample>
            </para>
            <para>
          This is called to release the resources allocated via
          <structfield>hw_params</structfield>. For example, releasing the
          buffer via 
          <function>snd_pcm_lib_malloc_pages()</function> is done by
          calling the following: 

          <informalexample><programlisting><![CDATA[
  snd_pcm_lib_free_pages(substream);
]]></programlisting></informalexample></para>
            <para>
          This function is always called before the close callback is called.
          Also, the callback may be called multiple times, too.
          Keep track whether the resource was already released. 
        </para>
          </section>
          <section id="pcm-interface-operators-prepare-callback">
            <title>prepare callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_xxx_prepare(struct snd_pcm_substream *substream);
]]></programlisting>
              </informalexample>
            </para>
            <para>
          This callback is called when the pcm is
        <quote>prepared</quote>. You can set the format type, sample
        rate, etc. here. The difference from
        <structfield>hw_params</structfield> is that the 
        <structfield>prepare</structfield> callback will be called each
        time 
        <function>snd_pcm_prepare()</function> is called, i.e. when
        recovering after underruns, etc. 
        </para>
            <para>
	Note that this callback is now non-atomic.
	You can use schedule-related functions safely in this callback.
        </para>
            <para>
          In this and the following callbacks, you can refer to the
        values via the runtime record,
        substream-&gt;runtime.
        For example, to get the current
        rate, format or channels, access to
        runtime-&gt;rate,
        runtime-&gt;format or
        runtime-&gt;channels, respectively. 
        The physical address of the allocated buffer is set to
	runtime-&gt;dma_area.  The buffer and period sizes are
	in runtime-&gt;buffer_size and runtime-&gt;period_size,
	respectively.
        </para>
            <para>
          Be careful that this callback will be called many times at
        each setup, too. 
        </para>
          </section>
          <section id="pcm-interface-operators-trigger-callback">
            <title>trigger callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static int snd_xxx_trigger(struct snd_pcm_substream *substream, int cmd);
]]></programlisting>
              </informalexample>

          This is called when the pcm is started, stopped or paused.
        </para>
            <para>
          Which action is specified in the second argument,
          <constant>SNDRV_PCM_TRIGGER_XXX</constant> in
          <filename>&lt;sound/pcm.h&gt;</filename>. At least,
          the <constant>START</constant> and <constant>STOP</constant>
          commands must be defined in this callback. 

          <informalexample><programlisting><![CDATA[
  switch (cmd) {
  case SNDRV_PCM_TRIGGER_START:
          /* do something to start the PCM engine */
          break;
  case SNDRV_PCM_TRIGGER_STOP:
          /* do something to stop the PCM engine */
          break;
  default:
          return -EINVAL;
  }
]]></programlisting></informalexample></para>
            <para>
          When the pcm supports the pause operation (given in the info
        field of the hardware table), the <constant>PAUSE_PUSH</constant>
        and <constant>PAUSE_RELEASE</constant> commands must be
        handled here, too. The former is the command to pause the pcm,
        and the latter to restart the pcm again. 
        </para>
            <para>
          When the pcm supports the suspend/resume operation,
	regardless of full or partial suspend/resume support,
        the <constant>SUSPEND</constant> and <constant>RESUME</constant>
        commands must be handled, too.
        These commands are issued when the power-management status is
        changed.  Obviously, the <constant>SUSPEND</constant> and
        <constant>RESUME</constant> commands
        suspend and resume the pcm substream, and usually, they
        are identical to the <constant>STOP</constant> and
        <constant>START</constant> commands, respectively.
	  See the <link linkend="power-management"><citetitle>
	Power Management</citetitle></link> section for details.
        </para>
            <para>
          As mentioned, this callback is atomic.  You cannot call
	  functions which may sleep.
	  The trigger callback should be as minimal as possible,
	  just really triggering the DMA.  The other stuff should be
	  initialized hw_params and prepare callbacks properly
	  beforehand.
        </para>
          </section>
          <section id="pcm-interface-operators-pointer-callback">
            <title>pointer callback</title>
            <para>
              <informalexample>
                <programlisting><![CDATA[
  static snd_pcm_uframes_t snd_xxx_pointer(struct snd_pcm_substream *substream)
]]></programlisting>
              </informalexample>

          This callback is called when the PCM middle layer inquires
        the current hardware position on the buffer. The position must
        be returned in frames,
        ranging from 0 to buffer_size - 1.
        </para>
            <para>
          This is called usually from the buffer-update routine in the
        pcm middle layer, which is invoked when
        <function>snd_pcm_period_elapsed()</function> is called in the
        interrupt routine. Then the pcm middle layer updates the
        position and calculates the available space, and wakes up the
        sleeping poll threads, etc. 
        </para>
            <para>
          This callback is also atomic.
        </para>
          </section>
          <section id="pcm-interface-operators-copy-silence">
            <title>copy and silence callbacks</title>
            <para>
          These callbacks are not mandatory, and can be omitted in
        most cases. These callbacks are used when the hardware buffer
        cannot be in the normal memory space. Some chips have their
        own buffer on the hardware which is not mappable. In such a
        case, you have to transfer the data manually from the memory
        buffer to the hardware buffer. Or, if the buffer is
        non-contiguous on both physical and virtual memory spaces,
        these callbacks must be defined, too. 
        </para>
            <para>
          If these two callbacks are defined, copy and set-silence
        operations are done by them. The detailed will be described in
        the later section <link linkend="buffer-and-memory"><citetitle>Buffer and Memory
        Management</citetitle></link>. 
        </para>
          </section>
          <section id="pcm-interface-operators-ack">
            <title>ack callback</title>
            <para>
          This callback is also not mandatory. This callback is called
        when the appl_ptr is updated in read or write operations.
        Some drivers like emu10k1-fx and cs46xx need to track the
	current appl_ptr for the internal buffer, and this callback
	is useful only for such a purpose.
	</para>
            <para>
	  This callback is atomic.
	</para>
          </section>
          <section id="pcm-interface-operators-page-callback">
            <title>page callback</title>
            <para>
          This callback is optional too. This callback is used
        mainly for non-contiguous buffers. The mmap calls this
        callback to get the page address. Some examples will be
        explained in the later section <link linkend="buffer-and-memory"><citetitle>Buffer and Memory
        Management</citetitle></link>, too. 
        </para>
          </section>
        </section>
        <section id="pcm-interface-interrupt-handler">
          <title>Interrupt Handler</title>
          <para>
        The rest of pcm stuff is the PCM interrupt handler. The
      role of PCM interrupt handler in the sound driver is to update
      the buffer position and to tell the PCM middle layer when the
      buffer position goes across the prescribed period size. To
      inform this, call the <function>snd_pcm_period_elapsed()</function>
      function. 
      </para>
          <para>
        There are several types of sound chips to generate the interrupts.
      </para>
          <section id="pcm-interface-interrupt-handler-boundary">
            <title>Interrupts at the period (fragment) boundary</title>
            <para>
          This is the most frequently found type:  the hardware
        generates an interrupt at each period boundary.
	In this case, you can call
        <function>snd_pcm_period_elapsed()</function> at each 
        interrupt. 
        </para>
            <para>
              <function>snd_pcm_period_elapsed()</function> takes the
        substream pointer as its argument. Thus, you need to keep the
        substream pointer accessible from the chip instance. For
        example, define substream field in the chip record to hold the
        current running substream pointer, and set the pointer value
        at open callback (and reset at close callback). 
        </para>
            <para>
          If you acquire a spinlock in the interrupt handler, and the
        lock is used in other pcm callbacks, too, then you have to
        release the lock before calling
        <function>snd_pcm_period_elapsed()</function>, because
        <function>snd_pcm_period_elapsed()</function> calls other pcm
        callbacks inside. 
        </para>
            <para>
          Typical code would be like:

          <example><title>Interrupt Handler Case #1</title><programlisting><![CDATA[
  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
  {
          struct mychip *chip = dev_id;
          spin_lock(&chip->lock);
          ....
          if (pcm_irq_invoked(chip)) {
                  /* call updater, unlock before it */
                  spin_unlock(&chip->lock);
                  snd_pcm_period_elapsed(chip->substream);
                  spin_lock(&chip->lock);
                  /* acknowledge the interrupt if necessary */
          }
          ....
          spin_unlock(&chip->lock);
          return IRQ_HANDLED;
  }
]]></programlisting></example></para>
          </section>
          <section id="pcm-interface-interrupt-handler-timer">
            <title>High frequency timer interrupts</title>
            <para>
	This happens when the hardware doesn't generate interrupts
        at the period boundary but issues timer interrupts at a fixed
        timer rate (e.g. es1968 or ymfpci drivers). 
        In this case, you need to check the current hardware
        position and accumulate the processed sample length at each
        interrupt.  When the accumulated size exceeds the period
        size, call 
        <function>snd_pcm_period_elapsed()</function> and reset the
        accumulator. 
        </para>
            <para>
          Typical code would be like the following.

          <example><title>Interrupt Handler Case #2</title><programlisting><![CDATA[
  static irqreturn_t snd_mychip_interrupt(int irq, void *dev_id)
  {
          struct mychip *chip = dev_id;
          spin_lock(&chip->lock);
          ....
          if (pcm_irq_invoked(chip)) {
                  unsigned int last_ptr, size;
                  /* get the current hardware pointer (in frames) */
                  last_ptr = get_hw_ptr(chip);
                  /* calculate the processed frames since the
                   * last update
                   */
                  if (last_ptr < chip->last_ptr)
                          size = runtime->buffer_size + last_ptr 
                                   - chip->last_ptr; 
                  else
                          size = last_ptr - chip->last_ptr;
                  /* remember the last updated point */
                  chip->last_ptr = last_ptr;
                  /* accumulate the size */
                  chip->size += size;
                  /* over the period boundary? */
                  if (chip->size >= runtime->period_size) {
                          /* reset the accumulator */
                          chip->size %= runtime->period_size;
                          /* call updater */
                          spin_unlock(&chip->lock);
                          snd_pcm_period_elapsed(substream);
                          spin_lock(&chip->lock);
                  }
                  /* acknowledge the interrupt if necessary */
          }
          ....
          spin_unlock(&chip->lock);
          return IRQ_HANDLED;
  }
]]></programlisting></example></para>
          </section>
          <section id="pcm-interface-interrupt-handler-both">
            <title>On calling <function>snd_pcm_period_elapsed()</function></title>
            <para>
          In both cases, even if more than one period are elapsed, you
        don't have to call
        <function>snd_pcm_period_elapsed()</function> many times. Call
        only once. And the pcm layer will check the current hardware
        pointer and update to the latest status. 
        </para>
          </section>
        </section>
        <section id="pcm-interface-atomicity">
          <title>Atomicity</title>
          <para>
      One of the most important (and thus difficult to debug) problems
      in kernel programming are race conditions.
      In the Linux kernel, they are usually avoided via spin-locks, mutexes
      or semaphores.  In general, if a race condition can happen
      in an interrupt handler, it has to be managed atomically, and you
      have to use a spinlock to protect the critical session. If the
      critical section is not in interrupt handler code and
      if taking a relatively long time to execute is acceptable, you
      should use mutexes or semaphores instead.
      </para>
          <para>
      As already seen, some pcm callbacks are atomic and some are
      not.  For example, the <parameter>hw_params</parameter> callback is
      non-atomic, while <parameter>trigger</parameter> callback is
      atomic.  This means, the latter is called already in a spinlock
      held by the PCM middle layer. Please take this atomicity into
      account when you choose a locking scheme in the callbacks.
      </para>
          <para>
      In the atomic callbacks, you cannot use functions which may call
      <function>schedule</function> or go to
      <function>sleep</function>.  Semaphores and mutexes can sleep,
      and hence they cannot be used inside the atomic callbacks
      (e.g. <parameter>trigger</parameter> callback).
      To implement some delay in such a callback, please use
      <function>udelay()</function> or <function>mdelay()</function>.
      </para>
          <para>
      All three atomic callbacks (trigger, pointer, and ack) are
      called with local interrupts disabled.
      </para>
        </section>
        <section id="pcm-interface-constraints">
          <title>Constraints</title>
          <para>
        If your chip supports unconventional sample rates, or only the
      limited samples, you need to set a constraint for the
      condition. 
      </para>
          <para>
        For example, in order to restrict the sample rates in the some
        supported values, use
	<function>snd_pcm_hw_constraint_list()</function>.
	You need to call this function in the open callback.

        <example><title>Example of Hardware Constraints</title><programlisting><![CDATA[
  static unsigned int rates[] =
          {4000, 10000, 22050, 44100};
  static struct snd_pcm_hw_constraint_list constraints_rates = {
          .count = ARRAY_SIZE(rates),
          .list = rates,
          .mask = 0,
  };

  static int snd_mychip_pcm_open(struct snd_pcm_substream *substream)
  {
          int err;
          ....
          err = snd_pcm_hw_constraint_list(substream->runtime, 0,
                                           SNDRV_PCM_HW_PARAM_RATE,
                                           &constraints_rates);
          if (err < 0)
                  return err;
          ....
  }
]]></programlisting></example></para>
          <para>
        There are many different constraints.
        Look at <filename>sound/pcm.h</filename> for a complete list.
        You can even define your own constraint rules.
        For example, let's suppose my_chip can manage a substream of 1 channel
        if and only if the format is S16_LE, otherwise it supports any format
        specified in the <structname>snd_pcm_hardware</structname> structure (or in any
        other constraint_list). You can build a rule like this:

        <example><title>Example of Hardware Constraints for Channels</title><programlisting><![CDATA[
  static int hw_rule_channels_by_format(struct snd_pcm_hw_params *params,
                                        struct snd_pcm_hw_rule *rule)
  {
          struct snd_interval *c = hw_param_interval(params,
                        SNDRV_PCM_HW_PARAM_CHANNELS);
          struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
          struct snd_interval ch;

          snd_interval_any(&ch);
          if (f->bits[0] == SNDRV_PCM_FMTBIT_S16_LE) {
                  ch.min = ch.max = 1;
                  ch.integer = 1;
                  return snd_interval_refine(c, &ch);
          }
          return 0;
  }
]]></programlisting></example></para>
          <para>
        Then you need to call this function to add your rule:

       <informalexample><programlisting><![CDATA[
  snd_pcm_hw_rule_add(substream->runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
                      hw_rule_channels_by_format, NULL,
                      SNDRV_PCM_HW_PARAM_FORMAT, -1);
]]></programlisting></informalexample></para>
          <para>
        The rule function is called when an application sets the PCM
	format, and it refines the number of channels accordingly.
        But an application may set the number of channels before
	setting the format. Thus you also need to define the inverse rule:

       <example><title>Example of Hardware Constraints for Formats</title><programlisting><![CDATA[
  static int hw_rule_format_by_channels(struct snd_pcm_hw_params *params,
                                        struct snd_pcm_hw_rule *rule)
  {
          struct snd_interval *c = hw_param_interval(params,
                SNDRV_PCM_HW_PARAM_CHANNELS);
          struct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
          struct snd_mask fmt;

          snd_mask_any(&fmt);    /* Init the struct */
          if (c->min < 2) {
                  fmt.bits[0] &= SNDRV_PCM_FMTBIT_S16_LE;
                  return snd_mask_refine(f, &fmt);
          }
          return 0;
  }
]]></programlisting></example></para>
          <para>
      ...and in the open callback:
       <informalexample><programlisting><![CDATA[
  snd_pcm_hw_rule_add(substream->runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,
                      hw_rule_format_by_channels, NULL,
                      SNDRV_PCM_HW_PARAM_CHANNELS, -1);
]]></programlisting></informalexample></para>
          <para>
        I won't give more details here, rather I
        would like to say, <quote>Luke, use the source.</quote></para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Control Interface  -->
      <!-- ****************************************************** -->
      <chapter id="control-interface">
        <title>Control Interface</title>
        <section id="control-interface-general">
          <title>General</title>
          <para>
        The control interface is used widely for many switches,
      sliders, etc. which are accessed from user-space. Its most
      important use is the mixer interface. In other words, since ALSA
      0.9.x, all the mixer stuff is implemented on the control kernel API.
      </para>
          <para>
        ALSA has a well-defined AC97 control module. If your chip
      supports only the AC97 and nothing else, you can skip this
      section. 
      </para>
          <para>
        The control API is defined in
      <filename>&lt;sound/control.h&gt;</filename>.
      Include this file if you want to add your own controls.
      </para>
        </section>
        <section id="control-interface-definition">
          <title>Definition of Controls</title>
          <para>
        To create a new control, you need to define the
	following three
      callbacks: <structfield>info</structfield>,
      <structfield>get</structfield> and
      <structfield>put</structfield>. Then, define a
      struct <structname>snd_kcontrol_new</structname> record, such as: 

        <example><title>Definition of a Control</title><programlisting><![CDATA[
  static struct snd_kcontrol_new my_control = {
          .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
          .name = "PCM Playback Switch",
          .index = 0,
          .access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
          .private_value = 0xffff,
          .info = my_control_info,
          .get = my_control_get,
          .put = my_control_put
  };
]]></programlisting></example></para>
          <para>
        The <structfield>iface</structfield> field specifies the control
      type, <constant>SNDRV_CTL_ELEM_IFACE_XXX</constant>, which
      is usually <constant>MIXER</constant>.
      Use <constant>CARD</constant> for global controls that are not
      logically part of the mixer.
      If the control is closely associated with some specific device on
      the sound card, use <constant>HWDEP</constant>,
      <constant>PCM</constant>, <constant>RAWMIDI</constant>,
      <constant>TIMER</constant>, or <constant>SEQUENCER</constant>, and
      specify the device number with the
      <structfield>device</structfield> and
      <structfield>subdevice</structfield> fields.
      </para>
          <para>
        The <structfield>name</structfield> is the name identifier
      string. Since ALSA 0.9.x, the control name is very important,
      because its role is classified from its name. There are
      pre-defined standard control names. The details are described in
      the <link linkend="control-interface-control-names"><citetitle>
      Control Names</citetitle></link> subsection.
      </para>
          <para>
        The <structfield>index</structfield> field holds the index number
      of this control. If there are several different controls with
      the same name, they can be distinguished by the index
      number. This is the case when 
      several codecs exist on the card. If the index is zero, you can
      omit the definition above. 
      </para>
          <para>
        The <structfield>access</structfield> field contains the access
      type of this control. Give the combination of bit masks,
      <constant>SNDRV_CTL_ELEM_ACCESS_XXX</constant>, there.
      The details will be explained in
      the <link linkend="control-interface-access-flags"><citetitle>
      Access Flags</citetitle></link> subsection.
      </para>
          <para>
        The <structfield>private_value</structfield> field contains
      an arbitrary long integer value for this record. When using
      the generic <structfield>info</structfield>,
      <structfield>get</structfield> and
      <structfield>put</structfield> callbacks, you can pass a value 
      through this field. If several small numbers are necessary, you can
      combine them in bitwise. Or, it's possible to give a pointer
      (casted to unsigned long) of some record to this field, too. 
      </para>
          <para>
      The <structfield>tlv</structfield> field can be used to provide
      metadata about the control; see the
      <link linkend="control-interface-tlv"><citetitle>Metadata</citetitle></link> subsection.
      </para>
          <para>
        The other three are
	<link linkend="control-interface-callbacks"><citetitle>
	callback functions</citetitle></link>.
      </para>
        </section>
        <section id="control-interface-control-names">
          <title>Control Names</title>
          <para>
        There are some standards to define the control names. A
      control is usually defined from the three parts as
      <quote>SOURCE DIRECTION FUNCTION</quote>. 
      </para>
          <para>
        The first, <constant>SOURCE</constant>, specifies the source
      of the control, and is a string such as <quote>Master</quote>,
      <quote>PCM</quote>, <quote>CD</quote> and
      <quote>Line</quote>. There are many pre-defined sources. 
      </para>
          <para>
        The second, <constant>DIRECTION</constant>, is one of the
      following strings according to the direction of the control:
      <quote>Playback</quote>, <quote>Capture</quote>, <quote>Bypass
      Playback</quote> and <quote>Bypass Capture</quote>. Or, it can
      be omitted, meaning both playback and capture directions. 
      </para>
          <para>
        The third, <constant>FUNCTION</constant>, is one of the
      following strings according to the function of the control:
      <quote>Switch</quote>, <quote>Volume</quote> and
      <quote>Route</quote>. 
      </para>
          <para>
        The example of control names are, thus, <quote>Master Capture
      Switch</quote> or <quote>PCM Playback Volume</quote>. 
      </para>
          <para>
        There are some exceptions:
      </para>
          <section id="control-interface-control-names-global">
            <title>Global capture and playback</title>
            <para>
              <quote>Capture Source</quote>, <quote>Capture Switch</quote>
        and <quote>Capture Volume</quote> are used for the global
        capture (input) source, switch and volume. Similarly,
        <quote>Playback Switch</quote> and <quote>Playback
        Volume</quote> are used for the global output gain switch and
        volume. 
        </para>
          </section>
          <section id="control-interface-control-names-tone">
            <title>Tone-controls</title>
            <para>
          tone-control switch and volumes are specified like
        <quote>Tone Control - XXX</quote>, e.g. <quote>Tone Control -
        Switch</quote>, <quote>Tone Control - Bass</quote>,
        <quote>Tone Control - Center</quote>.  
        </para>
          </section>
          <section id="control-interface-control-names-3d">
            <title>3D controls</title>
            <para>
          3D-control switches and volumes are specified like <quote>3D
        Control - XXX</quote>, e.g. <quote>3D Control -
        Switch</quote>, <quote>3D Control - Center</quote>, <quote>3D
        Control - Space</quote>. 
        </para>
          </section>
          <section id="control-interface-control-names-mic">
            <title>Mic boost</title>
            <para>
          Mic-boost switch is set as <quote>Mic Boost</quote> or
        <quote>Mic Boost (6dB)</quote>. 
        </para>
            <para>
          More precise information can be found in
        <filename>Documentation/sound/alsa/ControlNames.txt</filename>.
        </para>
          </section>
        </section>
        <section id="control-interface-access-flags">
          <title>Access Flags</title>
          <para>
      The access flag is the bitmask which specifies the access type
      of the given control.  The default access type is
      <constant>SNDRV_CTL_ELEM_ACCESS_READWRITE</constant>, 
      which means both read and write are allowed to this control.
      When the access flag is omitted (i.e. = 0), it is
      considered as <constant>READWRITE</constant> access as default. 
      </para>
          <para>
      When the control is read-only, pass
      <constant>SNDRV_CTL_ELEM_ACCESS_READ</constant> instead.
      In this case, you don't have to define
      the <structfield>put</structfield> callback.
      Similarly, when the control is write-only (although it's a rare
      case), you can use the <constant>WRITE</constant> flag instead, and
      you don't need the <structfield>get</structfield> callback.
      </para>
          <para>
      If the control value changes frequently (e.g. the VU meter),
      <constant>VOLATILE</constant> flag should be given.  This means
      that the control may be changed without
      <link linkend="control-interface-change-notification"><citetitle>
      notification</citetitle></link>. Applications should poll such
      a control constantly.
      </para>
          <para>
      When the control is inactive, set
      the <constant>INACTIVE</constant> flag, too.
      There are <constant>LOCK</constant> and
      <constant>OWNER</constant> flags to change the write
      permissions.
      </para>
        </section>
        <section id="control-interface-callbacks">
          <title>Callbacks</title>
          <section id="control-interface-callbacks-info">
            <title>info callback</title>
            <para>
          The <structfield>info</structfield> callback is used to get
        detailed information on this control. This must store the
        values of the given struct <structname>snd_ctl_elem_info</structname>
        object. For example, for a boolean control with a single
        element: 

          <example><title>Example of info callback</title><programlisting><![CDATA[
  static int snd_myctl_mono_info(struct snd_kcontrol *kcontrol,
                          struct snd_ctl_elem_info *uinfo)
  {
          uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
          uinfo->count = 1;
          uinfo->value.integer.min = 0;
          uinfo->value.integer.max = 1;
          return 0;
  }
]]></programlisting></example></para>
            <para>
          The <structfield>type</structfield> field specifies the type
        of the control. There are <constant>BOOLEAN</constant>,
        <constant>INTEGER</constant>, <constant>ENUMERATED</constant>,
        <constant>BYTES</constant>, <constant>IEC958</constant> and
        <constant>INTEGER64</constant>. The
        <structfield>count</structfield> field specifies the 
        number of elements in this control. For example, a stereo
        volume would have count = 2. The
        <structfield>value</structfield> field is a union, and 
        the values stored are depending on the type. The boolean and
        integer types are identical. 
        </para>
            <para>
          The enumerated type is a bit different from others.  You'll
          need to set the string for the currently given item index. 

          <informalexample><programlisting><![CDATA[
  static int snd_myctl_enum_info(struct snd_kcontrol *kcontrol,
                          struct snd_ctl_elem_info *uinfo)
  {
          static char *texts[4] = {
                  "First", "Second", "Third", "Fourth"
          };
          uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
          uinfo->count = 1;
          uinfo->value.enumerated.items = 4;
          if (uinfo->value.enumerated.item > 3)
                  uinfo->value.enumerated.item = 3;
          strcpy(uinfo->value.enumerated.name,
                 texts[uinfo->value.enumerated.item]);
          return 0;
  }
]]></programlisting></informalexample></para>
            <para>
	  Some common info callbacks are available for your convenience:
	<function>snd_ctl_boolean_mono_info()</function> and
	<function>snd_ctl_boolean_stereo_info()</function>.
	Obviously, the former is an info callback for a mono channel
	boolean item, just like <function>snd_myctl_mono_info</function>
	above, and the latter is for a stereo channel boolean item.
	</para>
          </section>
          <section id="control-interface-callbacks-get">
            <title>get callback</title>
            <para>
          This callback is used to read the current value of the
        control and to return to user-space. 
        </para>
            <para>
          For example,

          <example><title>Example of get callback</title><programlisting><![CDATA[
  static int snd_myctl_get(struct snd_kcontrol *kcontrol,
                           struct snd_ctl_elem_value *ucontrol)
  {
          struct mychip *chip = snd_kcontrol_chip(kcontrol);
          ucontrol->value.integer.value[0] = get_some_value(chip);
          return 0;
  }
]]></programlisting></example></para>
            <para>
	The <structfield>value</structfield> field depends on 
        the type of control as well as on the info callback.  For example,
	the sb driver uses this field to store the register offset,
        the bit-shift and the bit-mask.  The
        <structfield>private_value</structfield> field is set as follows:
          <informalexample><programlisting><![CDATA[
  .private_value = reg | (shift << 16) | (mask << 24)
]]></programlisting></informalexample>
	and is retrieved in callbacks like
          <informalexample><programlisting><![CDATA[
  static int snd_sbmixer_get_single(struct snd_kcontrol *kcontrol,
                                    struct snd_ctl_elem_value *ucontrol)
  {
          int reg = kcontrol->private_value & 0xff;
          int shift = (kcontrol->private_value >> 16) & 0xff;
          int mask = (kcontrol->private_value >> 24) & 0xff;
          ....
  }
]]></programlisting></informalexample></para>
            <para>
	In the <structfield>get</structfield> callback,
	you have to fill all the elements if the
        control has more than one elements,
        i.e. <structfield>count</structfield> &gt; 1.
	In the example above, we filled only one element
        (<structfield>value.integer.value[0]</structfield>) since it's
        assumed as <structfield>count</structfield> = 1.
        </para>
          </section>
          <section id="control-interface-callbacks-put">
            <title>put callback</title>
            <para>
          This callback is used to write a value from user-space.
        </para>
            <para>
          For example,

          <example><title>Example of put callback</title><programlisting><![CDATA[
  static int snd_myctl_put(struct snd_kcontrol *kcontrol,
                           struct snd_ctl_elem_value *ucontrol)
  {
          struct mychip *chip = snd_kcontrol_chip(kcontrol);
          int changed = 0;
          if (chip->current_value !=
               ucontrol->value.integer.value[0]) {
                  change_current_value(chip,
                              ucontrol->value.integer.value[0]);
                  changed = 1;
          }
          return changed;
  }
]]></programlisting></example>

          As seen above, you have to return 1 if the value is
        changed. If the value is not changed, return 0 instead. 
	If any fatal error happens, return a negative error code as
        usual.
        </para>
            <para>
	As in the <structfield>get</structfield> callback,
	when the control has more than one elements,
	all elements must be evaluated in this callback, too.
        </para>
          </section>
          <section id="control-interface-callbacks-all">
            <title>Callbacks are not atomic</title>
            <para>
          All these three callbacks are basically not atomic.
        </para>
          </section>
        </section>
        <section id="control-interface-constructor">
          <title>Constructor</title>
          <para>
        When everything is ready, finally we can create a new
      control. To create a control, there are two functions to be
      called, <function>snd_ctl_new1()</function> and
      <function>snd_ctl_add()</function>. 
      </para>
          <para>
        In the simplest way, you can do like this:

        <informalexample><programlisting><![CDATA[
  err = snd_ctl_add(card, snd_ctl_new1(&my_control, chip));
  if (err < 0)
          return err;
]]></programlisting></informalexample>

        where <parameter>my_control</parameter> is the
      struct <structname>snd_kcontrol_new</structname> object defined above, and chip
      is the object pointer to be passed to
      kcontrol-&gt;private_data 
      which can be referred to in callbacks. 
      </para>
          <para>
            <function>snd_ctl_new1()</function> allocates a new
      <structname>snd_kcontrol</structname> instance,
      and <function>snd_ctl_add</function> assigns the given
      control component to the card. 
      </para>
        </section>
        <section id="control-interface-change-notification">
          <title>Change Notification</title>
          <para>
        If you need to change and update a control in the interrupt
      routine, you can call <function>snd_ctl_notify()</function>. For
      example, 

        <informalexample><programlisting><![CDATA[
  snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, id_pointer);
]]></programlisting></informalexample>

        This function takes the card pointer, the event-mask, and the
      control id pointer for the notification. The event-mask
      specifies the types of notification, for example, in the above
      example, the change of control values is notified.
      The id pointer is the pointer of struct <structname>snd_ctl_elem_id</structname>
      to be notified.
      You can find some examples in <filename>es1938.c</filename> or
      <filename>es1968.c</filename> for hardware volume interrupts. 
      </para>
        </section>
        <section id="control-interface-tlv">
          <title>Metadata</title>
          <para>
      To provide information about the dB values of a mixer control, use
      on of the <constant>DECLARE_TLV_xxx</constant> macros from
      <filename>&lt;sound/tlv.h&gt;</filename> to define a variable
      containing this information, set the<structfield>tlv.p
      </structfield> field to point to this variable, and include the
      <constant>SNDRV_CTL_ELEM_ACCESS_TLV_READ</constant> flag in the
      <structfield>access</structfield> field; like this:
      <informalexample><programlisting><![CDATA[
  static DECLARE_TLV_DB_SCALE(db_scale_my_control, -4050, 150, 0);

  static struct snd_kcontrol_new my_control = {
          ...
          .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
                    SNDRV_CTL_ELEM_ACCESS_TLV_READ,
          ...
          .tlv.p = db_scale_my_control,
  };
]]></programlisting></informalexample></para>
          <para>
      The <function>DECLARE_TLV_DB_SCALE</function> macro defines
      information about a mixer control where each step in the control's
      value changes the dB value by a constant dB amount.
      The first parameter is the name of the variable to be defined.
      The second parameter is the minimum value, in units of 0.01 dB.
      The third parameter is the step size, in units of 0.01 dB.
      Set the fourth parameter to 1 if the minimum value actually mutes
      the control.
      </para>
          <para>
      The <function>DECLARE_TLV_DB_LINEAR</function> macro defines
      information about a mixer control where the control's value affects
      the output linearly.
      The first parameter is the name of the variable to be defined.
      The second parameter is the minimum value, in units of 0.01 dB.
      The third parameter is the maximum value, in units of 0.01 dB.
      If the minimum value mutes the control, set the second parameter to
      <constant>TLV_DB_GAIN_MUTE</constant>.
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- API for AC97 Codec  -->
      <!-- ****************************************************** -->
      <chapter id="api-ac97">
        <title>API for AC97 Codec</title>
        <section>
          <title>General</title>
          <para>
        The ALSA AC97 codec layer is a well-defined one, and you don't
      have to write much code to control it. Only low-level control
      routines are necessary. The AC97 codec API is defined in
      <filename>&lt;sound/ac97_codec.h&gt;</filename>. 
      </para>
        </section>
        <section id="api-ac97-example">
          <title>Full Code Example</title>
          <para>
            <example>
              <title>Example of AC97 Interface</title>
              <programlisting><![CDATA[
  struct mychip {
          ....
          struct snd_ac97 *ac97;
          ....
  };

  static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
                                             unsigned short reg)
  {
          struct mychip *chip = ac97->private_data;
          ....
          /* read a register value here from the codec */
          return the_register_value;
  }

  static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
                                   unsigned short reg, unsigned short val)
  {
          struct mychip *chip = ac97->private_data;
          ....
          /* write the given register value to the codec */
  }

  static int snd_mychip_ac97(struct mychip *chip)
  {
          struct snd_ac97_bus *bus;
          struct snd_ac97_template ac97;
          int err;
          static struct snd_ac97_bus_ops ops = {
                  .write = snd_mychip_ac97_write,
                  .read = snd_mychip_ac97_read,
          };

          err = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus);
          if (err < 0)
                  return err;
          memset(&ac97, 0, sizeof(ac97));
          ac97.private_data = chip;
          return snd_ac97_mixer(bus, &ac97, &chip->ac97);
  }

]]></programlisting>
            </example>
          </para>
        </section>
        <section id="api-ac97-constructor">
          <title>Constructor</title>
          <para>
        To create an ac97 instance, first call <function>snd_ac97_bus</function>
      with an <type>ac97_bus_ops_t</type> record with callback functions.

        <informalexample><programlisting><![CDATA[
  struct snd_ac97_bus *bus;
  static struct snd_ac97_bus_ops ops = {
        .write = snd_mychip_ac97_write,
        .read = snd_mychip_ac97_read,
  };

  snd_ac97_bus(card, 0, &ops, NULL, &pbus);
]]></programlisting></informalexample>

      The bus record is shared among all belonging ac97 instances.
      </para>
          <para>
      And then call <function>snd_ac97_mixer()</function> with an
      struct <structname>snd_ac97_template</structname>
      record together with the bus pointer created above.

        <informalexample><programlisting><![CDATA[
  struct snd_ac97_template ac97;
  int err;

  memset(&ac97, 0, sizeof(ac97));
  ac97.private_data = chip;
  snd_ac97_mixer(bus, &ac97, &chip->ac97);
]]></programlisting></informalexample>

        where chip-&gt;ac97 is a pointer to a newly created
        <type>ac97_t</type> instance.
        In this case, the chip pointer is set as the private data, so that
        the read/write callback functions can refer to this chip instance.
        This instance is not necessarily stored in the chip
	record.  If you need to change the register values from the
        driver, or need the suspend/resume of ac97 codecs, keep this
        pointer to pass to the corresponding functions.
      </para>
        </section>
        <section id="api-ac97-callbacks">
          <title>Callbacks</title>
          <para>
        The standard callbacks are <structfield>read</structfield> and
      <structfield>write</structfield>. Obviously they 
      correspond to the functions for read and write accesses to the
      hardware low-level codes. 
      </para>
          <para>
        The <structfield>read</structfield> callback returns the
        register value specified in the argument. 

        <informalexample><programlisting><![CDATA[
  static unsigned short snd_mychip_ac97_read(struct snd_ac97 *ac97,
                                             unsigned short reg)
  {
          struct mychip *chip = ac97->private_data;
          ....
          return the_register_value;
  }
]]></programlisting></informalexample>

        Here, the chip can be cast from ac97-&gt;private_data.
      </para>
          <para>
        Meanwhile, the <structfield>write</structfield> callback is
        used to set the register value. 

        <informalexample><programlisting><![CDATA[
  static void snd_mychip_ac97_write(struct snd_ac97 *ac97,
                       unsigned short reg, unsigned short val)
]]></programlisting></informalexample></para>
          <para>
      These callbacks are non-atomic like the control API callbacks.
      </para>
          <para>
        There are also other callbacks:
      <structfield>reset</structfield>,
      <structfield>wait</structfield> and
      <structfield>init</structfield>. 
      </para>
          <para>
        The <structfield>reset</structfield> callback is used to reset
      the codec. If the chip requires a special kind of reset, you can
      define this callback. 
      </para>
          <para>
        The <structfield>wait</structfield> callback is used to
      add some waiting time in the standard initialization of the codec. If the
      chip requires the extra waiting time, define this callback. 
      </para>
          <para>
        The <structfield>init</structfield> callback is used for
      additional initialization of the codec.
      </para>
        </section>
        <section id="api-ac97-updating-registers">
          <title>Updating Registers in The Driver</title>
          <para>
        If you need to access to the codec from the driver, you can
      call the following functions:
      <function>snd_ac97_write()</function>,
      <function>snd_ac97_read()</function>,
      <function>snd_ac97_update()</function> and
      <function>snd_ac97_update_bits()</function>. 
      </para>
          <para>
        Both <function>snd_ac97_write()</function> and
        <function>snd_ac97_update()</function> functions are used to
        set a value to the given register
        (<constant>AC97_XXX</constant>). The difference between them is
        that <function>snd_ac97_update()</function> doesn't write a
        value if the given value has been already set, while
        <function>snd_ac97_write()</function> always rewrites the
        value. 

        <informalexample><programlisting><![CDATA[
  snd_ac97_write(ac97, AC97_MASTER, 0x8080);
  snd_ac97_update(ac97, AC97_MASTER, 0x8080);
]]></programlisting></informalexample></para>
          <para>
            <function>snd_ac97_read()</function> is used to read the value
        of the given register. For example, 

        <informalexample><programlisting><![CDATA[
  value = snd_ac97_read(ac97, AC97_MASTER);
]]></programlisting></informalexample></para>
          <para>
            <function>snd_ac97_update_bits()</function> is used to update
        some bits in the given register.  

        <informalexample><programlisting><![CDATA[
  snd_ac97_update_bits(ac97, reg, mask, value);
]]></programlisting></informalexample></para>
          <para>
        Also, there is a function to change the sample rate (of a
        given register such as
        <constant>AC97_PCM_FRONT_DAC_RATE</constant>) when VRA or
        DRA is supported by the codec:
        <function>snd_ac97_set_rate()</function>. 

        <informalexample><programlisting><![CDATA[
  snd_ac97_set_rate(ac97, AC97_PCM_FRONT_DAC_RATE, 44100);
]]></programlisting></informalexample></para>
          <para>
        The following registers are available to set the rate:
      <constant>AC97_PCM_MIC_ADC_RATE</constant>,
      <constant>AC97_PCM_FRONT_DAC_RATE</constant>,
      <constant>AC97_PCM_LR_ADC_RATE</constant>,
      <constant>AC97_SPDIF</constant>. When
      <constant>AC97_SPDIF</constant> is specified, the register is
      not really changed but the corresponding IEC958 status bits will
      be updated. 
      </para>
        </section>
        <section id="api-ac97-clock-adjustment">
          <title>Clock Adjustment</title>
          <para>
        In some chips, the clock of the codec isn't 48000 but using a
      PCI clock (to save a quartz!). In this case, change the field
      bus-&gt;clock to the corresponding
      value. For example, intel8x0 
      and es1968 drivers have their own function to read from the clock.
      </para>
        </section>
        <section id="api-ac97-proc-files">
          <title>Proc Files</title>
          <para>
        The ALSA AC97 interface will create a proc file such as
      <filename>/proc/asound/card0/codec97#0/ac97#0-0</filename> and
      <filename>ac97#0-0+regs</filename>. You can refer to these files to
      see the current status and registers of the codec. 
      </para>
        </section>
        <section id="api-ac97-multiple-codecs">
          <title>Multiple Codecs</title>
          <para>
        When there are several codecs on the same card, you need to
      call <function>snd_ac97_mixer()</function> multiple times with
      ac97.num=1 or greater. The <structfield>num</structfield> field
      specifies the codec number. 
      </para>
          <para>
        If you set up multiple codecs, you either need to write
      different callbacks for each codec or check
      ac97-&gt;num in the callback routines. 
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- MIDI (MPU401-UART) Interface  -->
      <!-- ****************************************************** -->
      <chapter id="midi-interface">
        <title>MIDI (MPU401-UART) Interface</title>
        <section id="midi-interface-general">
          <title>General</title>
          <para>
        Many soundcards have built-in MIDI (MPU401-UART)
      interfaces. When the soundcard supports the standard MPU401-UART
      interface, most likely you can use the ALSA MPU401-UART API. The
      MPU401-UART API is defined in
      <filename>&lt;sound/mpu401.h&gt;</filename>. 
      </para>
          <para>
        Some soundchips have a similar but slightly different
      implementation of mpu401 stuff. For example, emu10k1 has its own
      mpu401 routines. 
      </para>
        </section>
        <section id="midi-interface-constructor">
          <title>Constructor</title>
          <para>
        To create a rawmidi object, call
      <function>snd_mpu401_uart_new()</function>. 

        <informalexample><programlisting><![CDATA[
  struct snd_rawmidi *rmidi;
  snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401, port, info_flags,
                      irq, &rmidi);
]]></programlisting></informalexample></para>
          <para>
        The first argument is the card pointer, and the second is the
      index of this component. You can create up to 8 rawmidi
      devices. 
      </para>
          <para>
        The third argument is the type of the hardware,
      <constant>MPU401_HW_XXX</constant>. If it's not a special one,
      you can use <constant>MPU401_HW_MPU401</constant>. 
      </para>
          <para>
        The 4th argument is the I/O port address. Many
      backward-compatible MPU401 have an I/O port such as 0x330. Or, it
      might be a part of its own PCI I/O region. It depends on the
      chip design. 
      </para>
          <para>
	The 5th argument is a bitflag for additional information.
        When the I/O port address above is part of the PCI I/O
      region, the MPU401 I/O port might have been already allocated
      (reserved) by the driver itself. In such a case, pass a bit flag
      <constant>MPU401_INFO_INTEGRATED</constant>,
      and the mpu401-uart layer will allocate the I/O ports by itself. 
      </para>
          <para>
	When the controller supports only the input or output MIDI stream,
	pass the <constant>MPU401_INFO_INPUT</constant> or
	<constant>MPU401_INFO_OUTPUT</constant> bitflag, respectively.
	Then the rawmidi instance is created as a single stream.
	</para>
          <para>
            <constant>MPU401_INFO_MMIO</constant> bitflag is used to change
	the access method to MMIO (via readb and writeb) instead of
	iob and outb. In this case, you have to pass the iomapped address
	to <function>snd_mpu401_uart_new()</function>.
	</para>
          <para>
	When <constant>MPU401_INFO_TX_IRQ</constant> is set, the output
	stream isn't checked in the default interrupt handler.  The driver
	needs to call <function>snd_mpu401_uart_interrupt_tx()</function>
	by itself to start processing the output stream in the irq handler.
	</para>
          <para>
	If the MPU-401 interface shares its interrupt with the other logical
	devices on the card, set <constant>MPU401_INFO_IRQ_HOOK</constant>
	(see <link linkend="midi-interface-interrupt-handler"><citetitle>
	below</citetitle></link>).
	</para>
          <para>
        Usually, the port address corresponds to the command port and
        port + 1 corresponds to the data port. If not, you may change
        the <structfield>cport</structfield> field of
        struct <structname>snd_mpu401</structname> manually 
        afterward. However, <structname>snd_mpu401</structname> pointer is not
        returned explicitly by
        <function>snd_mpu401_uart_new()</function>. You need to cast
        rmidi-&gt;private_data to
        <structname>snd_mpu401</structname> explicitly, 

        <informalexample><programlisting><![CDATA[
  struct snd_mpu401 *mpu;
  mpu = rmidi->private_data;
]]></programlisting></informalexample>

        and reset the cport as you like:

        <informalexample><programlisting><![CDATA[
  mpu->cport = my_own_control_port;
]]></programlisting></informalexample></para>
          <para>
	The 6th argument specifies the ISA irq number that will be
	allocated.  If no interrupt is to be allocated (because your
	code is already allocating a shared interrupt, or because the
	device does not use interrupts), pass -1 instead.
	For a MPU-401 device without an interrupt, a polling timer
	will be used instead.
      </para>
        </section>
        <section id="midi-interface-interrupt-handler">
          <title>Interrupt Handler</title>
          <para>
        When the interrupt is allocated in
      <function>snd_mpu401_uart_new()</function>, an exclusive ISA
      interrupt handler is automatically used, hence you don't have
      anything else to do than creating the mpu401 stuff.  Otherwise, you
      have to set <constant>MPU401_INFO_IRQ_HOOK</constant>, and call
      <function>snd_mpu401_uart_interrupt()</function> explicitly from your
      own interrupt handler when it has determined that a UART interrupt
      has occurred.
      </para>
          <para>
        In this case, you need to pass the private_data of the
        returned rawmidi object from
        <function>snd_mpu401_uart_new()</function> as the second
        argument of <function>snd_mpu401_uart_interrupt()</function>. 

        <informalexample><programlisting><![CDATA[
  snd_mpu401_uart_interrupt(irq, rmidi->private_data, regs);
]]></programlisting></informalexample></para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- RawMIDI Interface  -->
      <!-- ****************************************************** -->
      <chapter id="rawmidi-interface">
        <title>RawMIDI Interface</title>
        <section id="rawmidi-interface-overview">
          <title>Overview</title>
          <para>
      The raw MIDI interface is used for hardware MIDI ports that can
      be accessed as a byte stream.  It is not used for synthesizer
      chips that do not directly understand MIDI.
      </para>
          <para>
      ALSA handles file and buffer management.  All you have to do is
      to write some code to move data between the buffer and the
      hardware.
      </para>
          <para>
      The rawmidi API is defined in
      <filename>&lt;sound/rawmidi.h&gt;</filename>.
      </para>
        </section>
        <section id="rawmidi-interface-constructor">
          <title>Constructor</title>
          <para>
      To create a rawmidi device, call the
      <function>snd_rawmidi_new</function> function:
        <informalexample><programlisting><![CDATA[
  struct snd_rawmidi *rmidi;
  err = snd_rawmidi_new(chip->card, "MyMIDI", 0, outs, ins, &rmidi);
  if (err < 0)
          return err;
  rmidi->private_data = chip;
  strcpy(rmidi->name, "My MIDI");
  rmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |
                      SNDRV_RAWMIDI_INFO_INPUT |
                      SNDRV_RAWMIDI_INFO_DUPLEX;
]]></programlisting></informalexample></para>
          <para>
      The first argument is the card pointer, the second argument is
      the ID string.
      </para>
          <para>
      The third argument is the index of this component.  You can
      create up to 8 rawmidi devices.
      </para>
          <para>
      The fourth and fifth arguments are the number of output and
      input substreams, respectively, of this device (a substream is
      the equivalent of a MIDI port).
      </para>
          <para>
      Set the <structfield>info_flags</structfield> field to specify
      the capabilities of the device.
      Set <constant>SNDRV_RAWMIDI_INFO_OUTPUT</constant> if there is
      at least one output port,
      <constant>SNDRV_RAWMIDI_INFO_INPUT</constant> if there is at
      least one input port,
      and <constant>SNDRV_RAWMIDI_INFO_DUPLEX</constant> if the device
      can handle output and input at the same time.
      </para>
          <para>
      After the rawmidi device is created, you need to set the
      operators (callbacks) for each substream.  There are helper
      functions to set the operators for all the substreams of a device:
        <informalexample><programlisting><![CDATA[
  snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_mymidi_output_ops);
  snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_mymidi_input_ops);
]]></programlisting></informalexample></para>
          <para>
      The operators are usually defined like this:
        <informalexample><programlisting><![CDATA[
  static struct snd_rawmidi_ops snd_mymidi_output_ops = {
          .open =    snd_mymidi_output_open,
          .close =   snd_mymidi_output_close,
          .trigger = snd_mymidi_output_trigger,
  };
]]></programlisting></informalexample>
      These callbacks are explained in the <link linkend="rawmidi-interface-callbacks"><citetitle>Callbacks</citetitle></link>
      section.
      </para>
          <para>
      If there are more than one substream, you should give a
      unique name to each of them:
        <informalexample><programlisting><![CDATA[
  struct snd_rawmidi_substream *substream;
  list_for_each_entry(substream,
                      &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,
                      list {
          sprintf(substream->name, "My MIDI Port %d", substream->number + 1);
  }
  /* same for SNDRV_RAWMIDI_STREAM_INPUT */
]]></programlisting></informalexample></para>
        </section>
        <section id="rawmidi-interface-callbacks">
          <title>Callbacks</title>
          <para>
      In all the callbacks, the private data that you've set for the
      rawmidi device can be accessed as
      substream-&gt;rmidi-&gt;private_data.
      <!-- <code> isn't available before DocBook 4.3 --></para>
          <para>
      If there is more than one port, your callbacks can determine the
      port index from the struct snd_rawmidi_substream data passed to each
      callback:
        <informalexample><programlisting><![CDATA[
  struct snd_rawmidi_substream *substream;
  int index = substream->number;
]]></programlisting></informalexample></para>
          <section id="rawmidi-interface-op-open">
            <title>
              <function>open</function> callback</title>
            <informalexample>
              <programlisting><![CDATA[
  static int snd_xxx_open(struct snd_rawmidi_substream *substream);
]]></programlisting>
            </informalexample>
            <para>
        This is called when a substream is opened.
        You can initialize the hardware here, but you shouldn't
        start transmitting/receiving data yet.
        </para>
          </section>
          <section id="rawmidi-interface-op-close">
            <title>
              <function>close</function> callback</title>
            <informalexample>
              <programlisting><![CDATA[
  static int snd_xxx_close(struct snd_rawmidi_substream *substream);
]]></programlisting>
            </informalexample>
            <para>
        Guess what.
        </para>
            <para>
        The <function>open</function> and <function>close</function>
        callbacks of a rawmidi device are serialized with a mutex,
        and can sleep.
        </para>
          </section>
          <section id="rawmidi-interface-op-trigger-out">
            <title>
              <function>trigger</function> callback for output
      substreams</title>
            <informalexample>
              <programlisting><![CDATA[
  static void snd_xxx_output_trigger(struct snd_rawmidi_substream *substream, int up);
]]></programlisting>
            </informalexample>
            <para>
        This is called with a nonzero <parameter>up</parameter>
        parameter when there is some data in the substream buffer that
        must be transmitted.
        </para>
            <para>
        To read data from the buffer, call
        <function>snd_rawmidi_transmit_peek</function>.  It will
        return the number of bytes that have been read; this will be
        less than the number of bytes requested when there are no more
        data in the buffer.
        After the data have been transmitted successfully, call
        <function>snd_rawmidi_transmit_ack</function> to remove the
        data from the substream buffer:
          <informalexample><programlisting><![CDATA[
  unsigned char data;
  while (snd_rawmidi_transmit_peek(substream, &data, 1) == 1) {
          if (snd_mychip_try_to_transmit(data))
                  snd_rawmidi_transmit_ack(substream, 1);
          else
                  break; /* hardware FIFO full */
  }
]]></programlisting></informalexample></para>
            <para>
        If you know beforehand that the hardware will accept data, you
        can use the <function>snd_rawmidi_transmit</function> function
        which reads some data and removes them from the buffer at once:
          <informalexample><programlisting><![CDATA[
  while (snd_mychip_transmit_possible()) {
          unsigned char data;
          if (snd_rawmidi_transmit(substream, &data, 1) != 1)
                  break; /* no more data */
          snd_mychip_transmit(data);
  }
]]></programlisting></informalexample></para>
            <para>
        If you know beforehand how many bytes you can accept, you can
        use a buffer size greater than one with the
        <function>snd_rawmidi_transmit*</function> functions.
        </para>
            <para>
        The <function>trigger</function> callback must not sleep.  If
        the hardware FIFO is full before the substream buffer has been
        emptied, you have to continue transmitting data later, either
        in an interrupt handler, or with a timer if the hardware
        doesn't have a MIDI transmit interrupt.
        </para>
            <para>
        The <function>trigger</function> callback is called with a
        zero <parameter>up</parameter> parameter when the transmission
        of data should be aborted.
        </para>
          </section>
          <section id="rawmidi-interface-op-trigger-in">
            <title>
              <function>trigger</function> callback for input
      substreams</title>
            <informalexample>
              <programlisting><![CDATA[
  static void snd_xxx_input_trigger(struct snd_rawmidi_substream *substream, int up);
]]></programlisting>
            </informalexample>
            <para>
        This is called with a nonzero <parameter>up</parameter>
        parameter to enable receiving data, or with a zero
        <parameter>up</parameter> parameter do disable receiving data.
        </para>
            <para>
        The <function>trigger</function> callback must not sleep; the
        actual reading of data from the device is usually done in an
        interrupt handler.
        </para>
            <para>
        When data reception is enabled, your interrupt handler should
        call <function>snd_rawmidi_receive</function> for all received
        data:
          <informalexample><programlisting><![CDATA[
  void snd_mychip_midi_interrupt(...)
  {
          while (mychip_midi_available()) {
                  unsigned char data;
                  data = mychip_midi_read();
                  snd_rawmidi_receive(substream, &data, 1);
          }
  }
]]></programlisting></informalexample></para>
          </section>
          <section id="rawmidi-interface-op-drain">
            <title>
              <function>drain</function> callback</title>
            <informalexample>
              <programlisting><![CDATA[
  static void snd_xxx_drain(struct snd_rawmidi_substream *substream);
]]></programlisting>
            </informalexample>
            <para>
        This is only used with output substreams.  This function should wait
        until all data read from the substream buffer have been transmitted.
        This ensures that the device can be closed and the driver unloaded
        without losing data.
        </para>
            <para>
        This callback is optional. If you do not set
        <structfield>drain</structfield> in the struct snd_rawmidi_ops
        structure, ALSA will simply wait for 50 milliseconds
        instead.
        </para>
          </section>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Miscellaneous Devices  -->
      <!-- ****************************************************** -->
      <chapter id="misc-devices">
        <title>Miscellaneous Devices</title>
        <section id="misc-devices-opl3">
          <title>FM OPL3</title>
          <para>
        The FM OPL3 is still used in many chips (mainly for backward
      compatibility). ALSA has a nice OPL3 FM control layer, too. The
      OPL3 API is defined in
      <filename>&lt;sound/opl3.h&gt;</filename>. 
      </para>
          <para>
        FM registers can be directly accessed through the direct-FM API,
      defined in <filename>&lt;sound/asound_fm.h&gt;</filename>. In
      ALSA native mode, FM registers are accessed through
      the Hardware-Dependent Device direct-FM extension API, whereas in
      OSS compatible mode, FM registers can be accessed with the OSS
      direct-FM compatible API in <filename>/dev/dmfmX</filename> device. 
      </para>
          <para>
        To create the OPL3 component, you have two functions to
        call. The first one is a constructor for the <type>opl3_t</type>
        instance. 

        <informalexample><programlisting><![CDATA[
  struct snd_opl3 *opl3;
  snd_opl3_create(card, lport, rport, OPL3_HW_OPL3_XXX,
                  integrated, &opl3);
]]></programlisting></informalexample></para>
          <para>
        The first argument is the card pointer, the second one is the
      left port address, and the third is the right port address. In
      most cases, the right port is placed at the left port + 2. 
      </para>
          <para>
        The fourth argument is the hardware type.
      </para>
          <para>
        When the left and right ports have been already allocated by
      the card driver, pass non-zero to the fifth argument
      (<parameter>integrated</parameter>). Otherwise, the opl3 module will
      allocate the specified ports by itself. 
      </para>
          <para>
        When the accessing the hardware requires special method
        instead of the standard I/O access, you can create opl3 instance
        separately with <function>snd_opl3_new()</function>.

        <informalexample><programlisting><![CDATA[
  struct snd_opl3 *opl3;
  snd_opl3_new(card, OPL3_HW_OPL3_XXX, &opl3);
]]></programlisting></informalexample></para>
          <para>
	Then set <structfield>command</structfield>,
	<structfield>private_data</structfield> and
	<structfield>private_free</structfield> for the private
	access function, the private data and the destructor.
	The l_port and r_port are not necessarily set.  Only the
	command must be set properly.  You can retrieve the data
	from the opl3-&gt;private_data field.
      </para>
          <para>
	After creating the opl3 instance via <function>snd_opl3_new()</function>,
	call <function>snd_opl3_init()</function> to initialize the chip to the
	proper state. Note that <function>snd_opl3_create()</function> always
	calls it internally.
      </para>
          <para>
        If the opl3 instance is created successfully, then create a
        hwdep device for this opl3. 

        <informalexample><programlisting><![CDATA[
  struct snd_hwdep *opl3hwdep;
  snd_opl3_hwdep_new(opl3, 0, 1, &opl3hwdep);
]]></programlisting></informalexample></para>
          <para>
        The first argument is the <type>opl3_t</type> instance you
      created, and the second is the index number, usually 0. 
      </para>
          <para>
        The third argument is the index-offset for the sequencer
      client assigned to the OPL3 port. When there is an MPU401-UART,
      give 1 for here (UART always takes 0). 
      </para>
        </section>
        <section id="misc-devices-hardware-dependent">
          <title>Hardware-Dependent Devices</title>
          <para>
        Some chips need user-space access for special
      controls or for loading the micro code. In such a case, you can
      create a hwdep (hardware-dependent) device. The hwdep API is
      defined in <filename>&lt;sound/hwdep.h&gt;</filename>. You can
      find examples in opl3 driver or
      <filename>isa/sb/sb16_csp.c</filename>. 
      </para>
          <para>
        The creation of the <type>hwdep</type> instance is done via
        <function>snd_hwdep_new()</function>. 

        <informalexample><programlisting><![CDATA[
  struct snd_hwdep *hw;
  snd_hwdep_new(card, "My HWDEP", 0, &hw);
]]></programlisting></informalexample>

        where the third argument is the index number.
      </para>
          <para>
        You can then pass any pointer value to the
        <parameter>private_data</parameter>.
        If you assign a private data, you should define the
        destructor, too. The destructor function is set in
        the <structfield>private_free</structfield> field.  

        <informalexample><programlisting><![CDATA[
  struct mydata *p = kmalloc(sizeof(*p), GFP_KERNEL);
  hw->private_data = p;
  hw->private_free = mydata_free;
]]></programlisting></informalexample>

        and the implementation of the destructor would be:

        <informalexample><programlisting><![CDATA[
  static void mydata_free(struct snd_hwdep *hw)
  {
          struct mydata *p = hw->private_data;
          kfree(p);
  }
]]></programlisting></informalexample></para>
          <para>
        The arbitrary file operations can be defined for this
        instance. The file operators are defined in
        the <parameter>ops</parameter> table. For example, assume that
        this chip needs an ioctl. 

        <informalexample><programlisting><![CDATA[
  hw->ops.open = mydata_open;
  hw->ops.ioctl = mydata_ioctl;
  hw->ops.release = mydata_release;
]]></programlisting></informalexample>

        And implement the callback functions as you like.
      </para>
        </section>
        <section id="misc-devices-IEC958">
          <title>IEC958 (S/PDIF)</title>
          <para>
        Usually the controls for IEC958 devices are implemented via
      the control interface. There is a macro to compose a name string for
      IEC958 controls, <function>SNDRV_CTL_NAME_IEC958()</function>
      defined in <filename>&lt;include/asound.h&gt;</filename>.  
      </para>
          <para>
        There are some standard controls for IEC958 status bits. These
      controls use the type <type>SNDRV_CTL_ELEM_TYPE_IEC958</type>,
      and the size of element is fixed as 4 bytes array
      (value.iec958.status[x]). For the <structfield>info</structfield>
      callback, you don't specify 
      the value field for this type (the count field must be set,
      though). 
      </para>
          <para>
            <quote>IEC958 Playback Con Mask</quote> is used to return the
      bit-mask for the IEC958 status bits of consumer mode. Similarly,
      <quote>IEC958 Playback Pro Mask</quote> returns the bitmask for
      professional mode. They are read-only controls, and are defined
      as MIXER controls (iface =
      <constant>SNDRV_CTL_ELEM_IFACE_MIXER</constant>).  
      </para>
          <para>
        Meanwhile, <quote>IEC958 Playback Default</quote> control is
      defined for getting and setting the current default IEC958
      bits. Note that this one is usually defined as a PCM control
      (iface = <constant>SNDRV_CTL_ELEM_IFACE_PCM</constant>),
      although in some places it's defined as a MIXER control. 
      </para>
          <para>
        In addition, you can define the control switches to
      enable/disable or to set the raw bit mode. The implementation
      will depend on the chip, but the control should be named as
      <quote>IEC958 xxx</quote>, preferably using
      the <function>SNDRV_CTL_NAME_IEC958()</function> macro. 
      </para>
          <para>
        You can find several cases, for example,
      <filename>pci/emu10k1</filename>,
      <filename>pci/ice1712</filename>, or
      <filename>pci/cmipci.c</filename>.  
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Buffer and Memory Management  -->
      <!-- ****************************************************** -->
      <chapter id="buffer-and-memory">
        <title>Buffer and Memory Management</title>
        <section id="buffer-and-memory-buffer-types">
          <title>Buffer Types</title>
          <para>
        ALSA provides several different buffer allocation functions
      depending on the bus and the architecture. All these have a
      consistent API. The allocation of physically-contiguous pages is
      done via 
      <function>snd_malloc_xxx_pages()</function> function, where xxx
      is the bus type. 
      </para>
          <para>
        The allocation of pages with fallback is
      <function>snd_malloc_xxx_pages_fallback()</function>. This
      function tries to allocate the specified pages but if the pages
      are not available, it tries to reduce the page sizes until
      enough space is found.
      </para>
          <para>
      The release the pages, call
      <function>snd_free_xxx_pages()</function> function. 
      </para>
          <para>
      Usually, ALSA drivers try to allocate and reserve
       a large contiguous physical space
       at the time the module is loaded for the later use.
       This is called <quote>pre-allocation</quote>.
       As already written, you can call the following function at 
       pcm instance construction time (in the case of PCI bus). 

        <informalexample><programlisting><![CDATA[
  snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
                                        snd_dma_pci_data(pci), size, max);
]]></programlisting></informalexample>

        where <parameter>size</parameter> is the byte size to be
      pre-allocated and the <parameter>max</parameter> is the maximum
      size to be changed via the <filename>prealloc</filename> proc file.
      The allocator will try to get an area as large as possible
      within the given size. 
      </para>
          <para>
      The second argument (type) and the third argument (device pointer)
      are dependent on the bus.
      In the case of the ISA bus, pass <function>snd_dma_isa_data()</function>
      as the third argument with <constant>SNDRV_DMA_TYPE_DEV</constant> type.
      For the continuous buffer unrelated to the bus can be pre-allocated
      with <constant>SNDRV_DMA_TYPE_CONTINUOUS</constant> type and the
      <function>snd_dma_continuous_data(GFP_KERNEL)</function> device pointer,
      where <constant>GFP_KERNEL</constant> is the kernel allocation flag to
      use.
      For the PCI scatter-gather buffers, use
      <constant>SNDRV_DMA_TYPE_DEV_SG</constant> with
      <function>snd_dma_pci_data(pci)</function>
      (see the 
          <link linkend="buffer-and-memory-non-contiguous"><citetitle>Non-Contiguous Buffers
          </citetitle></link> section).
      </para>
          <para>
        Once the buffer is pre-allocated, you can use the
        allocator in the <structfield>hw_params</structfield> callback: 

        <informalexample><programlisting><![CDATA[
  snd_pcm_lib_malloc_pages(substream, size);
]]></programlisting></informalexample>

        Note that you have to pre-allocate to use this function.
      </para>
        </section>
        <section id="buffer-and-memory-external-hardware">
          <title>External Hardware Buffers</title>
          <para>
        Some chips have their own hardware buffers and the DMA
      transfer from the host memory is not available. In such a case,
      you need to either 1) copy/set the audio data directly to the
      external hardware buffer, or 2) make an intermediate buffer and
      copy/set the data from it to the external hardware buffer in
      interrupts (or in tasklets, preferably).
      </para>
          <para>
        The first case works fine if the external hardware buffer is large
      enough.  This method doesn't need any extra buffers and thus is
      more effective. You need to define the
      <structfield>copy</structfield> and
      <structfield>silence</structfield> callbacks for 
      the data transfer. However, there is a drawback: it cannot
      be mmapped. The examples are GUS's GF1 PCM or emu8000's
      wavetable PCM. 
      </para>
          <para>
        The second case allows for mmap on the buffer, although you have
      to handle an interrupt or a tasklet to transfer the data
      from the intermediate buffer to the hardware buffer. You can find an
      example in the vxpocket driver. 
      </para>
          <para>
        Another case is when the chip uses a PCI memory-map
      region for the buffer instead of the host memory. In this case,
      mmap is available only on certain architectures like the Intel one.
      In non-mmap mode, the data cannot be transferred as in the normal
      way. Thus you need to define the <structfield>copy</structfield> and
      <structfield>silence</structfield> callbacks as well, 
      as in the cases above. The examples are found in
      <filename>rme32.c</filename> and <filename>rme96.c</filename>. 
      </para>
          <para>
        The implementation of the <structfield>copy</structfield> and
        <structfield>silence</structfield> callbacks depends upon 
        whether the hardware supports interleaved or non-interleaved
        samples. The <structfield>copy</structfield> callback is
        defined like below, a bit 
        differently depending whether the direction is playback or
        capture: 

        <informalexample><programlisting><![CDATA[
  static int playback_copy(struct snd_pcm_substream *substream, int channel,
               snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count);
  static int capture_copy(struct snd_pcm_substream *substream, int channel,
               snd_pcm_uframes_t pos, void *dst, snd_pcm_uframes_t count);
]]></programlisting></informalexample></para>
          <para>
        In the case of interleaved samples, the second argument
      (<parameter>channel</parameter>) is not used. The third argument
      (<parameter>pos</parameter>) points the 
      current position offset in frames. 
      </para>
          <para>
        The meaning of the fourth argument is different between
      playback and capture. For playback, it holds the source data
      pointer, and for capture, it's the destination data pointer. 
      </para>
          <para>
        The last argument is the number of frames to be copied.
      </para>
          <para>
        What you have to do in this callback is again different
        between playback and capture directions. In the
        playback case, you copy the given amount of data
        (<parameter>count</parameter>) at the specified pointer
        (<parameter>src</parameter>) to the specified offset
        (<parameter>pos</parameter>) on the hardware buffer. When
        coded like memcpy-like way, the copy would be like: 

        <informalexample><programlisting><![CDATA[
  my_memcpy(my_buffer + frames_to_bytes(runtime, pos), src,
            frames_to_bytes(runtime, count));
]]></programlisting></informalexample></para>
          <para>
        For the capture direction, you copy the given amount of
        data (<parameter>count</parameter>) at the specified offset
        (<parameter>pos</parameter>) on the hardware buffer to the
        specified pointer (<parameter>dst</parameter>). 

        <informalexample><programlisting><![CDATA[
  my_memcpy(dst, my_buffer + frames_to_bytes(runtime, pos),
            frames_to_bytes(runtime, count));
]]></programlisting></informalexample>

        Note that both the position and the amount of data are given
      in frames. 
      </para>
          <para>
        In the case of non-interleaved samples, the implementation
      will be a bit more complicated. 
      </para>
          <para>
        You need to check the channel argument, and if it's -1, copy
      the whole channels. Otherwise, you have to copy only the
      specified channel. Please check
      <filename>isa/gus/gus_pcm.c</filename> as an example. 
      </para>
          <para>
        The <structfield>silence</structfield> callback is also
        implemented in a similar way. 

        <informalexample><programlisting><![CDATA[
  static int silence(struct snd_pcm_substream *substream, int channel,
                     snd_pcm_uframes_t pos, snd_pcm_uframes_t count);
]]></programlisting></informalexample></para>
          <para>
        The meanings of arguments are the same as in the
      <structfield>copy</structfield> 
      callback, although there is no <parameter>src/dst</parameter>
      argument. In the case of interleaved samples, the channel
      argument has no meaning, as well as on
      <structfield>copy</structfield> callback.  
      </para>
          <para>
        The role of <structfield>silence</structfield> callback is to
        set the given amount 
        (<parameter>count</parameter>) of silence data at the
        specified offset (<parameter>pos</parameter>) on the hardware
        buffer. Suppose that the data format is signed (that is, the
        silent-data is 0), and the implementation using a memset-like
        function would be like: 

        <informalexample><programlisting><![CDATA[
  my_memcpy(my_buffer + frames_to_bytes(runtime, pos), 0,
            frames_to_bytes(runtime, count));
]]></programlisting></informalexample></para>
          <para>
        In the case of non-interleaved samples, again, the
      implementation becomes a bit more complicated. See, for example,
      <filename>isa/gus/gus_pcm.c</filename>. 
      </para>
        </section>
        <section id="buffer-and-memory-non-contiguous">
          <title>Non-Contiguous Buffers</title>
          <para>
        If your hardware supports the page table as in emu10k1 or the
      buffer descriptors as in via82xx, you can use the scatter-gather
      (SG) DMA. ALSA provides an interface for handling SG-buffers.
      The API is provided in <filename>&lt;sound/pcm.h&gt;</filename>. 
      </para>
          <para>
        For creating the SG-buffer handler, call
        <function>snd_pcm_lib_preallocate_pages()</function> or
        <function>snd_pcm_lib_preallocate_pages_for_all()</function>
        with <constant>SNDRV_DMA_TYPE_DEV_SG</constant>
	in the PCM constructor like other PCI pre-allocator.
        You need to pass <function>snd_dma_pci_data(pci)</function>,
        where pci is the struct <structname>pci_dev</structname> pointer
        of the chip as well.
        The <type>struct snd_sg_buf</type> instance is created as
        substream-&gt;dma_private. You can cast
        the pointer like: 

        <informalexample><programlisting><![CDATA[
  struct snd_sg_buf *sgbuf = (struct snd_sg_buf *)substream->dma_private;
]]></programlisting></informalexample></para>
          <para>
        Then call <function>snd_pcm_lib_malloc_pages()</function>
      in the <structfield>hw_params</structfield> callback
      as well as in the case of normal PCI buffer.
      The SG-buffer handler will allocate the non-contiguous kernel
      pages of the given size and map them onto the virtually contiguous
      memory.  The virtual pointer is addressed in runtime-&gt;dma_area.
      The physical address (runtime-&gt;dma_addr) is set to zero,
      because the buffer is physically non-contiguous.
      The physical address table is set up in sgbuf-&gt;table.
      You can get the physical address at a certain offset via
      <function>snd_pcm_sgbuf_get_addr()</function>. 
      </para>
          <para>
        When a SG-handler is used, you need to set
      <function>snd_pcm_sgbuf_ops_page</function> as
      the <structfield>page</structfield> callback.
      (See <link linkend="pcm-interface-operators-page-callback"><citetitle>page callback section</citetitle></link>.)
      </para>
          <para>
        To release the data, call
      <function>snd_pcm_lib_free_pages()</function> in the
      <structfield>hw_free</structfield> callback as usual.
      </para>
        </section>
        <section id="buffer-and-memory-vmalloced">
          <title>Vmalloc'ed Buffers</title>
          <para>
        It's possible to use a buffer allocated via
      <function>vmalloc</function>, for example, for an intermediate
      buffer. Since the allocated pages are not contiguous, you need
      to set the <structfield>page</structfield> callback to obtain
      the physical address at every offset. 
      </para>
          <para>
        The implementation of <structfield>page</structfield> callback
        would be like this: 

        <informalexample><programlisting><![CDATA[
  #include <linux/vmalloc.h>

  /* get the physical page pointer on the given offset */
  static struct page *mychip_page(struct snd_pcm_substream *substream,
                                  unsigned long offset)
  {
          void *pageptr = substream->runtime->dma_area + offset;
          return vmalloc_to_page(pageptr);
  }
]]></programlisting></informalexample></para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Proc Interface  -->
      <!-- ****************************************************** -->
      <chapter id="proc-interface">
        <title>Proc Interface</title>
        <para>
      ALSA provides an easy interface for procfs. The proc files are
      very useful for debugging. I recommend you set up proc files if
      you write a driver and want to get a running status or register
      dumps. The API is found in
      <filename>&lt;sound/info.h&gt;</filename>. 
    </para>
        <para>
      To create a proc file, call
      <function>snd_card_proc_new()</function>. 

      <informalexample><programlisting><![CDATA[
  struct snd_info_entry *entry;
  int err = snd_card_proc_new(card, "my-file", &entry);
]]></programlisting></informalexample>

      where the second argument specifies the name of the proc file to be
    created. The above example will create a file
    <filename>my-file</filename> under the card directory,
    e.g. <filename>/proc/asound/card0/my-file</filename>. 
    </para>
        <para>
    Like other components, the proc entry created via
    <function>snd_card_proc_new()</function> will be registered and
    released automatically in the card registration and release
    functions.
    </para>
        <para>
      When the creation is successful, the function stores a new
    instance in the pointer given in the third argument.
    It is initialized as a text proc file for read only.  To use
    this proc file as a read-only text file as it is, set the read
    callback with a private data via 
     <function>snd_info_set_text_ops()</function>.

      <informalexample><programlisting><![CDATA[
  snd_info_set_text_ops(entry, chip, my_proc_read);
]]></programlisting></informalexample>
    
    where the second argument (<parameter>chip</parameter>) is the
    private data to be used in the callbacks. The third parameter
    specifies the read buffer size and the fourth
    (<parameter>my_proc_read</parameter>) is the callback function, which
    is defined like

      <informalexample><programlisting><![CDATA[
  static void my_proc_read(struct snd_info_entry *entry,
                           struct snd_info_buffer *buffer);
]]></programlisting></informalexample></para>
        <para>
    In the read callback, use <function>snd_iprintf()</function> for
    output strings, which works just like normal
    <function>printf()</function>.  For example,

      <informalexample><programlisting><![CDATA[
  static void my_proc_read(struct snd_info_entry *entry,
                           struct snd_info_buffer *buffer)
  {
          struct my_chip *chip = entry->private_data;

          snd_iprintf(buffer, "This is my chip!\n");
          snd_iprintf(buffer, "Port = %ld\n", chip->port);
  }
]]></programlisting></informalexample></para>
        <para>
    The file permissions can be changed afterwards.  As default, it's
    set as read only for all users.  If you want to add write
    permission for the user (root as default), do as follows:

      <informalexample><programlisting><![CDATA[
 entry->mode = S_IFREG | S_IRUGO | S_IWUSR;
]]></programlisting></informalexample>

    and set the write buffer size and the callback

      <informalexample><programlisting><![CDATA[
  entry->c.text.write = my_proc_write;
]]></programlisting></informalexample></para>
        <para>
      For the write callback, you can use
    <function>snd_info_get_line()</function> to get a text line, and
    <function>snd_info_get_str()</function> to retrieve a string from
    the line. Some examples are found in
    <filename>core/oss/mixer_oss.c</filename>, core/oss/and
    <filename>pcm_oss.c</filename>. 
    </para>
        <para>
      For a raw-data proc-file, set the attributes as follows:

      <informalexample><programlisting><![CDATA[
  static struct snd_info_entry_ops my_file_io_ops = {
          .read = my_file_io_read,
  };

  entry->content = SNDRV_INFO_CONTENT_DATA;
  entry->private_data = chip;
  entry->c.ops = &my_file_io_ops;
  entry->size = 4096;
  entry->mode = S_IFREG | S_IRUGO;
]]></programlisting></informalexample>

      For the raw data, <structfield>size</structfield> field must be
      set properly.  This specifies the maximum size of the proc file access.
    </para>
        <para>
      The read/write callbacks of raw mode are more direct than the text mode.
      You need to use a low-level I/O functions such as
      <function>copy_from/to_user()</function> to transfer the
      data.

      <informalexample><programlisting><![CDATA[
  static ssize_t my_file_io_read(struct snd_info_entry *entry,
                              void *file_private_data,
                              struct file *file,
                              char *buf,
                              size_t count,
                              loff_t pos)
  {
          if (copy_to_user(buf, local_data + pos, count))
                  return -EFAULT;
          return count;
  }
]]></programlisting></informalexample>

      If the size of the info entry has been set up properly,
      <structfield>count</structfield> and <structfield>pos</structfield> are
      guaranteed to fit within 0 and the given size.
      You don't have to check the range in the callbacks unless any
      other condition is required.

    </para>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Power Management  -->
      <!-- ****************************************************** -->
      <chapter id="power-management">
        <title>Power Management</title>
        <para>
      If the chip is supposed to work with suspend/resume
      functions, you need to add power-management code to the
      driver. The additional code for power-management should be
      <function>ifdef</function>'ed with
      <constant>CONFIG_PM</constant>. 
    </para>
        <para>
	If the driver <emphasis>fully</emphasis> supports suspend/resume
	that is, the device can be
	properly resumed to its state when suspend was called,
	you can set the <constant>SNDRV_PCM_INFO_RESUME</constant> flag
	in the pcm info field.  Usually, this is possible when the
	registers of the chip can be safely saved and restored to
	RAM. If this is set, the trigger callback is called with
	<constant>SNDRV_PCM_TRIGGER_RESUME</constant> after the resume
	callback completes. 
	</para>
        <para>
	Even if the driver doesn't support PM fully but 
	partial suspend/resume is still possible, it's still worthy to
	implement suspend/resume callbacks. In such a case, applications
	would reset the status by calling
	<function>snd_pcm_prepare()</function> and restart the stream
	appropriately.  Hence, you can define suspend/resume callbacks
	below but don't set <constant>SNDRV_PCM_INFO_RESUME</constant>
	info flag to the PCM.
	</para>
        <para>
	Note that the trigger with SUSPEND can always be called when
	<function>snd_pcm_suspend_all</function> is called,
	regardless of the <constant>SNDRV_PCM_INFO_RESUME</constant> flag.
	The <constant>RESUME</constant> flag affects only the behavior
	of <function>snd_pcm_resume()</function>.
	(Thus, in theory,
	<constant>SNDRV_PCM_TRIGGER_RESUME</constant> isn't needed
	to be handled in the trigger callback when no
	<constant>SNDRV_PCM_INFO_RESUME</constant> flag is set.  But,
	it's better to keep it for compatibility reasons.)
	</para>
        <para>
      In the earlier version of ALSA drivers, a common
      power-management layer was provided, but it has been removed.
      The driver needs to define the suspend/resume hooks according to
      the bus the device is connected to.  In the case of PCI drivers, the
      callbacks look like below:

      <informalexample><programlisting><![CDATA[
  #ifdef CONFIG_PM
  static int snd_my_suspend(struct pci_dev *pci, pm_message_t state)
  {
          .... /* do things for suspend */
          return 0;
  }
  static int snd_my_resume(struct pci_dev *pci)
  {
          .... /* do things for suspend */
          return 0;
  }
  #endif
]]></programlisting></informalexample></para>
        <para>
      The scheme of the real suspend job is as follows.

      <orderedlist><listitem><para>Retrieve the card and the chip data.</para></listitem><listitem><para>Call <function>snd_power_change_state()</function> with
	  <constant>SNDRV_CTL_POWER_D3hot</constant> to change the
	  power status.</para></listitem><listitem><para>Call <function>snd_pcm_suspend_all()</function> to suspend the running PCM streams.</para></listitem><listitem><para>If AC97 codecs are used, call
	<function>snd_ac97_suspend()</function> for each codec.</para></listitem><listitem><para>Save the register values if necessary.</para></listitem><listitem><para>Stop the hardware if necessary.</para></listitem><listitem><para>Disable the PCI device by calling
	  <function>pci_disable_device()</function>.  Then, call
          <function>pci_save_state()</function> at last.</para></listitem></orderedlist></para>
        <para>
      A typical code would be like:

      <informalexample><programlisting><![CDATA[
  static int mychip_suspend(struct pci_dev *pci, pm_message_t state)
  {
          /* (1) */
          struct snd_card *card = pci_get_drvdata(pci);
          struct mychip *chip = card->private_data;
          /* (2) */
          snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
          /* (3) */
          snd_pcm_suspend_all(chip->pcm);
          /* (4) */
          snd_ac97_suspend(chip->ac97);
          /* (5) */
          snd_mychip_save_registers(chip);
          /* (6) */
          snd_mychip_stop_hardware(chip);
          /* (7) */
          pci_disable_device(pci);
          pci_save_state(pci);
          return 0;
  }
]]></programlisting></informalexample></para>
        <para>
    The scheme of the real resume job is as follows.

    <orderedlist><listitem><para>Retrieve the card and the chip data.</para></listitem><listitem><para>Set up PCI. First, call <function>pci_restore_state()</function>.
    	Then enable the pci device again by calling <function>pci_enable_device()</function>.
	Call <function>pci_set_master()</function> if necessary, too.</para></listitem><listitem><para>Re-initialize the chip.</para></listitem><listitem><para>Restore the saved registers if necessary.</para></listitem><listitem><para>Resume the mixer, e.g. calling
    <function>snd_ac97_resume()</function>.</para></listitem><listitem><para>Restart the hardware (if any).</para></listitem><listitem><para>Call <function>snd_power_change_state()</function> with
	<constant>SNDRV_CTL_POWER_D0</constant> to notify the processes.</para></listitem></orderedlist></para>
        <para>
    A typical code would be like:

      <informalexample><programlisting><![CDATA[
  static int mychip_resume(struct pci_dev *pci)
  {
          /* (1) */
          struct snd_card *card = pci_get_drvdata(pci);
          struct mychip *chip = card->private_data;
          /* (2) */
          pci_restore_state(pci);
          pci_enable_device(pci);
          pci_set_master(pci);
          /* (3) */
          snd_mychip_reinit_chip(chip);
          /* (4) */
          snd_mychip_restore_registers(chip);
          /* (5) */
          snd_ac97_resume(chip->ac97);
          /* (6) */
          snd_mychip_restart_chip(chip);
          /* (7) */
          snd_power_change_state(card, SNDRV_CTL_POWER_D0);
          return 0;
  }
]]></programlisting></informalexample></para>
        <para>
	As shown in the above, it's better to save registers after
	suspending the PCM operations via
	<function>snd_pcm_suspend_all()</function> or
	<function>snd_pcm_suspend()</function>.  It means that the PCM
	streams are already stoppped when the register snapshot is
	taken.  But, remember that you don't have to restart the PCM
	stream in the resume callback. It'll be restarted via 
	trigger call with <constant>SNDRV_PCM_TRIGGER_RESUME</constant>
	when necessary.
    </para>
        <para>
      OK, we have all callbacks now. Let's set them up. In the
      initialization of the card, make sure that you can get the chip
      data from the card instance, typically via
      <structfield>private_data</structfield> field, in case you
      created the chip data individually.

      <informalexample><programlisting><![CDATA[
  static int snd_mychip_probe(struct pci_dev *pci,
                              const struct pci_device_id *pci_id)
  {
          ....
          struct snd_card *card;
          struct mychip *chip;
          int err;
          ....
          err = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);
          ....
          chip = kzalloc(sizeof(*chip), GFP_KERNEL);
          ....
          card->private_data = chip;
          ....
  }
]]></programlisting></informalexample>

	When you created the chip data with
	<function>snd_card_create()</function>, it's anyway accessible
	via <structfield>private_data</structfield> field.

      <informalexample><programlisting><![CDATA[
  static int snd_mychip_probe(struct pci_dev *pci,
                              const struct pci_device_id *pci_id)
  {
          ....
          struct snd_card *card;
          struct mychip *chip;
          int err;
          ....
          err = snd_card_create(index[dev], id[dev], THIS_MODULE,
                                sizeof(struct mychip), &card);
          ....
          chip = card->private_data;
          ....
  }
]]></programlisting></informalexample></para>
        <para>
      If you need a space to save the registers, allocate the
	buffer for it here, too, since it would be fatal
    if you cannot allocate a memory in the suspend phase.
    The allocated buffer should be released in the corresponding
    destructor.
    </para>
        <para>
      And next, set suspend/resume callbacks to the pci_driver.

      <informalexample><programlisting><![CDATA[
  static struct pci_driver driver = {
          .name = KBUILD_MODNAME,
          .id_table = snd_my_ids,
          .probe = snd_my_probe,
          .remove = snd_my_remove,
  #ifdef CONFIG_PM
          .suspend = snd_my_suspend,
          .resume = snd_my_resume,
  #endif
  };
]]></programlisting></informalexample></para>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Module Parameters  -->
      <!-- ****************************************************** -->
      <chapter id="module-parameters">
        <title>Module Parameters</title>
        <para>
      There are standard module options for ALSA. At least, each
      module should have the <parameter>index</parameter>,
      <parameter>id</parameter> and <parameter>enable</parameter>
      options. 
    </para>
        <para>
      If the module supports multiple cards (usually up to
      8 = <constant>SNDRV_CARDS</constant> cards), they should be
      arrays. The default initial values are defined already as
      constants for easier programming:

      <informalexample><programlisting><![CDATA[
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
  static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
]]></programlisting></informalexample></para>
        <para>
      If the module supports only a single card, they could be single
    variables, instead.  <parameter>enable</parameter> option is not
    always necessary in this case, but it would be better to have a
    dummy option for compatibility.
    </para>
        <para>
      The module parameters must be declared with the standard
    <function>module_param()()</function>,
    <function>module_param_array()()</function> and
    <function>MODULE_PARM_DESC()</function> macros.
    </para>
        <para>
      The typical coding would be like below:

      <informalexample><programlisting><![CDATA[
  #define CARD_NAME "My Chip"

  module_param_array(index, int, NULL, 0444);
  MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
  module_param_array(id, charp, NULL, 0444);
  MODULE_PARM_DESC(id, "ID string for " CARD_NAME " soundcard.");
  module_param_array(enable, bool, NULL, 0444);
  MODULE_PARM_DESC(enable, "Enable " CARD_NAME " soundcard.");
]]></programlisting></informalexample></para>
        <para>
      Also, don't forget to define the module description, classes,
      license and devices. Especially, the recent modprobe requires to
      define the module license as GPL, etc., otherwise the system is
      shown as <quote>tainted</quote>. 

      <informalexample><programlisting><![CDATA[
  MODULE_DESCRIPTION("My Chip");
  MODULE_LICENSE("GPL");
  MODULE_SUPPORTED_DEVICE("{{Vendor,My Chip Name}}");
]]></programlisting></informalexample></para>
      </chapter>
      <!-- ****************************************************** -->
      <!-- How To Put Your Driver  -->
      <!-- ****************************************************** -->
      <chapter id="how-to-put-your-driver">
        <title>How To Put Your Driver Into ALSA Tree</title>
        <section>
          <title>General</title>
          <para>
	So far, you've learned how to write the driver codes.
	And you might have a question now: how to put my own
	driver into the ALSA driver tree?
	Here (finally :) the standard procedure is described briefly.
	</para>
          <para>
	Suppose that you create a new PCI driver for the card
	<quote>xyz</quote>.  The card module name would be
	snd-xyz.  The new driver is usually put into the alsa-driver
	tree, <filename>alsa-driver/pci</filename> directory in
	the case of PCI cards.
	Then the driver is evaluated, audited and tested
	by developers and users.  After a certain time, the driver
	will go to the alsa-kernel tree (to the corresponding directory,
	such as <filename>alsa-kernel/pci</filename>) and eventually
 	will be integrated into the Linux 2.6 tree (the directory would be
	<filename>linux/sound/pci</filename>).
	</para>
          <para>
	In the following sections, the driver code is supposed
	to be put into alsa-driver tree. The two cases are covered:
	a driver consisting of a single source file and one consisting
	of several source files.
	</para>
        </section>
        <section>
          <title>Driver with A Single Source File</title>
          <para>
            <orderedlist>
              <listitem>
                <para>
	Modify alsa-driver/pci/Makefile
	</para>
                <para>
	Suppose you have a file xyz.c.  Add the following
	two lines
      <informalexample><programlisting><![CDATA[
  snd-xyz-objs := xyz.o
  obj-$(CONFIG_SND_XYZ) += snd-xyz.o
]]></programlisting></informalexample></para>
              </listitem>
              <listitem>
                <para>
	Create the Kconfig entry
	</para>
                <para>
	Add the new entry of Kconfig for your xyz driver.
      <informalexample><programlisting><![CDATA[
  config SND_XYZ
          tristate "Foobar XYZ"
          depends on SND
          select SND_PCM
          help
            Say Y here to include support for Foobar XYZ soundcard.

            To compile this driver as a module, choose M here: the module
            will be called snd-xyz.
]]></programlisting></informalexample>

	the line, select SND_PCM, specifies that the driver xyz supports
	PCM.  In addition to SND_PCM, the following components are
	supported for select command:
	SND_RAWMIDI, SND_TIMER, SND_HWDEP, SND_MPU401_UART,
	SND_OPL3_LIB, SND_OPL4_LIB, SND_VX_LIB, SND_AC97_CODEC.
	Add the select command for each supported component.
	</para>
                <para>
	Note that some selections imply the lowlevel selections.
	For example, PCM includes TIMER, MPU401_UART includes RAWMIDI,
	AC97_CODEC includes PCM, and OPL3_LIB includes HWDEP.
	You don't need to give the lowlevel selections again.
	</para>
                <para>
	For the details of Kconfig script, refer to the kbuild
	documentation.
	</para>
              </listitem>
              <listitem>
                <para>
	Run cvscompile script to re-generate the configure script and
	build the whole stuff again.
	</para>
              </listitem>
            </orderedlist>
          </para>
        </section>
        <section>
          <title>Drivers with Several Source Files</title>
          <para>
	Suppose that the driver snd-xyz have several source files.
	They are located in the new subdirectory,
	pci/xyz.

	<orderedlist><listitem><para>
	Add a new directory (<filename>xyz</filename>) in
	<filename>alsa-driver/pci/Makefile</filename> as below

      <informalexample><programlisting><![CDATA[
  obj-$(CONFIG_SND) += xyz/
]]></programlisting></informalexample></para></listitem><listitem><para>
	Under the directory <filename>xyz</filename>, create a Makefile

      <example><title>Sample Makefile for a driver xyz</title><programlisting><![CDATA[
  ifndef SND_TOPDIR
  SND_TOPDIR=../..
  endif

  include $(SND_TOPDIR)/toplevel.config
  include $(SND_TOPDIR)/Makefile.conf

  snd-xyz-objs := xyz.o abc.o def.o

  obj-$(CONFIG_SND_XYZ) += snd-xyz.o

  include $(SND_TOPDIR)/Rules.make
]]></programlisting></example></para></listitem><listitem><para>
	Create the Kconfig entry
	</para><para>
	This procedure is as same as in the last section.
	</para></listitem><listitem><para>
	Run cvscompile script to re-generate the configure script and
	build the whole stuff again.
	</para></listitem></orderedlist></para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Useful Functions  -->
      <!-- ****************************************************** -->
      <chapter id="useful-functions">
        <title>Useful Functions</title>
        <section id="useful-functions-snd-printk">
          <title>
            <function>snd_printk()</function> and friends</title>
          <para>
        ALSA provides a verbose version of the
      <function>printk()</function> function. If a kernel config
      <constant>CONFIG_SND_VERBOSE_PRINTK</constant> is set, this
      function prints the given message together with the file name
      and the line of the caller. The <constant>KERN_XXX</constant>
      prefix is processed as 
      well as the original <function>printk()</function> does, so it's
      recommended to add this prefix, e.g. 

        <informalexample><programlisting><![CDATA[
  snd_printk(KERN_ERR "Oh my, sorry, it's extremely bad!\n");
]]></programlisting></informalexample></para>
          <para>
        There are also <function>printk()</function>'s for
      debugging. <function>snd_printd()</function> can be used for
      general debugging purposes. If
      <constant>CONFIG_SND_DEBUG</constant> is set, this function is
      compiled, and works just like
      <function>snd_printk()</function>. If the ALSA is compiled
      without the debugging flag, it's ignored. 
      </para>
          <para>
            <function>snd_printdd()</function> is compiled in only when
      <constant>CONFIG_SND_DEBUG_VERBOSE</constant> is set. Please note
      that <constant>CONFIG_SND_DEBUG_VERBOSE</constant> is not set as default
      even if you configure the alsa-driver with
      <option>--with-debug=full</option> option. You need to give
      explicitly <option>--with-debug=detect</option> option instead. 
      </para>
        </section>
        <section id="useful-functions-snd-bug">
          <title>
            <function>snd_BUG()</function>
          </title>
          <para>
        It shows the <computeroutput>BUG?</computeroutput> message and
      stack trace as well as <function>snd_BUG_ON</function> at the point.
      It's useful to show that a fatal error happens there. 
      </para>
          <para>
	 When no debug flag is set, this macro is ignored. 
      </para>
        </section>
        <section id="useful-functions-snd-bug-on">
          <title>
            <function>snd_BUG_ON()</function>
          </title>
          <para>
            <function>snd_BUG_ON()</function> macro is similar with
	<function>WARN_ON()</function> macro. For example,  

        <informalexample><programlisting><![CDATA[
  snd_BUG_ON(!pointer);
]]></programlisting></informalexample>

	or it can be used as the condition,
        <informalexample><programlisting><![CDATA[
  if (snd_BUG_ON(non_zero_is_bug))
          return -EINVAL;
]]></programlisting></informalexample></para>
          <para>
        The macro takes an conditional expression to evaluate.
	When <constant>CONFIG_SND_DEBUG</constant>, is set, if the
	expression is non-zero, it shows the warning message such as
	<computeroutput>BUG? (xxx)</computeroutput>
	normally followed by stack trace.

	In both cases it returns the evaluated value.
      </para>
        </section>
      </chapter>
      <!-- ****************************************************** -->
      <!-- Acknowledgments  -->
      <!-- ****************************************************** -->
      <chapter id="acknowledgments">
        <title>Acknowledgments</title>
        <para>
      I would like to thank Phil Kerr for his help for improvement and
      corrections of this document. 
    </para>
        <para>
    Kevin Conder reformatted the original plain-text to the
    DocBook format.
    </para>
        <para>
    Giuliano Pochini corrected typos and contributed the example codes
    in the hardware constraints section.
    </para>
      </chapter>
    </book>
    <book id="USBDeviceDriver">
      <bookinfo>
        <title>Writing USB Device Drivers</title>
        <authorgroup>
          <author>
            <firstname>Greg</firstname>
            <surname>Kroah-Hartman</surname>
            <affiliation>
              <address>
                <email>greg@kroah.com</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2001-2002</year>
          <holder>Greg Kroah-Hartman</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
          <para>
     This documentation is based on an article published in 
     Linux Journal Magazine, October 2001, Issue 90.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
      The Linux USB subsystem has grown from supporting only two different
      types of devices in the 2.2.7 kernel (mice and keyboards), to over 20
      different types of devices in the 2.4 kernel. Linux currently supports
      almost all USB class devices (standard types of devices like keyboards,
      mice, modems, printers and speakers) and an ever-growing number of
      vendor-specific devices (such as USB to serial converters, digital
      cameras, Ethernet devices and MP3 players). For a full list of the
      different USB devices currently supported, see Resources.
  </para>
        <para>
      The remaining kinds of USB devices that do not have support on Linux are
      almost all vendor-specific devices. Each vendor decides to implement a
      custom protocol to talk to their device, so a custom driver usually needs
      to be created. Some vendors are open with their USB protocols and help
      with the creation of Linux drivers, while others do not publish them, and
      developers are forced to reverse-engineer. See Resources for some links
      to handy reverse-engineering tools.
  </para>
        <para>
      Because each different protocol causes a new driver to be created, I have
      written a generic USB driver skeleton, modelled after the pci-skeleton.c
      file in the kernel source tree upon which many PCI network drivers have
      been based. This USB skeleton can be found at drivers/usb/usb-skeleton.c
      in the kernel source tree. In this article I will walk through the basics
      of the skeleton driver, explaining the different pieces and what needs to
      be done to customize it to your specific device.
  </para>
      </chapter>
      <chapter id="basics">
        <title>Linux USB Basics</title>
        <para>
      If you are going to write a Linux USB driver, please become familiar with
      the USB protocol specification. It can be found, along with many other
      useful documents, at the USB home page (see Resources). An excellent
      introduction to the Linux USB subsystem can be found at the USB Working
      Devices List (see Resources). It explains how the Linux USB subsystem is
      structured and introduces the reader to the concept of USB urbs
      (USB Request Blocks), which are essential to USB drivers.
  </para>
        <para>
      The first thing a Linux USB driver needs to do is register itself with
      the Linux USB subsystem, giving it some information about which devices
      the driver supports and which functions to call when a device supported
      by the driver is inserted or removed from the system. All of this
      information is passed to the USB subsystem in the usb_driver structure.
      The skeleton driver declares a usb_driver as:
  </para>
        <programlisting>
static struct usb_driver skel_driver = {
        .name        = "skeleton",
        .probe       = skel_probe,
        .disconnect  = skel_disconnect,
        .fops        = &amp;skel_fops,
        .minor       = USB_SKEL_MINOR_BASE,
        .id_table    = skel_table,
};
  </programlisting>
        <para>
      The variable name is a string that describes the driver. It is used in
      informational messages printed to the system log. The probe and
      disconnect function pointers are called when a device that matches the
      information provided in the id_table variable is either seen or removed.
  </para>
        <para>
      The fops and minor variables are optional. Most USB drivers hook into
      another kernel subsystem, such as the SCSI, network or TTY subsystem.
      These types of drivers register themselves with the other kernel
      subsystem, and any user-space interactions are provided through that
      interface. But for drivers that do not have a matching kernel subsystem,
      such as MP3 players or scanners, a method of interacting with user space
      is needed. The USB subsystem provides a way to register a minor device
      number and a set of file_operations function pointers that enable this
      user-space interaction. The skeleton driver needs this kind of interface,
      so it provides a minor starting number and a pointer to its
      file_operations functions.
  </para>
        <para>
      The USB driver is then registered with a call to usb_register, usually in
      the driver's init function, as shown here:
  </para>
        <programlisting>
static int __init usb_skel_init(void)
{
        int result;

        /* register this driver with the USB subsystem */
        result = usb_register(&amp;skel_driver);
        if (result &lt; 0) {
                err("usb_register failed for the "__FILE__ "driver."
                    "Error number %d", result);
                return -1;
        }

        return 0;
}
module_init(usb_skel_init);
  </programlisting>
        <para>
      When the driver is unloaded from the system, it needs to deregister
      itself with the USB subsystem. This is done with the usb_deregister
      function:
  </para>
        <programlisting>
static void __exit usb_skel_exit(void)
{
        /* deregister this driver with the USB subsystem */
        usb_deregister(&amp;skel_driver);
}
module_exit(usb_skel_exit);
  </programlisting>
        <para>
     To enable the linux-hotplug system to load the driver automatically when
     the device is plugged in, you need to create a MODULE_DEVICE_TABLE. The
     following code tells the hotplug scripts that this module supports a
     single device with a specific vendor and product ID:
  </para>
        <programlisting>
/* table of devices that work with this driver */
static struct usb_device_id skel_table [] = {
        { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },
        { }                      /* Terminating entry */
};
MODULE_DEVICE_TABLE (usb, skel_table);
  </programlisting>
        <para>
     There are other macros that can be used in describing a usb_device_id for
     drivers that support a whole class of USB drivers. See usb.h for more
     information on this.
  </para>
      </chapter>
      <chapter id="device">
        <title>Device operation</title>
        <para>
     When a device is plugged into the USB bus that matches the device ID
     pattern that your driver registered with the USB core, the probe function
     is called. The usb_device structure, interface number and the interface ID
     are passed to the function:
  </para>
        <programlisting>
static int skel_probe(struct usb_interface *interface,
    const struct usb_device_id *id)
  </programlisting>
        <para>
     The driver now needs to verify that this device is actually one that it
     can accept. If so, it returns 0.
     If not, or if any error occurs during initialization, an errorcode
     (such as <literal>-ENOMEM</literal> or <literal>-ENODEV</literal>)
     is returned from the probe function.
  </para>
        <para>
     In the skeleton driver, we determine what end points are marked as bulk-in
     and bulk-out. We create buffers to hold the data that will be sent and
     received from the device, and a USB urb to write data to the device is
     initialized.
  </para>
        <para>
     Conversely, when the device is removed from the USB bus, the disconnect
     function is called with the device pointer. The driver needs to clean any
     private data that has been allocated at this time and to shut down any
     pending urbs that are in the USB system.
  </para>
        <para>
     Now that the device is plugged into the system and the driver is bound to
     the device, any of the functions in the file_operations structure that
     were passed to the USB subsystem will be called from a user program trying
     to talk to the device. The first function called will be open, as the
     program tries to open the device for I/O. We increment our private usage
     count and save a pointer to our internal structure in the file
     structure. This is done so that future calls to file operations will
     enable the driver to determine which device the user is addressing.  All
     of this is done with the following code:
  </para>
        <programlisting>
/* increment our usage count for the module */
++skel-&gt;open_count;

/* save our object in the file's private structure */
file-&gt;private_data = dev;
  </programlisting>
        <para>
     After the open function is called, the read and write functions are called
     to receive and send data to the device. In the skel_write function, we
     receive a pointer to some data that the user wants to send to the device
     and the size of the data. The function determines how much data it can
     send to the device based on the size of the write urb it has created (this
     size depends on the size of the bulk out end point that the device has).
     Then it copies the data from user space to kernel space, points the urb to
     the data and submits the urb to the USB subsystem.  This can be seen in
     the following code:
  </para>
        <programlisting>
/* we can only write as much as 1 urb will hold */
bytes_written = (count &gt; skel-&gt;bulk_out_size) ? skel-&gt;bulk_out_size : count;

/* copy the data from user space into our urb */
copy_from_user(skel-&gt;write_urb-&gt;transfer_buffer, buffer, bytes_written);

/* set up our urb */
usb_fill_bulk_urb(skel-&gt;write_urb,
                  skel-&gt;dev,
                  usb_sndbulkpipe(skel-&gt;dev, skel-&gt;bulk_out_endpointAddr),
                  skel-&gt;write_urb-&gt;transfer_buffer,
                  bytes_written,
                  skel_write_bulk_callback,
                  skel);

/* send the data out the bulk port */
result = usb_submit_urb(skel-&gt;write_urb);
if (result) {
        err("Failed submitting write urb, error %d", result);
}
  </programlisting>
        <para>
     When the write urb is filled up with the proper information using the
     usb_fill_bulk_urb function, we point the urb's completion callback to call our
     own skel_write_bulk_callback function. This function is called when the
     urb is finished by the USB subsystem. The callback function is called in
     interrupt context, so caution must be taken not to do very much processing
     at that time. Our implementation of skel_write_bulk_callback merely
     reports if the urb was completed successfully or not and then returns.
  </para>
        <para>
     The read function works a bit differently from the write function in that
     we do not use an urb to transfer data from the device to the driver.
     Instead we call the usb_bulk_msg function, which can be used to send or
     receive data from a device without having to create urbs and handle
     urb completion callback functions. We call the usb_bulk_msg function,
     giving it a buffer into which to place any data received from the device
     and a timeout value. If the timeout period expires without receiving any
     data from the device, the function will fail and return an error message.
     This can be shown with the following code:
  </para>
        <programlisting>
/* do an immediate bulk read to get data from the device */
retval = usb_bulk_msg (skel-&gt;dev,
                       usb_rcvbulkpipe (skel-&gt;dev,
                       skel-&gt;bulk_in_endpointAddr),
                       skel-&gt;bulk_in_buffer,
                       skel-&gt;bulk_in_size,
                       &amp;count, HZ*10);
/* if the read was successful, copy the data to user space */
if (!retval) {
        if (copy_to_user (buffer, skel-&gt;bulk_in_buffer, count))
                retval = -EFAULT;
        else
                retval = count;
}
  </programlisting>
        <para>
     The usb_bulk_msg function can be very useful for doing single reads or
     writes to a device; however, if you need to read or write constantly to a
     device, it is recommended to set up your own urbs and submit them to the
     USB subsystem.
  </para>
        <para>
     When the user program releases the file handle that it has been using to
     talk to the device, the release function in the driver is called. In this
     function we decrement our private usage count and wait for possible
     pending writes:
  </para>
        <programlisting>
/* decrement our usage count for the device */
--skel-&gt;open_count;
  </programlisting>
        <para>
     One of the more difficult problems that USB drivers must be able to handle
     smoothly is the fact that the USB device may be removed from the system at
     any point in time, even if a program is currently talking to it. It needs
     to be able to shut down any current reads and writes and notify the
     user-space programs that the device is no longer there. The following
     code (function <function>skel_delete</function>)
     is an example of how to do this: </para>
        <programlisting>
static inline void skel_delete (struct usb_skel *dev)
{
    kfree (dev-&gt;bulk_in_buffer);
    if (dev-&gt;bulk_out_buffer != NULL)
        usb_free_coherent (dev-&gt;udev, dev-&gt;bulk_out_size,
            dev-&gt;bulk_out_buffer,
            dev-&gt;write_urb-&gt;transfer_dma);
    usb_free_urb (dev-&gt;write_urb);
    kfree (dev);
}
  </programlisting>
        <para>
     If a program currently has an open handle to the device, we reset the flag
     <literal>device_present</literal>. For
     every read, write, release and other functions that expect a device to be
     present, the driver first checks this flag to see if the device is
     still present. If not, it releases that the device has disappeared, and a
     -ENODEV error is returned to the user-space program. When the release
     function is eventually called, it determines if there is no device
     and if not, it does the cleanup that the skel_disconnect
     function normally does if there are no open files on the device (see
     Listing 5).
  </para>
      </chapter>
      <chapter id="iso">
        <title>Isochronous Data</title>
        <para>
     This usb-skeleton driver does not have any examples of interrupt or
     isochronous data being sent to or from the device. Interrupt data is sent
     almost exactly as bulk data is, with a few minor exceptions.  Isochronous
     data works differently with continuous streams of data being sent to or
     from the device. The audio and video camera drivers are very good examples
     of drivers that handle isochronous data and will be useful if you also
     need to do this.
  </para>
      </chapter>
      <chapter id="Conclusion">
        <title>Conclusion</title>
        <para>
     Writing Linux USB device drivers is not a difficult task as the
     usb-skeleton driver shows. This driver, combined with the other current
     USB drivers, should provide enough examples to help a beginning author
     create a working driver in a minimal amount of time. The linux-usb-devel
     mailing list archives also contain a lot of helpful information.
  </para>
      </chapter>
      <chapter id="resources">
        <title>Resources</title>
        <para>
     The Linux USB Project: <ulink url="http://www.linux-usb.org">http://www.linux-usb.org/</ulink></para>
        <para>
     Linux Hotplug Project: <ulink url="http://linux-hotplug.sourceforge.net">http://linux-hotplug.sourceforge.net/</ulink></para>
        <para>
     Linux USB Working Devices List: <ulink url="http://www.qbik.ch/usb/devices">http://www.qbik.ch/usb/devices/</ulink></para>
        <para>
     linux-usb-devel Mailing List Archives: <ulink url="http://marc.theaimsgroup.com/?l=linux-usb-devel">http://marc.theaimsgroup.com/?l=linux-usb-devel</ulink></para>
        <para>
     Programming Guide for Linux USB Device Drivers: <ulink url="http://usb.cs.tum.edu/usbdoc">http://usb.cs.tum.edu/usbdoc</ulink></para>
        <para>
     USB Home Page: <ulink url="http://www.usb.org">http://www.usb.org</ulink></para>
      </chapter>
    </book>
    <book id="Z85230Guide">
      <bookinfo>
        <title>Z8530 Programming Guide</title>
        <authorgroup>
          <author>
            <firstname>Alan</firstname>
            <surname>Cox</surname>
            <affiliation>
              <address>
                <email>alan@lxorguk.ukuu.org.uk</email>
              </address>
            </affiliation>
          </author>
        </authorgroup>
        <copyright>
          <year>2000</year>
          <holder>Alan Cox</holder>
        </copyright>
        <legalnotice>
          <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>
          <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>
          <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>
          <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
        </legalnotice>
      </bookinfo>
      <toc>
      </toc>
      <chapter id="intro">
        <title>Introduction</title>
        <para>
	The Z85x30 family synchronous/asynchronous controller chips are
	used on a large number of cheap network interface cards. The
	kernel provides a core interface layer that is designed to make
	it easy to provide WAN services using this chip.
  </para>
        <para>
	The current driver only support synchronous operation. Merging the
	asynchronous driver support into this code to allow any Z85x30
	device to be used as both a tty interface and as a synchronous 
	controller is a project for Linux post the 2.4 release
  </para>
      </chapter>
      <chapter id="Driver_Modes">
        <title>Driver Modes</title>
        <para>
	The Z85230 driver layer can drive Z8530, Z85C30 and Z85230 devices
	in three different modes. Each mode can be applied to an individual
	channel on the chip (each chip has two channels).
  </para>
        <para>
	The PIO synchronous mode supports the most common Z8530 wiring. Here
	the chip is interface to the I/O and interrupt facilities of the
	host machine but not to the DMA subsystem. When running PIO the
	Z8530 has extremely tight timing requirements. Doing high speeds,
	even with a Z85230 will be tricky. Typically you should expect to
	achieve at best 9600 baud with a Z8C530 and 64Kbits with a Z85230.
  </para>
        <para>
	The DMA mode supports the chip when it is configured to use dual DMA
	channels on an ISA bus. The better cards tend to support this mode
	of operation for a single channel. With DMA running the Z85230 tops
	out when it starts to hit ISA DMA constraints at about 512Kbits. It
	is worth noting here that many PC machines hang or crash when the
	chip is driven fast enough to hold the ISA bus solid.
  </para>
        <para>
	Transmit DMA mode uses a single DMA channel. The DMA channel is used
	for transmission as the transmit FIFO is smaller than the receive
	FIFO. it gives better performance than pure PIO mode but is nowhere
	near as ideal as pure DMA mode. 
  </para>
      </chapter>
      <chapter id="Using_the_Z85230_driver">
        <title>Using the Z85230 driver</title>
        <para>
	The Z85230 driver provides the back end interface to your board. To
	configure a Z8530 interface you need to detect the board and to 
	identify its ports and interrupt resources. It is also your problem
	to verify the resources are available.
  </para>
        <para>
	Having identified the chip you need to fill in a struct z8530_dev,
	which describes each chip. This object must exist until you finally
	shutdown the board. Firstly zero the active field. This ensures 
	nothing goes off without you intending it. The irq field should
	be set to the interrupt number of the chip. (Each chip has a single
	interrupt source rather than each channel). You are responsible
	for allocating the interrupt line. The interrupt handler should be
	set to <function>z8530_interrupt</function>. The device id should
	be set to the z8530_dev structure pointer. Whether the interrupt can
	be shared or not is board dependent, and up to you to initialise.
  </para>
        <para>
	The structure holds two channel structures. 
	Initialise chanA.ctrlio and chanA.dataio with the address of the
	control and data ports. You can or this with Z8530_PORT_SLEEP to
	indicate your interface needs the 5uS delay for chip settling done
	in software. The PORT_SLEEP option is architecture specific. Other
	flags may become available on future platforms, eg for MMIO.
	Initialise the chanA.irqs to &amp;z8530_nop to start the chip up
	as disabled and discarding interrupt events. This ensures that
	stray interrupts will be mopped up and not hang the bus. Set
	chanA.dev to point to the device structure itself. The
	private and name field you may use as you wish. The private field
	is unused by the Z85230 layer. The name is used for error reporting
	and it may thus make sense to make it match the network name.
  </para>
        <para>
	Repeat the same operation with the B channel if your chip has
	both channels wired to something useful. This isn't always the
	case. If it is not wired then the I/O values do not matter, but
	you must initialise chanB.dev.
  </para>
        <para>
	If your board has DMA facilities then initialise the txdma and
	rxdma fields for the relevant channels. You must also allocate the
	ISA DMA channels and do any necessary board level initialisation
	to configure them. The low level driver will do the Z8530 and
	DMA controller programming but not board specific magic.
  </para>
        <para>
	Having initialised the device you can then call
	<function>z8530_init</function>. This will probe the chip and 
	reset it into a known state. An identification sequence is then
	run to identify the chip type. If the checks fail to pass the
	function returns a non zero error code. Typically this indicates
	that the port given is not valid. After this call the
	type field of the z8530_dev structure is initialised to either
	Z8530, Z85C30 or Z85230 according to the chip found.
  </para>
        <para>
	Once you have called z8530_init you can also make use of the utility
	function <function>z8530_describe</function>. This provides a 
	consistent reporting format for the Z8530 devices, and allows all
	the drivers to provide consistent reporting.
  </para>
      </chapter>
      <chapter id="Attaching_Network_Interfaces">
        <title>Attaching Network Interfaces</title>
        <para>
	If you wish to use the network interface facilities of the driver,
	then you need to attach a network device to each channel that is
	present and in use. In addition to use the generic HDLC
	you need to follow some additional plumbing rules. They may seem 
	complex but a look at the example hostess_sv11 driver should
	reassure you.
  </para>
        <para>
	The network device used for each channel should be pointed to by
	the netdevice field of each channel. The hdlc-&gt; priv field of the
	network device points to your private data - you will need to be
	able to find your private data from this.
  </para>
        <para>
	The way most drivers approach this particular problem is to
	create a structure holding the Z8530 device definition and
	put that into the private field of the network device. The
	network device fields of the channels then point back to the
	network devices.
  </para>
        <para>
	If you wish to use the generic HDLC then you need to register
	the HDLC device.
  </para>
        <para>
	Before you register your network device you will also need to
	provide suitable handlers for most of the network device callbacks. 
	See the network device documentation for more details on this.
  </para>
      </chapter>
      <chapter id="Configuring_And_Activating_The_Port">
        <title>Configuring And Activating The Port</title>
        <para>
	The Z85230 driver provides helper functions and tables to load the
	port registers on the Z8530 chips. When programming the register
	settings for a channel be aware that the documentation recommends
	initialisation orders. Strange things happen when these are not
	followed. 
  </para>
        <para>
          <function>z8530_channel_load</function> takes an array of
	pairs of initialisation values in an array of u8 type. The first
	value is the Z8530 register number. Add 16 to indicate the alternate
	register bank on the later chips. The array is terminated by a 255.
  </para>
        <para>
	The driver provides a pair of public tables. The
	z8530_hdlc_kilostream table is for the UK 'Kilostream' service and
	also happens to cover most other end host configurations. The
	z8530_hdlc_kilostream_85230 table is the same configuration using
	the enhancements of the 85230 chip. The configuration loaded is
	standard NRZ encoded synchronous data with HDLC bitstuffing. All
	of the timing is taken from the other end of the link.
  </para>
        <para>
	When writing your own tables be aware that the driver internally
	tracks register values. It may need to reload values. You should
	therefore be sure to set registers 1-7, 9-11, 14 and 15 in all
	configurations. Where the register settings depend on DMA selection
	the driver will update the bits itself when you open or close.
	Loading a new table with the interface open is not recommended.
  </para>
        <para>
	There are three standard configurations supported by the core
	code. In PIO mode the interface is programmed up to use
	interrupt driven PIO. This places high demands on the host processor
	to avoid latency. The driver is written to take account of latency
	issues but it cannot avoid latencies caused by other drivers,
	notably IDE in PIO mode. Because the drivers allocate buffers you
	must also prevent MTU changes while the port is open.
  </para>
        <para>
	Once the port is open it will call the rx_function of each channel
	whenever a completed packet arrived. This is invoked from
	interrupt context and passes you the channel and a network	
	buffer (struct sk_buff) holding the data. The data includes
	the CRC bytes so most users will want to trim the last two
	bytes before processing the data. This function is very timing
	critical. When you wish to simply discard data the support
	code provides the function <function>z8530_null_rx</function>
	to discard the data.
  </para>
        <para>
	To active PIO mode sending and receiving the <function>
	z8530_sync_open</function> is called. This expects to be passed
	the network device and the channel. Typically this is called from
	your network device open callback. On a failure a non zero error
	status is returned. The <function>z8530_sync_close</function> 
	function shuts down a PIO channel. This must be done before the 
	channel is opened again	and before the driver shuts down 
	and unloads.
  </para>
        <para>
	The ideal mode of operation is dual channel DMA mode. Here the
	kernel driver will configure the board for DMA in both directions.
	The driver also handles ISA DMA issues such as controller
	programming and the memory range limit for you. This mode is
	activated by calling the <function>z8530_sync_dma_open</function>
	function. On failure a non zero error value is returned.
	Once this mode is activated it can be shut down by calling the
	<function>z8530_sync_dma_close</function>. You must call the close
	function matching the open mode you used.
  </para>
        <para>
	The final supported mode uses a single DMA channel to drive the
	transmit side. As the Z85C30 has a larger FIFO on the receive
	channel	this tends to increase the maximum speed a little. 
	This is activated by calling the <function>z8530_sync_txdma_open
	</function>. This returns a non zero error code on failure. The
	<function>z8530_sync_txdma_close</function> function closes down
	the Z8530 interface from this mode.
  </para>
      </chapter>
      <chapter id="Network_Layer_Functions">
        <title>Network Layer Functions</title>
        <para>
	The Z8530 layer provides functions to queue packets for
	transmission. The driver internally buffers the frame currently
	being transmitted and one further frame (in order to keep back
	to back transmission running). Any further buffering is up to
	the caller.
  </para>
        <para>
	The function <function>z8530_queue_xmit</function> takes a network
	buffer in sk_buff format and queues it for transmission. The
	caller must provide the entire packet with the exception of the
	bitstuffing and CRC. This is normally done by the caller via
	the generic HDLC interface layer. It returns 0 if the buffer has been
	queued and non zero values for queue full. If the function accepts
	the buffer it becomes property of the Z8530 layer and the caller
	should not free it.
  </para>
        <para>
	The function <function>z8530_get_stats</function> returns a pointer
	to an internally maintained per interface statistics block. This
	provides most of the interface code needed to implement the network
	layer get_stats callback.
  </para>
      </chapter>
      <chapter id="Porting_The_Z8530_Driver">
        <title>Porting The Z8530 Driver</title>
        <para>
	The Z8530 driver is written to be portable. In DMA mode it makes
	assumptions about the use of ISA DMA. These are probably warranted
	in most cases as the Z85230 in particular was designed to glue to PC
	type machines. The PIO mode makes no real assumptions.
  </para>
        <para>
	Should you need to retarget the Z8530 driver to another architecture
	the only code that should need changing are the port I/O functions.
	At the moment these assume PC I/O port accesses. This may not be
	appropriate for all platforms. Replacing 
	<function>z8530_read_port</function> and <function>z8530_write_port
	</function> is intended to be all that is required to port this
	driver layer.
  </para>
      </chapter>
      <chapter id="bugs">
        <title>Known Bugs And Assumptions</title>
        <para>
          <variablelist>
            <varlistentry>
              <term>Interrupt Locking</term>
              <listitem>
                <para>
	The locking in the driver is done via the global cli/sti lock. This
	makes for relatively poor SMP performance. Switching this to use a
	per device spin lock would probably materially improve performance.
    </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Occasional Failures</term>
              <listitem>
                <para>
	We have reports of occasional failures when run for very long
	periods of time and the driver starts to receive junk frames. At
	the moment the cause of this is not clear.
    </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>
      </chapter>
      <chapter id="pubfunctions">
        <title>Public Functions Provided</title>
!Edrivers/net/wan/z85230.c
  </chapter>
      <chapter id="intfunctions">
        <title>Internal Functions</title>
!Idrivers/net/wan/z85230.c
  </chapter>
    </book>
  </d:InfElement>
</d:DocumentationCore>