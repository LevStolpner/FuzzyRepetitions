<?xml version="1.0" encoding="UTF-8"?>
<d:DocumentationCore xmlns:d="http://math.spbu.ru/drl" xmlns="http://docbook.org/ns/docbook"><d:InfElement id="root" name="test">

<!-- -*- sgml -*- -->

<appendix id="svn.intro">

  <title>Subversion Quick-Start Guide</title>


  <para>If you're eager to get Subversion up and running (and you
    enjoy learning by experimentation), this appendix will show you how
    to create a repository, import code, and then check it back out
    again as a working copy.  Along the way, we give links to the
    relevant chapters of this book.</para>

  <warning>
  <para>If you're new to the entire concept of version control or to
    the <quote>copy-modify-merge</quote> model used by both CVS and
    Subversion, you should read <xref linkend="svn.basic"/>
    before going any further.</para>
  </warning>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.install">

    <title>Installing Subversion</title>

    <para>Subversion is built on a portability layer called
      APR the Apache Portable Runtime library.  The APR library
      provides all the interfaces that Subversion needs to function on
      different operating systems: disk access, network access, memory
      management, and so on.  While Subversion is able to use Apache
      HTTP Server (or, <command>httpd</command>) as one of its network
      server programs, its dependence on APR <emphasis>does
      not</emphasis> mean that <command>httpd</command> is a required
      component.  APR is a standalone library usable by any
      application.  It does mean, however, that Subversion clients and
      servers run on any operating system
      that <command>httpd</command> runs on: Windows, Linux, all
      flavors of BSD, Mac OS X, NetWare, and others.</para>

    <para>The easiest way to get Subversion is to download a binary
      package built for your operating system.  Subversion's web site
      (<ulink url="http://subversion.apache.org"/>) often has these
      packages available for download, posted by volunteers.  The site
      usually contains graphical installer packages for users of
      Microsoft operating systems.  If you run a Unix-like operating
      system, you can use your system's native package distribution
      system (RPMs, DEBs, the ports tree, etc.) to get
      Subversion.</para>

    <para>Alternatively, you can build Subversion directly from source
      code, though it's not always an easy task. (If you're not
      experienced at building open source software packages, you're
      probably better off downloading a binary distribution instead!)
      From the Subversion web site, download the latest source code
      release.  After unpacking it, follow the instructions in
      the <filename>INSTALL</filename> file to build it.</para>

    <para>If you're one of those folks that likes to use bleeding-edge
      software, you can also get the Subversion source code from the
      Subversion repository in which it lives.  Obviously, you'll need
      to already have a Subversion client on hand to do this.  But
      once you do, you can check out a working copy from
      <ulink url="http://svn.apache.org/repos/asf/subversion"
      /><footnote><para>Note that the URL checked out in the example
      ends not with <literal>subversion</literal>, but with a
      subdirectory thereof called <literal>trunk</literal>.  See our
      discussion of Subversion's branching and tagging model for the
      reasoning behind this.</para></footnote>:</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.apache.org/repos/asf/subversion/trunk subversion
A    subversion/HACKING
A    subversion/INSTALL
A    subversion/README
A    subversion/autogen.sh
A    subversion/build.conf
</screen>
    </informalexample>

    <para>The preceding command will create a working copy of the
      latest (unreleased) Subversion source code into a subdirectory
      named <filename>subversion</filename> in your current working
      directory.  You can adjust that last argument as you see fit.
      Regardless of what you call the new working copy directory,
      though, after this operation completes, you will now have the
      Subversion source code.  Of course, you will still need to fetch
      a few helper libraries (apr, apr-util, etc.) see the
      <filename>INSTALL</filename> file in the top level of the
      working copy for details.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.quickstart">

    <title>High-Speed Tutorial</title>

    <blockquote>
      <para><quote>Please make sure your seat backs are in their full,
        upright position and that your tray tables are stored.  Flight
        attendants, prepare for take-off.</quote></para>
        </blockquote>

    <para>What follows is a quick tutorial that walks you through some
      basic Subversion configuration and operation.  When you finish
      it, you should have a general understanding of Subversion's
      typical usage.</para>

    <note>
      <para>The examples used in this appendix assume that you have
        <command>svn</command>, the Subversion command-line client,
        and <command>svnadmin</command>, the administrative tool,
        ready to go on a Unix-like operating system.  (This tutorial
        also works at the Windows command-line prompt, assuming you
        make some obvious tweaks.)  We also assume you are using
        Subversion 1.2 or later (run <userinput>svn --version</userinput>
        to check).</para>
    </note>

    <para>Subversion stores all versioned data in a central
      repository.  To begin, create a new repository:</para>

    <informalexample>
      <screen>
$ cd /var/svn
$ svnadmin create repos
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
$
</screen>
    </informalexample>

    <para>This command creates a Subversion repository in the directory
      <filename>/var/svn/repos</filename>, creating
      the <filename>repos</filename> directory itself if it doesn't
      already exist.  This directory contains (among other things) a
      collection of database files.  You won't see your versioned
      files if you peek inside.  For more information about repository
      creation and maintenance, see
      <xref linkend="svn.reposadmin"/>.</para>

    <para>Subversion has no concept of a <quote>project.</quote> The
      repository is just a virtual versioned filesystem, a large tree
      that can hold anything you wish.  Some administrators prefer to
      store only one project in a repository, and others prefer to
      store multiple projects in a repository by placing them into
      separate directories.  We discuss the merits of each approach
      in <xref linkend="svn.reposadmin.projects.chooselayout"/>.
      Either way, the repository manages only files and directories,
      so it's up to humans to interpret particular directories as
      <quote>projects.</quote>  So while you might see references to
      projects throughout this book, keep in mind that we're only ever
      talking about some directory (or collection of directories) in
      the repository.</para>

    <para>In this example, we assume you already have some sort
      of project (a collection of files and directories) that you wish
      to import into your newly created Subversion repository.  Begin
      by organizing your data into a single directory called
      <filename>myproject</filename> (or whatever you wish).  For
      reasons explained in <xref linkend="svn.branchmerge"/>, your
      project's tree structure should contain three top-level
      directories named <filename>branches</filename>,
      <filename>tags</filename>, and <filename>trunk</filename>.  The
      <filename>trunk</filename> directory should contain all of your
      data, and the <filename>branches</filename> and
      <filename>tags</filename> directories should be empty:</para>

    <informalexample>
      <literallayout>
/tmp/
   myproject/
      branches/
      tags/
      trunk/
         foo.c
         bar.c
         Makefile
          
</literallayout>
    </informalexample>

    <para>The <filename>branches</filename>, <filename>tags</filename>,
      and <filename>trunk</filename> subdirectories aren't actually
      required by Subversion.  They're merely a popular convention
      that you'll most likely want to use later on.</para>

    <para>Once you have your tree of data ready to go, import it into
      the repository with the <command>svn import</command> command
      (see <xref linkend="svn.tour.importing"/>):</para>

    <informalexample>
      <screen>
$ svn import /tmp/myproject file:///var/svn/repos/myproject \
      -m "initial import"
Adding         /tmp/myproject/branches
Adding         /tmp/myproject/tags
Adding         /tmp/myproject/trunk
Adding         /tmp/myproject/trunk/foo.c
Adding         /tmp/myproject/trunk/bar.c
Adding         /tmp/myproject/trunk/Makefile
 
Committed revision 1.
$ 
</screen>
    </informalexample>

    <para>Now the repository contains this tree of data.  As mentioned
      earlier, you won't see your files by directly peeking into the
      repository;  they're all stored within a database.  But the
      repository's imaginary filesystem now contains a top-level
      directory named <filename>myproject</filename>, which in turn
      contains your data.</para>

    <para>Note that the original <filename>/tmp/myproject</filename>
      directory is unchanged; Subversion is unaware of it.  (In fact,
      you can even delete that directory if you wish.)  To
      start manipulating repository data, you need to create a new
      <quote>working copy</quote> of the data, a sort of private
      workspace.  Ask Subversion to <quote>check out</quote> a working
      copy of the <filename>myproject/trunk</filename> directory in
      the repository:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos/myproject/trunk myproject
A    myproject/foo.c
A    myproject/bar.c
A    myproject/Makefile
 
Checked out revision 1.
$
</screen>
    </informalexample>

    <para>Now you have a personal copy of part of the repository in a
      new directory named <filename>myproject</filename>.  You can edit
      the files in your working copy and then commit those changes
      back into the repository.</para>

    <itemizedlist>
      <listitem>
        <para>Enter your working copy and edit a file's
          contents.</para>
      </listitem>
      <listitem>
        <para>Run <userinput>svn diff</userinput> to see unified diff
          output of your changes.</para>
      </listitem>
      <listitem>
        <para>Run <userinput>svn commit</userinput> to commit the new
          version of your file to the repository.</para>
      </listitem>
      <listitem>
        <para>Run <userinput>svn update</userinput> to bring your working
          copy <quote>up to date</quote> with the repository.</para>
      </listitem>
    </itemizedlist>

    <para>For a full tour of all the things you can do with your
      working copy, read <xref linkend="svn.tour"/>.</para>

    <para>At this point, you have the option of making your repository
      available to others over a network.  See <xref
      linkend="svn.serverconfig"/> to learn about the different sorts of
      server processes available and how to configure them.</para>

    <!-- ### TODO: Let's make this into a full tutorial, rather than
             simply referring off to other sections. ### -->

  </sect1>


</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
<!-- -*- sgml -*- -->

<appendix id="svn.forcvs">
  <title>Subversion for CVS Users</title>

  <para>This appendix is a guide for CVS users new to Subversion.
    It's essentially a list of differences between the two systems
    as <quote>viewed from 10,000 feet.</quote>  For each section, we
    provide references to relevant chapters when
    possible.</para>

  <para>Although the goal of Subversion is to take over the current
    and future CVS user base, some new features and design changes
    were required to fix certain <quote>broken</quote> behaviors
    that CVS had.  This means that, as a CVS user, you may need to
    break habits ones that you forgot were odd to begin
    with.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.revnums">
    <title>Revision Numbers Are Different Now</title>

    <para>In CVS, revision numbers are per file.  This is because CVS
      stores its data in RCS files; each file has a corresponding RCS
      file in the repository, and the repository is roughly laid out
      according to the structure of your project tree.</para>

    <para>In Subversion, the repository looks like a single
      filesystem.  Each commit results in an entirely new filesystem
      tree; in essence, the repository is an array of trees.  Each of
      these trees is labeled with a single revision number.  When
      someone talks about <quote>revision 54</quote>, he's talking
      about a particular tree (and indirectly, the way the filesystem
      looked after the 54th commit).</para>

    <para>Technically, it's not valid to talk about <quote>revision 5
      of <filename>foo.c</filename>.</quote>  Instead, one would say
      <quote><filename>foo.c</filename> as it appears in revision
      5.</quote>  Also, be careful when making assumptions about the
      evolution of a file.  In CVS, revisions 5 and 6 of
      <filename>foo.c</filename> are always different.  In Subversion,
      it's most likely that <filename>foo.c</filename> did
      <emphasis>not</emphasis> change between revisions 5 and
      6.</para>

    <para>Similarly, in CVS, a tag or branch is an annotation on the
      file or on the version information for that individual file,
      whereas in Subversion, a tag or branch is a copy of an entire
      tree (by convention, into the <filename>/branches</filename>
      or <filename>/tags</filename> directories that appear at the top
      level of the repository, beside <filename>/trunk</filename>).  In
      the repository as a whole, many versions of each file may be
      visible: the latest version on each branch, every tagged
      version, and of course the latest version on the trunk
      itself.  So, to refine the terms even further, one would often
      say <quote><filename>foo.c</filename> as it appears in
      <filename>/branches/REL1</filename> in revision
      5.</quote></para>

    <para>For more details on this topic, see <xref
      linkend="svn.basic.in-action.revs" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.directories">
    <title>Directory Versions</title>
    
    <para>Subversion tracks tree structures, not just file contents.
      It's one of the biggest reasons Subversion was written to
      replace CVS.</para>

    <para>Here's what this means to you, as a former CVS user:</para>

    <itemizedlist>
      <listitem>
        <para>The <command>svn add</command> and <command>svn
          delete</command> commands work on directories now, just as
          they work on files.  So do <command>svn copy</command> and
          <command>svn move</command>.  However, these commands do
          <emphasis>not</emphasis> cause any kind of immediate change
          in the repository.  Instead, the working items are simply
          <quote>scheduled</quote> for addition or deletion.  No
          repository changes happen until you run <userinput>svn
          commit</userinput>.</para>
      </listitem>
      <listitem>
        <para>Directories aren't dumb containers anymore; they have
          revision numbers like files.  (Or more properly, it's
          correct to talk about <quote>directory
          <filename>foo/</filename> in revision 5.</quote>)</para>
      </listitem>
    </itemizedlist>

    <para>Let's talk more about that last point.  Directory versioning
      is a hard problem; because we want to allow mixed-revision
      working copies, there are some limitations on how far we can
      abuse this model.</para>

    <para>From a theoretical point of view, we define <quote>revision
      5 of directory <filename>foo</filename></quote> to mean a
      specific collection of directory entries and properties.  Now
      suppose we start adding and removing files from
      <filename>foo</filename>, and then commit.  It would be a lie
      to say that we still have revision 5 of
      <filename>foo</filename>.  However, if we bumped
      <filename>foo</filename>'s revision number after the commit,
      that would be a lie too; there may be other changes to
      <filename>foo</filename> we haven't yet received, because we
      haven't updated yet.</para>
    
    <para>Subversion deals with this problem by quietly tracking
      committed adds and deletes in the <filename>.svn</filename>
      area.  When you eventually run <userinput>svn update</userinput>,
      all accounts are settled with the repository, and the
      directory's new revision number is set correctly.
      <emphasis>Therefore, only after an update is it truly safe to
      say that you have a <quote>perfect</quote> revision of a
      directory.</emphasis> Most of the time, your working copy will
      contain <quote>imperfect</quote> directory revisions.</para>
    
    <para>Similarly, a problem arises if you attempt to commit
      property changes on a directory.  Normally, the commit would
      bump the working directory's local revision number.  But again,
      that would be a lie, as there may be adds or deletes that
      the directory doesn't yet have, because no update has happened.
      <emphasis>Therefore, you are not allowed to commit
      property changes on a directory unless the directory is
      up to date.</emphasis></para>

    <para>For more discussion about the limitations of directory
      versioning, see <xref linkend="svn.basic.in-action.mixedrevs"/>.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.disconnected">
    <title>More Disconnected Operations</title>

    <para>In recent years, disk space has become outrageously cheap
      and abundant, but network bandwidth has not.  Therefore, the
      Subversion working copy has been optimized around the scarcer
      resource.</para>

    <para>The <filename>.svn</filename> administrative directory
      serves the same purpose as the <filename>CVS</filename>
      directory, except that it also stores read-only,
      <quote>pristine</quote> copies of your files.  This allows you
      to do many things offline:</para>
    
    <variablelist>
      
      <varlistentry>
        <term><command>svn status</command></term>
        <listitem>
          <para>Shows you any local changes you've made (see <xref
            linkend="svn.tour.cycle.examine.status"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn diff</command></term>
        <listitem>
          <para>Shows you the details of your changes (see <xref
            linkend="svn.tour.cycle.examine.diff"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn revert</command></term>
        <listitem>
          <para>Removes your local changes (see <xref
            linkend="svn.tour.cycle.revert"/>)</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>Also, the cached pristine files allow the Subversion client
      to send differences when committing, which CVS cannot do.</para>

    <para>The last subcommand in the list <command>svn
      revert</command> is new.  It will not only remove local
      changes, but also unschedule operations such as adds and
      deletes.  Although deleting the file and then running <userinput>svn
      update</userinput> will still work, doing so distorts the true
      purpose of updating.  And, while we're on this subject </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.status-vs-update">
    <title>Distinction Between Status and Update</title>

    <para>Subversion attempts to erase a lot of the confusion
      between the <command>cvs status</command> and
      <command>cvs update</command> commands.</para>

    <para>The <command>cvs status</command> command has two purposes:
      first, to show the user any local modifications in the working
      copy, and second, to show the user which files are out of date.
      Unfortunately, because of CVS's hard-to-read status output, many
      CVS users don't take advantage of this command at all.  Instead,
      they've developed a habit of running <userinput>cvs
      update</userinput> or <userinput>cvs -n update</userinput> to quickly
      see their changes.  If users forget to use
      the <option>-n</option> option, this has the side effect of
      merging repository changes they may not be ready to deal
      with.</para>

    <para>Subversion removes this muddle by making the output of
      <command>svn status</command> easy to read for both humans and
      parsers.  Also, <command>svn update</command> prints only
      information about files that are updated,
      <emphasis>not</emphasis> local modifications.</para>

    <sect2 id="svn.forcvs.status-vs-update.status">
      <title>Status</title>

      <para><command>svn status</command> prints all files that have
        local modifications.  By default, the repository is not
        contacted.  While this subcommand accepts a fair number of
        options, the following are the most commonly used ones:</para>

      <variablelist>
        <varlistentry>
          <term><option>-u</option></term>
          <listitem>
            <para>Contact the repository to determine, and then display,
              out-of-dateness information.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-v</option></term>
          <listitem>
            <para>Show <emphasis>all</emphasis> entries under
              version control.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-N</option></term>
          <listitem>
            <para>Run nonrecursively (do not descend into
              subdirectories).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The <command>svn status</command> command has two output
        formats.  In the default <quote>short</quote> format, local
        modifications look like this:</para>

      <informalexample>
        <screen>
$ svn status
M       foo.c
M       bar/baz.c
</screen>
      </informalexample>

      <para>If you specify the <option>--show-updates</option>
        (<option>-u</option>) option, a longer output format is
        used:</para>

      <informalexample>
        <screen>
$ svn status -u
M             1047   foo.c
        *     1045   faces.html
        *            bloo.png
M             1050   bar/baz.c
Status against revision:   1066
</screen>
      </informalexample>

      <para>In this case, two new columns appear.  The second column
        contains an asterisk if the file or directory is out of date.
        The third column shows the working copy's revision number of the
        item.  In the previous example, the asterisk indicates that
        <filename>faces.html</filename> would be patched if we updated,
        and that <filename>bloo.png</filename> is a newly added file in
        the repository.  (The absence of any revision number next to
        <filename>bloo.png</filename> means that it doesn't yet exist in
        the working copy.)</para>

      <para>For a more detailed discussion of <command>svn
        status</command>, including an explanation of the status codes
        shown in the previous example, see
        <xref linkend="svn.tour.cycle.examine.status" />.</para>

    </sect2>

    <sect2 id="svn.forcvs.status-vs-update.update">
      <title>Update</title>

      <para><command>svn update</command> updates your working copy,
        and prints only information about files that it updates.</para>

      <para>Subversion has combined CVS's <literal>P</literal> and
        <literal>U</literal> codes into just <literal>U</literal>.  When
        a merge or conflict occurs, Subversion simply prints
        <literal>G</literal> or <literal>C</literal>, rather than a
        whole sentence about it.</para>

      <para>For a more detailed discussion of <command>svn
        update</command>, see <xref linkend="svn.tour.cycle.update" />.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.branches-and-tags">
    <title>Branches and Tags</title>

    <para>Subversion doesn't distinguish between filesystem space and
      <quote>branch</quote> space; branches and tags are ordinary
      directories within the filesystem.  This is probably the single
      biggest mental hurdle that a CVS user will need to cross.  Read
      all about it in <xref linkend="svn.branchmerge"/>.</para>

    <warning>

      <para>Since Subversion treats branches and tags as ordinary
        directories, your project's various lines of development
        probably live in subdirectories of the main project directory.
        So remember to check out using the URL of the subdirectory
        that contains the particular line of development you want, not
        the project's root URL.  If you make the mistake of checking
        out the root of the project, you may very well wind up with a
        working copy that contains a complete copy of your project's
        content for each and every one of its branches and tags.
        <footnote><para>That is, providing you don't run out of disk
        space before your checkout finishes.</para></footnote></para>
    </warning>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.properties">
    <title>Metadata Properties</title>

    <para>A new feature of Subversion is that you can attach arbitrary
      metadata (or <quote>properties</quote>) to files and
      directories.  Properties are arbitrary name/value pairs
      associated with files and directories in your working
      copy.</para>
    
    <para>To set or get a property name, use the <command>svn
      propset</command> and <command>svn propget</command>
      subcommands.  To list all properties on an object, use
      <command>svn proplist</command>.</para>

    <para>For more information, see <xref linkend="svn.advanced.props"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.conflicts">
    <title>Conflict Resolution</title>

    <para>CVS marks conflicts with inline <quote>conflict
      markers,</quote> and then prints a <literal>C</literal> during
      an update or merge operation.  Historically, this has caused
      problems, because CVS isn't doing enough.  Many users forget
      about (or don't see) the <literal>C</literal> after it whizzes
      by on their terminal.  They often forget that the conflict
      markers are even present, and then accidentally commit files
      containing those conflict markers.</para>

    <para>Subversion solves this problem in a pair of ways.  First,
      when a conflict occurs in a file, Subversion records the fact
      that the file is in a state of conflict, and won't allow you to
      commit changes to that file until you explicitly resolve the
      conflict.  Second, Subversion provides interactive conflict
      resolution, which allows you to resolve conflicts as they happen
      instead of having to go back and do so after the update or merge
      operation completes.  See <xref linkend="svn.tour.cycle.resolve"
      /> for more about conflict resolution in Subversion.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.binary-and-trans">
    <title>Binary Files and Translation</title>

    <para>In the most general sense, Subversion handles binary files
      more gracefully than CVS does.  Because CVS uses RCS, it can
      only store successive full copies of a changing binary file.
      Subversion, however, expresses differences between files using a
      binary differencing algorithm, regardless of whether they
      contain textual or binary data.  That means all files are
      stored differentially (compressed) in the repository.</para>
    
    <para>CVS users have to mark binary files with
      <option>-kb</option> flags to prevent data from being
      garbled (due to keyword expansion and line-ending translations).
      They sometimes forget to do this.</para>

    <para>Subversion takes the more paranoid route.  First, it never
      performs any kind of keyword or line-ending translation unless
      you explicitly ask it to do so (see
      <xref linkend="svn.advanced.props.special.keywords"/> and
      <xref linkend="svn.advanced.props.special.eol-style"/> for more
      details).  By default, Subversion treats all file data as
      literal byte strings, and files are always stored in the
      repository in an untranslated state.</para>

    <para>Second, Subversion maintains an internal notion of whether a
      file is <quote>text</quote> or <quote>binary</quote> data, but
      this notion is <emphasis>only</emphasis> extant in the working
      copy.  During an <command>svn update</command>, Subversion will
      perform contextual merges on locally modified text files, but
      will not attempt to do so for binary files.</para>

    <para>To determine whether a contextual merge is possible,
      Subversion examines the <literal>svn:mime-type</literal>
      property.  If the file has no <literal>svn:mime-type</literal>
      property, or has a MIME type that is textual (e.g.,
      <literal>text/*</literal>),
      Subversion assumes it is text.  Otherwise, Subversion assumes
      the file is binary.  Subversion also helps users by running a
      binary-detection algorithm in the <command>svn import</command>
      and <command>svn add</command> commands.  These commands will
      make a good guess and then (possibly) set a binary
      <literal>svn:mime-type</literal> property on the file being
      added.  (If Subversion guesses wrong, the user can always remove
      or hand-edit the property.)</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.modules">

    <title>Versioned Modules</title>

    <para>Unlike CVS, a Subversion working copy is aware that it has
      checked out a module.  That means if somebody changes the
      definition of a module (e.g., adds or removes components), a
      call to <command>svn update</command> will update the working
      copy appropriately, adding and removing components.</para>

    <para>Subversion defines modules as a list of directories within a
      directory property; see <xref linkend="svn.advanced.externals"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.auth">

    <title>Authentication</title>

    <para>With CVS's pserver, you are required to log in to the server
      (using the <command>cvs login</command> command) before
      performing any read or write operation you sometimes even
      have to log in for anonymous operations.  With a Subversion
      repository using Apache <command>httpd</command> or
      <command>svnserve</command> as the server, you don't provide any
      authentication credentials at the outset if an operation
      that you perform requires authentication, the server will
      challenge you for your credentials (whether those credentials
      are username and password, a client certificate, or even both).
      So if your repository is world-readable, you will not be
      required to authenticate at all for read operations.</para>

    <para>As with CVS, Subversion still caches your credentials on
      disk (in your <filename>~/.subversion/auth/</filename>
      directory) unless you tell it not to by using the
      <option>--no-auth-cache</option> option.</para>

    <para>The exception to this behavior, however, is in the case of
      accessing an <command>svnserve</command> server over an SSH
      tunnel, using the <literal>svn+ssh://</literal> URL scheme.  In
      that case, the <command>ssh</command> program unconditionally
      demands authentication just to start the tunnel.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.forcvs.convert">

    <title>Converting a Repository from CVS to Subversion</title>

    <para>Perhaps the most important way to familiarize CVS users with
      Subversion is to let them continue to work on their projects
      using the new system.  And while that can be somewhat
      accomplished using a flat import into a Subversion repository of
      an exported CVS repository, the more thorough solution involves
      transferring not just the latest snapshot of their data, but all
      the history behind it as well, from one system to another.  This
      is an extremely difficult problem to solve; it involves
      deducing changesets in the absence of atomicity and translating
      between the systems' completely orthogonal branching policies,
      among other complications.  Still, a handful of tools claim
      to at least partially support the ability to convert
      existing CVS repositories into Subversion ones.</para>

    <para>The most popular (and mature) conversion tool is
      cvs2svn (<ulink url="http://cvs2svn.tigris.org/"/>), a Python
      program originally created by members of Subversion's own
      development community.  This tool is meant to run exactly once:
      it scans your CVS repository multiple times and attempts to
      deduce commits, branches, and tags as best it can.  When it
      finishes, the result is either a Subversion repository or a
      portable Subversion dump file representing your code's history.
      See the web site for detailed instructions and caveats.</para>

  </sect1>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
<!-- -*- sgml -*- -->

<appendix id="svn.webdav">
  <title>WebDAV and Autoversioning</title>

  <para>WebDAV is an extension to HTTP, and it is growing more
    and more popular as a standard for file sharing.  Today's
    operating systems are becoming extremely web-aware, and many now
    have built-in support for mounting <quote>shares</quote> exported
    by WebDAV servers.</para>

  <para>If you use Apache as your Subversion network server, to
    some extent you are also running a WebDAV server.  This appendix
    gives some background on the nature of this protocol, how
    Subversion uses it, and how well Subversion interoperates with
    other software that is WebDAV-aware.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.webdav.basic">
    <title>What Is WebDAV?</title>

    <para>
      <indexterm>
        <primary>WebDAV</primary>
      </indexterm><firstterm>DAV</firstterm> stands
      for <quote>Distributed Authoring and Versioning.</quote> RFC
      2518 defines a set of concepts and accompanying extension
      methods to HTTP 1.1 that make the Web a more universal
      read/write medium.  The basic idea is that a WebDAV-compliant
      web server can act like a generic file server; clients
      can <quote>mount</quote> shared folders over HTTP that behave
      much like other network filesystems (such as NFS or SMB).</para>

    <para>The tragedy, though, is that despite the acronym, the RFC
      specification doesn't actually describe any sort of version
      control.  Basic WebDAV clients and servers assume that only one
      version of each file or directory exists, and that it can be
      repeatedly overwritten.</para>

    <para>Because RFC 2518 left out versioning concepts, another
      committee was left with the responsibility of writing RFC 3253 a
      few years later.  The new RFC adds versioning concepts to
      WebDAV, placing the <quote>V</quote> back in
      <quote>DAV</quote> hence the term <quote>DeltaV.</quote>
      WebDAV/DeltaV clients and servers are often called just
      <quote>DeltaV</quote> programs, since DeltaV implies the
      existence of basic WebDAV.</para>

    <para>The original WebDAV standard has been widely successful.
      Every modern computer operating system has a general WebDAV
      client built in (details to follow), and a number of popular
      standalone applications are also able to speak
      WebDAV Microsoft Office, Dreamweaver, and Photoshop, to
      name a few.  On the server end, Apache HTTP Server has been
      able to provide WebDAV services since 1998 and is considered the
      de facto open source standard.  Several other
      commercial WebDAV servers are available, including Microsoft's own
      IIS.</para>

    <para>DeltaV, unfortunately, has not been so successful.  It's
      very difficult to find any DeltaV clients or servers.  The few
      that do exist are relatively unknown commercial products, and
      thus it's very difficult to test interoperability.  It's not
      entirely clear as to why DeltaV has remained stagnant.  Some
      opine that the specification is just too complex.  Others argue
      that while WebDAV's features have mass appeal (even the least
      technical users appreciate network file sharing), its version
      control features just aren't interesting or necessary for most
      users.  Finally, some believe that DeltaV remains unpopular
      because there's still no open source server product that
      implements it well.</para>

    <para>When Subversion was still in its design phase, it seemed
      like a great idea to use Apache as a network server.  It already
      had a module to provide WebDAV services.  DeltaV was a
      relatively new specification.  The hope was that the Subversion
      server module (<command>mod_dav_svn</command>) would eventually
      evolve into an open source DeltaV reference implementation.
      Unfortunately, DeltaV has a very specific versioning model that
      doesn't quite line up with Subversion's model.  Some concepts
      were mappable; others were not.</para>

    <para>What does this mean, then?</para>

    <para>First, the Subversion client is not a fully implemented
      DeltaV client.  It needs certain types of things from the server
      that DeltaV itself cannot provide, and thus is largely dependent
      on a number of Subversion-specific
      HTTP <literal>REPORT</literal> requests that
      only <command>mod_dav_svn</command> understands.</para>

    <para>Second, <command>mod_dav_svn</command> is not a
      fully realized DeltaV server.  Many portions of the DeltaV
      specification were irrelevant to Subversion, and thus were left
      unimplemented.</para>

    <para>A long-held debate in the Subversion developer community
      about whether it was worthfile to remedy either of these
      situations eventually reached closure, with the Subversion
      developers officially deciding to abandon plans to fully support
      DeltaV.  As of Subversion 1.7, Subversion clients and servers
      introduce numerous non-standard simplifications of the DeltaV
      standards<footnote><para>The Subversion developers colloquially
      refer to this deviation from the DeltaV standard
      as <quote>HTTPv2</quote>.</para></footnote>, with more
      customizations of this sort likely to come.  Those versions of
      Subversion will, of course, continue to provide the same DeltaV
      feature support already present in older releases, but no new
      work will be done to increase coverage of the
      specification Subversion is intentionally moving away from
      strict DeltaV as its primary HTTP-based protocol.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.webdav.autoversioning">
    <title>Autoversioning</title>

    <para>
      <indexterm>
        <primary>WebDAV</primary>
        <secondary>autoversioning</secondary>
      </indexterm>While the Subversion client is not a full DeltaV client, and
      the Subversion server is not a full DeltaV server, there's still a
      glimmer of WebDAV interoperability to be happy about:
      <firstterm>autoversioning</firstterm>.</para>

    <para>Autoversioning is an optional feature defined in the DeltaV
      standard.  A typical DeltaV server will reject an ignorant
      WebDAV client attempting to do a <literal>PUT</literal> to a
      file that's under version control.  To change a
      version-controlled file, the server expects a series of proper
      versioning requests: something like
      <literal>MKACTIVITY</literal>, <literal>CHECKOUT</literal>,
      <literal>PUT</literal>, <literal>CHECKIN</literal>.  But if the
      DeltaV server supports autoversioning, write requests from
      basic WebDAV clients are accepted.  The server behaves as though the
      client <emphasis>had</emphasis> issued the proper series of
      versioning requests, performing a commit under the hood.  In
      other words, it allows a DeltaV server to interoperate with
      ordinary WebDAV clients that don't understand versioning.</para>

    <para>Because so many operating systems already have integrated
      WebDAV clients, the use case for this feature can be incredibly
      appealing to administrators working with non-technical users.
      Imagine an office of ordinary users running Microsoft Windows or
      Mac OS.  Each user <quote>mounts</quote> the Subversion
      repository, which appears to be an ordinary network folder.
      They use the shared folder as they always do:  open files, edit
      them, and save them.  Meanwhile, the server is automatically
      versioning everything.  Any administrator (or knowledgeable
      user) can still use a Subversion client to search history and
      retrieve older versions of data.</para>

    <para>This scenario isn't fiction it's real and it works.
      To activate autoversioning in <command>mod_dav_svn</command>,
      use the <literal>SVNAutoversioning</literal> directive within
      the <filename>httpd.conf</filename> <literal>Location</literal>
      block, like so:</para>

    <informalexample>
      <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
  SVNAutoversioning on
&lt;/Location&gt;
</programlisting>
    </informalexample>

    <para>When Subversion autoversioning is active, write requests
      from WebDAV clients result in automatic commits.  A generic log
      message is automatically generated and attached to each
      revision.</para>

    <para>Before activating this feature, however, understand what
      you're getting into.  WebDAV clients tend to do
      <emphasis>many</emphasis> write requests, resulting in a huge
      number of automatically committed revisions.  For example, when
      saving data, many clients will do a <literal>PUT</literal> of a
      0-byte file (as a way of reserving a name) followed by another
      <literal>PUT</literal> with the real file data.  The single
      file-write results in two separate commits.  Also consider that
      many applications auto-save every few minutes, resulting in even
      more commits.</para>

    <para>If you have a post-commit hook program that sends email, you
      may want to disable email generation either altogether or on
      certain sections of the repository; it depends on whether you
      think the influx of emails will still prove to be valuable
      notifications or not.  Also, a smart post-commit hook program
      can distinguish between a transaction created via autoversioning
      and one created through a normal Subversion commit operation.
      The trick is to look for a revision property
      named <literal>svn:autoversioned</literal>.  If present, the
      commit was made by a generic WebDAV client.</para>

    <para>Another feature that may be a useful complement for
      Subversion's autoversioning comes from Apache's
      <literal>mod_mime</literal> module.  If a WebDAV client adds a
      new file to the repository, there's no opportunity for the user
      to set the the <literal>svn:mime-type</literal> property.  This
      might cause the file to appear as a generic icon when viewed
      within a WebDAV shared folder, not having an association with
      any application.  One remedy is to have a sysadmin (or other
      Subversion-knowledgeable person) check out a working copy and
      manually set the <literal>svn:mime-type</literal> property on
      necessary files.  But there's potentially no end to such cleanup
      tasks.  Instead, you can use the
      <literal>ModMimeUsePathInfo</literal> directive in your
      Subversion <literal>&lt;Location&gt;</literal> block:</para>

    <informalexample>
      <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
  SVNAutoversioning on

  ModMimeUsePathInfo on

&lt;/Location&gt;
</programlisting>
    </informalexample>

    <para>This directive allows <literal>mod_mime</literal> to attempt
      automatic deduction of the MIME type on new files that enter the
      repository via autoversioning.  The module looks at the file's
      named extension and possibly the contents as well; if the file
      matches some common patterns, the
      file's <literal>svn:mime-type</literal> property will be set
      automatically.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.webdav.clients">
    <title>Client Interoperability</title>

    <para>
      <indexterm>
        <primary>WebDAV</primary>
        <secondary>client support</secondary>
      </indexterm>All WebDAV clients fall into one of three
      categories standalone applications, file-explorer
      extensions, or filesystem implementations.  These categories
      broadly define the types of WebDAV functionality available to
      users.  <xref linkend="svn.webdav.clients.tbl-1"/> gives our
      categorization as well as a quick description of some common pieces of
      WebDAV-enabled software.  You can find more details about these software
      offerings, as well as their general category, in
      the sections that follow.</para>

    <table id="svn.webdav.clients.tbl-1">
      <title>Common WebDAV clients</title>
      <tgroup cols="6">
        <thead>
          <row>
            <entry>Software</entry>
            <entry>Type</entry>
            <entry>Windows</entry>
            <entry>Mac</entry>
            <entry>Linux</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Adobe Photoshop</entry>
            <entry>Standalone WebDAV application</entry>
            <entry>X</entry>
            <entry></entry>
            <entry></entry>
            <entry>Image editing software, allowing direct opening
              from, and writing to, WebDAV URLs</entry>
          </row>
          <row>
            <entry>cadaver</entry>
            <entry>Standalone WebDAV application</entry>
            <entry></entry>
            <entry>X</entry>
            <entry>X</entry>
            <entry>Command-line WebDAV client supporting file
              transfer, tree, and locking operations</entry>
          </row>
          <row>
            <entry>DAV Explorer</entry>
            <entry>Standalone WebDAV application</entry>
            <entry>X</entry>
            <entry>X</entry>
            <entry>X</entry>
            <entry>Java GUI tool for exploring WebDAV shares</entry>
          </row>
          <row>
            <entry>Adobe Dreamweaver</entry>
            <entry>Standalone WebDAV application</entry>
            <entry>X</entry>
            <entry></entry>
            <entry></entry>
            <entry>Web production software able to directly read from
              and write to WebDAV URLs</entry>
          </row>
          <row>
            <entry>Microsoft Office</entry>
            <entry>Standalone WebDAV application</entry>
            <entry>X</entry>
            <entry></entry>
            <entry></entry>
            <entry>Office productivity suite with several components
              able to directly read from and write to WebDAV
              URLs</entry>
          </row>
          <row>
            <entry>Microsoft Web Folders</entry>
            <entry>File-explorer WebDAV extension</entry>
            <entry>X</entry>
            <entry></entry>
            <entry></entry>
            <entry>GUI file explorer program able to perform tree
              operations on a WebDAV share</entry>
          </row>
          <row>
            <entry>GNOME Nautilus</entry>
            <entry>File-explorer WebDAV extension</entry>
            <entry></entry>
            <entry></entry>
            <entry>X</entry>
            <entry>GUI file explorer able to perform tree
              operations on a WebDAV share</entry>
          </row>
          <row>
            <entry>KDE Konqueror</entry>
            <entry>File-explorer WebDAV extension</entry>
            <entry></entry>
            <entry></entry>
            <entry>X</entry>
            <entry>GUI file explorer able to perform tree
              operations on a WebDAV share</entry>
          </row>
          <row>
            <entry>Mac OS X</entry>
            <entry>WebDAV filesystem implementation</entry>
            <entry></entry>
            <entry>X</entry>
            <entry></entry>
            <entry>Operating system that has built-in support for mounting
              WebDAV shares.</entry>
          </row>
          <row>
            <entry>Novell NetDrive</entry>
            <entry>WebDAV filesystem implementation</entry>
            <entry>X</entry>
            <entry></entry>
            <entry></entry>
            <entry>Drive-mapping program for assigning Windows drive
              letters to a mounted remote WebDAV share</entry>
          </row>
          <row>
            <entry>SRT WebDrive</entry>
            <entry>WebDAV filesystem implementation</entry>
            <entry>X</entry>
            <entry></entry>
            <entry></entry>
            <entry>File transfer software, which, among other things,
              allows the assignment of Windows drive letters to a
              mounted remote WebDAV share</entry>
          </row>
          <row>
            <entry>davfs2</entry>
            <entry>WebDAV filesystem implementation</entry>
            <entry></entry>
            <entry></entry>
            <entry>X</entry>
            <entry>Linux filesystem driver that allows you to mount a
              WebDAV share</entry>
          </row>

        </tbody>
      </tgroup>
    </table>

    <!-- =============================================================== -->
    <sect2 id="svn.webdav.clients.standalone">
      <title>Standalone WebDAV Applications</title>

      <para>A WebDAV application is a program that speaks WebDAV
        protocols with a WebDAV server.  We'll cover some of the most
        popular programs with this kind of WebDAV support.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.standalone.windows">
        <title>Microsoft Office, Dreamweaver, Photoshop</title> 

        <para>On Windows, several well-known applications contain
          integrated WebDAV client functionality, such as Microsoft's
          Office,<footnote><para>WebDAV support was removed from
          Microsoft Access for some reason, but it exists in the rest
          of the Office suite.</para></footnote> Adobe's Photoshop and
          Dreamweaver programs.  They're able to directly open and
          save to URLs, and tend to make heavy use of WebDAV locks
          when editing a file.</para>

        <para>Note that while many of these programs also exist for
          Mac OS X, they do not appear to support WebDAV directly
          on that platform.  In fact, on Mac OS X, the
          <guimenu>File Open</guimenu> dialog box doesn't allow
          one to type a path or URL at all.  It's likely that the
          WebDAV features were deliberately left out of Macintosh
          versions of these programs, since OS X already provides such
          excellent low-level filesystem support for WebDAV.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.standalone.free">
        <title>cadaver, DAV Explorer</title>

        <para>cadaver is a bare-bones Unix command-line program for
          browsing and changing WebDAV shares.  It uses the neon HTTP
          library not surprisingly, since both neon and cadaver
          are written by the same author.  cadaver is free software (GPL
          license) and is available at <ulink
          url="http://www.webdav.org/cadaver/"/>.</para>

        <para>Using cadaver is similar to using a command-line FTP
          program, and thus it's extremely useful for basic WebDAV
          debugging.  It can be used to upload or download files in a
          pinch, to examine properties, and to copy, move,
          lock, or unlock files:</para>

        <informalexample>
          <screen>
$ cadaver http://host/repos
dav:/repos/&gt; ls
Listing collection `/repos/': succeeded.
Coll: &gt; foobar                                 0  May 10 16:19
      &gt; playwright.el                       2864  May  4 16:18
      &gt; proofbypoem.txt                     1461  May  5 15:09
      &gt; westcoast.jpg                      66737  May  5 15:09

dav:/repos/&gt; put README
Uploading README to `/repos/README':
Progress: [=============================&gt;] 100.0% of 357 bytes succeeded.

dav:/repos/&gt; get proofbypoem.txt
Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:
Progress: [=============================&gt;] 100.0% of 1461 bytes succeeded.
</screen>
        </informalexample>

        <para>DAV Explorer is another standalone WebDAV client, written
          in Java.  It's under a free Apache-like license and is
          available at <ulink url="http://www.ics.uci.edu/~webdav/"/>.
          It does everything cadaver does, but has the
          advantages of being portable and being a more user-friendly GUI
          application.  It's also one of the first clients to support
          the new WebDAV Access Control Protocol (RFC 3744).</para>

        <para>Of course, DAV Explorer's ACL support is useless in this
          case, since <command>mod_dav_svn</command> doesn't support
          it.  The fact that both cadaver and DAV Explorer support
          some limited DeltaV commands isn't particularly useful
          either, since they don't allow <literal>MKACTIVITY</literal>
          requests.  But it's not relevant anyway; we're assuming all
          of these clients are operating against an autoversioning
          repository.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.webdav.clients.file-explorer-extensions">
      <title>File-Explorer WebDAV Extensions</title>

      <para>Some popular file explorer GUI programs support WebDAV
        extensions that allow a user to browse a DAV share as though it
        was just another directory on the local computer, and to
        perform basic tree editing operations on the items in that
        share.  For example, Windows Explorer is able to browse a
        WebDAV server as a <quote>network place.</quote>  Users can
        drag files to and from the desktop, or can rename, copy, or
        delete files in the usual way.  But because it's only a
        feature of the file explorer, the DAV share isn't visible to
        ordinary applications.  All DAV interaction must happen
        through the explorer interface.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.file-explorer-extensions.windows">
        <title>Microsoft Web Folders</title>

        <para>Microsoft was one of the original backers of the WebDAV
          specification, and first started shipping a client in
          Windows 98, which was known as Web Folders.  This client was
          also shipped in Windows NT 4.0 and Windows 2000.</para>

        <para>The original Web Folders client was an extension to
          Explorer, the main GUI program used to browse filesystems.  It
          works well enough.  In Windows 98, the feature might need to
          be explicitly installed if Web Folders aren't already visible
          inside My Computer.  In Windows 2000, simply
          add a new <quote>network place,</quote> enter the URL, and the
          WebDAV share will pop up for browsing.</para>

        <para>With the release of Windows XP, Microsoft started shipping
          a new implementation of Web Folders, known as the WebDAV
          Mini-Redirector.  The new implementation is a
          filesystem-level client, allowing WebDAV shares to be mounted
          as drive letters.  Unfortunately, this implementation is
          incredibly buggy.  The client usually tries to convert HTTP
          URLs (<literal>http://host/repos</literal>) into UNC share
          notation (<literal>\\host\repos</literal>); it also often
          tries to use Windows Domain authentication to respond to
          basic-auth HTTP challenges, sending usernames as
          <literal>HOST\username</literal>.  These interoperability
          problems are severe and are documented in numerous places around
          the Web, to the frustration of many users.  Even Greg Stein,
          the original author of Apache's WebDAV module, bluntly
          states that XP Web Folders simply can't operate against an Apache
          server.</para>

        <para>Windows Vista's initial implementation of Web Folders seems to
          be almost the same as XP's, so it has the same sort of
          problems.  With luck, Microsoft will remedy these issues in
          a Vista Service Pack.</para>

        <para>However, there seem to be workarounds for both XP and
          Vista that allow Web Folders to work against Apache.  Users
          have mostly reported success with these techniques, so we'll
          relay them here.</para>

        <para>On Windows XP, you have two options.  First, search
          Microsoft's web site for update KB907306, <quote>Software
          Update for Web Folders.</quote>  This may fix all your
          problems.  If it doesn't, it seems that the original pre-XP
          Web Folders implementation is still buried within the
          system.  You can unearth it by going to Network
          Places and adding a new network place.  When prompted,
          enter the URL of the repository, but <emphasis>include a
          port number</emphasis> in the URL.  For
          example, you should enter <userinput>http://host/repos</userinput> 
          as <userinput>http://host:80/repos</userinput> instead.
          Respond to any authentication prompts with your Subversion
          credentials.</para>

        <para>On Windows Vista, the same KB907306 update may clear
          everything up.  But there may still be other issues.  Some
          users have reported that Vista considers
          all <literal>http://</literal> connections insecure, and thus
          will always fail any authentication challenges from Apache
          unless the connection happens
          over <literal>https://</literal>.  If you're unable to connect
          to the Subversion repository via SSL, you can tweak the
          system registry to turn off this behavior.  Just change the
          value of the <literal>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters\BasicAuthLevel</literal>
          key from <userinput>1</userinput> to <userinput>2</userinput>.  A final warning:  be sure to set up the Web
          Folder to point to the repository's root directory
          (<filename>/</filename>), rather than some subdirectory
          such as <filename>/trunk</filename>.  Vista Web Folders
          seems to work only against repository roots.</para>

        <para>In general, while these workarounds may function for
          you, you might get a better overall experience using a
          third-party WebDAV client such as WebDrive or NetDrive.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.file-explorer-extensions.linux-de">
        <title>Nautilus, Konqueror</title>

        <para>Nautilus is the official file manager/browser for the
          GNOME desktop (<ulink url="http://www.gnome.org"/>), and
          Konqueror is the manager/browser for the KDE desktop (<ulink
          url="http://www.kde.org"/>).  Both of these applications
          have an explorer-level WebDAV client built in, and they
          operate just fine against an autoversioning repository.</para>

        <para>In GNOME's Nautilus, select the <guimenuitem>File Open
          location</guimenuitem> menu item and enter the URL in the
          dialog box presented.  The repository should then be
          displayed like any other filesystem.</para>

        <para>In KDE's Konqueror, you need to use the
          <literal>webdav://</literal> scheme when entering the URL in
          the location bar.  If you enter
          an <literal>http://</literal> URL, Konqueror will behave
          like an ordinary web browser.  You'll likely see the generic
          HTML directory listing produced
          by <command>mod_dav_svn</command>.  When you enter
          <userinput>webdav://host/repos</userinput> instead of
          <userinput>http://host/repos</userinput>, Konqueror becomes a
          WebDAV client and displays the repository as a
          filesystem.</para>

      </sect3>
    </sect2>

    <sect2 id="svn.webdav.clients.fs-impl">
      <title>WebDAV Filesystem Implementation</title>

      <para>The WebDAV filesystem implementation is arguably the best
        sort of WebDAV client.  It's implemented as a low-level
        filesystem module, typically within the operating system's
        kernel.  This means that the DAV share is mounted like any
        other network filesystem, similar to mounting an NFS share on
        Unix or attaching an SMB share as a drive letter in Windows.
        As a result, this sort of client provides completely
        transparent read/write WebDAV access to all programs.
        Applications aren't even aware that WebDAV requests are
        happening.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.fs-impl.windows">
        <title>WebDrive, NetDrive</title>

        <para>Both WebDrive and NetDrive are excellent commercial
          products that allow a WebDAV share to be attached as drive
          letters in Windows.  As a result, you can operate on the
          contents of these WebDAV-backed pseudodrives as easily as
          you can against real local hard drives, and in the same
          ways.  You can purchase WebDrive from South River
          Technologies (<ulink url="http://www.southrivertech.com"/>).
          Novell's NetDrive is freely available online, but requires
          users to have a NetWare license.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.fs-impl.macosx">
        <title>Mac OS X</title>

        <para>Apple's OS X operating system has an integrated
          filesystem-level WebDAV client.  From the Finder, select the
          <guimenuitem>Go Connect to Server</guimenuitem> menu
          item.  Enter a WebDAV URL, and it appears as a disk on the
          desktop, just like any other mounted volume.  You can also
          mount a WebDAV share from the Darwin terminal by using the
          <literal>webdav</literal> filesystem type with the
          <command>mount</command> command:</para>

        <informalexample>
          <screen>
$ mount -t webdav http://svn.example.com/repos/project /some/mountpoint
$
</screen>
        </informalexample>

        <para>Note that if your <command>mod_dav_svn</command> is
          older than version 1.2, OS X will refuse to mount the share
          as read/write; it will appear as read-only.  This is because
          OS X insists on locking support for read/write shares, and
          the ability to lock files first appeared in Subversion
          1.2.</para>

        <para>Also, OS X's WebDAV client can sometimes be overly
          sensitive to HTTP redirects.  If OS X is unable to mount the
          repository at all, you may need to enable
          the <literal>BrowserMatch</literal> directive in the Apache
          server's <filename>httpd.conf</filename>:</para>

        <informalexample>
          <programlisting>
BrowserMatch "^WebDAVFS/1.[012]" redirect-carefully
</programlisting>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.webdav.clients.fs-impl.linux">
        <title>Linux davfs2</title>

        <para>Linux davfs2 is a filesystem module for the Linux
          kernel, whose development is organized at
          <ulink url="http://dav.sourceforge.net/"/>.  Once you
          install davfs2, you can mount a WebDAV network share using
          the usual Linux mount command:</para>

        <informalexample>
          <screen>
$ mount.davfs http://host/repos /mnt/dav
</screen>
        </informalexample>

      </sect3>
    </sect2>
  </sect1>

</appendix>

<!--
local variables:
sgml-parent-document: ("book.xml" "appendix")
end:
-->
<book id="svn">
  <title>Version Control with Subversion [DRAFT]</title>

  <bookinfo>

    <subtitle>For Subversion 1.8</subtitle>

    <!-- Using revnumber would be more appropriate, but our stylesheets -->
    <!-- don't seem to render it. -->
    <subtitle>(Compiled from )</subtitle>

    <!--
    <edition>Second</edition>
    <isbn>?-?????-???-?</isbn>
    -->

    <authorgroup>

      <author>
        <firstname>Ben</firstname>
        <surname>Collins-Sussman</surname>
      </author>

      <author>
        <firstname>Brian W.</firstname>
        <surname>Fitzpatrick</surname>
      </author>

      <author>
        <firstname>C. Michael</firstname>
        <surname>Pilato</surname>
      </author>

    </authorgroup>

    <editor>
      <firstname>Tatiana</firstname>
      <surname>Apandi</surname>
    </editor>

    <!--
    <pagenums>350 pages (est.)</pagenums>
    <pubdate>(TBA)</pubdate>
    -->

    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <year>2006</year>
      <year>2007</year>
      <year>2008</year>
      <year>2009</year>
      <year>2010</year>
      <year>2011</year>
      <year>2012</year>
      <year>2013</year>
      <holder>Ben Collins-Sussman</holder>
      <holder>Brian W. Fitzpatrick</holder>
      <holder>C. Michael Pilato</holder>
    </copyright>

    <legalnotice><para>This work is licensed under the Creative
      Commons Attribution License.  To view a copy of this license,
      visit <ulink url="http://creativecommons.org/licenses/by/2.0/"/>
      or send a letter to Creative Commons, 559 Nathan Abbott Way,
      Stanford, California 94305, USA.</para></legalnotice>

  </bookinfo>

  <!-- External entity refs -->


  <part id="svn.content">
    <title>Getting to Know Subversion</title>
  </part>

  <part id="svn.ref">
    <title>Subversion Command Reference</title>
  </part>

  <part id="svn.apps">
    <title>Appendices</title>
  </part>

</book>
<!-- -*- sgml -*- -->

<preface id="svn.preface">
  <title>Preface</title>

  <blockquote>
    <attribution>Greg Hudson, Subversion developer</attribution>
    <para><quote>It is important not to let the perfect become the
      enemy of the good, even when you can agree on what perfect is.
      Doubly so when you can't.  As unpleasant as it is to be trapped by
      past mistakes, you can't make any progress by being afraid of your
      own shadow during design.</quote></para>
  </blockquote>

  <para>
    <indexterm>
      <primary>Concurrent Versions System</primary>
    </indexterm>
    <indexterm>
      <primary>CVS</primary>
      <see>Concurrent Versions System</see>
    </indexterm>In the world of open source software, the Concurrent
    Versions System (CVS) was the tool of choice for version control
    for many years.  And rightly so.  CVS was open source software
    itself, and its nonrestrictive modus operandi and support for
    networked operation allowed dozens of geographically dispersed
    programmers to share their work.  It fit the collaborative nature
    of the open source world very well.  CVS and its semi-chaotic
    development model have since become cornerstones of open source
    culture.</para>

  <para>But CVS was not without its flaws, and simply fixing those
    flaws promised to be an enormous effort.  Enter Subversion.
    Subversion was designed to be a successor to CVS, and its
    originators set out to win the hearts of CVS users in two
    ways by creating an open source system with a design
    (and <quote>look and feel</quote>) similar to CVS, and by
    attempting to avoid most of CVS's noticeable flaws.  While the
    result wasn't and isn't the next great evolution in
    version control design, Subversion <emphasis>is</emphasis> very
    powerful, very usable, and very flexible.</para>

  <para>This book is written to document the 1.8 series of the
    Apache Subversion <footnote><para>We'll refer to it
    simply as <quote>Subversion</quote> throughout this book.  You'll
    thank us when you realize just how much space that
    saves!</para></footnote> version control system.  We have made
    every attempt to be thorough in our coverage.  However, Subversion
    has a thriving and energetic development community, so already a
    number of features and improvements are planned for future
    versions that may change some of the commands and specific notes
    in this book.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.intro.whatis">
    <title>What Is Subversion?</title>

    <para>
      <indexterm>
        <primary>Subversion</primary>
      </indexterm>
      <indexterm>
        <primary>version control systems</primary>
      </indexterm>
      <indexterm>
        <primary>VCS</primary>
        <see>version control systems</see>
      </indexterm>Subversion is a free/open source <firstterm>version
      control system</firstterm> (VCS).  That is, Subversion manages
      files and directories, and the changes made to them, over time.
      This allows you to recover older versions of your data or
      examine the history of how your data changed.  In this regard,
      many people think of a version control system as a sort
      of <quote>time machine.</quote></para>
    
    <para>Subversion can operate across networks, which allows it to
      be used by people on different computers.  At some level, the
      ability for various people to modify and manage the same set of
      data from their respective locations fosters collaboration.
      Progress can occur more quickly without a single conduit through
      which all modifications must occur.  And because the work is
      versioned, you need not fear that quality is the trade-off for
      losing that conduit if some incorrect change is made to
      the data, just undo that change.</para>

    <para>
      <indexterm>
        <primary>software configuration management</primary>
      </indexterm>
      <indexterm>
        <primary>SCM</primary>
        <see>software configuration management</see>
      </indexterm>Some version control systems are
      also <firstterm>software configuration management</firstterm>
      (SCM) systems.  These systems are specifically tailored to
      manage trees of source code and have many features that are
      specific to software development such as natively
      understanding programming languages, or supplying tools for
      building software.  Subversion, however, is not one of these
      systems.  It is a general system that can be used to manage
      <emphasis>any</emphasis> collection of files.  For you, those
      files might be source code for others, anything from
      grocery shopping lists to digital video mixdowns and
      beyond.</para>


    <!-- =============================================================== -->
    <sect2 id="svn.intro.righttool">
      <title>Is Subversion the Right Tool?</title>
  
      <para>If you're a user or system administrator pondering the use
        of Subversion, the first question you should ask yourself is:
        "Is this the right tool for the job?"  Subversion is a
        fantastic hammer, but be careful not to view every problem as
        a nail.</para>

      <para>As a first step, you need to decide if version control in
        general is required for your purposes.  If you need to archive
        old versions of files and directories, possibly resurrect
        them, and examine logs of how they've changed over time, then
        version control tools can do that.  If you need to collaborate
        with people on documents (usually over a network) and keep
        track of who made which changes, a version control tool can do
        that, too.  In fact, this is why version control tools such as
        Subversion are so often used in software development
        environments working on a development team is an
        inherently social activity where changes to source code files
        are constantly being discussed, made, evaluated, and even
        sometimes unmade.  Version control tools facilitate that sort
        of collaboration.</para>

      <para>There is cost associated with using version control, too.
        Unless you can outsource the administration of your version
        control system to a third-party, you'll have the obvious costs
        of performing that administration yourself.  When working with
        the data on a daily basis, you won't be able to copy, move,
        rename, or delete files the way you usually do.  Instead,
        you'll have to do all of those things through the version
        control system.</para>

      <para>Even assuming that you are okay with the cost/benefit
        tradeoff afforded by a version control system, you shouldn't
        choose to use one merely because it <emphasis>can</emphasis>
        do what you want.  Consider whether your needs are better
        addressed by other tools.  For example, because Subversion
        replicates data to all the collaborators involved, a common
        misuse is to treat it as a generic distribution system.
        People will sometimes use Subversion to distribute huge
        collections of photos, digital music, or software packages.
        The problem is that this sort of data usually isn't changing
        at all.  The collection itself grows over time, but the
        individual files within the collection aren't being changed.
        In this case, using Subversion is
        <quote>overkill.</quote><footnote><para>Or as a friend puts
        it, <quote>swatting a fly with a
        Buick.</quote></para></footnote> There are simpler tools that
        efficiently replicate data <emphasis>without</emphasis> the
        overhead of tracking changes, such as <command>rsync</command>
        or <command>unison</command>.</para>

      <para>
        <indexterm>
          <primary>version control systems</primary>
          <secondary>centralized</secondary>
        </indexterm>Once you've decided that you need a version
        control solution, you'll find no shortage of available
        options.  When Subversion was first designed and released, the
        predominant methodology of version control
        was <firstterm>centralized version control</firstterm> a
        single remote master storehouse of versioned data with
        individual users operating locally against shallow copies of
        that data's version history.  Subversion quickly emerged after
        its initial introduction as the clear leader in this field of
        version control, earning widespread adoption and supplanting
        installations of many older version control systems.  It
        continues to hold that prominent position today.</para>

      <para>
        <indexterm>
          <primary>version control systems</primary>
          <secondary>distributed</secondary>
        </indexterm>
        <indexterm>
          <primary>DVCS</primary>
          <see>version control systems, distributed</see>
        </indexterm>Much has changed since that time, though.  In the
        years since the Subversion project began its life, a newer
        methodology of version control called <firstterm>distributed
        version control</firstterm> has likewise garnered widespread
        attention and adoption.  Tools such as Git
        (<ulink url="http://git-scm.com/" />) and Mercurial
        (<ulink url="http://mercurial.selenic.com/" />) have risen
        to the tops of the distributed version control system (DVCS)
        ranks.  Distributed version control harnesses the growing
        ubiquity of high-speed network connections and low storage
        costs to offer an approach which differs from the centralized
        model in key ways.  First and most obvious is the fact that
        there is no remote, central storehouse of versioned data.
        Rather, each user keeps and operates against very
        deep complete, in a sense local version history
        data stores.  Collaboration still occurs, but is accomplished
        by trading collections of changes made to versioned items
        directly between users' local data stores, not via a
        centralized master data store.  In fact, any semblance of a
        canonical <quote>master</quote> source of a project's
        versioned data is by convention only, a status imputed by
        the various collaborators on that project.</para>

      <para>There are pros and cons to each version control approach.
        Perhaps the two biggest benefits delivered by the DVCS tools
        are incredible performance for day-to-day operations (because
        the primary data store is locally held) and vastly better
        support for merging between branches (because merge algorithms
        serve as the very core of how DVCSes work at all).  The
        downside is that distributed version control is an inherently
        more complicated model, which can present a non-negligible
        challenge to comfortable collaboration.  Also, DVCS tools do
        what they do well in part because of a certain degree of
        control withheld from the user which centalized systems freely
        offer the ability to implement path-based access
        control, the flexibility to update or backdate individual
        versioned data items, etc.  Fortunately, many wise
        organizations have discovered that this needn't be a religious
        debate, and that Subversion and a DVCS tool such as Git can be
        used together harmoniously within the organization, each
        serving the purposes best suited to the tool.</para>

      <para>Alas, this book is about Subversion, so we'll not attempt
        a full comparison of Subversion and other tools.  Readers
        empowered to choose their version control system are
        encouraged to research the available options and make the
        determination that works best for themselves and their fellow
        collaborators.  And if, after doing so, Subversion is the
        chosen tool, there's <emphasis>plenty</emphasis> of detailed
        information about how to use it successfully in the chapters
        that follow!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.intro.history">
  
      <title>Subversion's History</title>
  
      <para>
        <indexterm>
          <primary>Subversion</primary>
          <secondary>history of</secondary>
        </indexterm>
        <indexterm>
          <primary>CollabNet</primary>
        </indexterm>In early 2000, CollabNet,
        Inc. (<ulink url="http://www.collab.net"/>) began seeking
        developers to write a replacement for CVS.  CollabNet
        offered<footnote><para>CollabNet Enterprise Edition has since
        been replaced by a new product line called CollabNet
        TeamForge.</para></footnote> a collaboration software suite
        called CollabNet Enterprise Edition (CEE), of which one
        component was version control.  Although CEE used CVS as its
        initial version control system, CVS's limitations were obvious
        from the beginning, and CollabNet knew it would eventually
        have to find something better.  Unfortunately, CVS had become
        the de facto standard in the open source world largely because
        there <emphasis>wasn't</emphasis> anything better, at least
        not under a free license.  So CollabNet determined to write a
        new version control system from scratch, retaining the basic
        ideas of CVS, but without the bugs and misfeatures.</para>
  
      <para>In February 2000, they contacted Karl Fogel, the author of
        <citetitle>Open Source Development with CVS</citetitle>
        (Coriolis, 1999), and asked if he'd like to work on this new
        project.  Coincidentally, at the time Karl was already
        discussing a design for a new version control system with his
        friend Jim Blandy.  In 1995, the two had started Cyclic
        Software, a company providing CVS support contracts, and
        although they later sold the business, they still used CVS
        every day at their jobs.  Their frustration with CVS had led
        Jim to think carefully about better ways to manage versioned
        data, and he'd already come up with not only the Subversion
        name, but also the basic design of the Subversion data store.
        When CollabNet called, Karl immediately agreed to work on the
        project, and Jim got his employer, Red Hat Software, to
        essentially donate him to the project for an indefinite period
        of time.  CollabNet hired Karl and Ben Collins-Sussman, and
        detailed design work began in May 2000.  With the help of some
        well-placed prods from Brian Behlendorf and Jason Robbins of
        CollabNet, and from Greg Stein (at the time an independent
        developer active in the WebDAV/DeltaV specification process),
        Subversion quickly attracted a community of active developers.
        It turned out that many people had encountered the same
        frustrating experiences with CVS and welcomed the chance to
        finally do something about it.</para>
  
      <para>The original design team settled on some simple goals.  They
        didn't want to break new ground in version control methodology,
        they just wanted to fix CVS.  They decided that Subversion would
        match CVS's features and preserve the same development model,
        but not duplicate CVS's most obvious flaws.  And although it did
        not need to be a drop-in replacement for CVS, it should be
        similar enough that any CVS user could make the switch with
        little effort.</para>
  
      <para>After 14 months of coding, Subversion became
        <quote>self-hosting</quote> on August 31, 2001.  That is,
        Subversion developers stopped using CVS to manage Subversion's
        own source code and started using Subversion instead.</para>

      <para>
        <indexterm>
          <primary>Apache Subversion</primary>
          <seealso>Subversion</seealso>
        </indexterm>While CollabNet started the project, and still
        funds a large chunk of the work (it pays the salaries of a few
        full-time Subversion developers), Subversion is run like most
        open source projects, governed by a loose, transparent set of
        rules that encourage meritocracy.  In 2009, CollabNet worked
        with the Subversion developers towards the goal of integrating
        the Subversion project into the Apache Software Foundation
        (ASF), one of the most well-known collectives of open source
        projects in the world.  Subversion's technical roots,
        community priorities, and development practices were a perfect
        fit for the ASF, many of whose members were already active
        Subversion contributors.  In early 2010, Subversion was fully
        adopted into the ASF's family of top-level projects, moved its
        project web presence to
        <ulink url="http://subversion.apache.org"/>, and was
        rechristened <quote>Apache Subversion</quote>.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.intro.architecture">
  
      <title>Subversion's Architecture</title>
    
      <para>
        <indexterm>
          <primary>Subversion</primary>
          <secondary>architecture</secondary>
        </indexterm><xref linkend="svn.intro.architecture.dia-1"/>
        illustrates a <quote>mile-high</quote> view of Subversion's
        design.</para>
      
      <figure id="svn.intro.architecture.dia-1">
        <title>Subversion's architecture</title>
        <graphic width="5in" depth="6.25in"
                 fileref="images/svn-arch-diagram.png"/>
      </figure>
  
      <para>On one end is a Subversion repository that holds all of
        your versioned data.  On the other end is your Subversion
        client program, which manages local reflections of portions of
        that versioned data.  Between these extremes are multiple
        routes through a Repository Access (RA) layer, some of which
        go across computer networks and through network servers which
        then access the repository, others of which bypass the network
        altogether and access the repository directly.</para>
  
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.intro.components">
  
      <title>Subversion's Components</title>
        
      <para>
        <indexterm>
          <primary>Subversion</primary>
          <secondary>components</secondary>
        </indexterm>Subversion, once installed, has a number of
        different pieces.  The following is a quick overview of what
        you get.  Don't be alarmed if the brief descriptions leave you
        scratching your head <emphasis>plenty</emphasis> more
        pages in this book are devoted to alleviating that
        confusion.</para>
  
      <variablelist>
        <indexterm>
          <primary>svn</primary>
        </indexterm>
        <indexterm>
          <primary>svnversion</primary>
        </indexterm>
        <indexterm>
          <primary>svnlook</primary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
        </indexterm>
        <indexterm>
          <primary>mod_dav_svn</primary>
        </indexterm> 
        <indexterm>
          <primary>svnserve</primary>
        </indexterm>
        <indexterm>
          <primary>svndumpfilter</primary>
        </indexterm>
        <indexterm>
          <primary>svnsync</primary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>
        <indexterm>
          <primary>svnmucc</primary>
        </indexterm>

        <varlistentry>
          <term>svn</term>
          <listitem>
            <para>The command-line client program</para>
          </listitem>
        </varlistentry>
  
        <varlistentry>
          <term>svnversion</term>
          <listitem>
            <para>A program for reporting the state (in terms of
              revisions of the items present) of a working copy</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svnlook</term>
          <listitem>
            <para>A tool for directly inspecting a Subversion repository</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svnadmin</term>
          <listitem>
            <para>A tool for creating, tweaking, or repairing a Subversion
              repository</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mod_dav_svn</term>
          <listitem>
           <para>A plug-in module for the Apache HTTP Server, used to
              make your repository available to others over a
              network</para>
          </listitem>
        </varlistentry>
  
        <varlistentry>
          <term>svnserve</term>
          <listitem>
            <para>A custom standalone server program, runnable as a
              daemon process or invokable by SSH; another way to make
              your repository available to others over a network</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svndumpfilter</term>
          <listitem>
            <para>A program for filtering Subversion repository dump
              streams</para>
          </listitem>
        </varlistentry>
  
        <varlistentry>
          <term>svnsync</term>
          <listitem>
            <para>A program for incrementally mirroring one repository
              to another over a network</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svnrdump</term>
          <listitem>
            <para>A program for performing repository history dumps
              and loads over a network</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>svnmucc</term>
          <listitem>
            <para>A program for performing multiple repository
              URL-based operations in a single commit and without the
              use of a working copy</para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.intro.whatsnew">

      <title>What's New in Subversion</title>

      <para>
        <indexterm>
          <primary>Subversion</primary>
          <secondary>history of</secondary>
        </indexterm>The first edition of this book was published by
        O'Reilly Media in 2004, shortly after Subversion had reached
        1.0.  Since that time, the Subversion project has continued to
        release new major releases of the software.  Here's a quick
        summary of major new changes since Subversion 1.0.  Note that
        this is not a complete list; for full details, please visit
        Subversion's web site at
        <ulink url="http://subversion.apache.org"/>.</para>

      <variablelist>

        <varlistentry>
          <term>Subversion 1.1 (September 2004)</term>
          <listitem>
            <para>Release 1.1 introduced FSFS, a flat-file repository
              storage option for the repository.  While the Berkeley DB
              backend is still widely used and supported, FSFS has
              since become the default choice for
              newly created repositories due to its low barrier to
              entry and minimal maintenance requirements.  Also in
              this release came the ability to put symbolic links
              under version control, auto-escaping of URLs, and a
              localized user interface.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.2 (May 2005)</term>
          <listitem>
            <para>Release 1.2 introduced the ability to create
              server-side locks on files, thus serializing commit
              access to certain resources.  While Subversion is still
              a fundamentally concurrent version control system,
              certain types of binary files (e.g. art assets)
              cannot be merged together.  The locking feature fulfills
              the need to version and protect such resources.  With
              locking also came a complete WebDAV auto-versioning
              implementation, allowing Subversion repositories to be
              mounted as network folders.  Finally, Subversion 1.2
              began using a new, faster binary-differencing algorithm
              to compress and retrieve old versions of files.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.3 (December 2005)</term>
          <listitem>
            <para>Release 1.3 brought path-based authorization
              controls to the <command>svnserve</command> server,
              matching a feature formerly found only in the Apache
              server.  The Apache server, however, gained some new
              logging features of its own, and Subversion's API
              bindings to other languages also made great leaps
              forward.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.4 (September 2006)</term>
          <listitem>
            <para>Release 1.4 introduced a whole new
              tool <command>svnsync</command> for doing
              one-way repository replication over a network.  Major
              parts of the working copy metadata were revamped to no
              longer use XML (resulting in client-side speed gains),
              while the Berkeley DB repository backend gained the
              ability to automatically recover itself after a server
              crash.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.5 (June 2008)</term>
          <listitem>
            <para>Release 1.5 took much longer to finish than prior
              releases, but the headliner feature was gigantic:
              semi-automated tracking of branching and merging.  This
              was a huge boon for users, and pushed Subversion far
              beyond the abilities of CVS and into the ranks of
              commercial competitors such as Perforce and ClearCase.
              Subversion 1.5 also introduced a bevy of other
              user-focused features, such as interactive resolution of
              file conflicts, sparse checkouts, client-side
              management of changelists, powerful new syntax for
              externals definitions, and SASL authentication support for
              the <command>svnserve</command> server.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.6 (March 2009)</term>
          <listitem>
            <para>Release 1.6 continued to make branching and merging
              more robust by introducing tree conflicts, and offered
              improvements to several other existing features: more
              interactive conflict resolution options; de-telescoping
              and outright exclusion support for sparse checkouts;
              file-based externals definitions; and operational
              logging support for <command>svnserve</command> similar
              to what <command>mod_dav_svn</command> offered.  Also,
              the command-line client introduced a new shortcut syntax
              for referring to Subversion repository URLs.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.7 (October 2011)</term>
          <listitem>
            <para>Release 1.7 was primarily a delivery vehicle for two
              big plumbing overhauls of existing Subversion
              components.  The largest and most impactful of these was
              the so-called <quote>WC-NG</quote> a complete
              rewrite of the <command>libsvn_wc</command> working copy
              management library.  The second change was the
              introduction of a sleeker HTTP protocol for Subversion
              client/server interaction.  Subversion 1.7 delivered a
              handful of additional features, many bug fixes, and some
              notable performance improvements, too.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Subversion 1.8 (not yet released)</term>
          <listitem>
            <para><emphasis>*shrug*</emphasis>.  Patches (to
              Subversion) welcome.</para>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.preface.audience">

    <title>Audience</title>
    
    <para>This book is written for computer-literate folk who want to
      use Subversion to manage their data.  While Subversion runs on a
      number of different operating systems, its primary user
      interface is command-line-based.  That command-line tool
      (<command>svn</command>), and some additional auxiliary
      programs, are the focus of this book.</para>

    <para>For consistency, the examples in this book assume that the reader
      is using a Unix-like operating system and is relatively comfortable
      with Unix and command-line interfaces.  That said, the
      <command>svn</command> program also runs on non-Unix platforms
      such as Microsoft Windows.  With a few minor exceptions, such as
      the use of backward slashes (<literal>\</literal>) instead of
      forward slashes (<literal>/</literal>) for path separators, the
      input to and output from this tool when run on Windows are
      identical to that of its Unix counterpart.</para>

    <para>Most readers are probably programmers or system
      administrators who need to track changes to source code.  This
      is the most common use for Subversion, and therefore it is the
      scenario underlying all of the book's examples.  But Subversion
      can be used to manage changes to any sort of
      information images, music, databases, documentation, and
      so on.  To Subversion, all data is just data.</para>
    
    <para>While this book is written with the assumption that the
      reader has never used a version control system, we've also tried
      to make it easy for users of CVS (and other systems) to make a
      painless leap into Subversion.  Special sidebars may mention
      other version control systems from time to time, and
      <xref linkend="svn.forcvs"/> summarizes many of the differences
      between CVS and Subversion.</para>

    <para>Note also that the source code examples used throughout the
      book are only examples.  While they will compile with the proper
      compiler incantations, they are intended to illustrate a
      particular scenario and not necessarily to serve as examples of good
      programming style or practices.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.preface.howread">
    <title>How to Read This Book</title>

    <para>Technical books always face a certain dilemma: whether to
      cater to <quote>top-down</quote> or to <quote>bottom-up</quote>
      learners.  A top-down learner prefers to read or skim
      documentation, getting a large overview of how the system works;
      only then does she actually start using the software.  A
      bottom-up learner is a <quote>learn by doing</quote>
      person someone who just wants to dive into the software
      and figure it out as she goes, referring to book sections when
      necessary.  Most books tend to be written for one type of person
      or the other, and this book is undoubtedly biased toward
      top-down learners.  (And if you're actually reading this
      section, you're probably already a top-down learner yourself!)
      However, if you're a bottom-up person, don't despair.  While the
      book may be laid out as a broad survey of Subversion topics, the
      content of each section tends to be heavy with specific examples
      that you can try-by-doing.  For the impatient folks who just
      want to get going, you can jump right to
      <xref linkend="svn.intro"/>.</para>

    <para>Regardless of your learning style, this book aims to be
      useful to people of widely different backgrounds from
      those with no previous experience in version control to
      experienced system administrators.  Depending on your own
      background, certain chapters may be more or less important to
      you.  The following can be considered a
      <quote>recommended reading list</quote> for various types of
      readers:</para>

    <variablelist>
      <varlistentry>
        <term>Experienced system administrators</term>
        <listitem>
          <para>The assumption here is that you've probably used
            version control before and are dying to get a
            Subversion server up and running ASAP.
            <xref linkend="svn.reposadmin"/> and
            <xref linkend="svn.serverconfig"/> will show you how to
            create your first repository and make it available over
            the network.  After that's done,
            <xref linkend="svn.tour"/> and
            <xref linkend="svn.forcvs"/> are the fastest routes to
            learning the Subversion client.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>New users</term>
        <listitem>
          <para>Your administrator has probably set up Subversion
            already, and you need to learn how to use the client.  If
            you've never used a version control system, then
            <xref linkend="svn.basic"/> is a vital introduction to the
            ideas behind version control.  <xref linkend="svn.tour"/>
            is a guided tour of the Subversion client.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Advanced users</term>
        <listitem>
          <para>Whether you're a user or administrator, eventually
            your project will grow larger.  You're going to want to
            learn how to do more advanced things with Subversion, such
            as how to use Subversion's property support
            (<xref linkend="svn.advanced"/>), how to use branches and
            perform merges (<xref linkend="svn.branchmerge"/>), how to
            configure runtime options
            (<xref linkend="svn.customization"/>), and other things.
            These chapters aren't critical at first, but be sure to
            read them once you're comfortable with the basics.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Developers</term>
        <listitem>
          <para>Presumably, you're already familiar with Subversion,
            and now want to either extend it or build new software on
            top of its many APIs.  <xref linkend="svn.developer"/> is
            just for you.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The book ends with reference material <xref
      linkend="svn.ref"/> is a reference guide for all Subversion
      commands, and the appendixes cover a number of useful topics.
      These are the chapters you're most likely to come back to
      after you've finished the book.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.preface.organization">
    <title>Organization of This Book</title>

    <para>The chapters that follow and their contents are listed
      here:</para>

    <variablelist>

      <varlistentry>
        <term><xref linkend="svn.basic"/></term>
        <listitem>
          <para>Explains the basics of version control and different
            versioning models, along with Subversion's repository,
            working copies, and revisions.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.tour"/></term>
        <listitem>
          <para>Walks you through a day in the life of a Subversion
            user.  It demonstrates how to use a Subversion client to
            obtain, modify, and commit data.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.advanced"/></term>
        <listitem>
          <para>Covers more complex features that regular users will
            eventually come into contact with, such as versioned
            metadata, file locking, and peg revisions.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.branchmerge"/></term>
        <listitem>
          <para>Discusses branches, merges, and tagging, including
            best practices for branching and merging, common
            use cases, how to undo changes, and how to easily swing
            from one branch to the next.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.reposadmin"/></term>
        <listitem>
          <para>Describes the basics of the Subversion repository,
            how to create, configure, and maintain a repository, and
            the tools you can use to do all of this.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.serverconfig"/></term>
        <listitem>
          <para>Explains how to configure your Subversion server and
            offers different ways to access your repository:
            <literal>HTTP</literal>, the <literal>svn</literal>
            protocol, and local disk access.  It also covers the details
            of authentication, authorization and anonymous
            access.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.customization"/></term>
        <listitem>
          <para>Explores the Subversion client configuration files,
            the handling of internationalized text, and how to make
            external tools cooperate with Subversion.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.developer"/></term>
        <listitem>
          <para>Describes the internals of Subversion, the
            Subversion filesystem, and the working copy
            administrative areas from a programmer's point of view.
            It also demonstrates how to use the public APIs to write a
            program that uses Subversion.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.ref"/></term>
        <listitem>
          <para>Explains in great detail every subcommand of
            <command>svn</command>, <command>svnadmin</command>, and
            <command>svnlook</command> with plenty of examples for
            the whole family!</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.intro"/></term>
        <listitem>
          <para>For the impatient, a whirlwind explanation of how to
            install Subversion and start using it immediately.  You
            have been warned.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.forcvs"/></term>
        <listitem>
          <para>Covers the similarities and differences between
            Subversion and CVS, with numerous suggestions on how to
            break all the bad habits you picked up from years of
            using CVS.  Included are descriptions of Subversion
            revision numbers, versioned directories, offline
            operations, <command>update</command>
            versus <command>status</command>, branches, tags, metadata,
            conflict resolution, and authentication.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.webdav"/></term>
        <listitem>
          <para>Describes the details of WebDAV and DeltaV and how
            you can configure your Subversion repository to be
            mounted read/write as a DAV share.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><xref linkend="svn.copyright"/></term>
        <listitem>
          <para>A copy of the Creative Commons Attribution License,
            under which this book is licensed.</para>
        </listitem>
      </varlistentry>

    </variablelist>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.preface.free">
    <title>This Book Is Free</title>

    <para>This book started out as bits of documentation written by
      Subversion project developers, which were then coalesced into a
      single work and rewritten.  As such, it has always been under a
      free license (see <xref linkend="svn.copyright"/>).  In fact,
      the book was written in the public eye, originally as part of
      the Subversion project itself.  This means two things:</para>

    <itemizedlist>
      <listitem>
        <para>You will always find the latest version of this book in
          the book's own Subversion repository.</para>
      </listitem>

      <listitem>
        <para>You can make changes to this book and redistribute it
          however you wish it's under a free license.  Your only
          obligation is to maintain proper attribution to the original
          authors.  Of course, we'd much rather you send feedback and
          patches to the Subversion developer community, instead of 
          distributing your private version of this book.</para>
      </listitem>
    </itemizedlist>
    
    <para>The online home of this book's development and most of the
      volunteer-driven translation efforts regarding it is
      <ulink url="http://svnbook.red-bean.com"/>.  There you can find
      links to the latest releases and tagged versions of the book in
      various formats, as well as instructions for accessing the
      book's Subversion repository (where its DocBook XML source
      code lives).  Feedback is welcomed encouraged, even.  Please
      submit all comments, complaints, and patches against the book
      sources to <email>svnbook-dev@red-bean.com</email>.</para>

  </sect1>

  <!-- O'Reilly put its "Using Code Examples", "Safari Books Online",
       and "How to Contact Us" sections here.  -->

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.preface.acks">
    <title>Acknowledgments</title>

    <para>This book would not be possible (nor very useful) if
      Subversion did not exist.  For that, the authors would like to
      thank Brian Behlendorf and CollabNet for the vision to fund such
      a risky and ambitious new open source project; Jim Blandy for
      the original Subversion name and design we love you, Jim;
      and Karl Fogel for being such a good friend and a great
      community leader, in that order.<footnote><para>Oh, and thanks,
      Karl, for being too overworked to write this book
      yourself.</para></footnote></para>

    <para>Thanks to O'Reilly and the team of professional editors who
      have helped us polish this text at various stages of its
      evolution: Chuck Toporek, Linda Mui, Tatiana Apandi, Mary Brady,
      and Mary Treseler.  Your patience and support has been
      tremendous.</para>

    <para>Finally, we thank the countless people who contributed to
      this book with informal reviews, suggestions, and patches.  An
      exhaustive listing of those folks' names would be impractical to
      print and maintain here, but may their names live on forever in
      this book's version control history!</para>

  </sect1>

</preface>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.basic">
  <title>Fundamental Concepts</title>

  <para>This chapter is a short, casual introduction to Subversion and
    its approach to version control.  We begin with a discussion of
    general version control concepts, work our way into the specific
    ideas behind Subversion, and show some simple examples of
    Subversion in use.</para>

  <para>Even though the examples in this chapter show people sharing
    collections of program source code, keep in mind that Subversion
    can manage any sort of file collection it's not limited to
    helping computer programmers.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.version-control-basics">
    <title>Version Control Basics</title>

    <para>
      <indexterm>
        <primary>version control systems</primary>
      </indexterm>A version control system (or revision control
      system) is a system that tracks incremental versions (or
      revisions) of files and, in some cases, directories over time.
      Of course, merely tracking the various versions of a user's (or
      group of users') files and directories isn't very interesting in
      itself.  What makes a version control system useful is the fact
      that it allows you to explore the changes which resulted in each
      of those versions and facilitates the arbitrary recall of the
      same.</para>

    <para>In this section, we'll introduce some fairly high-level
      version control system components and concepts.  We'll limit our
      discussion to modern version control systems in today's
      interconnected world, there is very little point in
      acknowledging version control systems which cannot
      operate across wide-area networks.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.repository">
      <title>The Repository</title>

      <para>
        <indexterm>
          <primary>repositories</primary>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem tree</secondary>
        </indexterm>
        <indexterm>
          <primary>version control systems</primary>
          <secondary>clients</secondary>
        </indexterm>At the core of the version control system is a
        repository, which is the central store of that system's data.
        The repository usually stores information in the form of a
        <firstterm>filesystem tree</firstterm> a hierarchy of
        files and directories.  Any number of
        <firstterm>clients</firstterm> connect to the repository, and
        then read or write to these files.  By writing data, a client
        makes the information available to others; by reading data,
        the client receives information from others.
        <xref linkend="svn.basic.repository.dia-1"/> illustrates
        this.</para>

      <figure id="svn.basic.repository.dia-1">
        <title>A typical client/server system</title>
        <graphic fileref="images/ch02dia1.png"/>
      </figure>

      <para>Why is this interesting?  So far, this sounds like the
        definition of a typical file server.  And indeed, the
        repository <emphasis>is</emphasis> a kind of file server, but
        it's not your usual breed.  What makes the repository special
        is that as the files in the repository are changed, the
        repository remembers each version of those files.</para>

      <para>When a client reads data from the repository, it normally
        sees only the latest version of the filesystem tree.  But what
        makes a version control client interesting is that it also has
        the ability to request previous states of the filesystem from
        the repository.  A version control client can ask historical
        questions such as <quote>What did this directory contain last
        Wednesday?</quote> and <quote>Who was the last person to
        change this file, and what changes did he make?</quote>
        These are the sorts of questions that are at the heart of any
        version control system.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.working-copy">
      <title>The Working Copy</title>

      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A version control system's value comes from the
        fact that it tracks versions of files and directories, but the
        rest of the software universe doesn't operate
        on <quote>versions of files and directories</quote>.  Most
        software programs understand how to operate only on
        a <emphasis>single</emphasis> version of a specific type of
        file.  So how does a version control user interact with an
        abstract and, often, remote repository full of
        multiple versions of various files in a concrete fashion?  How
        does his or her word processing software, presentation
        software, source code editor, web design software, or some
        other program all of which trade in the currency of
        simple data files get access to such files?  The answer
        is found in the version control construct known as
        a <firstterm>working copy</firstterm>.</para>

      <para>A working copy is, quite literally, a local copy of a
        particular version of a user's VCS-managed data upon which
        that user is free to work.  Working copies<footnote><para>The
        term <quote>working copy</quote> can be generally applied to
        any one file version's local instance.  When most folks use
        the term, though, they are referring to a whole directory tree
        containing files and subdirectories managed by the version
        control system.</para></footnote> appear to other software
        just as any other local directory full of files, so those
        programs don't have to be <quote>version-control-aware</quote>
        in order to read from and write to that data.  The task of
        managing the working copy and communicating changes made to
        its contents to and from the repository falls squarely to the
        version control system's client software.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.vsn-models">
      <title>Versioning Models</title>

      <para>If the primary mission of a version control system is to
        track the various versions of digital information over time, a
        very close secondary mission in any modern version control
        system is to enable collaborative editing and sharing of that
        data.  But different systems use different strategies to
        achieve this.  It's important to understand these different
        strategies, for a couple of reasons.  First, it will help you
        compare and contrast existing version control systems, in case
        you encounter other systems similar to Subversion.  Beyond
        that, it will also help you make more effective use of
        Subversion, since Subversion itself supports a couple of
        different ways of working.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.problem-sharing">
        <title>The problem of file sharing</title>

        <para>All version control systems have to solve the same
          fundamental problem: how will the system allow users to
          share information, but prevent them from accidentally
          stepping on each other's feet?  It's all too easy for users
          to accidentally overwrite each other's changes in the
          repository.</para>

        <para>Consider the scenario shown in
          <xref linkend="svn.basic.vsn-models.problem-sharing.dia-1"/>.
          Suppose we have two coworkers, Harry and Sally.  They each
          decide to edit the same repository file at the same time.
          If Harry saves his changes to the repository first, it's
          possible that (a few moments later) Sally could accidentally
          overwrite them with her own new version of the file.  While
          Harry's version of the file won't be lost forever (because
          the system remembers every change), any changes Harry made
          <emphasis>won't</emphasis> be present in Sally's newer version
          of the file, because she never saw Harry's changes to begin
          with.  Harry's work is still effectively lost or at
          least missing from the latest version of the file and
          probably by accident.  This is definitely a situation we want
          to avoid!</para>

        <figure id="svn.basic.vsn-models.problem-sharing.dia-1">
          <title>The problem to avoid</title>
          <graphic fileref="images/ch02dia2.png"/>
        </figure>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.lock-unlock">
        <title>The lock-modify-unlock solution</title>

        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>lock-modify-unlock</tertiary>
          </indexterm>Many version control systems use a
          <firstterm>lock-modify-unlock</firstterm> model to address
          the problem of many authors clobbering each other's work.
          In this model, the repository allows only one person to
          change a file at a time.  This exclusivity policy is managed
          using locks.  Harry must <quote>lock</quote> a file before
          he can begin making changes to it.  If Harry has locked a
          file, Sally cannot also lock it, and therefore cannot make
          any changes to that file.  All she can do is
          wait for Harry to finish his changes, save the file and
          release his lock.  After Harry unlocks the file, Sally
          can take her turn by locking the file.  Then she may read
          the latest version of the file and edit it.
          <xref linkend="svn.basic.vsn-models.lock-unlock.dia-1"/>
          demonstrates this simple solution.</para>

        <figure id="svn.basic.vsn-models.lock-unlock.dia-1">
          <title>The lock-modify-unlock solution</title>
          <graphic fileref="images/ch02dia3.png"/>
        </figure>

        <para>The problem with the lock-modify-unlock model is that it's
          a bit restrictive and often becomes a roadblock for
          users:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>Locking may cause administrative
              problems.</emphasis>

              Sometimes Harry will lock a file and then forget about it.
              Meanwhile, because Sally is still waiting to edit the file,
              her hands are tied.  And then Harry goes on vacation.  Now
              Sally has to get an administrator to release Harry's lock.
              The situation ends up causing a lot of unnecessary delay
              and wasted time.</para>
          </listitem>

          <listitem>
            <para><emphasis>Locking may cause unnecessary
              serialization.</emphasis>

              What if Harry is editing the beginning of a text file,
              and Sally simply wants to edit the end of the same file?
              These changes don't overlap at all.  They could easily
              edit the file simultaneously, and no great harm would
              come, assuming the changes were properly merged together.
              There's no need for them to take turns in this
              situation.</para>
          </listitem>

          <listitem>
            <para><emphasis>Locking may create a false sense of
              security.</emphasis>

              Suppose Harry locks and edits file A, while Sally
              simultaneously locks and edits file B.  But what if A and
              B depend on one another, and the changes made to each are
              semantically incompatible?  Suddenly A and B don't work
              together anymore.  The locking system was powerless to
              prevent the problem yet it somehow provided a false
              sense of security.  It's easy for Harry and Sally to
              imagine that by locking files, each is beginning a safe,
              insulated task, and thus they need not bother discussing
              their incompatible changes early on.  Locking often
              becomes a substitute for real communication.</para>
          </listitem>
        </itemizedlist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.vsn-models.copy-merge">
        <title>The copy-modify-merge solution</title>

        <para>
          <indexterm>
            <primary>version control</primary>
            <secondary>models</secondary>
            <tertiary>copy-modify-merge</tertiary>
          </indexterm>Subversion, CVS, and many other version control
          systems use a <firstterm>copy-modify-merge</firstterm> model
          as an alternative to locking.  In this model, each user's
          client contacts the project repository and creates a
          personal working copy.  Users then work simultaneously and
          independently, modifying their private copies.  Finally, the
          private copies are merged together into a new, final
          version.  The version control system often assists with the
          merging, but ultimately, a human being is responsible for
          making it happen correctly.</para>

        <para>
          <indexterm>
            <primary>out of date</primary>
          </indexterm>Here's an example.  Say that Harry and Sally
          each create working copies of the same project, copied from
          the repository.  They work concurrently and make changes to
          the same file A within their copies.  Sally saves her
          changes to the repository first.  When Harry attempts to
          save his changes later, the repository informs him that his
          file A is <firstterm>out of date</firstterm>.  In other
          words, file A in the repository has somehow changed since he
          last copied it.  So Harry asks his client to merge any new
          changes from the repository into his working copy of file A.
          Chances are that Sally's changes don't overlap with his own;
          once he has both sets of changes integrated, he saves his
          working copy back to the repository.
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-1"/> and
          <xref linkend="svn.basic.vsn-models.copy-merge.dia-2"/> show
          this process.</para>

        <figure id="svn.basic.vsn-models.copy-merge.dia-1">
          <title>The copy-modify-merge solution</title>
          <graphic fileref="images/ch02dia4.png"/>
        </figure>

        <figure id="svn.basic.vsn-models.copy-merge.dia-2">
          <title>The copy-modify-merge solution (continued)</title>
          <graphic fileref="images/ch02dia5.png"/>
        </figure>

        <para>
          <indexterm>
            <primary>conflicts</primary>
          </indexterm>But what if Sally's changes
          <emphasis>do</emphasis> overlap with Harry's changes?  What
          then?  This situation is called a
          <firstterm>conflict</firstterm>, and it's usually not much
          of a problem.  When Harry asks his client to merge the
          latest repository changes into his working copy, his copy of
          file A is somehow flagged as being in a state of conflict:
          he'll be able to see both sets of conflicting changes and
          manually choose between them.  Note that software can't
          automatically resolve conflicts; only humans are capable of
          understanding and making the necessary intelligent choices.
          Once Harry has manually resolved the overlapping
          changes perhaps after a discussion with Sally he
          can safely save the merged file back to the
          repository.</para>

        <para>The copy-modify-merge model may sound a bit chaotic, but
          in practice, it runs extremely smoothly.  Users can work in
          parallel, never waiting for one another.  When they work on
          the same files, it turns out that most of their concurrent
          changes don't overlap at all; conflicts are infrequent.  And
          the amount of time it takes to resolve conflicts is usually
          far less than the time lost by a locking system.</para>

        <para>In the end, it all comes down to one critical factor:
          user communication.  When users communicate poorly, both
          syntactic and semantic conflicts increase.  No system can
          force users to communicate perfectly, and no system can
          detect semantic conflicts.  So there's no point in being
          lulled into a false sense of security that a locking system
          will somehow prevent conflicts; in practice, locking seems
          to inhibit productivity more than anything else.</para>

        <sidebar id="svn.basic.vsn-models.copy-merge.sb-1">
          <title>When Locking Is Necessary</title>

          <para>While the lock-modify-unlock model is considered
            generally harmful to collaboration, sometimes
            locking is appropriate.</para>

          <para>The copy-modify-merge model is based on the assumption
            that files are contextually mergeable that is, that the
            majority of the files in the repository are line-based text
            files (such as program source code).  But for files with
            binary formats, such as artwork or sound, it's often
            impossible to merge conflicting changes.  In these
            situations, it really is necessary for users to take strict
            turns when changing the file.  Without serialized access,
            somebody ends up wasting time on changes that are ultimately
            discarded.</para>

          <para>While Subversion is primarily a copy-modify-merge
            system, it still recognizes the need to lock an occasional
            file, and thus provides mechanisms for this.  We discuss
            this feature in <xref linkend="svn.advanced.locking"/>.</para>

        </sidebar>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.in-action">
    <title>Version Control the Subversion Way</title>

    <para>We've mentioned already that Subversion is a modern,
      network-aware version control system.  As we described in
      <xref linkend="svn.basic.version-control-basics"/> (our
      high-level version control overview), a repository serves as the
      core storage mechanism for Subversion's versioned data, and it's
      via working copies that users and their software programs
      interact with that data.  In this section, we'll begin to
      introduce the specific ways in which Subversion implements
      version control.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.svn-repositories">
      <title>Subversion Repositories</title>

      <para>Subversion implements the concept of a version control
        repository much as any other modern version control system
        would.  Unlike a working copy, a Subversion repository is an
        abstract entity, able to be operated upon almost exclusively
        by Subversion's own libraries and tools.  As most of a user's
        Subversion interactions involve the use of the Subversion
        client and occur in the context of a working copy, we spend
        the majority of this book discussing the Subversion working
        copy and how to manipulate it.  For the finer details of the
        repository, though, check out
        <xref linkend="svn.reposadmin"/>.</para>

      <warning id="svn.basic.svn-repositories.not-working-copy">
        <para>In Subversion, the client-side object which every user
          of the system has the directory of versioned files,
          along with metadata that enables the system to track them
          and communicate with the server is called
          a <emphasis>working copy</emphasis>.  Although other version
          control systems use the term <quote>repository</quote> for
          the client-side object, it is both incorrect and a common
          source of confusion to use the term in that way in the
          context of Subversion.</para>

        <para>Working copies are described later, in
          <xref linkend="svn.basic.in-action.wc"/>.</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.revs">
      <title>Revisions</title>

      <para>A Subversion client commits (that is, communicates the
        changes made to) any number of files and directories as a
        single atomic transaction.  By atomic transaction, we mean
        simply this: either all of the changes are accepted into the
        repository, or none of them is.  Subversion tries to retain
        this atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</para>

      <para>
        <indexterm>
          <primary>revisions</primary>
        </indexterm>Each time the repository accepts a commit, this
        creates a new state of the filesystem tree, called a
        <firstterm>revision</firstterm>.  Each revision is assigned a
        unique natural number, one greater than the number assigned to
        the previous revision.  The initial revision of a freshly
        created repository is numbered 0 and consists of nothing but
        an empty root directory.</para>

      <para><xref linkend="svn.basic.in-action.revs.dia-1"/>
        illustrates a nice way to visualize the repository.  Imagine
        an array of revision numbers, starting at 0, stretching from
        left to right.  Each revision number has a filesystem tree
        hanging below it, and each tree is a <quote>snapshot</quote>
        of the way the repository looked after a commit.</para>

      <figure id="svn.basic.in-action.revs.dia-1">
        <title>Tree changes over time</title>
        <graphic fileref="images/ch02dia7.png"/>
      </figure>

      <sidebar>
        <title>Global Revision Numbers</title>

        <para>
          <indexterm>
            <primary>revisions</primary>
            <secondary>global</secondary>
          </indexterm>Unlike most version control systems,
          Subversion's revision numbers apply to <emphasis>the entire
          repository tree</emphasis>, not individual files.  Each
          revision number selects an entire tree, a particular state
          of the repository after some committed change.  Another way
          to think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When
          Subversion users talk about <quote>revision 5 of
          <filename>foo.c</filename>,</quote> they really mean
          <quote><filename>foo.c</filename> as it appears in revision
          5.</quote> Notice that in general, revisions N and M of a
          file do <emphasis>not</emphasis> necessarily differ!  Many
          other version control systems use per-file revision numbers,
          so this concept may seem unusual at first. (Former CVS users
          might want to see <xref linkend="svn.forcvs"/> for more
          details.)</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.reposurls">
      <title>Addressing the Repository</title>

      <para>
        <indexterm>
          <primary>repository URL</primary>
        </indexterm>Subversion client programs use URLs to identify
        versioned files and directories in Subversion repositories.
        For the most part, these URLs use the standard syntax,
        allowing for server names and port numbers to be specified as
        part of the URL.</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>http://svn.example.com/svn/project</simpara>
          </listitem>
          <listitem>
            <simpara>http://svn.example.com:9834/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Subversion repository URLs aren't limited to only
        the <literal>http://</literal> variety.  Because Subversion
        offers several different ways for its clients to communicate
        with its servers, the URLs used to address the repository
        differ subtly depending on which repository access mechanism
        is employed.  <xref linkend="svn.basic.in-action.wc.tbl-1"/>
        describes how different URL schemes map to the available
        repository access methods.  For more details about
        Subversion's server options, see
        <xref linkend="svn.serverconfig"/>.</para>

      <table id="svn.basic.in-action.wc.tbl-1">
        <title>Repository access URLs</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Schema</entry>
              <entry>Access method</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>file:///</literal></entry>
              <entry>Direct repository access (on local disk)</entry>
            </row>
            <row>
              <entry><literal>http://</literal></entry>
              <entry>Access via WebDAV protocol to Subversion-aware
                Apache server</entry>
            </row>
            <row>
              <entry><literal>https://</literal></entry>
              <entry>Same as <literal>http://</literal>, but with
                SSL encryption</entry>
            </row>
            <row>
              <entry><literal>svn://</literal></entry>
              <entry>Access via custom protocol to an
                <literal>svnserve</literal> server</entry>
            </row>
            <row>
              <entry><literal>svn+ssh://</literal></entry>
              <entry>Same as <literal>svn://</literal>, but through
                an SSH tunnel</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Subversion's handling of URLs has some notable nuances.
        For example, URLs containing the <literal>file://</literal>
        access method (used for local repositories) must, in
        accordance with convention, have either a server name
        of <literal>localhost</literal> or no server name at
        all:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file://localhost/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Also, users of the <literal>file://</literal> scheme on
        Windows platforms will need to use an unofficially
        <quote>standard</quote> syntax for accessing repositories
        that are on the same machine, but on a different drive than
        the client's current working drive.  Either of the two
        following URL path syntaxes will work, where
        <literal>X</literal> is the drive on which the repository
        resides:</para>

      <informalexample>
        <itemizedlist spacing="compact">
          <listitem>
            <simpara>file:///X:/var/svn/repos</simpara>
          </listitem>
          <listitem>
            <simpara>file:///X|/var/svn/repos</simpara>
          </listitem>
        </itemizedlist>
      </informalexample>

      <para>Note that a URL uses forward slashes even though the
        native (non-URL) form of a path on Windows uses backslashes.
        Also note that when using
        the <literal>file:///<replaceable>X</replaceable>|/</literal>
        form at the command line, you need to quote the URL (wrap it
        in quotation marks) so that the vertical bar character is not
        interpreted as a pipe.</para>

      <note>
        <para>You cannot use Subversion's <literal>file://</literal> URLs
          in a regular web browser the way you can use typical
          <literal>file://</literal> URLs.  When you attempt to view
          a <literal>file://</literal> URL in a regular web browser, it
          reads and displays the contents of the file at that location
          by examining the filesystem directly.  However, Subversion's
          resources exist in a virtual filesystem (see <xref
          linkend="svn.developer.layerlib.repos" />), and your browser
          will not understand how to interact with that
          filesystem.</para>
      </note>

      <para>The Subversion client will automatically encode URLs as
        necessary, just like a web browser does.  For example, the URL
        <literal>http://host/path with space/project/españa</literal>
          which contains both spaces and upper-ASCII characters
          will be automatically interpreted by Subversion as if
        you'd provided
        <literal>http://host/path%20with%20space/project/espa%C3%B1a</literal>.
        If the URL contains spaces, be sure to place it within
        quotation marks at the command line so that your shell treats
        the whole thing as a single argument to the program.</para>

      <para>There is one notable exception to Subversion's handling of
        URLs which also applies to its handling of local paths in many
        contexts, too.  If the final path component of your URL or
        local path contains an at sign (<literal>@</literal>), you need
        to use a special syntax described in
        <xref linkend="svn.advanced.pegrevs" /> in order to make
        Subversion properly address that resource.</para>

      <para>
        <indexterm>
          <primary>repository-relative URL</primary>
        </indexterm>
        <indexterm>
          <primary>caret syntax</primary>
        </indexterm>
        <indexterm>
          <primary>^</primary>
          <see>caret syntax</see>
        </indexterm>In Subversion 1.6, a new caret (<literal>^</literal>)
        notation was introduced as a shorthand for <quote>the URL of
        the repository's root directory</quote>.  For example, you can
        use the <literal>^/tags/bigsandwich/</literal> to refer to the
        URL of the <filename>/tags/bigsandwich</filename> directory in
        the root of the repository.  Such a URL is called a
        <firstterm>repository-relative URL</firstterm>.  Note
        that this URL syntax works only when your current working
        directory is a working copy the command-line client
        knows the repository's root URL by looking at the working
        copy's metadata.  Also note that when you wish to refer
        precisely to the root directory of the repository, you must do
        so using <literal>^/</literal> (with the trailing slash
        character), not merely
        <literal>^</literal>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.basic.in-action.wc">
      <title>Subversion Working Copies</title>

      <para>
        <indexterm>
          <primary>working copies</primary>
        </indexterm>A Subversion working copy is an ordinary directory
        tree on your local system, containing a collection of files.
        You can edit these files however you wish, and if they're
        source code files, you can compile your program from them in
        the usual way.  Your working copy is your own private work
        area: Subversion will never incorporate other people's
        changes, nor make your own changes available to others, until
        you explicitly tell it to do so.  You can even have multiple
        working copies of the same project.</para>

      <para>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to <quote>publish</quote> your
        changes (by writing to the repository), thereby making them
        available to the other people working with you on your
        project.  If other people publish their own changes,
        Subversion provides you with commands to merge those changes
        into your own working copy (by reading from the repository).
        Notice that the central repository is the broker for
        everybody's changes in Subversion changes aren't passed
        directly from working copy to working copy in the typical
        workflow.</para>

      <para>
        <indexterm>
          <primary>administrative directory</primary>
        </indexterm>
        <indexterm>
          <primary>.svn</primary>
          <see>administrative directory</see>
        </indexterm>A working copy also contains some extra files,
        created and maintained by Subversion, to help it carry out
        these commands.  In particular, each working copy contains a
        subdirectory named <filename>.svn</filename>, also known as
        the working copy's <firstterm>administrative
        directory</firstterm>.  The files in the administrative
        directory help Subversion recognize which of your versioned
        files contain unpublished changes, and which files are out of
        date with respect to others' work.</para>

      <note>
        <para>Prior to version 1.7, Subversion
          maintained <filename>.svn</filename> administrative
          subdirectories in <emphasis>every</emphasis> versioned
          directory of your working copy.  Subversion 1.7 offers a
          completely new approach to how working copy metadata is
          stored and maintained, and chief among the visible changes
          to this approach is that each working copy now has only
          one <filename>.svn</filename> subdirectory which is an
          immediate child of the root of that working copy.</para>
      </note>
      
      <tip>
        <para>While <filename>.svn</filename> is the de facto name of
          the Subversion administrative directory, Windows users may
          run into problems with the ASP.NET Web application framework
          disallowing access to directories whose names begin with a
          dot (<literal>.</literal>).  As a special consideration to
          users in such situations, Subversion will instead use
          <literal>_svn</literal> as the administrative directory name
          if it finds a variable
          named <literal>SVN_ASP_DOT_NET_HACK</literal> in its
          operating environment.  Throughout this book, any reference
          you find to <filename>.svn</filename> applies also
          to <literal>_svn</literal> when this <quote>ASP.NET
          hack</quote> is in use.</para>
      </tip>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.track-repos">
        <title>How the working copy works</title>

        <para>For each file in a working directory, Subversion records
          (among other things) two essential pieces of information:</para>

        <itemizedlist>
          <indexterm>
            <primary>revisions</primary>
            <secondary>working</secondary>
          </indexterm>

          <listitem>
            <para>What revision your working file is based on (this is
              called the file's <firstterm>working
              revision</firstterm>)</para>
          </listitem>
          <listitem>
            <para>A timestamp recording when the local copy was last
              updated by the repository</para>
          </listitem>
        </itemizedlist>

        <para>Given this information, by talking to the repository,
          Subversion can tell which of the following four states a
          working file is in:</para>

        <variablelist>
          <varlistentry>
            <term>Unchanged, and current</term>
            <listitem>
              <para>The file is unchanged in the working directory, and
                no changes to that file have been committed to the
                repository since its working revision.  An <command>svn
                commit</command> of the file will do nothing, and an
                <command>svn update</command> of the file will do
                nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Locally changed, and current</term>
            <listitem>
              <para>The file has been changed in the working directory,
                and no changes to that file have been committed to the
                repository since you last updated.  There are local
                changes that have not been committed to the repository;
                thus an <command>svn commit</command> of the file will
                succeed in publishing your changes, and an <command>svn
                update</command> of the file will do nothing.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Unchanged, and out of date</term>
            <listitem>
              <para>The file has not been changed in the working
                directory, but it has been changed in the repository.
                The file should eventually be updated in order to make
                it current with the latest public revision.
                An <command>svn commit</command> of the file will do
                nothing, and an
                <command>svn update</command> of the file will fold the
                latest changes into your working copy.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Locally changed, and out of date</term>
            <listitem>
              <para>The file has been changed both in the working
                directory and in the repository.  An <command>svn
                commit</command> of the file will fail with an
                <quote>out-of-date</quote> error.  The file should be
                updated first; an <command>svn update</command> command
                will attempt to merge the public changes with the local
                changes.  If Subversion can't complete the merge in a
                plausible way automatically, it leaves it to the user to
                resolve the conflict.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.wc-funcdamentals">
        <title>Fundamental working copy interactions</title>

        <para>A typical Subversion repository often holds the files (or
          source code) for several projects; usually, each project is a
          subdirectory in the repository's filesystem tree.  In this
          arrangement, a user's working copy will usually correspond to
          a particular subtree of the repository.</para>

        <para>For example, suppose you have a repository that contains
          two software projects, <literal>paint</literal> and
          <literal>calc</literal>.  Each project lives in its own
          top-level subdirectory, as shown in <xref
          linkend="svn.basic.in-action.wc.dia-1"/>.</para>

        <figure id="svn.basic.in-action.wc.dia-1">
          <title>The repository's filesystem</title>
          <graphic fileref="images/ch02dia6.png"/>
        </figure>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>checkout</tertiary>
          </indexterm>
          <indexterm>
            <primary>checking out</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>creating</secondary>
            <see>checking out</see>
          </indexterm>To get a working copy, you must <firstterm>check
          out</firstterm> some subtree of the repository.  (The term
          <emphasis>check out</emphasis> may sound like it has something to do
          with locking or reserving resources, but it doesn't; it simply
          creates a working copy of the project for you.)  For example,
          if you check out <filename>/calc</filename>, you will get a
          working copy like this:</para>

        <informalexample>
          <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 56.
$ ls -A calc
Makefile  button.c integer.c .svn/
$
</screen>
        </informalexample>

        <para>The list of letter <literal>A</literal>s in the left
          margin indicates that Subversion is adding a number of items
          to your working copy.  You now have a personal copy of the
          repository's <filename>/calc</filename> directory, with one
          additional entry <filename>.svn</filename> which
          holds the extra information needed by Subversion, as mentioned
          earlier.</para>

        <para>
          <indexterm>
            <primary>committing</primary>
          </indexterm>
          <indexterm>
            <primary>checking in</primary>
            <see>committing</see>
          </indexterm>Suppose you make changes
          to <filename>button.c</filename>.  Since
          the <filename>.svn</filename> directory remembers the file's
          original modification date and contents, Subversion can tell
          that you've changed the file.  However, Subversion does not
          make your changes public until you explicitly tell it to.
          The act of publishing your changes is more commonly known as
          <firstterm>committing</firstterm> (or <firstterm>checking
          in</firstterm>) changes to the repository.</para>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>commit</tertiary>
          </indexterm>
          <indexterm>
            <primary>committing</primary>
          </indexterm>To publish your changes, you can use
          Subversion's <command>svn commit</command> command:</para>

        <informalexample>
          <screen>
$ svn commit button.c -m "Fixed a typo in button.c."
Sending        button.c
Transmitting file data .
Committed revision 57.
$
</screen>
        </informalexample>

        <para>Now your changes to <filename>button.c</filename> have
          been committed to the repository, with a note describing your
          change (namely, that you fixed a typo).  If another user
          checks out a working copy of <filename>/calc</filename>, she
          will see your changes in the latest version of the
          file.</para>

        <para>Suppose you have a collaborator, Sally, who checked out a
          working copy of <filename>/calc</filename> at the same time
          you did.  When you commit your change to
          <filename>button.c</filename>, Sally's working copy is left
          unchanged; Subversion modifies working copies only at the
          user's request.</para>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>update</tertiary>
          </indexterm>
          <indexterm>
            <primary>updating</primary>
          </indexterm>
          <indexterm>
            <primary>working copies</primary>
            <secondary>updating</secondary>
            <see>updating</see>
          </indexterm>To bring her project up to date, Sally can ask
          Subversion to <firstterm>update</firstterm> her working
          copy, by using the <command>svn update</command> command.
          This will incorporate your changes into her working copy, as
          well as any others that have been committed since she
          checked it out.</para>

        <informalexample>
          <screen>
$ pwd
/home/sally/calc
$ ls -A
Makefile button.c integer.c .svn/
$ svn update
Updating '.':
U    button.c
Updated to revision 57.
$
</screen>
        </informalexample>

        <para>The output from the <command>svn update</command> command
          indicates that Subversion updated the contents of
          <filename>button.c</filename>.  Note that Sally didn't need to
          specify which files to update; Subversion uses the information
          in the <filename>.svn</filename> directory as well as further
          information in the repository, to decide which files need to
          be brought up to date.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.basic.in-action.mixedrevs">
        <title>Mixed-revision working copies</title>

        <para>
          <indexterm>
            <primary>working copies</primary>
            <secondary>mixed-revision</secondary>
          </indexterm>As a general principle, Subversion tries to be
          as flexible as possible.  One special kind of flexibility is
          the ability to have a working copy containing files and
          directories with a mix of different working revision
          numbers.  Subversion working copies do not always correspond
          to any single revision in the repository; they may contain
          files from several different revisions.  For example,
          suppose you check out a working copy from a repository whose
          most recent revision is 4:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:4
</literallayout>
        </informalexample>

        <para>At the moment, this working directory corresponds exactly
          to revision 4 in the repository.  However, suppose you make a
          change to <filename>button.c</filename>, and commit that
          change.  Assuming no other commits have taken place, your
          commit will create revision 5 of the repository, and your
          working copy will now look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:4
   integer.c:4
   button.c:5
</literallayout>
        </informalexample>

        <para>Suppose that, at this point, Sally commits a change to
          <filename>integer.c</filename>, creating revision 6.  If you
          use <command>svn update</command> to bring your working copy
          up to date, it will look like this:</para>

        <informalexample>
          <literallayout>
calc/
   Makefile:6
   integer.c:6
   button.c:6
</literallayout>
        </informalexample>

        <para>Sally's change to <filename>integer.c</filename> will
          appear in your working copy, and your change will still be
          present in <filename>button.c</filename>.  In this example,
          the text of <filename>Makefile</filename> is identical in
          revisions 4, 5, and 6, but Subversion will mark your working
          copy of <filename>Makefile</filename> with revision 6 to
          indicate that it is still current.  So, after you do a clean
          update at the top of your working copy, it will generally
          correspond to exactly one revision in the repository.</para>
  
        <sect4 id="svn.basic.in-action.mixedrevs.update-commit">
          <title>Updates and commits are separate</title>

          <para>One of the fundamental rules of Subversion is that
            a <quote>push</quote> action does not cause
            a <quote>pull</quote> nor vice versa.  Just
            because you're ready to submit new changes to the repository
            doesn't mean you're ready to receive changes that others
            have checked in.  And if you have new changes still in progress,
            <command>svn update</command> should gracefully merge
            repository changes into your own, rather than forcing you to
            publish them.</para>

          <para>The main side effect of this rule is that it means a
            working copy has to do extra bookkeeping to track mixed
            revisions as well as be tolerant of the mixture.  It's made
            more complicated by the fact that directories themselves are
            versioned.</para>

          <para>For example, suppose you have a working copy entirely
            at revision 10, while others have been committing their
            changes so that the youngest revision in the repository is
            now revision 14.  You edit the file
            <filename>foo.html</filename> and then perform
            an <command>svn commit</command>, which creates revision
            15 in the repository.  After the commit succeeds, many new
            users would expect the working copy to be entirely at
            revision 15, but that's not the case!  Any number of
            changes might have happened in the repository between
            revisions 10 and 15.  The client knows nothing of those
            changes in the repository, since you haven't yet
            run <command>svn update</command>, and <command>svn
            commit</command> doesn't pull down new changes.  If, on
            the other hand, <command>svn commit</command> were to
            automatically download the newest changes, it would be
            possible to set the entire working copy to revision
            15 but then we'd be breaking the fundamental rule
            of <quote>push</quote> and <quote>pull</quote> remaining
            separate actions.  Therefore, the only safe thing the
            Subversion client can do is mark the one
            file <filename>foo.html</filename> as being at
            revision 15.  The rest of the working copy remains at
            revision 10.  Only by running <command>svn
            update</command> can the latest changes be downloaded and
            the whole working copy be marked as revision 15.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.normal">
          <title>Mixed revisions are normal</title>

          <para>The fact is, <emphasis>every time</emphasis> you run
            <command>svn commit</command> your working copy ends up
            with some mixture of revisions.  The things you just
            committed are marked as having larger working revisions than
            everything else.  After several commits (with no updates
            in between), your working copy will contain a whole mixture
            of revisions.  Even if you're the only person using the
            repository, you will still see this phenomenon.  To examine
            your mixture of working revisions, use the <command>svn
            status</command> command with the <option>--verbose</option>
            (<option>-v</option>) option (see
            <xref linkend="svn.tour.cycle.examine.status"/> for more
            information).</para>

          <para>Often, new users are completely unaware that their
            working copy contains mixed revisions.  This can be
            confusing, because many client commands are sensitive to the
            working revision of the item they're examining.  For
            example, the <command>svn log</command> command is used to
            display the history of changes to a file or directory (see
            <xref linkend="svn.tour.history.log"/>).  When the user
            invokes this command on a working copy object, he expects
            to see the entire history of the object.  But if the
            object's working revision is quite old (often because
            <command>svn update</command> hasn't been run in a long
            time), the history of the <emphasis>older</emphasis>
            version of the object is shown.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.useful">
          <title>Mixed revisions are useful</title>

          <para>
            <indexterm>
              <primary>backdating</primary>
            </indexterm>If your project is sufficiently complex, you'll
            discover that it's sometimes nice to
            forcibly <firstterm>backdate</firstterm> (or update to a
            revision older than the one you already have) portions of
            your working copy to an earlier revision; you'll learn how
            to do that in <xref linkend="svn.tour"/>.  Perhaps you'd
            like to test an earlier version of a submodule contained
            in a subdirectory, or perhaps you'd like to figure out
            when a bug first came into existence in a specific file.
            This is the <quote>time machine</quote> aspect of a
            version control system the feature that allows you
            to move any portion of your working copy forward and
            backward in history.</para>

        </sect4>

        <sect4 id="svn.basic.in-action.mixedrevs.limits">
          <title>Mixed revisions have limitations</title>

          <para>However you make use of mixed revisions in your working
            copy, there are limitations to this flexibility.</para>

          <para>First, you cannot commit the deletion of a file or
            directory that isn't fully up to date.  If a newer version
            of the item exists in the repository, your attempt to delete
            will be rejected to prevent you from accidentally
            destroying changes you've not yet seen.</para>

          <para>Second, you cannot commit a metadata change to a
            directory unless it's fully up to date.  You'll learn about
            attaching <quote>properties</quote> to items in <xref
            linkend="svn.advanced"/>.  A directory's working revision
            defines a specific set of entries and properties, and thus
            committing a property change to an out-of-date directory may
            destroy properties you've not yet seen.</para>

          <para>Finally, beginning in Subversion 1.7, you cannot by
            default use a mixed-revision working copy as the target of
            a merge operation.  (This new requirement was introduced
            to prevent common problems which stem from doing so.)</para>

        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.basic.summary">
    <title>Summary</title>
    
    <para>We covered a number of fundamental Subversion concepts in
      this chapter:</para>

    <itemizedlist>
      <listitem>
        <para>We introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</para>
      </listitem>

      <listitem>
        <para>We saw some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the <quote>copy-modify-merge</quote>
          model.</para>
      </listitem>

      <listitem>
        <para>We talked a bit about the way Subversion tracks and
          manages information in a working copy.</para>
      </listitem>

    </itemizedlist>

    <para>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to move into the next chapter, which is a
      detailed tour of Subversion's commands and features.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.tour">
  <title>Basic Usage</title>

  <para>Theory is useful, but its application is just plain fun.
    Let's move now into the details of using Subversion.  By the time
    you reach the end of this chapter, you will be able to perform all
    the tasks you need to use Subversion in a normal day's work.
    You'll start with getting your files into Subversion, followed by
    an initial checkout of your code.  We'll then walk you through
    making changes and examining those changes.  You'll also see how
    to bring changes made by others into your working copy, examine
    them, and work through any conflicts that might arise.</para>

  <para>This chapter will not provide exhaustive coverage
    of all of Subversion's commands rather, it's a conversational
    introduction to the most common Subversion tasks that you'll
    encounter.  This chapter assumes that you've read and understood
    <xref linkend="svn.basic"/> and are familiar with the general
    model of Subversion.  For a complete reference of all commands,
    see <xref linkend="svn.ref.svn"/>.</para>

  <para>Also, this chapter assumes that the reader is seeking
    information about how to interact in a basic fashion with an
    existing Subversion repository.  No repository means no working
    copy; no working copy means not much of interest in this chapter.
    There are many Internet sites which offer free or inexpensive
    Subversion repository hosting services.  Or, if you'd prefer to
    set up and administer your own repositories, check out
    <xref linkend="svn.reposadmin"/>.  But don't expect the
    examples in this chapter to work without the user having access
    to a Subversion repository.</para>

  <para>Finally, any Subversion operation that contacts the repository
    over a network may potentially require that the user authenticate.
    For the sake of simplicity, our examples throughout this chapter
    avoid demonstrating and discussing authentication.  Be aware that
    if you hope to apply the knowledge herein to an existing,
    real-world Subversion instance, you'll probably be forced to
    provide at least a username and password to the server.  See
    <xref linkend="svn.serverconfig.netmodel.creds"/> for a detailed
    description of Subversion's handling of authentication and client
    credentials.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.help">
    <title>Help!</title>

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <para>It goes without saying that this book exists to be a source
      of information and assistance for Subversion users new and old.
      Conveniently, though, the Subversion command-line is
      self-documenting, alleviating the need to grab a book off the
      shelf (wooden, virtual, or otherwise).  The <command>svn
      help</command> command is your gateway to that built-in
      documentation:</para>

    <informalexample>
      <screen>
$ svn help
Subversion command-line client, version 1.7.0.
Type 'svn help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svn --version' to see the program version and RA modules
  or 'svn --version --quiet' to see just the version number.

Most subcommands take file and/or directory arguments, recursing
on the directories.  If no arguments are supplied to such a
command, it recurses on the current directory (inclusive) by default.

Available subcommands:
   add
   blame (praise, annotate, ann)
   cat
 
</screen>
    </informalexample>

    <para>As described in the previous output, you can ask for help on
      a particular subcommand by running <userinput>svn help
      <replaceable>SUBCOMMAND</replaceable></userinput>.  Subversion
      will respond with the full usage message for that subcommand,
      including its syntax, options, and behavior:</para>

    <informalexample>
      <screen>
$ svn help help
help (?, h): Describe the usage of this program or its subcommands.
usage: help [SUBCOMMAND...]

Global options:
  --username ARG           : specify a username ARG
  --password ARG           : specify a password ARG
 
</screen>
    </informalexample>

    <sidebar>
      <title>Options and Switches and Flags, Oh My!</title>
        
      <indexterm>
        <primary>svn</primary>
        <secondary>options</secondary>
      </indexterm>

      <para>The Subversion command-line client has numerous command
        modifiers.  Some folks refer to such things
        as <quote>switches</quote> or <quote>flags</quote> in
        this book, we'll call them <quote>options</quote>.  You'll
        find the options supported by a given <command>svn</command>
        subcommand, plus a set of options which are globally supported
        by all subcommands, listed near the bottom of the built-in
        usage message for that subcommand.</para>

      <para>Subversion's options have two distinct forms:  short
        options are a single hyphen followed by a single letter, and
        long options consist of two hyphens followed by several
        letters and hyphens (e.g., <literal>-s</literal>
        and <literal>--this-is-a-long-option</literal>, respectively).
        Every option has at least one long format.  Some, such as
        the <option>--changelist</option> option, feature an
        abbreviated long-format alias (<option>--cl</option>, in this
        case).  Only certain options generally the most-used
        ones have an additional short format.  To maintain
        clarity in this book, we usually use the long form in code
        examples, but when describing options, if there's a short
        form, we'll provide the long form (to improve clarity) and the
        short form (to make it easier to remember).  Use the form
        you're more comfortable with when executing your own
        Subversion commands.</para>

    </sidebar>

    <para>Many Unix-based distributions of Subversion include manual
      pages of the sort that can be invoked using
      the <command>man</command> program, but those tend to carry only
      pointers to other sources of real help, such as the project's
      website and to the website which hosts this book.  Also, several
      companies offer Subversion help and support, too, usually via a
      mixture of web-based discussion forums and fee-based consulting.
      And of course, the Internet holds a decade's worth of
      Subversion-related discussions just begging to be located by
      your favorite search engine.  Subversion help is never too far
      away.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.importing">
    <title>Getting Data into Your Repository</title>

    <para>You can get new files into your Subversion
      repository in two ways: <command>svn import</command> and <command>svn
      add</command>.  We'll discuss <command>svn import</command> now
      and will discuss <command>svn add</command> later in this
      chapter when we review a typical day with Subversion.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.import">
      <title>Importing Files and Directories</title>

      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands</secondary>
        <tertiary>import</tertiary>
      </indexterm>

      <para>The <command>svn import</command> command is a quick way to
        copy an unversioned tree of files into a repository, creating
        intermediate directories as necessary.  <command>svn
        import</command> doesn't require a working copy, and your files
        are immediately committed to the repository.  You typically
        use this when you have an existing tree of files that you want to
        begin tracking in your Subversion repository.  For example:</para>

      <informalexample>
        <screen>
$ svn import /path/to/mytree \
             http://svn.example.com/svn/repo/some/project \
             -m "Initial import"
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.
$
</screen>
      </informalexample>

      <para>The previous example copied the contents of the local
        directory <filename>mytree</filename> into the directory
        <filename>some/project</filename> in the repository.  Note
        that you didn't have to create that new directory
        first <command>svn import</command> does that for you.
        Immediately after the commit, you can see your data in the
        repository:</para>

      <informalexample>
        <screen>
$ svn list http://svn.example.com/svn/repo/some/project
bar.c
foo.c
subdir/
$
</screen>
      </informalexample>

      <para>Note that after the import is finished, the original local
        directory is <emphasis>not</emphasis> converted into a working
        copy.  To begin working on that data in a versioned fashion,
        you still need to create a fresh working copy of that
        tree.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.layout">
      <title>Recommended Repository Layout</title>

      <para>Subversion provides the ultimate flexibility in terms of
        how you arrange your data.  Because it simply versions
        directories and files, and because it ascribes no particular
        meaning to any of those objects, you may arrange the data in
        your repository in any way that you choose.  Unfortunately,
        this flexibility also means that it's easy to find
        yourself <quote>lost without a roadmap</quote> as you attempt
        to navigate different Subversion repositories which may carry
        completely different and unpredictable arrangements of the
        data within them.</para>

      <para>
        <indexterm>
          <primary>trunk</primary>
        </indexterm>
        <indexterm>
          <primary>tags</primary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
        </indexterm>
        <indexterm>
          <primary>project root</primary>
        </indexterm>To counteract this confusion, we recommend that
        you follow a repository layout convention (established long
        ago, in the nascency of the Subversion project itself) in
        which a handful of strategically named Subversion repository
        directories convey valuable meaning about the data they hold.
        Most projects have a recognizable <quote>main line</quote>,
        or <firstterm>trunk</firstterm>, of development;
        some <firstterm>branches</firstterm>, which are divergent
        copies of development lines; and
        some <firstterm>tags</firstterm>, which are named, stable
        snapshots of a particular line of development.  So we first
        recommend that each project have a
        recognizable <firstterm>project root</firstterm> in the
        repository, a directory under which all of the versioned
        information for that project and only that
        project lives.  Secondly, we suggest that each project
        root contain a <filename>trunk</filename> subdirectory for the
        main development line, a
        <filename>branches</filename> subdirectory in which specific
        branches (or collections of branches) will be created, and
        a <filename>tags</filename> subdirectory in which specific
        tags (or collections of tags) will be created.  Of course, if
        a repository houses only a single project, the root of the
        repository can serve as the project root, too.</para>

      <para>Here are some examples:</para>

      <informalexample>
        <screen>
$ svn list file:///var/svn/single-project-repo
trunk/
branches/
tags/
$ svn list file:///var/svn/multi-project-repo
project-A/
project-B/
$ svn list file:///var/svn/multi-project-repo/project-A
trunk/
branches/
tags/
$
</screen>
      </informalexample>

      <para>We talk much more about tags and branches in
        <xref linkend="svn.branchmerge"/>.  For details and some
        advice on how to set up repositories when you have multiple
        projects, see <xref linkend="svn.branchmerge.maint.layout"/>.
        Finally, we discuss project roots more in
        <xref linkend="svn.reposadmin.projects.chooselayout"/>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.importing.naming">
      <title>What's In a Name?</title>

      <para>Subversion tries hard not to limit the type of data you
        can place under version control.  The contents of files and
        property values are stored and transmitted as binary data, and
        <xref linkend="svn.advanced.props.special.mime-type"/>
        tells you how to give Subversion a hint that
        <quote>textual</quote> operations don't make sense for a
        particular file.  There are a few places, however, where
        Subversion places restrictions on information it
        stores.</para>

      <para>Subversion internally handles certain bits of
        data for example, property names, pathnames, and log
        messages as UTF-8-encoded Unicode.  This is not to say
        that all your interactions with Subversion must involve UTF-8,
        though.  As a general rule, Subversion clients will gracefully
        and transparently handle conversions between UTF-8 and the
        encoding system in use on your computer, if such a conversion
        can meaningfully be done (which is the case for most common
        encodings in use today).</para>

      <para>In WebDAV exchanges and older versions of some of
        Subversion's administrative files, paths are used as XML
        attribute values, and property names in XML tag names.  This
        means that pathnames can contain only legal XML (1.0)
        characters, and properties are further limited to ASCII
        characters.  Subversion also prohibits <literal>TAB</literal>,
        <literal>CR</literal>, and <literal>LF</literal> characters in
        path names to prevent paths from being broken up in diffs or
        in the output of commands such as <command>svn log</command>
        or <command>svn status</command>.</para>

      <para>While it may seem like a lot to remember, in practice
        these limitations are rarely a problem.  As long as your
        locale settings are compatible with UTF-8 and you don't use
        control characters in path names, you should have no trouble
        communicating with Subversion.  The command-line client adds
        an extra bit of help to create
        <quote>legally correct</quote> versions for internal
        use it will automatically escape illegal
        path characters as needed in URLs that you type.</para>

      <warning>
        <para>Of course, when it comes to choosing valid path names,
          Subversion isn't the only limiting factor.  Teams using
          multiple operating systems need to consider the limitations
          placed on path names by those operating systems, too.  For
          example, while Windows disallows the use of colon characters
          in file names, a user on a Linux system can very easily add
          such a file to version control, resulting in a dataset that
          can no longer be checked out on Windows.  Adding multiple
          files to a directory whose names differ only in their letter
          casing will likewise cause problems for users checking out
          working copies onto case-insensitive filesystems.  So, some
          broad awareness of the various limitations introduced by
          different operating systems and filesystems, then, is
          recommended.</para>
      </warning>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.initial">
    <title>Creating a Working Copy</title>

    <para>
      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands</secondary>
        <tertiary>checkout</tertiary>
      </indexterm>Most of the time, you will start using a Subversion
      repository by performing a <firstterm>checkout</firstterm> of
      your project.  Checking out a directory from a repository
      creates a working copy of that directory on your local machine.
      Unless otherwise specified, this copy contains the youngest
      (that is, most recently created or modified) versions of the
      directory and its children found in the Subversion
      repository:</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/svn/repo/trunk
A    trunk/README
A    trunk/INSTALL
A    trunk/src/main.c
A    trunk/src/header.h
 
Checked out revision 8810.
$
</screen>
    </informalexample>

    <para>Although the preceding example checks out the trunk
      directory, you can just as easily check out a deeper
      subdirectory of a repository by specifying that subdirectory's
      URL as the checkout URL:</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/svn/repo/trunk/src
A    src/main.c
A    src/header.h
A    src/lib/helpers.c
 
Checked out revision 8810.
$
</screen>
    </informalexample>

    <para>Since Subversion uses a copy-modify-merge model instead of
      lock-modify-unlock (see <xref linkend="svn.basic.vsn-models"/>),
      you can immediately make changes to the files and directories in
      your working copy.  Your working copy is just like any other
      collection of files and directories on your system.  You can
      edit the files inside it, rename it, even delete the entire
      working copy and forget about it.</para>

    <warning>
      <para>While your working copy is <quote>just like any other
        collection of files and directories on your system,</quote>
        you can edit files at will, but you must tell Subversion
        about <emphasis>everything else</emphasis> that you do.  For
        example, if you want to copy or move an item in a working
        copy, you should use <command>svn copy</command> or
        <command>svn move</command> instead of the copy and move
        commands provided by your operating system.  We'll talk more
        about them later in this chapter.</para>
    </warning>

    <para>Unless you're ready to commit the addition of a new file or
      directory or changes to existing ones, there's no need to
      further notify the Subversion server that you've done
      anything.</para>

    <sidebar>
      <title>What Is This .svn Directory?</title>

      <para>The topmost directory of a working copy and prior to
        version 1.7, every versioned subdirectory
        thereof contains a special administrative subdirectory
        named <filename>.svn</filename>.  Usually, your operating
        system's directory listing commands won't show this
        subdirectory, but it is nevertheless an important directory.
        Whatever you do, don't delete or change anything in the
        administrative area!  Subversion uses that directory and its
        contents to manage your working copy.</para>
    </sidebar>

    <para>Notice that in the previous pair of examples, Subversion
      chose to create a working copy in a directory named for the
      final component of the checkout URL.  This occurs only as a
      convenience to the user when the checkout URL is the only bit of
      information provided to the <command>svn checkout</command>
      command.  Subversion's command-line client gives you additional
      flexibility, though, allowing you to optionally specify the
      local directory name that Subversion should use for the working
      copy it creates.  For example:</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/svn/repo/trunk my-working-copy
A    my-working-copy/README
A    my-working-copy/INSTALL
A    my-working-copy/src/main.c
A    my-working-copy/src/header.h
 
Checked out revision 8810.
$
</screen>
    </informalexample>

    <para>If the local directory you specify doesn't yet
      exist, that's okay <command>svn checkout</command> will
      create it for you.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.cycle">
    <title>Basic Work Cycle</title>

    <para>Subversion has numerous features, options, bells, and
      whistles, but on a day-to-day basis, odds are that you will use
      only a few of them.  In this section, we'll run through the most
      common things that you might find yourself doing with Subversion
      in the course of a day's work.</para>

    <para>The typical work cycle looks like this:</para>

    <orderedlist>
      <listitem>
        <para><emphasis>Update your working copy.</emphasis> This
          involves the use of the <command>svn update</command>
          command.</para>
      </listitem>
      <listitem>
        <para><emphasis>Make your changes.</emphasis> The most common
          changes that you'll make are edits to the contents of your
          existing files.  But sometimes you need to add, remove, copy
          and move files and directories the <command>svn
          add</command>, <command>svn delete</command>, <command>svn
          copy</command>, and <command>svn move</command> commands
          handle those sorts of structural changes within the working
          copy.</para>
      </listitem>
      <listitem>
        <para><emphasis>Review your changes.</emphasis>
          The <command>svn status</command> and <command>svn
          diff</command> commands are critical to reviewing the
          changes you've made in your working copy.</para>
      </listitem>
      <listitem>
        <para><emphasis>Fix your mistakes.</emphasis>  Nobody's
          perfect, so as you review your changes, you may spot
          something that's not quite right.  Sometimes the easiest way
          to fix a mistake is start all over again from scratch.
          The <command>svn revert</command> command restores a file
          or directory to its unmodified state.</para>
      </listitem>
      <listitem>
        <para><emphasis>Resolve any conflicts (merge others'
          changes).</emphasis>  In the time it takes you to make and
          review your changes, others might have made and published
          changes, too.  You'll want to integrate their changes into
          your working copy to avoid the potential out-of-dateness
          scenarios when you attempt to publish your own.  Again,
          the <command>svn update</command> command is the way to do
          this.  If this results in local conflicts, you'll need to
          resolve those using the <command>svn resolve</command>
          command.</para>
      </listitem>
      <listitem>
        <para><emphasis>Publish (commit) your changes.</emphasis>
          The <command>svn commit</command> command transmits your
          changes to the repository where, if they are accepted, they
          create the newest versions of all the things you modified.
          Now others can see your work, too!</para>
      </listitem>
    </orderedlist>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.update">
      <title>Update Your Working Copy</title>

      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands</secondary>
        <tertiary>update</tertiary>
      </indexterm>

      <para>When working on a project that is being modified via
        multiple working copies, you'll want to update your working
        copy to receive any changes committed from other working
        copies since your last update.  These might be changes that
        other members of your project team have made, or they might
        simply be changes you've made yourself from a different
        computer.  To protect your data, Subversion won't
        allow you commit new changes to out-of-date files and
        directories, so it's best to have the latest versions
        of all your project's files and directories before making new
        changes of your own.</para>

      <para>Use <command>svn update</command> to bring your working
        copy into sync with the latest revision in the
        repository:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
U    foo.c
U    bar.c
Updated to revision 2.
$
</screen>
      </informalexample>

      <para>In this case, it appears that someone checked in
        modifications to both <filename>foo.c</filename>
        and <filename>bar.c</filename> since the last time you
        updated, and Subversion has updated your working copy to
        include those changes.</para>

      <para>When the server sends changes to your working copy via
        <command>svn update</command>, a letter code is displayed next
        to each item to let you know what actions Subversion performed
        to bring your working copy up to date.  To find out what these
        letters mean, run <userinput>svn help update</userinput> or
        see <xref linkend="svn.ref.svn.c.update"/> in
        <xref linkend="svn.ref.svn"/>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.edit">
      <title>Make Your Changes </title>

      <para>
        <indexterm>
          <primary>file changes</primary>
        </indexterm>
        <indexterm>
          <primary>tree changes</primary>
        </indexterm>Now you can get to work and make changes in your
        working copy.  You can make two kinds of changes to your
        working copy: <firstterm>file changes</firstterm>
        and <firstterm>tree changes</firstterm>.  You don't need to
        tell Subversion that you intend to change a file; just make
        your changes using your text editor, word processor, graphics
        program, or whatever tool you would normally use.  Subversion
        automatically detects which files have been changed, and in
        addition, it handles binary files just as easily as it handles
        text files and just as efficiently, too.  Tree changes
        are different, and involve changes to a directory's structure.
        Such changes include adding and removing files, renaming files
        or directories, and copying files or directories to new
        locations.  For tree changes, you use Subversion operations
        to <quote>schedule</quote> files and directories for removal,
        addition, copying, or moving.  These changes may take place
        immediately in your working copy, but no additions or removals
        will happen in the repository until you commit them.</para>

      <sidebar>
        <title>Versioning Symbolic Links</title>

        <para>
          <indexterm>
            <primary>svmlink</primary>
          </indexterm>
          <indexterm>
            <primary>svmbolic link</primary>
            <see>symlink</see>
          </indexterm>On non-Windows platforms, Subversion is able to
          version files of the special type <firstterm>symbolic
          link</firstterm> (or <quote>symlink</quote>).  A symlink is
          a file that acts as a sort of transparent reference to some
          other object in the filesystem, allowing programs to read
          and write to those objects indirectly by performing
          operations on the symlink itself.</para>

        <para>When a symlink is committed into a Subversion
          repository, Subversion remembers that the file was in fact a
          symlink, as well as the object to which the symlink
          <quote>points.</quote>  When that symlink is checked out to
          another working copy on a non-Windows system, Subversion
          reconstructs a real filesystem-level symbolic link from the
          versioned symlink.  But that doesn't in any way limit the
          usability of working copies on systems such as Windows that
          do not support symlinks.  On such systems, Subversion simply
          creates a regular text file whose contents are the path to
          which the original symlink pointed.  While that file
          can't be used as a symlink on a Windows system, it also
          won't prevent Windows users from performing their other
          Subversion-related activities.</para> </sidebar>

      <para>Here is an overview of the five Subversion subcommands
        that you'll use most often to make tree changes:</para>

      <variablelist>

        <varlistentry>
          <term><userinput>svn add FOO</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands</secondary>
              <tertiary>add</tertiary>
            </indexterm>
            <para>Use this to schedule the file, directory, or
              symbolic link <filename>FOO</filename> to be added to
              the repository.  When you next
              commit, <filename>FOO</filename> will become a child of
              its parent directory.  Note that if
              <filename>FOO</filename> is a directory, everything
              underneath <filename>FOO</filename> will be scheduled
              for addition.  If you want only to add
              <filename>FOO</filename> itself, pass the
              <option>--depth=empty</option> option.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn delete FOO</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands</secondary>
              <tertiary>delete</tertiary>
            </indexterm>
            <para>Use this to schedule the file, directory, or
              symbolic link <filename>FOO</filename> to be deleted
              from the repository.  If <filename>FOO</filename> is a
              file or link, it is immediately deleted from your
              working copy.  If <filename>FOO</filename> is a
              directory, it is not deleted, but Subversion schedules
              it for deletion.  When you commit your
              changes, <filename>FOO</filename> will be entirely
              removed from your working copy and the
              repository.<footnote><para>Of course, nothing is ever
              totally deleted from the repository just from
              its <literal>HEAD</literal> revision.  You may continue
              to access the deleted item in previous revisions.
              Should you desire to resurrect the item so that it is
              again present in <literal>HEAD</literal>, see
              <xref linkend="svn.branchmerge.basicmerging.resurrect"
              />.</para></footnote></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn copy FOO BAR</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands</secondary>
              <tertiary>copy</tertiary>
            </indexterm>
            <para>Create a new item <filename>BAR</filename> as a
              duplicate of <filename>FOO</filename> and automatically
              schedule <filename>BAR</filename> for addition.  When
              <filename>BAR</filename> is added to the repository on
              the next commit, its copy history is recorded (as having
              originally come from <filename>FOO</filename>).
              <command>svn copy</command> does not create intermediate
              directories unless you pass the
              <option>--parents</option> option.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn move FOO BAR</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands</secondary>
              <tertiary>move</tertiary>
            </indexterm>
            <para>This command is exactly the same as running
              <userinput>svn copy FOO BAR; svn delete FOO</userinput>.
              That is, <filename>BAR</filename> is scheduled for
              addition as a copy of <filename>FOO</filename>, and
              <filename>FOO</filename> is scheduled for removal.
              <command>svn move</command> does not create intermediate
              directories unless you pass the
              <option>--parents</option> option.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>svn mkdir FOO</userinput></term>
          <listitem>
            <indexterm>
              <primary>svn</primary>
              <secondary>subcommands</secondary>
              <tertiary>mkdir</tertiary>
            </indexterm>
            <para>This command is exactly the same as running
              <userinput>mkdir FOO; svn add FOO</userinput>.  That is,
              a new directory named <filename>FOO</filename> is
              created and scheduled for addition.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <sidebar>
        <title>Changing the Repository Without a Working Copy</title>

        <para>Subversion <emphasis>does</emphasis> offer ways to
          immediately commit tree changes to the repository without an
          explicit commit action.  In particular, specific uses
          of <command>svn mkdir</command>, <command>svn
          copy</command>, <command>svn move</command>, and
          <command>svn delete</command> can operate directly on
          repository URLs as well as on working copy paths.  Of
          course, as previously mentioned, <command>svn
          import</command> always makes direct changes to the
          repository.</para>

        <para>There are pros and cons to performing URL-based
          operations.  One obvious advantage to doing so is speed:
          sometimes, checking out a working copy that you don't
          already have solely to perform some seemingly simple action
          is an overbearing cost.  A disadvantage is that you are
          generally limited to a single, or single type of, operation
          at a time when operating directly on URLs.  Finally, the
          primary advantage of a working copy is in its utility as a
          sort of <quote>staging area</quote> for changes.  You can
          make sure that the changes you are about to commit make
          sense in the larger scope of your project before committing
          them.  And, of course, these staged changes can be as
          complex or as a simple as they need to be, yet result in but
          a single new revision when committed.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.examine">
      <title>Review Your Changes</title>

      <para>
        <indexterm>
          <primary>log message</primary>
        </indexterm>Once you've finished making changes, you need to commit
        them to the repository, but before you do so, it's usually a
        good idea to take a look at exactly what you've changed.  By
        examining your changes before you commit, you can compose a
        more accurate <firstterm>log message</firstterm> (a
        human-readable description of the committed changes stored
        alongside those changes in the repository).  You may also
        discover that you've inadvertently changed a file, and that
        you need to undo that change before committing.  Additionally,
        this is a good opportunity to review and scrutinize changes
        before publishing them.  You can see an overview of the
        changes you've made by using the <command>svn status</command>
        command, and you can dig into the details of those changes by
        using the <command>svn diff</command> command.</para>

      <sidebar>
        <title>Look Ma! No Network!</title>

        <para>You can use the commands <command>svn status</command>,
          <command>svn diff</command>, and <command>svn
          revert</command> without any network access even if your
          repository <emphasis>is</emphasis> across the network.  This
          makes it easy to manage and review your changes-in-progress
          when you are working offline or are otherwise unable to
          contact your repository over the network.</para>

        <para>
          <indexterm>
            <primary>text-base</primary>
          </indexterm>
          <indexterm>
            <primary>delta</primary>
          </indexterm>Subversion does this by keeping private caches
          of pristine, unmodified versions of each versioned file
          inside its working copy administrative area (or prior to
          version 1.7, potentially multiple administrative areas).
          This allows Subversion to report and
          revert local modifications to those
          files <emphasis>without network access</emphasis>.  This
          cache (called the
          <firstterm>text-base</firstterm>) also allows Subversion to
          send the user's local modifications during a commit to the
          server as a compressed <firstterm>delta</firstterm> (or
          <quote>difference</quote>) against the pristine version.
          Having this cache is a tremendous benefit even if you
          have a fast Internet connection, it's generally much faster
          to send only a file's changes rather than the whole file to
          the server.</para>

      </sidebar>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.examine.status">
        <title>See an overview of your changes</title>

        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>status</tertiary>
        </indexterm>

        <para>To get an overview of your changes, use the
          <command>svn status</command> command.  You'll probably use
          <command>svn status</command> more than any other Subversion
          command.</para>

        <tip>
          <para>Because the <command>cvs status</command> command's
            output was so noisy, and because <command>cvs
            update</command> not only performs an update, but also
            reports the status of your local changes, most CVS users
            have grown accustomed to using <command>cvs
            update</command> to report their changes.  In Subversion,
            the update and status reporting facilities are completely
            separate.  See
            <xref linkend="svn.forcvs.status-vs-update"/> for more
            details.</para>
        </tip>

        <para>If you run <userinput>svn status</userinput> at the top
          of your working copy with no additional arguments, it will
          detect and report all file and tree changes you've
          made.</para>

        <informalexample>
          <screen>
$ svn status
?       scratch.c
A       stuff/loot
A       stuff/loot/new.c
D       stuff/old.c
M       bar.c
$
</screen>
        </informalexample>

        <para>In its default output mode, <command>svn
          status</command> prints seven columns of characters,
          followed by several whitespace characters, followed by a
          file or directory name.  The first column tells the status
          of a file or directory and/or its contents.  Some of the
          most common codes that <command>svn status</command>
          displays are:</para>

        <variablelist>

          <varlistentry>
            <term><computeroutput>?      item</computeroutput></term>
            <listitem>
              <para>The file, directory, or symbolic link
                <filename>item</filename> is not under version
                control.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>A      item</computeroutput></term>
            <listitem>
              <para>The file, directory, or symbolic link
                <filename>item</filename> has been scheduled for
                addition into the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>C      item</computeroutput></term>
            <listitem>
              <para>The file <filename>item</filename> is in a state
                of conflict.  That is, changes received from the
                server during an update overlap with local changes
                that you have in your working copy (and weren't
                resolved during the update).  You must resolve this
                conflict before committing your changes to the
                repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>D      item</computeroutput></term>
            <listitem>
              <para>The file, directory, or symbolic link
                <filename>item</filename> has been scheduled for
                deletion from the repository.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><computeroutput>M      item</computeroutput></term>
            <listitem>
              <para>The contents of the file <filename>item</filename>
                have been modified.</para>
            </listitem>
          </varlistentry>

        </variablelist>

        <para>If you pass a specific path to <command>svn
          status</command>, you get information about that item
          alone:</para>

        <informalexample>
          <screen>
$ svn status stuff/fish.c
D       stuff/fish.c
</screen>
        </informalexample>

        <para><command>svn status</command> also has a
          <option>--verbose</option> (<option>-v</option>) option,
          which will show you the status of <emphasis>every</emphasis>
          item in your working copy, even if it has not been
          changed:</para>

        <informalexample>
          <screen>
$ svn status -v
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c
</screen>
        </informalexample>

        <para>This is the <quote>long form</quote> output of
          <command>svn status</command>.  The letters in the first
          column mean the same as before, but the second column shows
          the working revision of the item.  The third and fourth
          columns show the revision in which the item last changed,
          and who changed it.</para>

        <para>None of the prior invocations to <command>svn
          status</command> contact the repository they merely
          report what is known about the working copy items based on
          the records stored in the working copy administrative area
          and on the timestamps and contents of modified files.  But
          sometimes it is useful to see which of the items in your
          working copy have been modified in the repository since the
          last time you updated your working copy.  For
          this, <command>svn status</command> offers the
          <option>--show-updates</option> (<option>-u</option>)
          option, which contacts the repository and adds information
          about items that are out of date:</para>

        <informalexample>
          <screen>
$ svn status -u -v
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46
</screen>
        </informalexample>

        <para>Notice in the previous example the two asterisks: if you
          were to run <userinput>svn update</userinput> at this point,
          you would receive changes to <filename>README</filename>
          and <filename>trout.c</filename>.  This tells you some very
          useful information because one of those items is also
          one that you have locally modified (the
          file <filename>README</filename>), you'll need to update and
          get the server's changes for that file before you commit, or
          the repository will reject your commit for being out of
          date.  We discuss this in more detail later.</para>

        <para><command>svn status</command> can display much more
          information about the files and directories in your working
          copy than we've shown here for an exhaustive
          description of <command>svn status</command> and its output,
          run <userinput>svn help status</userinput> or see
          <xref linkend="svn.ref.svn.c.status"/> in
          <xref linkend="svn.ref.svn"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.examine.diff">
        <title>Examine the details of your local modifications</title>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>diff</tertiary>
          </indexterm>
          <indexterm>
            <primary>differences</primary>
            <secondary>unified diff</secondary>
          </indexterm>Another way to examine your changes is with the
          <command>svn diff</command> command, which displays
          differences in file content.  When you run <userinput>svn
          diff</userinput> at the top of your working copy with no
          arguments, Subversion will print the changes you've made to
          human-readable files in your working copy.  It displays
          those changes in <firstterm>unified diff</firstterm> format,
          a format which describes changes as <quote>hunks</quote>
          (or <quote>snippets</quote>) of a file's content where each
          line of text is prefixed with a single-character code: a
          space, which means the line was unchanged; a minus sign
          (<literal>-</literal>), which means the line was removed
          from the file; or a plus sign (<literal>+</literal>), which
          means the line was added to the file.  In the context
          of <command>svn diff</command>, those minus-sign- and
          plus-sign-prefixed lines show how the lines looked before
          and after your modifications, respectively.</para>

        <para>Here's an example:</para>

        <informalexample>
          <screen>
$ svn diff
Index: bar.c
===================================================================
--- bar.c	(revision 3)
+++ bar.c	(working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
--- README	(revision 3)
+++ README	(working copy)
@@ -193,3 +193,4 @@
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
--- stuff/fish.c	(revision 1)
+++ stuff/fish.c	(working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
--- stuff/things/bloo.h	(revision 8)
+++ stuff/things/bloo.h	(working copy)
+Here is a new file to describe
+things about bloo.
</screen>
        </informalexample>

        <para>
          <indexterm>
            <primary>svn</primary>
            <secondary>subcommands</secondary>
            <tertiary>patch</tertiary>
          </indexterm>
          <indexterm>
            <primary>patches</primary>
          </indexterm>
          <indexterm>
            <primary>patch file</primary>
            <see>patches</see>
          </indexterm>The <command>svn diff</command> command produces this
          output by comparing your working files against its pristine
          text-base.  Files scheduled for addition are displayed as
          files in which every line was added; files scheduled for
          deletion are displayed as if every line was removed from
          those files.  The output from <command>svn diff</command> is
          somewhat compatible with the <command>patch</command>
          program more so with the <command>svn patch</command>
          subcommand introduced in Subversion 1.7.  Patch processing
          commands such as these read and apply <firstterm>patch
          files</firstterm> (or <quote>patches</quote>), which are
          files that describe differences made to one or more files.
          Because of this, you can share the changes you've made in
          your working copy with someone else without first committing
          those changes by creating a patch file from the redirected
          output of <command>svn diff</command>:</para>

        <informalexample>
          <screen>
$ svn diff &gt; patchfile
$
</screen>
        </informalexample>

        <para>Subversion uses its internal diff engine, which produces
          unified diff format, by default.  If you want diff output in
          a different format, specify an external diff program using
          <option>--diff-cmd</option> and pass any additional flags
          that it needs via the <option>--extensions</option>
          (<option>-x</option>) option.  For example, you might want
          Subversion to defer its difference calculation and display
          to the GNU <command>diff</command> program, asking that
          program to print local modifications made to the
          file <filename>foo.c</filename> in context diff format
          (another flavor of difference format) while ignoring changes
          made only to the case of the letters used in the file's
          contents:</para>

        <informalexample>
          <screen>
$ svn diff --diff-cmd /usr/bin/diff -x "-i" foo.c
 
$
</screen>
        </informalexample>

      </sect3>

    </sect2>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.revert">
      <title>Fix Your Mistakes</title>

      <para>Suppose while viewing the output of <command>svn
        diff</command> you determine that all the changes you made to
        a particular file are mistakes.  Maybe you shouldn't have
        changed the file at all, or perhaps it would be easier to make
        different changes starting from scratch.  You could edit the
        file again and unmake all those changes.  You could try to
        find a copy of how the file looked before you changed it, and
        then copy its contents atop your modified version.  You
        could attempt to apply those changes to the file again in
        reverse using <userinput>svn patch --reverse-diff</userinput>
        or using your operating system's <userinput>patch -R</userinput>.  
        And there are probably other approaches you could take.</para>

      <indexterm>
        <primary>svn</primary>
        <secondary>subcommands</secondary>
        <tertiary>revert</tertiary>
      </indexterm>

      <para>Fortunately in Subversion, undoing your work and starting
        over from scratch doesn't require such acrobatics.  Just use
        the <command>svn revert</command> command:</para>

      <informalexample>
        <screen>
$ svn status README
M       README
$ svn revert README
Reverted 'README'
$ svn status README
$
</screen>
      </informalexample>

      <para>In this example, Subversion has reverted the file to its
        premodified state by overwriting it with the pristine version
        of the file cached in the text-base area.  But note that
        <command>svn revert</command> can undo
        <emphasis>any</emphasis> scheduled operation for
        example, you might decide that you don't want to add a new
        file after all:</para>

      <informalexample>
        <screen>
$ svn status new-file.txt
?       new-file.txt
$ svn add new-file.txt
A         new-file.txt
$ svn revert new-file.txt
Reverted 'new-file.txt'
$ svn status new-file.txt
?       new-file.txt
$
</screen>
      </informalexample>

      <para>Or perhaps you mistakenly removed a file from version
        control:</para>

      <informalexample>
        <screen>
$ svn status README
$ svn delete README
D         README
$ svn revert README
Reverted 'README'
$ svn status README
$
</screen>
      </informalexample>

      <para>The <command>svn revert</command> command offers salvation
        for imperfect people.  It can save you huge amounts of time
        and energy that would otherwise be spent manually unmaking
        changes or, worse, disposing of your working copy and checking
        out a fresh one just to have a clean slate to work with
        again.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.resolve">
      <title>Resolve Any Conflicts</title>

      <para>
        <indexterm>
          <primary>conflicts</primary>
          <secondary>resolving</secondary>
        </indexterm>We've already seen how <userinput>svn status
        -u</userinput> can predict conflicts, but dealing with those
        conflicts is still something that remains to be done.
        Conflicts can occur any time you attempt to merge or integrate
        (in a very general sense) changes from the repository into
        your working copy.  By now you know that <command>svn
        update</command> creates exactly that sort of
        scenario that command's very purpose is to bring your
        working copy up to date with the repository by merging all the
        changes made since your last update into your working copy.
        So how does Subversion report these conflicts to you, and how
        do you deal with them?</para>

      <para>Suppose you run <userinput>svn update</userinput> and you
        see this sort of interesting output:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
U    INSTALL
G    README
Conflict discovered in 'bar.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: 
</screen>
      </informalexample>

      <para>The <computeroutput>U</computeroutput> (which stands for
        <quote>Updated</quote>) and <computeroutput>G</computeroutput>
        (for <quote>merGed</quote>) codes are no cause for concern;
        those files cleanly absorbed changes from the repository.  A
        file marked with <computeroutput>U</computeroutput> contains
        no local changes but was updated with changes from the
        repository.  One marked with
        <computeroutput>G</computeroutput> had local changes to begin
        with, but the changes coming from the repository didn't
        overlap with those local changes.</para>

      <para>It's the next few lines which are interesting.  First,
        Subversion reports to you that in its attempt to merge
        outstanding server changes into the
        file <filename>bar.c</filename>, it has detected that some of
        those changes clash with local modifications you've made to
        that file in your working copy but have not yet committed.
        Perhaps someone has changed the same line of text you also
        changed.  Whatever the reason, Subversion instantly flags this
        file as being in a state of conflict.  It then asks you what
        you want to do about the problem, allowing you to
        interactively choose an action to take toward resolving the
        conflict.  The most commonly used options are displayed, but
        you can see all of the options by
        typing <replaceable>s</replaceable>:</para>

      <informalexample>
        <screen>
 
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: s

  (e)  edit             - change merged file in an editor
  (df) diff-full        - show all changes made to merged file
  (r)  resolved         - accept merged version of file

  (dc) display-conflict - show all conflicts (ignoring merged version)
  (mc) mine-conflict    - accept my version for all conflicts (same)
  (tc) theirs-conflict  - accept their version for all conflicts (same)

  (mf) mine-full        - accept my version of entire file (even non-conflicts)
  (tf) theirs-full      - accept their version of entire file (same)

  (p)  postpone         - mark the conflict to be resolved later
  (l)  launch           - launch external tool to resolve conflict
  (s)  show all         - show this list

Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options:
</screen>
      </informalexample>

      <para>Let's briefly review each of these options before we go
        into detail on what each option means.</para>

      <variablelist>
        <varlistentry>
          <term><computeroutput>(e)  edit</computeroutput></term>
          <listitem>
            <para>Open the file in conflict with your favorite editor,
              as set in the environment variable
              <literal>EDITOR</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(df) diff-full</computeroutput></term>
          <listitem>
            <para>Display the differences between the base revision
              and the conflicted file itself in unified diff format.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(r)  resolved</computeroutput></term>
          <listitem>
            <para>After editing a file, tell
              <command>svn</command> that you've resolved the
              conflicts in the file and that it should accept the
              current contents basically that you've
              <quote>resolved</quote> the conflict.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(dc) display-conflict</computeroutput></term>
          <listitem>
            <para>Display all conflicting regions of the file,
              ignoring changes which were successfully merged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(mc) mine-conflict</computeroutput></term>
          <listitem>
            <para>Discard any newly received changes from the server
              which conflict with your local changes to the file under
              review.  However, accept and merge all non-conflicting
              changes received from the server for that file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(tc) theirs-conflict</computeroutput></term>
          <listitem>
            <para>Discard any local changes which conflict with
              incoming changes from the server for the file under
              review.  However, preserve all non-conflicting local
              changes to that file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(mf) mine-full</computeroutput></term>
          <listitem>
            <para>Discard all newly received changes from the server
              for the file under review, but preserve all your local
              changes for that file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(tf) theirs-full</computeroutput></term>
          <listitem>
            <para>Discard all your local changes to the file under
              review and use only the newly received changes from the
              server for that file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(p)  postpone</computeroutput></term>
          <listitem>
            <para>Leave the file in a conflicted state for you to
              resolve after your update is complete.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(l)  launch</computeroutput></term>
          <listitem>
            <para>Launch an external program to perform the conflict
              resolution.  This requires a bit of preparation
              beforehand.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><computeroutput>(s)  show all</computeroutput></term>
          <listitem>
            <para>Show the list of all possible commands you can use
              in interactive conflict resolution.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>We'll cover these commands in more detail now, grouping
        them together by related functionality.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.diff">

        <title>Viewing conflict differences interactively</title>

        <para>
          <indexterm>
            <primary>conflicts</primary>
            <secondary>reviewing</secondary>
          </indexterm>Before deciding how to attack a conflict
          interactively, odds are that you'd like to see exactly what
          is in conflict.  Two of the commands available at the
          interactive conflict resolution prompt can assist you here.
          The first is the <quote>diff-full</quote> command
          (<userinput>df</userinput>), which displays all the local
          modifications to the file in question plus any conflict
          regions:</para>

        <informalexample>
          <screen>
 
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: df
--- .svn/text-base/sandwich.txt.svn-base      Tue Dec 11 21:33:57 2007
+++ .svn/tmp/tempfile.32.tmp     Tue Dec 11 21:34:33 2007
@@ -1 +1,5 @@
-Just buy a sandwich.
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
+Go pick up a cheesesteak.
+=======
+Bring me a taco!
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r32
 
</screen>
        </informalexample>

        <para>The first line of the diff content shows the previous
          contents of the working copy (the <literal>BASE</literal>
          revision), the next content line is your change, and the
          last content line is the change that was just received from
          the server (<emphasis>usually</emphasis> the
          <literal>HEAD</literal> revision).</para>

        <para>The second command is similar to the first, but
          the <quote>display-conflict</quote>
          (<userinput>dc</userinput>) command shows only the conflict
          regions, not all the changes made to the file.
          Additionally, this command uses a slightly different display
          format for the conflict regions which allows you to more
          easily compare the file's contents in those regions as they
          would appear in each of three states: original and unedited;
          with your local changes applied and the server's conflicting
          changes ignored; and with only the server's incoming changes
          applied and your local, conflicting changes reverted.</para>

        <para>After reviewing the information provided by these
          commands, you're ready to move on to the next action.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.resolve">

        <title>Resolving conflict differences interactively</title>

        <indexterm>
          <primary>hook scripts</primary>
          <secondary>interactive</secondary>
        </indexterm>

        <para>There are several different ways to resolve conflicts
          interactively two of which allow you to selectively
          merge and edit changes, the rest of which allow you to
          simply pick a version of the file and move along.</para>

        <para>If you wish to choose some combination of your local
          changes, you can use the <quote>edit</quote> command
          (<userinput>e</userinput>) to manually edit the file with
          conflict markers in a text editor (configured per the
          instructions in <xref linkend="svn.advanced.externaleditors"
          />).  After you've edited the file, if you're satisfied with
          the changes you've made, you can tell Subversion that the
          edited file is no longer in conflict by using
          the <quote>resolved</quote> command
          (<literal>r</literal>).</para>

        <para>Regardless of what your local Unix snob will likely tell
          you, editing the file by hand in your favorite text editor
          is a somewhat low-tech way of remedying conflicts (see
          <xref linkend="svn.tour.cycle.resolve.byhand" /> for a
          walkthrough).  For this reason, Subversion provides
          the <quote>launch</quote> resolution command
          (<userinput>l</userinput>) to fire up a fancy graphical
          merge tool instead (see
          <xref linkend="svn.advanced.externaldifftools.merge"
          />).</para>

        <para>If you decide that you don't need to merge any changes,
          but just want to accept one version of the file or the
          other, you can either choose your changes (a.k.a.
          <quote>mine</quote>) by using the <quote>mine-full</quote>
          command (<userinput>mf</userinput>) or choose theirs by using the
          <quote>theirs-full</quote> command
          (<userinput>tf</userinput>).</para>

        <para>Finally, there is also a pair of compromise options
          available.  The <quote>mine-conflict</quote>
          (<userinput>mc</userinput>)
          and <quote>theirs-conflict</quote>
          (<userinput>tc</userinput>) commands instruct Subversion to
          select your local changes or the server's incoming changes,
          respectively, as the <quote>winner</quote> for all conflicts
          in the file.  But, unlike the <quote>mine-full</quote>
          and <quote>theirs-full</quote> commands, these commands
          preserve both your local changes and changes received from
          the server in regions of the file where no conflict was
          detected.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.pending">

        <title>Postponing conflict resolution</title>

        <indexterm>
          <primary>hook scripts</primary>
          <secondary>postponing</secondary>
        </indexterm>

        <para>This may sound like an appropriate section for avoiding
          marital disagreements, but it's actually still about
          Subversion, so read on.  If you're doing an update and
          encounter a conflict that you're not prepared to review or
          resolve, you can type <userinput>p</userinput> to postpone
          resolving a conflict on a file-by-file basis when you run
          <userinput>svn update</userinput>.  If you know in advance
          that you don't want to resolve any conflicts interactively,
          you can pass the <option>--non-interactive</option> option
          to <command>svn update</command>, and any file in conflict
          will be marked with a <computeroutput>C</computeroutput>
          automatically.</para>

        <para>The <computeroutput>C</computeroutput>
          (for <quote>Conflicted</quote>) means that the changes from the
          server overlapped with your own, and now you have to
          manually choose between them after the update has completed.
          When you postpone a conflict resolution,
          <command>svn</command> typically does three things to assist
          you in noticing and resolving that conflict:</para>

        <itemizedlist>

          <indexterm>
            <primary>conflicts</primary>
            <secondary>conflict markers</secondary>
          </indexterm>

          <listitem>
            <para>Subversion prints a <computeroutput>C</computeroutput>
              during the update and remembers that the file is in a
              state of conflict.</para>
          </listitem>

          <listitem>
            <para>If Subversion considers the file to be mergeable, it
              places <firstterm>conflict
              markers</firstterm> special strings of text that
              delimit the <quote>sides</quote> of the
              conflict into the file to visibly demonstrate the
              overlapping areas.  (Subversion uses the
              <literal>svn:mime-type</literal> property to decide whether a
              file is capable of contextual, line-based merging.  See
              <xref linkend="svn.advanced.props.special.mime-type"/>
              to learn more.)</para>
          </listitem>

          <listitem>
            <para>For every conflicted file, Subversion places three
              extra unversioned files in your working copy:</para>

            <variablelist>

              <varlistentry>
                <term><filename>filename.mine</filename></term>
                <listitem>
                  <para>This is the file as it existed in your working
                    copy before you began the update process.  It
                    contains any local modifications you had made to
                    the file up to that point.  (If Subversion
                    considers the file to be unmergeable,
                    the <filename>.mine</filename> file isn't created,
                    since it would be identical to the working
                    file.)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><filename>filename.r<replaceable>OLDREV</replaceable>
                      </filename></term>
                <listitem>
                  <para>This is the file as it existed in the
                    <literal>BASE</literal> revision that is,
                    the unmodified revision of the file in your
                    working copy <emphasis>before</emphasis> you began
                    the update process where
                    <replaceable>OLDREV</replaceable> is that base
                    revision number.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><filename>filename.r<replaceable>NEWREV</replaceable>
                      </filename></term>
                <listitem>
                  <para>This is the file that your Subversion client
                    just received from the server via the update of
                    your working copy, where
                    <replaceable>NEWREV</replaceable> corresponds to
                    the revision number to which you were updating
                    (<literal>HEAD</literal>, unless otherwise
                    requested).</para>
                </listitem>
              </varlistentry>

            </variablelist>
          </listitem>

        </itemizedlist>

        <para>For example, Sally makes changes to the file
          <filename>sandwich.txt</filename>, but does not yet commit
          those changes.  Meanwhile, Harry commits changes to that
          same file.  Sally updates her working copy before committing
          and she gets a conflict, which she postpones:</para>

        <informalexample>
          <screen>
$ svn update
Updating '.':
Conflict discovered in 'sandwich.txt'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: p
C    sandwich.txt
Updated to revision 2.
Summary of conflicts:
  Text conflicts: 1
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</screen>
        </informalexample>

        <para>At this point, Subversion will <emphasis>not</emphasis>
          allow Sally to commit the file
          <filename>sandwich.txt</filename> until the three temporary
          files are removed:</para>

        <informalexample>
          <screen>
$ svn commit -m "Add a few more things"
svn: E155015: Commit failed (details follow):
svn: E155015: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
</screen>
        </informalexample>

        <para>If you've postponed a conflict, you need to resolve the
          conflict before Subversion will allow you to commit your
          changes.  You'll do this with the <command>svn
          resolve</command> command.  This command accepts
          the <option>--accept</option> option, which allows you
          specify your desired approach for resolving the conflict.
          Prior to Subversion 1.8, the <command>svn resolve</command>
          <emphasis>required</emphasis> the use of this option.
          Subversion now allows you to run the <command>svn
          resolve</command> command without that option.  When you do
          so, Subversion cranks up its interactive conflict resolution
          mechanism, which you can read about (if you haven't done so
          already) in the previous section,
          <xref linkend="svn.tour.cycle.resolve.resolve" />.  We'll
          take the opportunity in this section, though, to discuss
          the use of the <option>--accept</option> option for
          conflict resolution.</para>

        <para>The <option>--accept</option> option to the <command>svn
          resolve</command> command instructs Subversion to use one of
          its pre-packaged approaches to conflict resolution.  If
          you want Subversion to resolve the conflict using the
          version of the file that you last checked out before making
          your edits, use <option>--accept=base</option>.  If you'd
          prefer instead to keep the version that contains only your
          edits, use <option>--accept=mine-full</option>.  You can also
          select the version that your most recent update pulled from
          the server (discarding your edits entirely) that's
          done using <option>--accept=theirs-full</option>.  There
          are other <quote>canned</quote> resolution types, too.  See
          <xref linkend="svn.ref.svn.sw.accept" /> in
          <xref linkend="svn.ref.svn" /> for details.</para>

        <para>You aren't limited strictly to all-or-nothing options.
          If you want to pick and choose from your changes and the
          changes that your update fetched from the server, you can
          manually repair the working file, fixing up the conflicted
          text <quote>by hand</quote> (by examining and editing the
          conflict markers within the file), then tell Subversion to
          resolve the conflict by keeping the working file in its
          current state by running <command>svn resolve</command> with
          the <option>--accept=working</option> option.</para>

        <para><command>svn resolve</command> removes the three
          temporary files and accepts the version of the file that you
          specified.  After the command completes
          successfully and assuming you didn't interactively
          choose to postpone resolution, of course Subversion no
          longer considers the file to be in a state of
          conflict:</para>

        <informalexample>
          <screen>
$ svn resolve --accept working sandwich.txt
Resolved conflicted state of 'sandwich.txt'
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.byhand">
        <title>Manual conflict resolution</title>

        <indexterm>
          <primary>hook scripts</primary>
          <secondary>manual</secondary>
        </indexterm>

        <para>Manually resolving conflicts can be quite intimidating the
          first time you attempt it, but with a little practice, it
          can become as easy as falling off a bike.</para>

        <para>Here's an example.  Due to a miscommunication, you and
          Sally, your collaborator, both edit the file
          <filename>sandwich.txt</filename> at the same time.  Sally
          commits her changes, and when you go to update your working
          copy, you get a conflict and you're going to have to edit
          <filename>sandwich.txt</filename> to resolve the conflict.
          First, let's take a look at the file:</para>

        <informalexample>
          <screen>
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
</screen>
        </informalexample>

        <para>The strings of less-than signs, equals signs, and
          greater-than signs are conflict markers and are not part of
          the actual data in conflict.  You generally want to ensure
          that those are removed from the file before your next
          commit.  The text between the first two sets of markers is
          composed of the changes you made in the conflicting
          area:</para>

        <informalexample>
          <screen>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
</screen>
        </informalexample>

        <para>The text between the second and third sets of conflict
          markers is the text from Sally's commit:</para>

        <informalexample>
          <screen>
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</screen>
        </informalexample>

        <para>Usually you won't want to just delete the conflict
          markers and Sally's changes she's going to be awfully
          surprised when the sandwich arrives and it's not what she
          wanted.  This is where you pick up the phone or walk across
          the office and explain to Sally that you can't get
          sauerkraut from an Italian deli.<footnote><para>And if you
          ask them for it, they may very well ride you out of town on
          a rail.</para></footnote>  Once you've agreed on the changes
          you will commit, edit your file and remove the conflict
          markers:</para>

        <informalexample>
          <screen>
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
</screen>
        </informalexample>

        <para>Now use <command>svn resolve</command>, and you're
          ready to commit your changes:</para>

        <informalexample>
          <screen>
$ svn resolve --accept working sandwich.txt
Resolved conflicted state of 'sandwich.txt'
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
</screen>
        </informalexample>

        <para>Naturally, you want to be careful that when using
          <command>svn resolve</command> you don't tell Subversion
          that you've resolved a conflict when you truly haven't.
          Once the temporary files are removed, Subversion will let
          you commit the file even if it still contains conflict
          markers.</para>

        <para>If you ever get confused while editing the conflicted
          file, you can always consult the three files that Subversion
          creates for you in your working copy including your
          file as it was before you updated.  You can even use a
          third-party interactive merging tool to examine those three
          files.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.theirsfull">
        <title>Discarding your changes in favor of a newly fetched
          revision</title>
  
        <para>
          <indexterm>
            <primary>conflicts</primary>
            <secondary>resolution</secondary>
          </indexterm>If you get a conflict and decide that you want
          to throw out your changes, you can run <userinput>svn
          resolve --accept theirs-full
          <replaceable>CONFLICTED-PATH</replaceable></userinput> and
          Subversion will discard your edits and remove the temporary
          files:</para>

        <informalexample>
         <screen>
$ svn update
Updating '.':
Conflict discovered in 'sandwich.txt'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: p
C    sandwich.txt
Updated to revision 2.
Summary of conflicts:
  Text conflicts: 1
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ svn resolve --accept theirs-full sandwich.txt
Resolved conflicted state of 'sandwich.txt'
$
</screen>
       </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.cycle.resolve.revert">
        <title>Punting: using svn revert</title>

        <para>If you decide that you want to throw out your changes
          and start your edits again (whether this occurs after a
          conflict or anytime), just revert your changes:</para>

        <informalexample>
          <screen>
$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt
$
</screen>
        </informalexample>

        <para>Note that when you revert a conflicted file, you don't
          have to use <command>svn resolve</command>.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cycle.commit">
      <title>Commit Your Changes</title>

      <para>Finally!  Your edits are finished, you've merged all
        changes from the server, and you're ready to commit your
        changes to the repository.</para>

      <para>The <command>svn commit</command> command sends all of
        your changes to the repository.  When you commit a change, you
        need to supply a log message describing your change.  Your log
        message will be attached to the new revision you create.  If
        your log message is brief, you may wish to supply it on the
        command line using the <option>--message</option>
        (<option>-m</option>) option:</para>

      <informalexample>
        <screen>
$ svn commit -m "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</screen>
      </informalexample>

      <para>However, if you've been composing your log message in some
        other text file as you work, you may want to tell Subversion
        to get the message from that file by passing its filename as
        the value of the <option>--file</option> (<option>-F</option>)
        option:</para>

      <informalexample>
        <screen>
$ svn commit -F logmsg
Sending        sandwich.txt
Transmitting file data .
Committed revision 4.
</screen>
      </informalexample>

      <para>If you fail to specify either the
        <option>--message</option> (<option>-m</option>)
        or <option>--file</option> (<option>-F</option>) option,
        Subversion will automatically launch your favorite editor (see
        the information on <literal>editor-cmd</literal> in
        <xref linkend="svn.advanced.confarea.opts.config"/>) for
        composing a log message.</para>

      <tip>
        <para>If you're in your editor writing a commit message and
          decide that you want to cancel your commit, you can just
          quit your editor without saving changes.  If you've already
          saved your commit message, simply delete all the text, save
          again, and then abort:</para>

        <informalexample>
          <screen>
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
(a)bort, (c)ontinue, (e)dit
a
$
</screen>
        </informalexample>
      </tip>

      <para>The repository doesn't know or care whether your changes make
        any sense as a whole; it checks only to make sure nobody
        else has changed any of the same files that you did when you
        weren't looking.  If somebody <emphasis>has</emphasis> done
        that, the entire commit will fail with a message informing you
        that one or more of your files are out of date:</para>

      <informalexample>
        <screen>
$ svn commit -m "Add another rule"
Sending        rules.txt
svn: E155011: Commit failed (details follow):
svn: E155011: File '/home/sally/svn-work/sandwich.txt' is out of date
 
</screen>
      </informalexample>

      <para>(The exact wording of this error message depends on the
        network protocol and server you're using, but the idea is the
        same in all cases.)</para>

      <para>At this point, you need to run <userinput>svn
        update</userinput>, deal with any merges or conflicts that
        result, and attempt your commit again.</para>

      <para>That covers the basic work cycle for using Subversion.
        Subversion offers many other features that you can use
        to manage your repository and working copy, but most of your
        day-to-day use of Subversion will involve only the commands
        that we've discussed so far in this chapter.  We will,
        however, cover a few more commands that you'll use fairly
        often.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.history">
    <title>Examining History</title>

    <para>Your Subversion repository is like a time machine.  It keeps
      a record of every change ever committed and allows you to
      explore this history by examining previous versions of files and
      directories as well as the metadata that accompanies them.  With
      a single Subversion command, you can check out the repository
      (or restore an existing working copy) exactly as it was at any
      date or revision number in the past.  However, sometimes you
      just want to <emphasis>peer into</emphasis> the past instead of
      <emphasis>going into</emphasis> it.</para>

    <para>Several commands can provide you with historical data from
      the repository:</para>

      <variablelist>

        <varlistentry>
          <term><command>svn diff</command></term>
          <listitem>
            <para>Shows line-level details of a particular change</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn log</command></term>
          <listitem>
            <para>Shows you broad information: log messages with date
              and author information attached to revisions and which
              paths changed in each revision</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn cat</command></term>
          <listitem>
            <para>Retrieves a file as it existed in a particular
              revision number and displays it on your screen</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn annotate</command></term>
          <listitem>
            <para>Retrieves a human-readable file as it existed in a
              particular revision number, displaying its contents in a
              tabular form with last-changed information attributed to
              each line of the file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><command>svn list</command></term>
          <listitem>
            <para>Displays the files in a directory for any given
              revision</para>
          </listitem>
        </varlistentry>

      </variablelist>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.diff">
      <title>Examining the Details of Historical Changes</title>

      <para>We've already seen <command>svn diff</command>
        before it displays file differences in unified diff
        format; we used it to show the local modifications made to
        our working copy before committing to the repository.</para>

      <para>In fact, it turns out that there are
        <emphasis>three</emphasis> distinct uses of <command>svn
        diff</command>:</para>

      <itemizedlist>

        <listitem>
          <para>Examining local changes</para>
        </listitem>

        <listitem>
          <para>Comparing your working copy to the repository</para>
        </listitem>

        <listitem>
          <para>Comparing repository revisions</para>
        </listitem>

      </itemizedlist>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.local">
        <title>Examining local changes</title>

        <para>As we've seen, invoking <userinput>svn diff</userinput> with
          no options will compare your working files to the cached
          <quote>pristine</quote> copies in
          the <filename>.svn</filename> area:</para>

        <informalexample>
          <screen>
$ svn diff
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.wcrepos">
        <title>Comparing working copy to repository</title>

        <para>If a single <option>--revision</option>
          (<option>-r</option>) number is passed, your
          working copy is compared to the specified revision in the
          repository:</para>

        <informalexample>
          <screen>
$ svn diff -r 3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.diff.reposrepos">
        <title>Comparing repository revisions</title>

        <para>If two revision numbers, separated by a colon, are
          passed via <option>--revision</option>
          (<option>-r</option>), the two revisions are directly
          compared:</para>

        <informalexample>
          <screen>
$ svn diff -r 2:3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</screen>
        </informalexample>

        <para>A more convenient way of comparing one revision to the
          previous revision is to use the <option>--change</option>
          (<option>-c</option>) option:</para>

        <informalexample>
          <screen>
$ svn diff -c 3 rules.txt
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</screen>
        </informalexample>

        <para>Lastly, you can compare repository revisions even when
          you don't have a working copy on your local machine, just by
          including the appropriate URL on the command line:</para>

        <informalexample>
          <screen>
$ svn diff -c 5 http://svn.example.com/repos/example/trunk/text/rules.txt
 
$
</screen>
        </informalexample>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.log">
      <title>Generating a List of Historical Changes</title>

      <para>To find information about the history of a file or
        directory, use the <command>svn log</command>
        command. <command>svn log</command> will provide you with a
        record of who made changes to a file or directory, at what
        revision it changed, the time and date of that revision,
        and if it was provided the log message that accompanied
        the commit:</para>

      <informalexample>
        <screen>
$ svn log
------------------------------------------------------------------------
r3 | sally | 2008-05-15 23:09:28 -0500 (Thu, 15 May 2008) | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | 2008-05-14 18:43:15 -0500 (Wed, 14 May 2008) | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | 2008-05-10 19:50:31 -0500 (Sat, 10 May 2008) | 1 line

Initial import
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Note that the log messages are printed in
        <emphasis>reverse chronological order</emphasis> by default.
        If you wish to see a different range of revisions in a
        particular order or just a single revision, pass the
        <option>--revision</option> (<option>-r</option>)
        option:</para>

      <table id="svn.tour.history.log.tbl-1">
        <title>Common log requests</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Command</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><userinput>svn log -r 5:19</userinput></entry>
              <entry>Display logs for revisions 5 through 19 in
                chronological order</entry>
            </row>
            <row>
              <entry><userinput>svn log -r 19:5</userinput></entry>
              <entry>Display logs for revisions 5 through 19 in
                reverse chronological order</entry>
            </row>
            <row>
              <entry><userinput>svn log -r 8</userinput></entry>
              <entry>Display logs for revision 8 only</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>You can also examine the log history of a single file or
        directory.  For example:</para>

      <informalexample>
        <screen>
$ svn log foo.c
 
$ svn log http://foo.com/svn/trunk/code/foo.c
 
</screen>
      </informalexample>

      <para>These will display log messages <emphasis>only</emphasis>
        for those revisions in which the named file (or directory)
        changed.</para>

      <sidebar>

        <title>Why Does svn log Not Show Me What I
          Just Committed?</title>

        <para>If you make a commit and immediately type <userinput>svn
          log</userinput> with no arguments, you may notice that your
          most recent commit doesn't show up in the list of log
          messages.  This is due to a combination of the behavior of
          <command>svn commit</command> and the default behavior of
          <command>svn log</command>.  First, when you commit changes
          to the repository, <command>svn</command> bumps only the
          revision of files (and directories) that it commits, so
          usually the parent directory remains at the older revision
          (See
          <xref linkend="svn.basic.in-action.mixedrevs.update-commit"/>
          for an explanation of why).  <command>svn log</command> then
          defaults to fetching the history of the directory at its
          current revision, and thus you don't see the newly committed
          changes.  The solution here is to either update your working
          copy or explicitly provide a revision number to <command>svn
          log</command> by using the <option>--revision</option>
          (<option>-r</option>) option.</para>

      </sidebar>

      <para>If you want even more information about a file or
        directory, <command>svn log</command> also takes a
        <option>--verbose</option> (<option>-v</option>) option.
        Because Subversion allows you to move and copy files and
        directories, it is important to be able to track path changes
        in the filesystem.  So, in verbose mode, <command>svn
        log</command> will include a list of changed paths in a
        revision in its output:</para>

      <informalexample>
        <screen>
$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2008-05-21 13:19:25 -0500 (Wed, 21 May 2008) | 1 line
Changed paths:
   M /trunk/code/foo.c
   M /trunk/code/bar.h
   A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</screen>
      </informalexample>

      <para><command>svn log</command> also takes
        a <option>--quiet</option> (<option>-q</option>) option, which
        suppresses the body of the log message.  When combined
        with <option>--verbose</option> (<option>-v</option>), it
        gives just the names of the changed files.</para>

      <sidebar>
        <title>Why Does svn log Give Me an Empty
          Response?</title>

        <para>After working with Subversion for a bit, most users will
          come across something like this:</para>

        <informalexample>
          <screen>
$ svn log -r 2
------------------------------------------------------------------------
$
</screen>
        </informalexample>

        <para>At first glance, this seems like an error.  But recall
          that while revisions are repository-wide, <command>svn
          log</command> operates on a path in the repository.  If you
          supply no path, Subversion uses the current working
          directory as the default target.  As a result, if you're
          operating in a subdirectory of your working copy and attempt
          to see the log of a revision in which neither that directory
          nor any of its children was changed, Subversion will show you
          an empty log.  If you want to see what changed in that
          revision, try pointing <command>svn log</command> directly at
          the topmost URL of your repository, as in <userinput>svn log
          -r 2 ^/</userinput>.</para>

      </sidebar>

      <para>As of Subversion 1.7, users of the Subversion command-line
        can also take advantage of a special output mode
        for <command>svn log</command> which integrates a difference
        report such as is generated by the <command>svn diff</command>
        command we introduced earlier.  When you invoke <command>svn
        log</command> with the <option>--diff</option> option,
        Subversion will append to each revision log chunk in the log
        report a <command>diff</command>-style difference report.
        This is a very convenient way to see both the high-level, semantic
        changes and the line-based modifications of a revision all at
        the same time!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.browsing">
      <title>Browsing the Repository</title>

      <para>Using <command>svn cat</command> and <command>svn
        list</command>, you can view various revisions of files and
        directories without changing the working revision of your
        working copy.  In fact, you don't even need a working copy to
        use either one.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.cat">
        <title>Displaying file contents</title>

        <para>If you want to examine an earlier version of a file and
          not necessarily the differences between two files, you can use
          <command>svn cat</command>:</para>

        <informalexample>
          <screen>
$ svn cat -r 2 rules.txt
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth open
$
</screen>
        </informalexample>

        <para>You can also redirect the output directly into a
          file:</para>

        <informalexample>
          <screen>
$ svn cat -r 2 rules.txt &gt; rules.txt.v2
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.annotate">
        <title>Displaying line-by-line change attribution</title>

        <para>Very similar to the <command>svn cat</command> command
          we discussed in the previous section is the <command>svn
          annotate</command> command.  This command also displays the
          contents of a versioned file, but it does so using a tabular
          format.  Each line of output shows not only a line of the
          file's content but also the username, the revision number
          and (optionally) the datestamp of the revision in which that
          line was last modified.</para>

        <para>When used with a working copy file target, <command>svn
          annotate</command> will by default show line-by-line
          attribution of the file as it currently appears in the
          working copy.</para>

        <informalexample>
          <screen>
$ svn annotate rules.txt
     1      harry Be kind to others
     3      sally Freedom = Responsibility
     1      harry Everything in moderation
     -          - Chew with your mouth closed
     -          - Listen when others are speaking
</screen>
        </informalexample>

        <para>Notice that for some lines, there is no attribution
          provided.  In this case, that's because those lines have
          been modified in the working copy's version of the file.  In
          this way, <command>svn annotate</command> becomes another
          way for you to see which lines in the file you have
          changed.  You can use the <literal>BASE</literal> revision
          keyword (see <xref linkend="svn.tour.revs.keywords" />) to
          instead see the unmodified form of the file as it resides
          in your working copy.</para>

        <informalexample>
          <screen>
$ svn annotate rules.txt@BASE
     1      harry Be kind to others
     3      sally Freedom = Responsibility
     1      harry Everything in moderation
     1      harry Chew with your mouth open
</screen>
        </informalexample>

        <para>The <option>--verbose (-v)</option> option causes
          <command>svn annotate</command> to also include on each line
          the datestamp associated with that line's reported revision
          number.  (This adds a significant amount of width to each
          line of ouput, so we'll skip the demonstration here.)</para>

        <para>As with <command>svn cat</command>, you can also
          ask <command>svn annotate</command> to display previous
          versions of the file.  This can be a handy trick when, after
          finding out who most recently modified a particular line of
          interest in the file, you then wish to see who modified the
          same line prior to that.</para>

        <informalexample>
          <screen>
$ svn blame rules.txt -r 2
     1      harry Be kind to others
     1      harry Freedom = Chocolate Ice Cream
     1      harry Everything in moderation
     1      harry Chew with your mouth open
</screen>
        </informalexample>

        <para>Unlike the <command>svn cat</command> command, the
          functionality of <command>svn annotate</command> is tied
          heavily to the idea of <quote>lines</quote> of text in a
          human-readable file.  As such, if you attempt to run the
          command on a file that Subversion has determined is
          <emphasis>not</emphasis> human-readable (per the file's
          <literal>svn:mime-type</literal> property see <xref
          linkend="svn.advanced.props.special.mime-type" /> for
          details), you'll get an error message.</para>

        <informalexample>
          <screen>
$ svn annotate images/logo.png
Skipping binary file (use --force to treat as text): 'images/logo.png'
$
</screen>
        </informalexample>

        <para>As revealed in the error message, you can use
          the <option>--force</option> option to disable this check
          and proceed with the annotation as if the file's contents
          are, in fact, human-readable and line-based.  Naturally, if
          you force Subversion to try to perform line-based annotation
          on a nontextual file, you'll get what you asked for: a
          screenful of nonsense.</para>

        <informalexample>
          <screen>
$ svn annotate images/logo.png --force
     6      harry \211PNG
     6      harry ^Z
     6      harry 
     7      harry \274\361\MI\300\365\353^X\300 
</screen>
        </informalexample>

        <tip>
          <para>Depending on your mood at the time you execute this
            command and your reasons for doing so, you may find
            yourself typing <userinput>svn blame  </userinput>
            or <userinput>svn praise  </userinput> instead of
            using the canonical <command>svn annotate</command>
            command form.  That's okay the Subversion developers
            anticipated as much, so those particular command aliases
            work, too!</para>
        </tip>

        <para>Finally, as with many of Subversion's informational
          commands, you can also reference files in your <command>svn
          annotate</command> command invocations by their repository
          URLs, allowing access to this information even when you
          don't have ready access to a working copy.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.history.browsing.list">
        <title>Listing versioned directories</title>

        <para>The <command>svn list</command> command shows you what
          files are in a repository directory without actually
          downloading the files to your local machine:</para>

        <informalexample>
          <screen>
$ svn list http://svn.example.com/repo/project
README
branches/
tags/
trunk/
</screen>
        </informalexample>

        <para>If you want a more detailed listing, pass the
          <option>--verbose</option> (<option>-v</option>) flag to get
          output like this:</para>

        <informalexample>
          <screen>
$ svn list -v http://svn.example.com/repo/project
  23351 sally                 Feb 05 13:26 ./
  20620 harry            1084 Jul 13  2006 README
  23339 harry                 Feb 04 01:40 branches/
  23198 harry                 Jan 23 17:17 tags/
  23351 sally                 Feb 05 13:26 trunk/
</screen>
        </informalexample>

        <para>The columns tell you the revision at which the file or
          directory was last modified, the user who modified it, the size
          if it is a file, the date it was last modified, and the item's
          name.</para>

        <warning>
          <para>The <userinput>svn list</userinput> command with no
            arguments defaults to the <emphasis>repository
            URL</emphasis> of the current working
            directory, <emphasis>not</emphasis> the local working copy
            directory.  After all, if you want a listing of your local
            directory, you could use just plain
            <command>ls</command> (or any reasonable non-Unixy
            equivalent).</para>
        </warning>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.history.snapshots">
      <title>Fetching Older Repository Snapshots</title>

      <para>In addition to all of the previous commands, you can use
        the <option>--revision</option> (<option>-r</option>) option
        with <command>svn update</command> to take an entire working
        copy <quote>back in time</quote>:<footnote><para>See?  We told
        you that Subversion was a time
        machine.</para></footnote></para>

      <informalexample>
        <screen>
# Make the current directory look like it did in r1729.
$ svn update -r 1729
Updating '.':
 
$
</screen>
      </informalexample>

      <tip>
        <para>Many Subversion newcomers attempt to use the preceding
          <command>svn update</command> example to <quote>undo</quote>
          committed changes, but this won't work as you can't commit
          changes that you obtain from backdating a working copy if
          the changed files have newer revisions.  See <xref
          linkend="svn.branchmerge.basicmerging.resurrect"/> for a
          description of how to <quote>undo</quote> a commit.</para>
      </tip>

      <para>If you'd prefer to create a whole new working copy from an
        older snapshot, you can do so by modifying the typical
        <command>svn checkout</command> command.  As with <command>svn
        update</command>, you can provide
        the <option>--revision</option> (<option>-r</option>) option.
        But for reasons that we cover in
        <xref linkend="svn.advanced.pegrevs" />, you might instead want
        to specify the target revision as part of Subversion's
        expanded URL syntax.</para>

      <informalexample>
        <screen>
# Checkout the trunk from r1729.
$ svn checkout http://svn.example.com/svn/repo/trunk@1729 trunk-1729
 
# Checkout the current trunk as it looked in r1729.
$ svn checkout http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729
 
$
</screen>
      </informalexample>

      <para>Lastly, if you're building a release and wish to bundle up
        your versioned files and directories, you can use <command>svn
        export</command> to create a local copy of all or part of your
        repository without any <filename>.svn</filename>
        administrative directories included.  The basic syntax of this
        subcommand is identical to that of <command>svn
        checkout</command>:</para>

      <informalexample>
        <screen>
# Export the trunk from the latest revision.
$ svn export http://svn.example.com/svn/repo/trunk trunk-export
 
# Export the trunk from r1729.
$ svn export http://svn.example.com/svn/repo/trunk@1729 trunk-1729
 
# Export the current trunk as it looked in r1729. 
$ svn export http://svn.example.com/svn/repo/trunk -r 1729 trunk-1729
 
$
</screen>
      </informalexample>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.cleanup">
    <title>Sometimes You Just Need to Clean Up</title>

    <para>Now that we've covered the day-to-day tasks that you'll
      frequently use Subversion for, we'll review a few administrative
      tasks relating to your working copy.</para>


    <!-- =============================================================== -->
    <sect2 id="svn.tour.cleanup.disposal">
      <title>Disposing of a Working Copy</title>

      <para>Subversion doesn't track either the state or the existence of
        working copies on the server, so there's no server overhead to
        keeping working copies around.  Likewise, there's no need to
        let the server know that you're going to delete a working
        copy.</para>

      <para>If you're likely to use a working copy again, there's
        nothing wrong with just leaving it on disk until you're ready
        to use it again, at which point all it takes is an
        <command>svn update</command> to bring it up to date and ready
        for use.</para>

      <para>However, if you're definitely not going to use a working
        copy again, you can safely delete the entire thing using
        whatever directory removal capabilities your operating system
        offers.  We recommend that before you do so you
        run <userinput>svn status</userinput> and review any files
        listed in its output that are prefixed with a
        <literal>?</literal> to make certain that they're not of
        importance.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.cleanup.interruption">
      <title>Recovering from an Interruption</title>

      <para>When Subversion modifies your working copy either
        your files or its own administrative state it tries to do
        so as safely as possible.  Before changing the working copy,
        Subversion logs its intentions in a private <quote>to-do
        list</quote>, of sorts.  Next, it performs those actions to
        effect the desired change, holding a lock on the relevant part
        of the working copy while it works.  This prevents other
        Subversion clients from accessing the working copy mid-change.
        Finally, Subversion releases its lock and cleans up its
        private to-do list.  Architecturally, this is similar to a
        journaled filesystem.  If a Subversion operation is
        interrupted (e.g, if the process is killed or if the machine
        crashes), the private to-do list remains on disk.  This allows
        Subversion to return to that list later to complete any
        unfinished operations and return your working copy to a
        consistent state.</para>

      <para>This is exactly what <command>svn cleanup</command> does:
        it searches your working copy and runs any leftover to-do
        items, removing working copy locks as it completes those
        operations.  If Subversion ever tells you that some part of
        your working copy is <quote>locked,</quote> run <command>svn
        cleanup</command> to remedy the problem.  The <command>svn
        status</command> command will inform you about administrative
        locks in the working copy, too, by displaying
        an <literal>L</literal> next to those locked paths:</para>

      <informalexample>
        <screen>
$ svn status
  L     somedir
M       somedir/foo.c
$ svn cleanup
$ svn status
M       somedir/foo.c
</screen>
      </informalexample>

      <para>Don't confuse these working copy administrative locks with
        the user-managed locks that Subversion users create when using
        the lock-modify-unlock model of concurrent version control;
        see the sidebar
        <xref linkend="svn.advanced.locking.meanings"/> for
        clarification.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.treeconflicts">
    <title>Dealing with Structural Conflicts</title>
      
    <para>So far, we have only talked about conflicts at the level of
      file content.  When you and your collaborators make overlapping
      changes within the same file, Subversion forces you to merge
      those changes before you can commit.<footnote><para>Well,
      you <emphasis>could</emphasis> mark files containing conflict
      markers as resolved and commit them, if you really wanted to.
      But this is rarely done in practice.</para></footnote></para>
        
    <para>
      <indexterm>
        <primary>tree conflicts</primary>
      </indexterm>
      <indexterm>
        <primary>conflicts</primary>
        <secondary>tree</secondary>
        <see>tree conflicts</see>
      </indexterm>But what happens if your collaborators move or
      delete a file that you are still working on?  Maybe there was a
      miscommunication, and one person thinks the file should be
      deleted, while another person still wants to commit changes to
      the file.  Or maybe your collaborators did some refactoring,
      renaming files and moving around directories in the process.  If
      you were still working on these files, those modifications may
      need to be applied to the files at their new location.  Such
      conflicts manifest themselves at the directory tree structure
      level rather than at the file content level, and are known
      as <firstterm>tree conflicts</firstterm>.</para>

    <sidebar>
      <title>Tree conflicts prior to Subversion 1.6</title>

      <para>Prior to Subversion 1.6, tree conflicts could yield rather
        unexpected results.  For example, if a file was locally
        modified, but had been renamed in the repository,
        running <command>svn update</command> would make Subversion
        carry out the following steps:</para>

      <itemizedlist>
        <listitem><para>Check the file to be renamed for local
          modifications.</para></listitem>

        <listitem><para>Delete the file at its old location, and if it
          had local modifications, keep an on-disk copy of the file at
          the old location.  This on-disk copy now appears as an
          unversioned file in the working copy.</para></listitem>

        <listitem><para>Add the file, as it exists in the repository,
          at its new location.</para></listitem>
      </itemizedlist>

      <para>When this situation arises, there is the possibility that
        the user makes a commit without realizing that local
        modifications have been left in a now-unversioned file in the
        working copy, and have not reached the repository.  This gets
        more and more likely (and tedious) if the number of files
        affected by this problem is large.</para>

      <para>Since Subversion 1.6, this and other similar situations
        are flagged as conflicts in the working copy.</para>

    </sidebar>

    <para>As with textual conflicts, tree conflicts prevent a commit
      from being made from the conflicted state, giving the user the
      opportunity to examine the state of the working copy for
      potential problems arising from the tree conflict, and resolving
      any such problems before committing.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.tour.treeconflicts.example">
      <title>An Example Tree Conflict</title>

      <para>Suppose a software project you were working on currently
        looked like this:</para>

      <informalexample>
        <screen>
$ svn list -Rv svn://svn.example.com/trunk/
     13 harry                 Sep 06 10:34 ./
     13 harry              27 Sep 06 10:34 COPYING
     13 harry              41 Sep 06 10:32 Makefile
     13 harry              53 Sep 06 10:34 README
     13 harry                 Sep 06 10:32 code/
     13 harry              54 Sep 06 10:32 code/bar.c
     13 harry             130 Sep 06 10:32 code/foo.c
$
</screen>
      </informalexample>

      <para>Later, in revision 14, your collaborator Harry renames the file
        <filename>bar.c</filename> to <filename>baz.c</filename>.
        Unfortunately, you don't realize this yet.  As it turns out,
        you are busy in your working copy composing a different set of
        changes, some of which also involve modifications
        to <filename>bar.c</filename>:</para>

      <informalexample>
        <screen>
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c	(revision 13)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/bar.c
===================================================================
--- code/bar.c	(revision 13)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$
</screen>
      </informalexample>

      <para>You first realize that someone else has
        changed <filename>bar.c</filename> when your own commit
        attempt fails:</para>

      <informalexample>
        <screen>
$ svn commit -m "Small fixes"
Sending        code/bar.c
svn: E155011: Commit failed (details follow):
svn: E155011: File '/home/svn/project/code/bar.c' is out of date
svn: E160013: File not found: transaction '14-e', path '/code/bar.c'
$
</screen>
      </informalexample>
<!-- XXX: That error message should be cleaned up! -->

      <para>At this point, you need to run <command>svn update</command>.
        Besides bringing our working copy up to date so that you can
        see Harry's changes, this also flags a tree conflict so you
        have the opportunity to evaluate and properly resolve it.</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
   C code/bar.c
A    code/baz.c
U    Makefile
Updated to revision 14.
Summary of conflicts:
  Tree conflicts: 1
$
</screen>
      </informalexample>

      <para>In its output, <command>svn update</command> signifies tree
        conflicts using a capital C in the fourth output column.
        <command>svn status</command> reveals additional details of the
        conflict:</para>

      <informalexample>
        <screen>
$ svn status
M       code/foo.c
A  +  C code/bar.c
      >   local edit, incoming delete upon update
Summary of conflicts:
  Tree conflicts: 1
$
</screen>
      </informalexample>

      <para>Note how <filename>bar.c</filename> is automatically
        scheduled for re-addition in your working copy, which
        simplifies things in case you want to keep the file.</para>

      <para>Because a move in Subversion is implemented as a copy
        operation followed by a delete operation, and these two
        operations cannot be easily related to one another during an
        update, all Subversion can warn you about is an incoming
        delete operation on a locally modified file.  This delete
        operation <emphasis>may</emphasis> be part of a move, or it
        could be a genuine delete operation.  Determining exactly what
        semantic change was made to the repository is
        important you want to know just how your own edits fit
        into the overall trajectory of the project.  So read log
        messages, talk to your collaborators, study the line-based
        differences do whatever you must do to determine
        your best course of action.</para>

      <para>In this case, Harry's commit log message tells you what
        you need to know.</para>

      <informalexample>
        <screen>
$ svn log -r14 ^/trunk
------------------------------------------------------------------------
r14 | harry | 2011-09-06 10:38:17 -0400 (Tue, 06 Sep 2011) | 1 line
Changed paths:
   M /Makefile
   D /code/bar.c
   A /code/baz.c (from /code/bar.c:13)

Rename bar.c to baz.c, and adjust Makefile accordingly.
------------------------------------------------------------------------
$
</screen>
      </informalexample>

      <para><command>svn info</command> shows the URLs of the items
        involved in the conflict. The <emphasis>left</emphasis> URL
        shows the source of the local side of the conflict, while
        the <emphasis>right</emphasis> URL shows the source of the
        incoming side of the conflict. These URLs indicate where you
        should start searching the repository's history for the change
        which conflicts with your local change.</para>

      <informalexample>
        <screen>
$ svn info code/bar.c
Path: code/bar.c
Name: bar.c
URL: http://svn.example.com/svn/repo/trunk/code/bar.c
 
Tree conflict: local edit, incoming delete upon update
  Source  left: (file) ^/trunk/code/bar.c@4
  Source right: (none) ^/trunk/code/bar.c@5

$
</screen>
      </informalexample>

      <para><filename>bar.c</filename> is now said to be the victim of
        a tree conflict.  It cannot be committed until the conflict is
        resolved:</para>

      <informalexample>
        <screen>
$ svn commit -m "Small fixes" 
svn: E155015: Commit failed (details follow):
svn: E155015: Aborting commit: '/home/svn/project/code/bar.c' remains in confl
ict
$
</screen>
      </informalexample>

      <para>To resolve this conflict, you must either agree or
        disagree with the move that Harry made.</para>

      <para>If you agree with the move, your <filename>bar.c</filename>
        is superfluous.  You'll want to delete it and mark the tree
        conflict as resolved.  But wait:  you made changes to that
        file!  Before deleting <filename>bar.c</filename>, you need to
        decide if the changes you made to it need to be applied
        elsewhere, for example to the new <filename>baz.c</filename>
        file where all of <filename>bar.c</filename>'s code now lives.
        Let's assume that your changes do need to <quote>follow the
        move</quote>.  Subversion isn't smart enough to do this work
        for you<footnote><para>In some cases, Subversion 1.5 and 1.6
        <emphasis>would</emphasis> actually handle this for you, but
        this somewhat hit-or-miss functionality was removed in
        Subversion 1.7.</para></footnote>, so you need to migrate your
        changes manually.</para>

      <para>In our example, you could manually re-make your change
        to <filename>bar.c</filename> pretty easily it was,
        after all, a single-line change.  That's not always the case,
        though, so we'll show a more scalable approach.  We'll first
        use <command>svn diff</command> to create a patch file.  Then
        we'll edit the headers of that patch file to point to the new
        name of our renamed file.  Finally, we re-apply the modified
        patch to our working copy.</para>

      <informalexample>
        <screen>
$ svn diff code/bar.c > PATCHFILE
$ cat PATCHFILE
Index: code/bar.c
===================================================================
--- code/bar.c	(working copy)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$ ### Edit PATCHFILE to refer to code/baz.c instead of code/bar.c
$ cat PATCHFILE
Index: code/baz.c
===================================================================
--- code/baz.c	(working copy)
+++ code/baz.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$ svn patch PATCHFILE
U         code/baz.c
$
</screen>
      </informalexample>

      <para>Now that the changes you originally made
        to <filename>bar.c</filename> have been successfully
        reproduced in <filename>baz.c</filename>, you can
        delete <filename>bar.c</filename> and resolve the conflict,
        instructing the resolution logic to accept what is currently
        in the working copy as the desired result.</para>

      <informalexample>
        <screen>
$ svn delete --force code/bar.c
D         code/bar.c
$ svn resolve --accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
M       code/baz.c
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c  (revision 14)
+++ code/foo.c  (working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/baz.c
===================================================================
--- code/baz.c  (revision 14)
+++ code/baz.c  (working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
$
</screen>
      </informalexample>

      <para>But what if you do not agree with the move?  Well, in that
        case, you can delete <filename>baz.c</filename> instead, after
        making sure any changes made to it after it was renamed are
        either preserved or not worth keeping.  (Do not forget to also
        revert the changes Harry made to <filename>Makefile</filename>.)
        Since <filename>bar.c</filename> is already scheduled for
        re-addition, there is nothing else left to do, and the
        conflict can be marked resolved:</para>

      <informalexample>
        <screen>
$ svn delete --force code/baz.c
D         code/baz.c
$ svn resolve --accept=working code/bar.c
Resolved conflicted state of 'code/bar.c'
$ svn status
M       code/foo.c
A  +    code/bar.c
D       code/baz.c
M       Makefile
$ svn diff
Index: code/foo.c
===================================================================
--- code/foo.c	(revision 14)
+++ code/foo.c	(working copy)
@@ -3,5 +3,5 @@
 int main(int argc, char *argv[])
 {
     printf("I don't like being moved around!\n%s", bar());
-    return 0;
+    return 1;
 }
Index: code/bar.c
===================================================================
--- code/bar.c	(revision 14)
+++ code/bar.c	(working copy)
@@ -1,4 +1,4 @@
 const char *bar(void)
 {
-    return "Me neither!\n";
+    return "Well, I do like being moved around!\n";
 }
Index: code/baz.c
===================================================================
--- code/baz.c	(revision 14)
+++ code/baz.c	(working copy)
@@ -1,4 +0,0 @@
-const char *bar(void)
-{
-    return "Me neither!\n";
-}
Index: Makefile
===================================================================
--- Makefile	(revision 14)
+++ Makefile	(working copy)
@@ -1,2 +1,2 @@
 foo: 
-	$(CC) -o $@ code/foo.c code/baz.c
+	$(CC) -o $@ code/foo.c code/bar.c
</screen>
      </informalexample>

      <para>You've now resolved your first tree conflict!  You can
        commit your changes and tell Harry during tea break about all
        the extra work he caused for you.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.summary">
    <title>Summary</title>

      <para>Now we've covered most of the Subversion client commands.
        Notable exceptions are those dealing with branching and
        merging (see <xref linkend="svn.branchmerge"/>) and properties (see
        <xref linkend="svn.advanced.props"/>).  However, you may want to
        take a moment to skim through <xref linkend="svn.ref.svn"/> to
        get an idea of all the different commands that Subversion
        has and how you can use them to make your work
        easier.</para>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.advanced">
  <title>Advanced Topics</title>

  <para>If you've been reading this book chapter by chapter, from
    start to finish, you should by now have acquired enough
    knowledge to use the Subversion client to perform the most
    common version control operations.  You understand how to
    check out a working copy from a Subversion repository.  You are
    comfortable with submitting and receiving changes using the
    <command>svn commit</command> and <command>svn update</command>
    operations.  You've probably even developed a reflex that causes
    you to run the <command>svn status</command> command almost
    unconsciously.  For all intents and purposes, you are ready to
    use Subversion in a typical environment.</para>

  <para>But the Subversion feature set doesn't stop at <quote>common
    version control operations.</quote>  It has other bits of
    functionality besides just communicating file and
    directory changes to and from a central repository.</para>

  <para>This chapter highlights some of Subversion's features that,
    while important, may not be part of the typical user's daily routine.
    It assumes that you are familiar with Subversion's basic file and
    directory versioning capabilities.  If you aren't, you'll want to
    first read <xref linkend="svn.basic" /> and <xref
    linkend="svn.tour" />.  Once you've mastered those basics and
    consumed this chapter, you'll be a Subversion power user!</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.tour.revs.specifiers">
    <title>Revision Specifiers</title>

    <para>As we described in <xref linkend="svn.basic.in-action.revs"
      />, revision numbers in Subversion are pretty
      straightforward integers that keep getting larger as you
      commit more changes to your versioned data.  Still, it doesn't
      take long before you can no longer remember exactly what
      happened in each and every revision.  Fortunately, the typical
      Subversion workflow doesn't often demand that you supply
      arbitrary revisions to the Subversion operations you perform.
      For operations that <emphasis>do</emphasis> require a revision
      specifier, you generally supply a revision number that you saw
      in a commit email, in the output of some other Subversion
      operation, or in some other context that would give meaning to
      that particular number.</para>

    <note>
      <para>Referring to revision numbers with
        an <quote><literal>r</literal></quote> prefix
        (<literal>r314</literal>, for example) is an established
        practice in Subversion communities, and is both supported and
        encouraged by many Subversion-related tools.  In most places
        where you would specify a bare revision number on the command
        line, you may also use
        the <literal>r</literal><replaceable>NNN</replaceable>
        syntax.</para>
    </note>

    <para>
      <indexterm>
        <primary>revisions</primary>
        <secondary>keywords</secondary>
      </indexterm>But occasionally, you need to pinpoint a moment in
      time for which you don't already have a revision number
      memorized or handy.  So besides the integer revision numbers,
      <command>svn</command> allows as input some additional forms of
      revision specifiers: <firstterm>revision keywords</firstterm>
      and revision dates.</para>

    <note>
      <para>The various forms of Subversion revision specifiers can be
        mixed and matched when used to specify revision ranges.  For
        example, you can use <option>-r
        <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option>
        where <replaceable>REV1</replaceable> is a revision keyword
        and <replaceable>REV2</replaceable> is a revision number, or
        where <replaceable>REV1</replaceable> is a date and
        <replaceable>REV2</replaceable> is a revision keyword, and so
        on.  The individual revision specifiers are independently
        evaluated, so you can put whatever you want on the opposite
        sides of that colon.</para>
    </note>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.keywords">
      <title>Revision Keywords</title>
       
      <indexterm>
        <primary>revisions</primary>
        <secondary>keywords</secondary>
      </indexterm>

      <para>The Subversion client understands a number of revision
        keywords.  These keywords can be used instead of integer
        arguments to the <option>--revision</option>
        (<option>-r</option>) option, and are resolved into specific
        revision numbers by Subversion:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>HEAD</literal></term>
          <listitem>
            <indexterm>
              <primary>HEAD</primary>
            </indexterm>
            <indexterm>
              <primary>revisions</primary>
              <secondary>keywords</secondary>
              <tertiary>HEAD</tertiary>
            </indexterm>
            <para>The latest (or <quote>youngest</quote>) revision in
              the repository.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>BASE</literal></term>
          <listitem>
            <indexterm>
              <primary>BASE</primary>
            </indexterm>
            <indexterm>
              <primary>revisions</primary>
              <secondary>keywords</secondary>
              <tertiary>BASE</tertiary>
            </indexterm>
            <para>The revision number of an item in a working copy.
              If the item has been locally modified, this refers to
              the way the item appears without those local
              modifications.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>COMMITTED</literal></term>
          <listitem>
            <indexterm>
              <primary>COMMITTED</primary>
            </indexterm>
            <indexterm>
              <primary>revisions</primary>
              <secondary>keywords</secondary>
              <tertiary>COMMITTED</tertiary>
            </indexterm>
            <para>The most recent revision prior to, or equal to,
              <literal>BASE</literal>, in which an item changed.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>PREV</literal></term>
          <listitem>
            <indexterm>
              <primary>PREV</primary>
            </indexterm>
            <indexterm>
              <primary>revisions</primary>
              <secondary>keywords</secondary>
              <tertiary>PREV</tertiary>
            </indexterm>
            <para>The revision immediately <emphasis>before</emphasis>
              the last revision in which an item changed.
              Technically, this boils down to
              <literal>COMMITTED</literal>-1.</para>
          </listitem>
        </varlistentry>
        
      </variablelist>

      <para>As can be derived from their descriptions, the
        <literal>PREV</literal>, <literal>BASE</literal>, and
        <literal>COMMITTED</literal> revision keywords are used only
        when referring to a working copy path they don't apply
        to repository URLs.  <literal>HEAD</literal>, on the other
        hand, can be used in conjunction with both of these path
        types.</para>
      
      <para>Here are some examples of revision keywords in
        action:</para>
      
      <informalexample>
        <screen>
$ svn diff -r PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log -r HEAD
# shows log message for the latest repository commit

$ svn diff -r HEAD
# compares your working copy (with all of its local changes) to the
# latest version of that tree in the repository

$ svn diff -r BASE:HEAD foo.c
# compares the unmodified version of foo.c with the latest version of
# foo.c in the repository

$ svn log -r BASE:HEAD
# shows all commit logs for the current versioned directory since you
# last updated

$ svn update -r PREV foo.c
# rewinds the last change on foo.c, decreasing foo.c's working revision

$ svn diff -r BASE:14 foo.c
# compares the unmodified version of foo.c with the way foo.c looked
# in revision 14
</screen>
      </informalexample>
      
    </sect2>
    
    <!-- =============================================================== -->
    <sect2 id="svn.tour.revs.dates">
      <title>Revision Dates</title>
      
      <indexterm>
        <primary>revisions</primary>
        <secondary>as dates</secondary>
      </indexterm>

      <para>Revision numbers reveal nothing about the world outside
        the version control system, but sometimes you need to
        correlate a moment in real time with a moment in version
        history.  To facilitate this, the <option>--revision</option>
        (<option>-r</option>) option can also accept as input date
        specifiers wrapped in curly braces (<literal>{</literal> and
        <literal>}</literal>).  Subversion accepts the standard
        ISO-8601 date and time formats, plus a few others.  Here are
        some examples.</para>

      <informalexample>
        <screen>
$ svn update -r {2006-02-17}
$ svn update -r {15:30}
$ svn update -r {15:30:00.200000}
$ svn update -r {"2006-02-17 15:30"}
$ svn update -r {"2006-02-17 15:30 +0230"}
$ svn update -r {2006-02-17T15:30}
$ svn update -r {2006-02-17T15:30Z}
$ svn update -r {2006-02-17T15:30-04:00}
$ svn update -r {20060217T1530}
$ svn update -r {20060217T1530Z}
$ svn update -r {20060217T1530-0500}
 
</screen>
      </informalexample>

      <note>
        <para>Keep in mind that most shells will require you to, at a
          minimum, quote or otherwise escape any spaces that are
          included as part of revision date specifiers.  Certain
          shells may also take issue with the unescaped use of curly
          braces, too.  Consult your shell's documentation for the
          requirements specific to your environment.</para>
      </note>
    
      <para>When you specify a date, Subversion resolves that date to
        the most recent revision of the repository as of that date,
        and then continues to operate against that resolved revision
        number:</para>
        
      <informalexample>
        <screen>
$ svn log -r {2006-11-28}
------------------------------------------------------------------------
r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines
 
</screen>
      </informalexample>
        
      <sidebar>
        <title>Is Subversion a Day Early?</title>
        
        <para>If you specify a single date as a revision without
          specifying a time of day (for example
          <literal>2006-11-27</literal>), you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <emphasis>most recent revision of the
          repository</emphasis> as of the date you give.  If you give
          a date without a timestamp, such as
          <literal>2006-11-27</literal>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the 27th.</para>

        <para>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<literal>{"2006-11-27
          23:59"}</literal>), or just specify the next day
          (<literal>{2006-11-28}</literal>).</para>
        
      </sidebar>
      
      <para>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</para>
      
      <informalexample>
        <screen>
$ svn log -r {2006-11-20}:{2006-11-29}
 
</screen>
      </informalexample>
        
      <warning>
        <para>Since the timestamp of a revision is stored as an
          unversioned, modifiable property of the revision (see <xref
          linkend="svn.advanced.props" />), revision timestamps can be
          changed to represent complete falsifications of true
          chronology, or even removed altogether.  Subversion's
          ability to correctly convert revision dates into real
          revision numbers depends on revision datestamps maintaining
          a sequential ordering the younger the revision, the
          younger its timestamp.  If this ordering isn't maintained,
          you will likely find that trying to use dates to specify
          revision ranges in your repository doesn't always return the
          data you might have expected.</para>
      </warning>
        
    </sect2>
      
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.pegrevs">
    <title>Peg and Operative Revisions</title>

    <para>We copy, move, rename, and completely replace files and
      directories on our computers all the time.  And your version
      control system shouldn't get in the way of your doing these
      things with your version-controlled files and directories,
      either.  Subversion's file management support is quite
      liberating, affording almost as much flexibility for versioned
      files as you'd expect when manipulating your unversioned ones.
      But that flexibility means that across the lifetime of your
      repository, a given versioned object might have many paths, and
      a given path might represent several entirely different
      versioned objects.  This introduces a certain level of
      complexity to your interactions with those paths and
      objects.</para>

    <para>Subversion is pretty smart about noticing when an object's
      version history includes such <quote>changes of address.</quote>
      For example, if you ask for the revision history log of a
      particular file that was renamed last week, Subversion happily
      provides all those logs the revision in which the rename
      itself happened, plus the logs of relevant revisions both before
      and after that rename.  So, most of the time, you don't even
      have to think about such things.  But occasionally, Subversion
      needs your help to clear up ambiguities.</para>

    <para>The simplest example of this occurs when a directory or file
      is deleted from version control, and then a new directory or
      file is created with the same name and added to version control.
      The thing you deleted and the thing you later added aren't the
      same thing.  They merely happen to have had the same
      path <filename>/trunk/object</filename>, for example.
      What, then, does it mean to ask Subversion about the history of
      <filename>/trunk/object</filename>?  Are you asking about the
      thing currently at that location, or the old thing you deleted
      from that location?  Are you asking about the operations that
      have happened to <emphasis>all</emphasis> the objects that have
      ever lived at that path?  Subversion needs a hint about what you
      really want.</para>

    <para>And thanks to moves, versioned object history can get far
      more twisted than even that.  For example, you might have a
      directory named <filename>concept</filename>, containing some
      nascent software project you've been toying with.  Eventually,
      though, that project matures to the point that the idea seems to
      actually have some wings, so you do the unthinkable and decide
      to give the project a name.<footnote><para><quote>You're not
      supposed to name it.  Once you name it, you start getting
      attached to it.</quote> Mike Wazowski</para></footnote>
      Let's say you called your software Frabnaggilywort.  At this
      point, it makes sense to rename the directory to reflect the
      project's new name, so <filename>concept</filename> is renamed
      to <filename>frabnaggilywort</filename>.  Life goes on,
      Frabnaggilywort releases a 1.0 version and is downloaded and
      used daily by hordes of people aiming to improve their
      lives.</para>
    
    <para>It's a nice story, really, but it doesn't end there.
      Entrepreneur that you are, you've already got another think in
      the tank.  So you make a new directory,
      <filename>concept</filename>, and the cycle begins again.  In
      fact, the cycle begins again many times over the years, each
      time starting with that old <filename>concept</filename>
      directory, then sometimes seeing that directory renamed as the
      idea cures, sometimes seeing it deleted when you scrap the idea.
      Or, to get really sick, maybe you rename
      <filename>concept</filename> to something else for a while, but
      later rename the thing back to <filename>concept</filename> for
      some reason.</para>

    <para>In scenarios like these, attempting to instruct
      Subversion to work with these reused paths can be a little like
      instructing a motorist in Chicago's West Suburbs to drive east
      down Roosevelt Road and turn left onto Main Street.  In a mere
      20 minutes, you can cross <quote>Main Street</quote> in
      Wheaton, Glen Ellyn, and Lombard.  And no, they aren't the same
      street.  Our motorist and our Subversion need a
      little more detail to do the right thing.</para>

    <para>
      <indexterm>
        <primary>revisions</primary>
        <secondary>peg revisions</secondary>
      </indexterm>
      <indexterm>
        <primary>at syntax</primary>
      </indexterm>
      <indexterm>
        <primary>@</primary>
        <see>at syntax</see>
      </indexterm>Fortunately, Subversion allows you to tell it
      exactly which Main Street you meant.  The mechanism used is
      called a <firstterm>peg revision</firstterm>, and you provide
      these to Subversion for the sole purpose of identifying unique
      lines of history.  Because at most one versioned object may
      occupy a path at any given time or, more precisely, in any
      one revision the combination of a path and a peg revision
      is all that is needed to unambiguously identify a specific line
      of history.  Peg revisions are specified to the Subversion
      command-line client using <firstterm>at syntax</firstterm>, so
      called because the syntax involves appending an <quote>at
      sign</quote> (<literal>@</literal>) and the peg revision to the
      end of the path with which the revision is associated.</para>

    <para>
      <indexterm>
        <primary>revisions</primary>
        <secondary>operative revisions</secondary>
      </indexterm>
      <indexterm>
        <primary>revisions</primary>
        <secondary>operative revision range</secondary>
      </indexterm>But what of the <option>--revision</option>
      (<option>-r</option>) of which we've spoken so much in this
      book?  That revision (or set of revisions) is called the
      <firstterm>operative revision</firstterm> (or
      <firstterm>operative revision range</firstterm>).  Once a
      particular line of history has been identified using a path and
      peg revision, Subversion performs the requested operation using
      the operative revision(s).  To map this to our Chicagoland
      streets analogy, if we are told to go to 606 N. Main Street in
      Wheaton,<footnote><para>606 N. Main Street, Wheaton, Illinois,
      is the home of the Wheaton <emphasis>History</emphasis> Center.
      It seemed appropriate </para></footnote> we can think
      of <quote>Main Street</quote> as our path and
      <quote>Wheaton</quote> as our peg revision.  These two pieces of
      information identify a unique path that can be traveled (north or
      south on Main Street), and they keep us from traveling up and
      down the wrong Main Street in search of our destination.  Now we
      throw in <quote>606 N.</quote> as our operative revision of
      sorts, and we know <emphasis>exactly</emphasis> where to
      go.</para>

    <sidebar id="svn.advanced.pegrevs.algorithm">
      <title>The Peg Revision Algorithm</title>
      
      <para>The Subversion command-line client performs the peg revision
        algorithm any time it needs to resolve possible ambiguities in
        the paths and revisions provided to it.  Here's an example of
        such an invocation:</para>

      <informalexample>
        <screen>
$ svn <replaceable>command</replaceable> -r <replaceable>OPERATIVE-REV</replaceable> item@<replaceable>PEG-REV</replaceable>
</screen>
      </informalexample>
      
      <para>If <replaceable>OPERATIVE-REV</replaceable> is older than
        <replaceable>PEG-REV</replaceable>, the algorithm is as
        follows:</para>

      <orderedlist>
        <listitem>
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>PEG-REV</replaceable>.  There
            can be only one such object.</para>
        </listitem>
        <listitem>
          <para>Trace the object's history backwards (through any
            possible renames) to its ancestor in the revision
            <replaceable>OPERATIVE-REV</replaceable>.</para>
        </listitem>
        <listitem>
          <para>Perform the requested action on that ancestor,
            wherever it is located, or whatever its name might
            be or might have been at that time.</para>
        </listitem>
      </orderedlist>

      <para>But what if <replaceable>OPERATIVE-REV</replaceable> is
        <emphasis>younger</emphasis> than
        <replaceable>PEG-REV</replaceable>?  Well, that adds some
        complexity to the theoretical problem of locating the path in
        <replaceable>OPERATIVE-REV</replaceable>, because the path's
        history could have forked multiple times (thanks to copy
        operations) between <replaceable>PEG-REV</replaceable> and
        <replaceable>OPERATIVE-REV</replaceable>.  And that's not
        all Subversion doesn't store enough information to
        performantly trace an object's history forward, anyway.  So
        the algorithm is a little different:</para>

      <orderedlist>
        <listitem>
          <para>Locate <replaceable>item</replaceable> in the revision
            identified by <replaceable>OPERATIVE-REV</replaceable>.  There
            can be only one such object.</para>
        </listitem>
        <listitem>
          <para>Trace the object's history backward (through any
            possible renames) to its ancestor in the revision
            <replaceable>PEG-REV</replaceable>.</para>
        </listitem>
        <listitem>
          <para>Verify that the object's location (path-wise) in
            <replaceable>PEG-REV</replaceable> is the same as it is in
            <replaceable>OPERATIVE-REV</replaceable>.  If that's the
            case, at least the two locations are known to be
            directly related, so perform the requested action on the
            location in <replaceable>OPERATIVE-REV</replaceable>.
            Otherwise, relatedness was not established, so error out
            with a loud complaint that no viable location was found.
            (Someday, we expect that Subversion will be able to handle
            this usage scenario with more flexibility and
            grace.)</para>
        </listitem>
      </orderedlist>

      <para>Note that even when you don't explicitly supply a peg
        revision or operative revision, they are still present.  For
        your convenience, the default peg revision is
        <literal>BASE</literal> for working copy items and
        <literal>HEAD</literal> for repository URLs.  And when no
        operative revision is provided, it defaults to being the same
        revision as the peg revision.</para>
        
    </sidebar>

    <para>Say that long ago we created our repository, and in revision 1
      we added our first <filename>concept</filename> directory, plus an
      <filename>IDEA</filename> file in that directory talking about
      the concept.  After several revisions in which real code was
      added and tweaked, we, in revision 20, renamed this directory to
      <filename>frabnaggilywort</filename>.  By revision 27, we had a
      new concept, a new <filename>concept</filename> directory to
      hold it, and a new <filename>IDEA</filename> file to describe
      it.  And then five years and thousands of revisions flew by,
      just like they would in any good romance story.</para>

    <para>Now, years later, we wonder what the
      <filename>IDEA</filename> file looked like back in revision 1.
      But Subversion needs to know whether we are asking about how the
      <emphasis>current</emphasis> file looked back in revision 1, or
      whether we are asking for the contents of whatever file lived at
      <filename>concept/IDEA</filename> in revision 1.  Certainly
      those questions have different answers, and because of peg
      revisions, you can ask those questions.  To find out how the
      current <filename>IDEA</filename> file looked in that old
      revision, you run:</para>

    <informalexample>
      <screen>
$ svn cat -r 1 concept/IDEA 
svn: E195012: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>
    </informalexample>

    <para>Of course, in this example, the current
      <filename>IDEA</filename> file didn't exist yet in revision 1,
      so Subversion gives an error.  The previous command is shorthand
      for a longer notation which explicitly lists a peg revision.
      The expanded notation is:</para>

    <informalexample>
      <screen>
$ svn cat -r 1 concept/IDEA@BASE
svn: E195012: Unable to find repository location for 'concept/IDEA' in revision 1
</screen>
    </informalexample>

    <para>And when executed, it has the expected results.</para>

    <para>The perceptive reader is probably wondering at this point whether
      the peg revision syntax causes problems for working copy paths
      or URLs that actually have at signs in them.  After
      all, how does <command>svn</command> know whether
      <literal>news@11</literal> is the name of a directory in my
      tree or just a syntax for <quote>revision 11 of
      <filename>news</filename></quote>?  Thankfully, while
      <command>svn</command> will always assume the latter, there is a
      trivial workaround.  You need only append an at sign to the
      end of the path, such as <literal>news@11@</literal>.
      <command>svn</command> cares only about the last at sign in
      the argument, and it is not considered illegal to omit a literal
      peg revision specifier after that at sign.  This workaround
      even applies to paths that end in an at sign you would
      use <literal>filename@@</literal> to talk about a file named
      <filename>filename@</filename>.</para>

    <para>Let's ask the other question, then in revision 1, what
      were the contents of whatever file occupied the address
      <filename>concepts/IDEA</filename> at the time?  We'll use an
      explicit peg revision to help us out.</para>

    <informalexample>
      <screen>
$ svn cat concept/IDEA@1
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>
    </informalexample>

    <para>Notice that we didn't provide an operative revision this
      time.  That's because when no operative revision is specified,
      Subversion assumes a default operative revision that's the same
      as the peg revision.</para>

    <para>As you can see, the output from our operation appears to be
      correct.  The text even mentions frabbing naggily worts, so this
      is almost certainly the file that describes the software now
      called Frabnaggilywort.  In fact, we can verify this using the
      combination of an explicit peg revision and explicit operative
      revision.  We know that in <literal>HEAD</literal>, the
      Frabnaggilywort project is located in the
      <filename>frabnaggilywort</filename> directory.  So we specify
      that we want to see how the line of history identified in
      <literal>HEAD</literal> as the path
      <filename>frabnaggilywort/IDEA</filename> looked in revision
      1.</para>

    <informalexample>
      <screen>
$ svn cat -r 1 frabnaggilywort/IDEA@HEAD
The idea behind this project is to come up with a piece of software
that can frab a naggily wort.  Frabbing naggily worts is tricky
business, and doing it incorrectly can have serious ramifications, so
we need to employ over-the-top input validation and data verification
mechanisms.
</screen>
    </informalexample>

    <para>And the peg and operative revisions need not be so trivial,
      either.  For example, say <filename>frabnaggilywort</filename>
      had been deleted from <literal>HEAD</literal>, but we know it
      existed in revision 20, and we want to see the diffs for its
      <filename>IDEA</filename> file between revisions 4 and 10.  We
      can use peg revision 20 in conjunction with the URL that
      would have held Frabnaggilywort's <filename>IDEA</filename> file
      in revision 20, and then use 4 and 10 as our operative revision
      range.</para>

    <informalexample>
      <screen>
$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20
Index: frabnaggilywort/IDEA
===================================================================
--- frabnaggilywort/IDEA	(revision 4)
+++ frabnaggilywort/IDEA	(revision 10)
@@ -1,5 +1,5 @@
-The idea behind this project is to come up with a piece of software
-that can frab a naggily wort.  Frabbing naggily worts is tricky
-business, and doing it incorrectly can have serious ramifications, so
-we need to employ over-the-top input validation and data verification
-mechanisms.
+The idea behind this project is to come up with a piece of
+client-server software that can remotely frab a naggily wort.
+Frabbing naggily worts is tricky business, and doing it incorrectly
+can have serious ramifications, so we need to employ over-the-top
+input validation and data verification mechanisms.
</screen>
    </informalexample>

    <para>Fortunately, most folks aren't faced with such complex
      situations.  But when you are, remember that peg revisions are
      that extra hint Subversion needs to clear up ambiguity.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props">
    <title>Properties</title>

    <para>We've already covered in detail how Subversion stores and
      retrieves various versions of files and directories in its
      repository.  Whole chapters have been devoted to this most
      fundamental piece of functionality provided by the tool.  And
      if the versioning support stopped there, Subversion would still
      be complete from a version control perspective.</para>

    <para>But it doesn't stop there.</para>

    <para>
      <indexterm>
        <primary>properties</primary>
      </indexterm>In addition to versioning your directories and files,
      Subversion provides interfaces for adding, modifying, and
      removing versioned metadata on each of your versioned
      directories and files.  We refer to this metadata as
      <firstterm>properties</firstterm>, and they can be thought of as
      two-column tables that map property names to arbitrary values
      attached to each item in your working copy.  Generally speaking,
      the names and values of the properties can be whatever you want
      them to be, with the constraint that the names must contain only
      ASCII characters.  And the best part about these properties is
      that they, too, are versioned, just like the textual contents of
      your files.  You can modify, commit, and revert property changes
      as easily as you can file content changes.  And the sending and
      receiving of property changes occurs as part of your typical
      commit and update operations you don't have to change your
      basic processes to accommodate them.</para>

    <note>
      <para>Subversion has reserved the set of properties whose names
        begin with <literal>svn:</literal> as its own.  While there
        are only a handful of such properties in use today, you should
        avoid creating custom properties for your own needs whose names
        begin with this prefix.  Otherwise, you run the risk that a
        future release of Subversion will grow support for a feature
        or behavior driven by a property of the same name but with
        perhaps an entirely different interpretation.</para>
    </note>

    <para>Properties show up elsewhere in Subversion, too.  Just as
      files and directories may have arbitrary property names and
      values attached to them, each revision as a whole may have
      arbitrary properties attached to it.  The same constraints
      apply human-readable names and anything-you-want binary
      values.  The main difference is that revision properties are not
      versioned.  In other words, if you change the value of, or
      delete, a revision property, there's no way, within the scope of
      Subversion's functionality, to recover the previous value.</para>

    <para>Subversion has no particular policy regarding the use of
      properties.  It asks only that you do not use property names that
      begin with the prefix <literal>svn:</literal> as that's the
      namespace that it sets aside for its own use.  And Subversion
      does, in fact, use properties both the versioned and
      unversioned variety.  Certain versioned properties have special
      meaning or effects when found on files and directories, or they
      house a particular bit of information about the revisions on
      which they are found.  Certain revision properties are
      automatically attached to revisions by Subversion's commit
      process, and they carry information about the revision.  Most of
      these properties are mentioned elsewhere in this or other
      chapters as part of the more general topics to which they are
      related.  For an exhaustive list of Subversion's predefined
      properties, see <xref linkend="svn.advanced.props.ref" />.</para>

    <note>
      <para>While Subversion automatically attaches properties
        (<literal>svn:date</literal>, <literal>svn:author</literal>,
        <literal>svn:log</literal>, and so on) to revisions, it does
        <emphasis>not</emphasis> presume thereafter the existence of
        those properties, and neither should you or the tools you use to
        interact with your repository.  Revision properties can be
        deleted programmatically or via the client (if allowed by the
        repository hooks) without damaging Subversion's ability to
        function.  So, when writing scripts which operate on your
        Subversion repository data, do not make the mistake of
        assuming that any particular revision property exists on a
        revision.</para>
    </note>

    <para>In this section, we will examine the utility both to
      users of Subversion and to Subversion itself of property
      support.  You'll learn about the property-related
      <command>svn</command> subcommands and how property
      modifications affect your normal Subversion workflow.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.why">
      <title>Why Properties?</title>

      <para>Just as Subversion uses properties to store extra
        information about the files, directories, and revisions that
        it contains, you might also find properties to be of similar
        use.  You might find it useful to have a place
        close to your versioned data to hang custom metadata about
        that data.</para>

      <para>Say you wish to design a web site that houses many digital
        photos and displays them with captions and a datestamp.  Now,
        your set of photos is constantly changing, so you'd like to
        have as much of this site automated as possible.  These photos
        can be quite large, so as is common with sites of this nature,
        you want to provide smaller thumbnail images to your site
        visitors.</para>

      <para>Now, you can get this functionality using traditional
        files.  That is, you can have your
        <filename>image123.jpg</filename> and an
        <filename>image123-thumbnail.jpg</filename> side by side in a
        directory.  Or if you want to keep the filenames the same, you
        might have your thumbnails in a different directory, such as
        <filename>thumbnails/image123.jpg</filename>.  You can also
        store your captions and datestamps in a similar fashion, again
        separated from the original image file.  But the problem here
        is that your collection of files multiplies with each new
        photo added to the site.</para>

      <para>Now consider the same web site deployed in a way that
        makes use of Subversion's file properties.  Imagine having a
        single image file, <filename>image123.jpg</filename>, with
        properties set on that file that are named
        <literal>caption</literal>, <literal>datestamp</literal>, and
        even <literal>thumbnail</literal>.  Now your working copy
        directory looks much more manageable in fact, it looks
        to the casual browser like there are nothing but image files
        in it.  But your automation scripts know better.  They know
        that they can use <command>svn</command> (or better yet, they
        can use the Subversion language bindings see <xref
        linkend="svn.developer.usingapi" />) to dig out the extra
        information that your site needs to display without having to
        read an index file or play path manipulation games.</para>

      <note>
        <para>While Subversion places few restrictions on the names
          and values you use for properties, it has not been designed
          to optimally carry large property values or large sets of
          properties on a given file or directory.  Subversion
          commonly holds all the property names and values associated
          with a single item in memory at the same time, which can
          cause detrimental performance or failed operations when
          extremely large property sets are used.</para>
      </note>

      <para>Custom revision properties are also frequently used.  One
        common such use is a property whose value contains an issue
        tracker ID with which the revision is associated, perhaps
        because the change made in that revision fixes a bug filed in
        the tracker issue with that ID.  Other uses include hanging
        more friendly names on the revision it might be hard to
        remember that revision 1935 was a fully tested revision.  But
        if there's, say, a <literal>test-results</literal> property on
        that revision with the value <literal>all passing</literal>,
        that's meaningful information to have.  And Subversion allows
        you to easily do this via the <option>--with-revprop</option>
        option of the <command>svn commit</command> command:</para>

      <informalexample>
        <screen>
$ svn commit -m "Fix up the last remaining known regression bug." \
             --with-revprop "test-results=all passing"
Sending        lib/crit_bits.c
Transmitting file data .
Committed revision 912.
$
</screen>
      </informalexample>

      <sidebar>
        <title>Searchability (or, Why <emphasis>Not</emphasis>
          Properties)</title>

        <para>For all their utility, Subversion properties or,
          more accurately, the available interfaces to them have
          a major shortcoming: while it is a simple matter to
          <emphasis>set</emphasis> a custom property,
          <emphasis>finding</emphasis> that property later is a whole
          different ball of wax.</para>

        <para>Trying to locate a custom revision property generally
          involves performing a linear walk across all the revisions
          of the repository, asking of each revision, <quote>Do you
          have the property I'm looking for?</quote>  Use
          the <option>--with-all-revprops</option> option with
          the <command>svn log</command> command's XML output mode to
          facilitate this search.  Notice the presence of the custom
          revision property <literal>testresults</literal> in the
          following output:</para>

        <informalexample>
          <screen>
$ svn log --with-all-revprops --xml lib/crit_bits.c
&lt;?xml version="1.0"?&gt;
&lt;log&gt;
&lt;logentry
   revision="912"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2011-07-29T14:47:41.169894Z&lt;/date&gt;
&lt;msg&gt;Fix up the last remaining known regression bug.&lt;/msg&gt;
&lt;revprops&gt;
&lt;property
   name="testresults"&gt;all passing&lt;/property&gt;
&lt;/revprops&gt;
&lt;/logentry&gt;
 
$
</screen>
        </informalexample>

        <para>Trying to find a custom versioned property is painful,
          too, and often involves a recursive <command>svn
          propget</command> across an entire working copy.  In your
          situation, that might not be as bad as a linear walk across
          all revisions.  But it certainly leaves much to be desired
          in terms of both performance and likelihood of success,
          especially if the scope of your search would require a
          working copy from the root of your repository.</para>

        <para>For this reason, you might choose especially in
          the revision property use case to simply add your
          metadata to the revision's log message using some
          policy-driven (and perhaps programmatically enforced)
          formatting that is designed to be quickly parsed from the
          output of <command>svn log</command>.  It is quite common to
          see the following in Subversion log messages:</para>

        <informalexample>
          <programlisting>
Issue(s): IZ2376, IZ1919
Reviewed by:  sally

This fixes a nasty segfault in the wort frabbing process
 
</programlisting>
        </informalexample>

        <para>But here again lies some misfortune.  Subversion doesn't
          yet provide a log message templating mechanism, which would
          go a long way toward helping users be consistent with the
          formatting of their log-embedded revision metadata.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.manip">
      <title>Manipulating Properties</title>

      <para>The <command>svn</command> program affords a few ways to
        add or modify file and directory properties.  For properties
        with short, human-readable values, perhaps the simplest way to
        add a new property is to specify the property name and value
        on the command line of the <command>svn propset</command>
        subcommand:</para>

      <informalexample>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c
property 'copyright' set on 'calc/button.c'
$
</screen>
      </informalexample>
       
      <para>But we've been touting the flexibility that Subversion
        offers for your property values.  And if you are planning to
        have a multiline textual, or even binary, property value, you
        probably do not want to supply that value on the command line.
        So the <command>svn propset</command> subcommand takes a
        <option>--file</option> (<option>-F</option>) option for
        specifying the name of a file that contains the new property
        value.</para>

      <informalexample>
        <screen>
$ svn propset license -F /path/to/LICENSE calc/button.c
property 'license' set on 'calc/button.c'
$
</screen>
      </informalexample>

      <para>There are some restrictions on the names you can use for
        properties.  A property name must start with a letter, a colon
        (<literal>:</literal>), or an underscore
        (<literal>_</literal>); after that, you can also use digits,
        hyphens (<literal>-</literal>), and periods
        (<literal>.</literal>).<footnote><para>If you're familiar with
        XML, this is pretty much the ASCII subset of the syntax for
        XML <quote>Name</quote>.</para></footnote></para>

      <para>In addition to the <command>propset</command> command, the
        <command>svn</command> program supplies the
        <command>propedit</command> command.  This command uses the
        configured editor program (see <xref
        linkend="svn.advanced.confarea.opts.config" />) to add or
        modify properties.  When you run the command,
        <command>svn</command> invokes your editor program on a
        temporary file that contains the current value of the property
        (or that is empty, if you are adding a new property).  Then,
        you just modify that value in your editor program until it
        represents the new value you wish to store for the property,
        save the temporary file, and then exit the editor program.  If
        Subversion detects that you've actually changed the existing
        value of the property, it will accept that as the new property
        value.  If you exit your editor without making any changes, no
        property modification will occur:</para>

      <informalexample>
        <screen>
$ svn propedit copyright calc/button.c  ### exit the editor without changes
No changes to property 'copyright' on 'calc/button.c'
$
</screen>
      </informalexample>

      <para>We should note that, as with other <command>svn</command>
        subcommands, those related to properties can act on multiple
        paths at once.  This enables you to modify properties on whole
        sets of files with a single command.  For example, we could
        have done the following:</para>

      <informalexample>
        <screen>
$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*
property 'copyright' set on 'calc/Makefile'
property 'copyright' set on 'calc/button.c'
property 'copyright' set on 'calc/integer.c'
 
$
</screen>
      </informalexample>

      <para>All of this property adding and editing isn't really very
        useful if you can't easily get the stored property value.  So
        the <command>svn</command> program supplies two subcommands
        for displaying the names and values of properties stored on
        files and directories.  The <command>svn proplist</command>
        command will list the names of properties that exist on a
        path.  Once you know the names of the properties on the node,
        you can request their values individually using <command>svn
        propget</command>.  This command will, given a property name
        and a path (or set of paths), print the value of the property
        to the standard output stream.</para>

      <informalexample>
        <screen>
$ svn proplist calc/button.c
Properties on 'calc/button.c':
  copyright
  license
$ svn propget copyright calc/button.c
(c) 2006 Red-Bean Software
</screen>
      </informalexample>

      <para>There's even a variation of the
        <command>proplist</command> command that will list both the
        name and the value for all of the properties.  Simply supply the
        <option>--verbose</option> (<option>-v</option>) option.</para>

      <informalexample>
        <screen>
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright
    (c) 2006 Red-Bean Software
  license
    ================================================================
    Copyright (c) 2006 Red-Bean Software.  All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions 
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions, and the recipe for Fitz's famous
    red-beans-and-rice.
     
</screen>
      </informalexample>

      <para>The last property-related subcommand is
        <command>propdel</command>.  Since Subversion allows you to
        store properties with empty values, you can't remove a
        property altogether using <command>svn propedit</command> or
        <command>svn propset</command>.  For example, this command will
        <emphasis>not</emphasis> yield the desired effect:</para>

      <informalexample>
        <screen>
$ svn propset license "" calc/button.c
property 'license' set on 'calc/button.c'
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright
    (c) 2006 Red-Bean Software
  license
    
$
</screen>
      </informalexample>

      <para>You need to use the <command>propdel</command> subcommand
        to delete properties altogether.  The syntax is similar to the
        other property commands:</para>

      <informalexample>
        <screen>
$ svn propdel license calc/button.c
property 'license' deleted from 'calc/button.c'.
$ svn proplist -v calc/button.c
Properties on 'calc/button.c':
  copyright
    (c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

      <para>Remember those unversioned revision properties?  You can
        modify those, too, using the same <command>svn</command>
        subcommands that we just described.  Simply add the
        <option>--revprop</option> command-line parameter and specify
        the revision whose property you wish to modify.  Since
        revisions are global, you don't need to specify a target path
        to these property-related commands so long as you are
        positioned in a working copy of the repository whose revision
        property you wish to modify.  Otherwise, you can simply
        provide the URL of any path in the repository of interest
        (including the repository's root URL).  For example, you might
        want to replace the commit log message of an existing
        revision.<footnote><para>Fixing spelling errors, grammatical
        gotchas, and <quote>just-plain-wrongness</quote> in commit log
        messages is perhaps the most common use case for
        the <option>--revprop</option> option.</para></footnote>  If
        your current working directory is part of a working copy of
        your repository, you can simply run the
        <command>svn propset</command> command with no target path:</para>

      <informalexample>
        <screen>
$ svn propset svn:log "* button.c: Fix a compiler warning." -r11 --revprop
property 'svn:log' set on repository revision '11'
$
</screen>
      </informalexample>

      <para>But even if you haven't checked out a working copy from
        that repository, you can still effect the property change by
        providing the repository's root URL:</para>

      <informalexample>
        <screen>
$ svn propset svn:log "* button.c: Fix a compiler warning." -r11 --revprop \
              http://svn.example.com/repos/project
property 'svn:log' set on repository revision '11'
$
</screen>
      </informalexample>

      <para>Note that the ability to modify these unversioned
        properties must be explicitly added by the repository
        administrator (see <xref linkend="svn.reposadmin.maint.setlog" />).
        That's because the properties aren't versioned, so you run the risk of
        losing information if you aren't careful with your edits.
        The repository administrator can set up methods to protect
        against this loss, and by default, modification of
        unversioned properties is disabled.</para>

      <tip>
        <para>Users should, where possible, use <command>svn
          propedit</command> instead of <command>svn
          propset</command>.  While the end result of the commands is
          identical, the former will allow them to see the current
          value of the property that they are about to change, which helps
          them to verify that they are, in fact, making the change
          they think they are making.  This is especially true when
          modifying unversioned revision properties.  Also, it is
          significantly easier to modify multiline property values in
          a text editor than at the command line.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.workflow">
      <title>Properties and the Subversion Workflow</title>

      <para>Now that you are familiar with all of the
        property-related <command>svn</command> subcommands, let's see
        how property modifications affect the usual Subversion
        workflow.  As we mentioned earlier, file and directory
        properties are versioned, just like your file contents.  As a
        result, Subversion provides the same opportunities for
        merging cleanly or with conflicts someone
        else's modifications into your own.</para>

      <para>As with file contents, your property changes are local
        modifications, made permanent only when you commit them to the
        repository with <command>svn commit</command>.  Your property
        changes can be easily unmade, too the <command>svn
        revert</command> command will restore your files and
        directories to their unedited states contents, properties,
        and all.  Also, you can receive interesting information about
        the state of your file and directory properties by using the
        <command>svn status</command> and <command>svn diff</command>
        commands.</para>

      <informalexample>
        <screen>
$ svn status calc/button.c
 M      calc/button.c
$ svn diff calc/button.c
Property changes on: calc/button.c
___________________________________________________________________
Added: copyright
## -0,0 +1 ##
+(c) 2006 Red-Bean Software
$
</screen>
      </informalexample>

      <para>Notice how the <command>status</command> subcommand
        displays <literal>M</literal> in the second column instead of
        the first.  That is because we have modified the properties on
        <filename>calc/button.c</filename>, but not its textual
        contents.  Had we changed both, we would have seen
        <literal>M</literal> in the first column, too.  (We cover
        <command>svn status</command> in <xref
        linkend="svn.tour.cycle.examine.status" />).</para>

      <sidebar>
        <title>Property Conflicts</title>

        <para>As with file contents, local property modifications can
          conflict with changes committed by someone else.  If you
          update your working copy directory and receive property
          changes on a versioned object that clash with your own,
          Subversion will report that the object is in a conflicted
          state.</para>
 
        <informalexample>
          <screen>
$ svn update calc
Updating 'calc':
M  calc/Makefile.in
Conflict for property 'linecount' discovered on 'calc/button.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (s) show all options: p
 C calc/button.c
Updated to revision 143.
Summary of conflicts:
  Property conflicts: 1
$ 
</screen>
        </informalexample>
         
        <para>Subversion will also create, in the same directory as
          the conflicted object, a file with a
          <filename>.prej</filename> extension that contains the
          details of the conflict.  You should examine the contents of
          this file so you can decide how to resolve the conflict.
          Until the conflict is resolved, you will see a
          <literal>C</literal> in the second column of <command>svn
          status</command> output for that object, and attempts to
          commit your local modifications will fail.</para>

        <informalexample>
          <screen>
$ svn status calc
 C      calc/button.c
?       calc/button.c.prej
$ cat calc/button.c.prej 
Trying to change property 'linecount' from '1267' to '1301',
but property has been locally changed from '1267' to '1256'.
$
</screen>
        </informalexample>
 
        <para>To resolve property conflicts, simply ensure that the
          conflicting properties contain the values that they should,
          and then use the <command>svn resolve --accept=working</command>
          command to alert Subversion that you have manually resolved the
          problem.</para>

      </sidebar>

      <para>You might also have noticed the nonstandard way that
        Subversion currently displays property differences.  You can
        still use <command>svn diff</command> and redirect its output
        to create a usable patch file.  The <command>patch</command>
        program will ignore property patches as a rule, it
        ignores any noise it can't understand.  This does,
        unfortunately, mean that to fully apply a patch generated by
        <command>svn diff</command> using <command>patch</command>,
        any property modifications will need to be applied by
        hand.</para>

      <para>Subversion 1.7 improves this situation in two ways.
        First, its nonstandard display of property differences is at
        least machine-readable an improvement over the display
        of properties in versions prior to 1.7.  But Subversion 1.7
        also introduces the <command>svn patch</command> subcommand,
        designed specifically to handle the additional information
        which <command>svn diff</command>'s output can carry, applying
        those changes to the Subversion working copy.  Of specific
        relevance to our topic, property differences present in patch
        files generated by <command>svn diff</command> in Subversion
        1.7 or better can be automatically applied to a working copy
        by the <command>svn patch</command> command.  For more
        about <command>svn patch</command>, see
        <xref linkend="svn.ref.svn.c.patch" /> in
        <xref linkend="svn.ref.svn"/>.</para>

      <note>
        <para>There's one exception to how property changes are
          reported by <command>svn diff</command>: changes to
          Subversion's special <literal>svn:mergeinfo</literal>
          property used to track information about merges which
          have been performed in your repository are described
          in a more human-readable fashion.  This is quite helpful to
          the humans who have to read those descriptions.  But it also
          serves to cause patching programs (including <command>svn
          patch</command>) to skip those change descriptions as noise.
          This might sound like a bug, but it really isn't because
          this property is intended to be managed solely by
          the <command>svn merge</command> subcommand.  For more about
          merge tracking, see <xref linkend="svn.branchmerge"
          />.</para>
      </note>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.inheritable">
      <title>Inherited Properties</title>

      <para>Subversion 1.8 introduces the concept of inherited properties.
        There is really nothing special about a property that makes it
        inheritable.  In fact, all versioned properties are inheritable!
        The main difference between versioned properties before 1.8 and
        after is that the latter provides a mechanism to find the
        properties set on a target path's <emphasis>parents</emphasis>,
        even if those parents are not found within the working copy.
        </para>

      <para>Generic property inheritance manifests itself in a few
        commands.  First, the <command>svn proplist</command> and <command>
        svn propget</command> subcommands can retrieve all the properties
        on a URL's or a working copy path's parents by using the <option>
        --show-inherited-props</option> option.  You might think of this
        as the opposite of a <option>--recursive</option> subcommand
        operation instead of recursing "down" into a target's
        subdirectories, subcommands with the <option>--show-inherited-props
        </option> option look "up" into the target's parent directories.
        The <command>svnlook propget</command> and <command>svnlook
        proplist </command> subcommands also use the <option>
        --show-inherited-props</option> option in a similar fashion.</para>

      <para>Let's look at an example of how this works. The following
        recursive propget on the root of our working copy finds that the
        <literal>svn:auto-props</literal> property is set on both the target
        of the subcommand and one of its subdirectories <filename>site
        </filename>:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose -R .
Properties on '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Properties on 'site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

      <para>If we were to instead make the target of the subcommand the
        subdirectory <filename>site</filename>, then using the <option>
        -show-inherited-props</option> option, we find that the <literal>
        svn:auto-props</literal> property is set on the target <emphasis>
        and</emphasis> its parent.  The parent's properties are called out
        as "inherited":</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose --show-inherited-props site
Inherited properties on 'site',
from '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Properties on 'site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

      <para>In the prior examples the root of the working copy
        corresponds to the root of the repository, but properties can
        also be inherited from outside the working copy when this is
        not the case.  Let's checkout the <filename>site</filename>
        directory from the prior example, making it the root of our
        working copy:</para>

        <informalexample>
          <screen>
$ svn co http://svn.example.com/repos site-wc
A    site-wc/publish
A    site-wc/publish/ch2.html
A    site-wc/publish/news.html
A    site-wc/publish/ch3.html
A    site-wc/publish/faq.html
A    site-wc/publish/index.html
A    site-wc/publish/ch1.html
 U   site-wc
Checked out revision 19.

$ cd site-wc
</screen>
        </informalexample>

      <para>Now when we check for inherited properties on a working copy
        path we can see that one property is inherited from a working
        copy parent and one from a repository parent representing a
        location "above" the root of the working copy:</para>

        <informalexample>
          <screen>
$ svn pg svn:auto-props --verbose --show-inherited-props publish
Inherited properties on 'publish',
from 'http://svn.example.com/repos':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Inherited properties on 'publish',
from '.':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

        <warning>
          <para>You can only inherit properties from repository paths
            which you have read authorization to see
            <xref linkend="svn.serverconfig.svnserve.auth" /> and
            <xref linkend="svn.serverconfig.httpd.authz" />.  If you
            don't have read authorization to a parent path then it will
            appear as if the parent has no properties set on it.
          </para>
        </warning>

      <para>As mentioned above, the <command>svnlook proplist</command>
        and <command>svnlook propget</command> commands also support the
        <option>--show-inherited-props</option> option, but instead of
        reporting the inherited props by working copy path or URL, they
        are listed by repository paths:</para>

        <informalexample>
          <screen>
$ svnlook pg repos svn:auto-props /site/publish --show-inherited-props -v
Inherited properties on '/site/publish',
from '/':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Inherited properties on '/site/publish',
from '/site':
  svn:auto-props
    *.html = svn:eol-style=native
</screen>
        </informalexample>

      <para>Properties inherited from above the root of the working copy
        are cached in the working copy's administrative database when the
        working copy is initially checked out and then refreshed whenever
        the working copy is updated.  This means that you don't need
        access to your repository to view inherited properties.  This
        allows Subversion subcommands that have traditionally not
        required access to the repository (e.g. <command>svn add</command>
        ) to remain "disconnected" while still accessing properties
        inherited from paths not found in the working copy.  However it
        also means that inherited properties from above the root of the
        working copy may have changed since your most recent update,
        causing your local cache to become out of date.  So if you require
        the absolute latest value of some inherited property, it's always
        safest to update your working copy first or query the repository
        directly.</para>

      <para>At this point you might be thinking, "nice trick, but what
        good is it?"  By itself property inheritance isn't very useful.
        Before 1.8, all of Subversion's own reserved <literal>svn:*
        </literal> properties (and likely all of your own custom user
        properties) applied only to the path on which they were set or
        at most, the path's immediate children<footnote><para>The one
        noteable exception to this being the <literal>svn:mergeinfo
        </literal> property, which is inheritable see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo" />
        </para></footnote>  Rather, inheritable properties are a tool
        that Subversion uses to do other more interesting things, like
        setting automatic properties with the <literal>svn:auto-props
        </literal> property or repository-wide ignores with the <literal>
        svn:global-ignores</literal> property see
        <xref linkend="svn.advanced.props.auto" /> and
        <xref linkend="svn.advanced.props.special.ignore" /> for more
        information about these special properties and how to use them.
        </para>

        <tip>
          <para>Currently inheritable properties are primarily useful only
            as regards the <literal>svn:auto-props</literal> and <literal>
            svn:global-ignores</literal> properties but that doesn't mean
            those two properties are the end of the story.  Look for more
            features to be built with inherited properties in future
            releases of Subversion a log message templating mechanism
            comes to mind.  In the meantime feel free to use the feature
            however you'd like.  Any piece of versioned metadata you want
            to apply to your whole repository (or large subsections
            thereof) can easily be stored in a property on the root of
            your repository (or the appropriate subtree).  We suspect that
            some users and administrators will come up with clever ways to
            use inheritable properties which we never considered.</para>
        </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.auto">
      <title>Automatic Property Setting</title>

      <para>Properties are a powerful feature of Subversion, acting as
        key components of many Subversion features discussed elsewhere
        in this and other chapters textual diff and merge
        support, keyword substitution, newline translation, and so on.  But
        to get the full benefit of properties, they must be set on the
        right files and directories.  Unfortunately, that
        step can be easily forgotten in the routine of things, especially
        since failing to set a property doesn't usually result in an
        obvious error (at least compared to, say, failing to
        add a file to version control).  To help your properties get
        applied to the places that need them, Subversion provides a
        few simple but useful features.</para>

      <para>Whenever you introduce a file to version control using the
        <command>svn add</command> or <command>svn import</command>
        commands, Subversion tries to assist by setting some common
        file properties automatically.  First, on operating systems
        whose filesystems support an execute permission bit,
        Subversion will automatically set the
        <literal>svn:executable</literal> property on newly added or
        imported files whose execute bit is enabled.  (See <xref
        linkend="svn.advanced.props.special.executable" /> later in
        this chapter for more about this property.)</para>

      <para>Second, Subversion tries to determine the file's MIME
        type.  If you've configured a
        <literal>mime-types-files</literal> runtime configuration
        parameter, Subversion will try to find a MIME type mapping in
        that file for your file's extension.  If it finds such a
        mapping, it will set your file's
        <literal>svn:mime-type</literal> property to the MIME type it
        found.  If no mapping file is configured, or no mapping for
        your file's extension could be found, Subversion will fall
        back to heuristic algorithms to determine the file's MIME
        type.  Depending on how it is built, Subversion 1.7 can make
        use of file scanning libraries<footnote><para>Currently,
        libmagic is the support library used to accomplish
        this.</para></footnote> to detect a file's type based on its
        content.  Failing all else, Subversion will employ its own
        very basic heuristic to determine whether the file contains
        nontextual content.  If so, it automatically sets the
        <literal>svn:mime-type</literal> property on that file to
        <literal>application/octet-stream</literal> (the generic
        <quote>this is a collection of bytes</quote> MIME type).  Of
        course, if Subversion guesses incorrectly, or if you wish to
        set the <literal>svn:mime-type</literal> property to something
        more precise perhaps <literal>image/png</literal> or
        <literal>application/x-shockwave-flash</literal> you can
        always remove or edit that property.  (For more on
        Subversion's use of MIME types, see <xref
        linkend="svn.advanced.props.special.mime-type" /> later in
        this chapter.)</para>

      <note>
        <para>UTF-16 is commonly used to encode files whose semantic
          content is textual in nature, but the encoding itself makes
          heavy use of bytes which are outside the typical ASCII
          character byte range.  As such, Subversion will tend to
          classify such files as binary files, much to the chagrin of
          users who desire line-based differencing and merging,
          keyword substitution, and other behaviors for those
          files.</para>
      </note>

      <para>Subversion also provides, via its runtime configuration
        system (see <xref linkend="svn.advanced.confarea" />), a more
        flexible automatic property setting feature that allows you
        to create mappings of filename patterns to property names and
        values.  Once again, these mappings affect adds and imports,
        and can not only override the default MIME type decision made
        by Subversion during those operations, but can also set
        additional Subversion or custom properties, too.  For example,
        you might create a mapping that says that anytime you add
        JPEG files ones whose names match the pattern
        <literal>*.jpg</literal> Subversion should automatically
        set the <literal>svn:mime-type</literal> property on those
        files to <literal>image/jpeg</literal>.  Or perhaps any files
        that match <literal>*.cpp</literal> should have
        <literal>svn:eol-style</literal> set to
        <literal>native</literal>, and <literal>svn:keywords</literal>
        set to <literal>Id</literal>.  For more details on automatic
        property support in the runtime configuration see <xref
        linkend="svn.advanced.confarea.opts.config"/>.</para>


      <para>While automatic property support via the runtime
        configuration system is certainly handy, Subversion
        administrators might prefer a set of property definitions
        which all connecting clients automatically consider when
        operating on working copies checked out from a given server.
        Subversion 1.8 and newer clients support such functionality
        through the <literal>svn:auto-props</literal> inheritable
        property.</para>

      <para>The <literal>svn:auto-props</literal> property works like
        the runtime configuration to automatically set properties on
        files when they are added or imported.  The value of the
        <literal>svn:auto-props</literal> property is expected to be
        the same as the <literal>auto-props</literal> runtime
        configuration option (i.e. Any number of key-value pairs in
        the format FILE_PATTERN = PROPNAME=VALUE[;PROPNAME=VALUE ...])
        Like the <literal>auto-props</literal> runtime option, the
        <literal>svn:auto-props</literal> property can be disregarded
        when using the <option>--no-auto-props</option> option, but unlike
        the config option, the <literal>svn:auto-props</literal> property
        is <emphasis>not</emphasis> disabled when the
        <literal>enable-auto-props</literal> configuration option is set
        to <literal>no</literal>.
        </para>

      <para>For example, say you have checked out a working copy of your
        <filename>trunk</filename> branch and need to add a new file
        (let's assume that automatic properties in your runtime
        configuration are disabled):</para>

    <informalexample>
      <screen>
$ svn st
?       calc/data.c

$ svn add calc/data.c
A         calc/data.c

$ svn proplist -v calc/data.c
Properties on 'calc/data.c':
  svn:eol-style
    native
</screen>
    </informalexample>

      <para>Notice that after you place the unversioned file
        <filename>data.c</filename> under version control the
        <literal>svn:eol-style</literal> property was automatically set
        on it.  Since we assumed that the <literal>auto-props</literal>
        runtime configuration option is disabled, we know
        that the <literal>svn:auto-props</literal> property must be set
        on some parent path of <filename>data.c</filename>.  Using the
        <command>svn propget</command> subcommand with the
        <option>--show-inherited-props</option> option we see that this
        is indeed the case:</para>

    <informalexample>
      <screen>
$ svn propget svn:auto-props --show-inherited-props -v calc
Inherited properties on 'calc',
from 'http://svn.example.com/repos':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
</screen>
    </informalexample>

      <para>Unlike the <literal>svn:global-ignores</literal> property and
        its analogous runtime configuration
        <literal>global-ignores</literal>, which are combined, the
        <literal>svn:auto-props</literal> property
        <emphasis>overrides</emphasis> the <literal>auto-props</literal>
        runtime configuration if it defines an auto-prop for the
        <emphasis>same</emphasis> pattern as the runtime configuration.
        Automatic properties inherited<footnote><para>Remember that users
        can only inherit properties from paths for which they have read
        access.  So if an administrator sets
        <literal>svn:auto-props</literal> on some high-level parent
        path (e.g. the repository root), they need to be sure all users
        have read access to that path or the desired automatic property
        setting won't kick in.</para></footnote> from one path can also
        override the <emphasis>identical</emphasis> pattern inherited from
        a different path.  The hierarchy of these overrides works as
        follows:</para>

      <itemizedlist>
        <listitem>
          <para>An auto-prop, for a given pattern, defined in
            <literal>svn:auto-props</literal> overrides the same auto-prop
            for the identical pattern in the <literal>auto-props</literal>
            runtime configuration.</para>
        </listitem>
        <listitem>
          <para>If an auto-prop, for a given pattern, is inherited from
            more than one parents' <literal>svn:auto-props</literal>
            property, the nearer path-wise parent overrides the more
            distant parents.</para>
        </listitem>
        <listitem>
          <para>An auto-prop, for a given pattern, defined in a
            <literal>svn:auto-props</literal> property explicitly set on
            a path overrides the same auto-prop(s) for the identical
            pattern inherited from any parents.</para>
        </listitem>
      </itemizedlist>

      <para>Let's look at an example.  Suppose you have this runtime
        configuration:</para>

    <informalexample>
      <screen>
[miscellany]
enable-auto-props = yes
[auto-props]
*.py  = svn:eol-style=CR
*.c   = svn:eol-style=CR
*.h   = svn:eol-style=CR
*.cpp = svn:eol-style=CR
</screen>
    </informalexample>

      <para>And you want to add three files in the <filename>calc</filename>
        directory of your working copy:</para>

    <informalexample>
      <screen>
$ svn st
?       calc/data-binding.cpp
?       calc/data.c
?       calc/editor.py
</screen>
    </informalexample>

      <para>Let's check what <literal>svn:auto-props</literal> apply to
        <filename>calc</filename>:</para>

    <informalexample>
      <screen>
$ svn propget svn:auto-props -v --show-inherited-props calc
Inherited properties on 'calc',
from 'http://svn.example.com/repos':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

Inherited properties on 'calc',
from '.':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:keywords=Author Date Id Rev URL
</screen>
    </informalexample>

      <para>When we add these three files what auto-props do we expect?
        We add the trio to version control and then check:</para>

    <informalexample>
      <screen>
$ svn add calc --force
A         calc/data-binding.cpp
A         calc/data.c
A         calc/editor.py
</screen>
    </informalexample>

      <para>The file <filename>data-binding.cpp</filename> has only one
        matching pattern, <literal>*.cpp = svn:eol-style=CR</literal>
        in the runtime configuration, so obviously the
        <literal>svn:eol-style</literal> property is set to
        <literal>CR</literal>:</para>

    <informalexample>
      <screen>
$ svn proplist -v calc/data-binding.cpp
Properties on 'calc/data-binding.cpp':
  svn:eol-style
    CR
</screen>
    </informalexample>

      <para>The file <filename>editor.py</filename> matches a single
        pattern in runtime config and both of the
        <literal>svn:auto-props</literal> properties, but by the hierarchy
        described above, the property explicitly set on
        <filename>calc</filename>,
        <literal>*.py = svn:eol-style=native</literal>, takes precedence.
        So the <literal>svn:eol-style</literal> property is set to
        <literal>native:</literal>:</para>

    <informalexample>
      <screen>
$ svn proplist -v calc/editor.py
Properties on 'calc/editor.py':
  svn:eol-style
    native
</screen>
    </informalexample>

      <para>The file <filename>data.c</filename> also matches patterns
        in the runtime config and both of the inherited
        <literal>svn:auto-props</literal> properties.  The
        <literal>svn:keywords</literal> auto-prop is only defined once,
        on <filename>calc</filename>, so <filename>data.c</filename>
        automatically gets that property.  The
        <literal>svn:auto-props</literal> on <filename>calc</filename>
        don't define a <literal>svn:eol-style</literal> value however, so
        the nearest inherited parent,
        <literal>http://svn.example.com/repos</literal>,
        provides that value:</para>

    <informalexample>
      <screen>
$ svn proplist -v calc/data.c
Properties on 'calc/data.c':
  svn:eol-style
    native
  svn:keywords
    Author Date Id Rev URL
</screen>
    </informalexample>

      <warning>
        <para>Overriding auto-props only applies for
          <emphasis>identical</emphasis> patterns.  If a file to be added
          or imported matches more than one pattern, then there is no
          guarantee which pattern's auto-props will be applied.  For
          example, say you want to add the file
          <filename>foo.cpp</filename> in the directory
          <filename>bar</filename>.  Further, suppose the
          <literal>svn:auto-props</literal> property is set on
          <filename>bar</filename> with the value:</para>

    <informalexample>
      <screen>
*.c*  = svn:eol-style=native
*.cpp = svn:eol-style=native;svn:keywords=Author Date Id Rev URL
</screen>
    </informalexample>

        <para>Since <filename>foo.cpp</filename> matches both patterns,
          there is no way to know if the <literal>svn:keywords</literal>
          property will be set on <filename>foo.cpp</filename> when it
          is added.</para>
      </warning>

      <para>A final note on <literal>svn:auto-props</literal>.  This
        property (along with the similar
        <literal>svn:global-ignores</literal>, see
        <xref linkend="svn.advanced.props.special.ignore"/>)
        only provides a <emphasis>recommendation</emphasis> to clients
        that understand the meaning of the property.  Older clients will
        ignore these properties, the <option>--no-auto-props</option>
        option will disregard them, a user might manually change or remove
        automatic properties after they have been set there are
        numerous ways in which the recommended properties contained in
        <literal>svn:auto-props</literal> can be by-passed.  Given
        this, administrators will still need to use hook scripts to
        validate that the properties added to and modified on files
        and directories match the administrator's preferred policies,
        rejecting commits which are non-compliant in this fashion.
        (See <xref linkend="svn.reposadmin.hooks"/> for more about
        hook scripts.)</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.ref">
      <title>Subversion's Reserved Properties</title>

      <para>In this section, we'll briefly summarize all the
        properties which Subversion reserves for its own use.  We'll
        look at both types of properties those which are
        associated with individual versioned files and directories,
        and those which are associated with revisions.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.props.ref.versioned">
        <title>Versioned properties</title>

        <para>These are the versioned (or node) properties that
          Subversion reserves for its own use:</para>

        <variablelist>
  
          <varlistentry>
            <term><literal>svn:auto-props</literal></term>
            <listitem>
              <para>If present on a directory, the value is a set of
                automatic property definitions which apply to all files
                under the directory, See
                <xref linkend="svn.advanced.props.auto" />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:executable</literal></term>
            <listitem>
              <para>If present on a file, the client will make the file
                executable in Unix-hosted working copies.  See
                <xref linkend="svn.advanced.props.special.executable"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:mime-type</literal></term>
            <listitem>
              <para>If present on a file, the value indicates the file's
                MIME type.  This allows the client to decide whether
                line-based contextual merging is safe to perform during
                updates, and can also affect how the file behaves when
                fetched via a web browser.  See
                <xref linkend="svn.advanced.props.special.mime-type"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:ignore</literal></term>
            <listitem>
              <para>If present on a directory, the value is a list of
                <emphasis>unversioned</emphasis> file patterns to be
                ignored by <command>svn status</command> and other
                subcommands.  See
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:global-ignores</literal></term>
            <listitem>
              <para>If present on a directory, the value is a list of
                <emphasis>unversioned</emphasis> file patterns to be
                ignored by <command>svn status</command> and other
                subcommands.  Unlike <literal>svn:ignore</literal> these
                patterns apply to <emphasis>all</emphasis> unversioned
                subtrees under the directory, not just the directory's
                immediate file children.  See
                <xref linkend="svn.advanced.props.special.ignore"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:keywords</literal></term>
            <listitem>
              <para>If present on a file, the value tells the client how
                to expand particular keywords within the file.  See
                <xref linkend="svn.advanced.props.special.keywords"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:eol-style</literal></term>
            <listitem>
              <para>If present on a file, the value tells the client how
                to manipulate the file's line-endings in the working
                copy and in exported trees.  See
                <xref linkend="svn.advanced.props.special.eol-style" />
                and <xref linkend="svn.ref.svn.c.export" />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:externals</literal></term>
            <listitem>
              <para>If present on a directory, the value is a multiline
                list of other paths and URLs the client should check
                out.  See <xref linkend="svn.advanced.externals"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:special</literal></term>
            <listitem>
              <para>If present on a file, indicates that the file is not
                an ordinary file, but a symbolic link or other special
                object.<footnote><para>As of this writing, symbolic
                links are indeed the only <quote>special</quote>
                objects.  But there might be more in future releases of
                Subversion.</para></footnote></para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:needs-lock</literal></term>
            <listitem>
              <para>If present on a file, tells the client to make the
                file read-only in the working copy, as a reminder that
                the file should be locked before editing begins.  See
                <xref linkend="svn.advanced.locking.lock-communication"
                />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:mergeinfo</literal></term>
            <listitem>
              <para>Used by Subversion to track merge data.  See
                <xref linkend="svn.branchmerge.basicmerging.mergeinfo"
                /> for details, but you should never edit this property
                unless you <emphasis>really</emphasis> know what you're
                doing.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.props.ref.unversioned">
        <title>Unversioned properties</title>

        <para>The following are the unversioned (or revision) properties
          that Subversion reserves for its own use.  Most of these
          appear on every revision in the repository, carrying important
          information about the origin and nature of the changes made in
          that revision.</para>
  
        <variablelist>
  
          <varlistentry>
            <term><literal>svn:author</literal></term>
            <listitem>
              <para>If present, contains the authenticated username of
                the person who created the revision.  (If not present,
                the revision was committed anonymously.)</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:autoversioned</literal></term>
            <listitem>
              <para>If present, the revision was created via the
                autoversioning feature.  See
                <xref linkend="svn.webdav.autoversioning" />.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:date</literal></term>
            <listitem>
              <para>Contains the UTC time the revision was created, in
                ISO 8601 format.  The value comes from the
                <emphasis>server</emphasis> machine's clock, not the
                client's.</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:log</literal></term>
            <listitem>
              <para>Contains the log message describing the
                revision.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>
  
        <para>Certain auxiliary tools in the Subversion
          toolchain namely, <command>svnrdump</command>
          and <command>svnsync</command> also use unversioned
          properties for their own accounting purposes.  These
          properties are found only on revision 0 of repositories on
          which these tools are operating.  For more about
          <command>svnrdump</command> and <command>svnsync</command> and
          the functionality they offer, see
          <xref linkend="svn.reposadmin" />.  The following are the
          properties created and managed by these tools.</para>
  
        <variablelist>
  
          <varlistentry>
            <term><literal>svn:rdump-lock</literal></term>
            <listitem>
              <para>Used to temporarily enforce mutually exclusive
                access to the repository by <command>svnrdump
                load</command>.  This property is generally only
                observed when such an operation is active or when
                an <command>svnrdump</command> command failed to cleanly
                disconnect from the repository.  (This property is only
                relevant when it appears on revision 0.)</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-currently-copying</literal></term>
            <listitem>
              <para>Contains the revision number from the source
                repository which is currently being mirrored to this one
                by the <command>svnsync</command> tool.  (This property
                is only relevant when it appears on revision 0.)</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-from-uuid</literal></term>
            <listitem>
              <para>Contains the UUID of the repository of which this
                repository has been initialized as a mirror by
                the <command>svnsync</command> tool.  (This property is
                only relevant when it appears on revision 0.)</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-from-url</literal></term>
            <listitem>
              <para>Contains the URL of the repository directory of
                which this repository has been initialized as a mirror
                by the <command>svnsync</command> tool.  (This property
                is only relevant when it appears on revision 0.)</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-last-merged-rev</literal></term>
            <listitem>
              <para>Contains the revision of the source repository which
                was most recently and successfully mirrored to this one.
                (This property is only relevant when it appears on
                revision 0.)</para>
            </listitem>
          </varlistentry>
  
          <varlistentry>
            <term><literal>svn:sync-lock</literal></term>
            <listitem>
              <para>Used to temporarily enforce mutually exclusive
                access to the repository by <command>svnsync</command>
                mirroring operations.  This property is generally only
                observed when such an operation is active or when
                an <command>svnsync</command> command failed to cleanly
                disconnect from the repository.  (This property is
                only relevant when it appears on revision 0.)</para>
            </listitem>
          </varlistentry>
  
        </variablelist>
      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.file-portability">
    <title>File Portability</title>

    <para>Fortunately for Subversion users who routinely find
      themselves on different computers with different operating
      systems, Subversion's command-line program behaves almost
      identically on all those systems.  If you know how to wield
      <command>svn</command> on one platform, you know how to wield it
      everywhere.</para>

    <para>However, the same is not always true of other general classes
      of software or of the actual files you keep in Subversion.  For
      example, on a Windows machine, the definition of a <quote>text
      file</quote> would be similar to that used on a Linux box, but
      with a key difference the character sequences used to mark
      the ends of the lines of those files.  There are other
      differences, too.  Unix platforms have (and Subversion supports)
      symbolic links; Windows does not.  Unix platforms use filesystem
      permission to determine executability; Windows uses filename
      extensions.</para>

    <para>Because Subversion is in no position to unite the whole
      world in common definitions and implementations of all of these
      things, the best it can do is to try to help make your life
      simpler when you need to work with your versioned files and
      directories on multiple computers and operating systems.  This
      section describes some of the ways Subversion does this.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.mime-type">
      <title>File Content Type</title>
      
      <para>Subversion joins the ranks of the many applications that
        recognize and make use of Multipurpose Internet Mail
        Extensions (MIME) content types.  Besides being a
        general-purpose storage location for a file's content type,
        the value of the <literal>svn:mime-type</literal> file
        property determines some behavioral characteristics of
        Subversion itself.</para>

      <sidebar>
        <title>Identifying File Types</title>
    
        <para>Various programs on most modern operating systems make
          assumptions about the type and format of the contents of a
          file by the file's name, specifically its file extension.
          For example, files whose names end in
          <filename>.txt</filename> are generally assumed to be
          human-readable; that is, able to be understood by simple perusal
          rather than requiring complex processing to decipher.  Files
          whose names end in <filename>.png</filename>, on the other
          hand, are assumed to be of the Portable Network Graphics
          type not human-readable at all, and sensible only when
          interpreted by software that understands the PNG format and
          can render the information in that format as a raster
          image.</para>

        <para>Unfortunately, some of those extensions have changed
          their meanings over time.  When personal computers first appeared,
          a file named <filename>README.DOC</filename> would have
          almost certainly been a plain-text file, just like today's
          <filename>.txt</filename> files.  But by the mid-1990s, you
          could almost bet that a file of that name would not be a
          plain-text file at all, but instead a Microsoft Word
          document in a proprietary, non-human-readable format.  But
          this change didn't occur overnight there was certainly
          a period of confusion for computer users over what exactly
          they had in hand when they saw a <filename>.DOC</filename>
          file.<footnote><para>You think that was rough?  During that
          same era, WordPerfect also used <filename>.DOC</filename>
          for their proprietary file format's preferred
          extension!</para></footnote></para>

        <para>The popularity of computer networking cast still more
          doubt on the mapping between a file's name and its content.
          With information being served across networks and generated
          dynamically by server-side scripts, there was often no real
          file per se, and therefore no filename.  Web
          servers, for example, needed some other way to tell browsers
          what they were downloading so that the browser could do something
          intelligent with that information, whether that was to
          display the data using a program registered to handle that
          datatype or to prompt the user for where on the client
          machine to store the downloaded data.</para>

        <para>Eventually, a standard emerged for, among other things,
          describing the contents of a data stream.  In 1996, RFC 2045
          was published.  It was the first of five RFCs describing
          MIME.  It describes the concept of media types and subtypes
          and recommends a syntax for the representation of those
          types.  Today, MIME media types or <quote>MIME
          types</quote> are used almost universally across
          email applications, web servers, and other software as the
          de facto mechanism for clearing up the file content
          confusion.</para>

      </sidebar>
    
      <para>For example, one of the benefits that Subversion typically
        provides is contextual, line-based merging of changes received
        from the server during an update into your working file.  But
        for files containing nontextual data, there is often no
        concept of a <quote>line.</quote>  So, for versioned files
        whose <literal>svn:mime-type</literal> property is set to a
        nontextual MIME type (generally, something that doesn't begin
        with <literal>text/</literal>, though there are exceptions),
        Subversion does not attempt to perform contextual merges
        during updates.  Instead, any time you have locally modified a
        binary working copy file that is also being updated, your file
        is left untouched and Subversion creates two new files.  One
        file has a <filename>.oldrev</filename> extension and contains
        the BASE revision of the file.  The other file has a
        <filename>.newrev</filename> extension and contains the
        contents of the updated revision of the file.  This behavior
        is really for the protection of the user against failed
        attempts at performing contextual merges on files that simply
        cannot be contextually merged.</para>

      <para>Additionally, since the acts of displaying line-based
        differences and line-based change attribution are, rather
        obviously, dependent on there being a meaningful definition
        of <quote>line</quote> for a given file, files with nontextual
        MIME types will by default trigger errors when used as the
        targets of <command>svn diff</command> and <command>svn
        annotate</command> operations.  This can be especially
        frustrating for users with XML files whose
        <literal>svn:mime-type</literal> property is set to something
        such as <literal>application/xml</literal> which is not
        unambiguously human-readable and as such is treated as
        nontextual by Subversion.  Fortunately, those subcommands
        offer a <option>--force</option> option for forcing
        Subversion to attempt the operations in spite of the apparent
        non-human-readability of the files.</para>

      <warning>
        <para>The <literal>svn:mime-type</literal> property, when set
          to a value that does not indicate textual file contents, can
          cause some unexpected behaviors with respect to other
          properties.  For example, since the idea of line endings
          (and therefore, line-ending conversion) makes no sense when
          applied to nontextual files, Subversion will prevent you
          from setting the <literal>svn:eol-style</literal> property
          on such files.  This is obvious when attempted on a single
          file target <command>svn propset</command> will error
          out.  But it might not be as clear if you perform a
          recursive property set, where Subversion will silently skip
          over files that it deems unsuitable for a given
          property.</para>
      </warning>

      <para>Subversion provides a number of mechanisms by which to
        automatically set the <literal>svn:mime-type</literal>
        property on a versioned file.  See
        <xref linkend="svn.advanced.props.auto" /> for details.</para>

      <para>Also, if the <literal>svn:mime-type</literal> property is
        set, then the Subversion Apache module will use its value to
        populate the <literal>Content-type:</literal> HTTP header when
        responding to GET requests.  This gives your web browser a
        crucial clue about how to display a file when you use it to
        peruse your Subversion repository's contents.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.executable">
      <title>File Executability</title>
 
      <para>On many operating systems, the ability to execute a file
        as a command is governed by the presence of an execute
        permission bit.  This bit usually defaults to being disabled,
        and must be explicitly enabled by the user for each file that
        needs it.  But it would be a monumental hassle to have to
        remember exactly which files in a freshly checked-out working
        copy were supposed to have their executable bits toggled on,
        and then to have to do that toggling.  So, Subversion provides
        the <literal>svn:executable</literal> property as a way to
        specify that the executable bit for the file on which that
        property is set should be enabled, and Subversion honors that
        request when populating working copies with such files.</para>

      <para>This property has no effect on filesystems that have no
        concept of an executable permission bit, such as FAT32 and
        NTFS.<footnote><para>The Windows filesystems use file
        extensions (such
        as <filename>.EXE</filename>, <filename>.BAT</filename>, and
        <filename>.COM</filename>) to denote executable
        files.</para></footnote>  Also, although it has no defined
        values, Subversion will force its value
        to <literal>*</literal> when setting this property.  Finally,
        this property is valid only on files, not on
        directories.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.props.special.eol-style">
      <title>End-of-Line Character Sequences</title>

      <para>Unless otherwise noted using a versioned file's
        <literal>svn:mime-type</literal> property, Subversion
        assumes the file contains human-readable data.  Generally
        speaking, Subversion uses this knowledge only to determine
        whether contextual difference reports for that file are
        possible.  Otherwise, to Subversion, bytes are bytes.</para>
      
      <para>
        <indexterm>
          <primary>line endings</primary>
        </indexterm>
        <indexterm>
          <primary>end-of-line (EOL) markers</primary>
          <see>line endings</see>
        </indexterm>This means that by default, Subversion doesn't pay
        any attention to the type of <firstterm>end-of-line (EOL)
        markers</firstterm> used in your files.  Unfortunately,
        different operating systems have different conventions about
        which character sequences represent the end of a line of text
        in a file.  For example, the usual line-ending token used by
        software on the Windows platform is a pair of ASCII control
        characters a carriage return (<literal>CR</literal>)
        followed by a line feed (<literal>LF</literal>).  Unix
        software, however, just uses the <literal>LF</literal>
        character to denote the end of a line.</para>

      <para>
        <indexterm>
          <primary>line endings</primary>
          <secondary>native</secondary>
        </indexterm>Not all of the various tools on these operating
        systems understand files that contain line endings in a format
        that differs from the <firstterm>native line-ending
        style</firstterm> of the operating system on which they are
        running.  So, typically, Unix programs treat the
        <literal>CR</literal> character present in Windows files as a
        regular character (usually rendered as <literal>^M</literal>),
        and Windows programs combine all of the lines of a Unix file
        into one giant line because no <literal>CR</literal>
        characters are found to denote the ends of the lines.</para>

      <para>This sensitivity to foreign EOL markers can be
        frustrating for folks who share a file across different
        operating systems.  For example, consider a source code
        file, and developers who edit this file on both Windows and
        Unix systems.  If all the developers always use tools that
        preserve the line-ending style of the file, no problems
        occur.</para>

      <para>But in practice, many common tools either fail to
        properly read a file with foreign EOL markers, or
        convert the file's line endings to the native style when the
        file is saved.  If the former is true for a developer, he
        has to use an external conversion utility (such as
        <command>dos2unix</command> or its companion,
        <command>unix2dos</command>) to prepare the file for
        editing.  The latter case requires no extra preparation.
        But both cases result in a file that differs from the
        original quite literally on every line!  Prior to committing
        his changes, the user has two choices.  Either he can use a
        conversion utility to restore the modified file to the same
        line-ending style that it was in before his edits were made,
        or he can simply commit the file new EOL markers and
        all.</para>

      <para>The result of scenarios like these include wasted time
        and unnecessary modifications to committed files.  Wasted
        time is painful enough.  But when commits change every line
        in a file, this complicates the job of determining which of
        those lines were changed in a nontrivial way.  Where was
        that bug really fixed?  On what line was a syntax error
        introduced?</para>

      <para>The solution to this problem is the
        <literal>svn:eol-style</literal> property.  When this
        property is set to a valid value, Subversion uses it to
        determine what special processing to perform on the file so
        that the file's line-ending style isn't flip-flopping with
        every commit that comes from a different operating
        system.  The valid values are:</para>

      <variablelist>
        <varlistentry>
          <term><literal>native</literal></term>
          <listitem>
            <para>This causes the file to contain the EOL markers
              that are native to the operating system on which
              Subversion was run.  In other words, if a user on a
              Windows machine checks out a working copy that
              contains a file with an
              <literal>svn:eol-style</literal> property set to
              <literal>native</literal>, that file will contain
              <literal>CRLF</literal> EOL markers.  A Unix user
              checking out a working copy that contains the same
              file will see <literal>LF</literal> EOL markers in his
              copy of the file.</para>

            <para>Note that Subversion will actually store the file
              in the repository using normalized
              <literal>LF</literal> EOL markers regardless of the
              operating system.  This is basically transparent to
              the user, though.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CRLF</literal></term>
          <listitem>
            <para>This causes the file to contain
              <literal>CRLF</literal> sequences for EOL markers,
              regardless of the operating system in use.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>LF</literal></term>
          <listitem>
            <para>This causes the file to contain
              <literal>LF</literal> characters for EOL markers,
              regardless of the operating system in use.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>CR</literal></term>
          <listitem>
            <para>This causes the file to contain
              <literal>CR</literal> characters for EOL markers,
              regardless of the operating system in use.  This
              line-ending style is not very common.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.ignore">
    <title>Ignoring Unversioned Items</title>

    <para>In any given working copy, there is a good chance that
      alongside all those versioned files and directories are other
      files and directories that are neither versioned nor intended
      to be.  Text editors litter directories with backup files.
      Software compilers generate intermediate or even
      final files that you typically wouldn't bother to
      version.  And users themselves drop various other files and
      directories wherever they see fit, often in version control
      working copies.</para>

    <para>It's ludicrous to expect Subversion working copies to be
      somehow impervious to this kind of clutter and impurity.  In
      fact, Subversion counts it as a <emphasis>feature</emphasis>
      that its working copies are just typical directories, just like
      unversioned trees.  But these not-to-be-versioned files and
      directories can cause some annoyance for Subversion users.  For
      example, because the <command>svn add</command> and <command>svn
      import</command> commands act recursively by default and don't
      know which files in a given tree you do and don't wish to
      version, it's easy to accidentally add stuff to version control
      that you didn't mean to.  And because <command>svn
      status</command> reports, by default, every item of interest in
      a working copy including unversioned files and
      directories its output can get quite noisy where many of
      these things exist.</para>

    <para>
      <indexterm>
        <primary>file patterns</primary>
      </indexterm>
      <indexterm>
        <primary>globs</primary>
        <see>file patterns</see>
      </indexterm>
      <indexterm>
        <primary>shell wildcard patterns</primary>
        <see>file patterns</see>
      </indexterm>So Subversion provides several ways for telling it
      which files you would prefer that it simply disregard.  One of
      the ways involves the use of Subversion's runtime configuration
      system (see <xref linkend="svn.advanced.confarea" />), and
      therefore applies to all the Subversion operations that make use
      of that runtime configuration generally those performed on
      a particular computer or by a particular user of a computer.
      Two other methods make use of Subversion's directory property
      support and are more tightly bound to the versioned tree itself,
      and therefore affects everyone who has a working copy of that
      tree.  All of these mechanisms use <firstterm>file
      patterns</firstterm> (strings of literal and special wildcard
      characters used to match against filenames) to decide which
      files to ignore.</para>

    <para>The Subversion runtime configuration system provides an
      option, <literal>global-ignores</literal>, whose value is a
      whitespace-delimited collection of file patterns.  The
      Subversion client checks these patterns against the names of the
      files that are candidates for addition to version control, as
      well as to unversioned files that the <command>svn
      status</command> command notices.  If any file's name matches
      one of the patterns, Subversion will basically act as if the
      file didn't exist at all.  This is really useful for the kinds
      of files that you almost never want to version, such as editor
      backup files such as Emacs' <literal>*~</literal> and
      <literal>.*~</literal> files.</para>

    <sidebar>
      <title>File Patterns in Subversion</title>

      <para>File patterns (also called <firstterm>globs</firstterm> or
        <firstterm>shell wildcard patterns</firstterm>) are strings of
        characters that are intended to be matched against filenames,
        typically for the purpose of quickly selecting some subset of
        similar files from a larger grouping without having to
        explicitly name each file.  The patterns contain two types of
        characters:  regular characters, which are compared explicitly
        against potential matches, and special wildcard characters,
        which are interpreted differently for matching
        purposes.</para>

      <para>There are different types of file pattern syntaxes, but
        Subversion uses the one most commonly found in Unix systems
        implemented as the <function>fnmatch</function> system
        function.  It supports the following wildcards, described here
        simply for your convenience:</para>

      <variablelist>
        <varlistentry>
          <term><literal>?</literal></term>
          <listitem>
            <para>Matches any single character</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>*</literal></term>
          <listitem>
            <para>Matches any string of characters, including the
              empty string</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>[</literal></term>
          <listitem>
            <para>Begins a character class definition terminated by
              <literal>]</literal>, used for matching a subset of
              characters</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>You can see this same pattern matching behavior at a Unix
        shell prompt.  The following are some examples of patterns
        being used for various things:</para>

      <informalexample>
        <screen>
$ ls   ### the book sources
appa-quickstart.xml             ch06-server-configuration.xml
appb-svn-for-cvs-users.xml      ch07-customizing-svn.xml
appc-webdav.xml                 ch08-embedding-svn.xml
book.xml                        ch09-reference.xml
ch00-preface.xml                ch10-world-peace-thru-svn.xml
ch01-fundamental-concepts.xml   copyright.xml
ch02-basic-usage.xml            foreword.xml
ch03-advanced-topics.xml        images/
ch04-branching-and-merging.xml  index.xml
ch05-repository-admin.xml       styles.css
$ ls ch*   ### the book chapters
ch00-preface.xml                ch06-server-configuration.xml
ch01-fundamental-concepts.xml   ch07-customizing-svn.xml
ch02-basic-usage.xml            ch08-embedding-svn.xml
ch03-advanced-topics.xml        ch09-reference.xml
ch04-branching-and-merging.xml  ch10-world-peace-thru-svn.xml
ch05-repository-admin.xml
$ ls ch?0-*   ### the book chapters whose numbers end in zero
ch00-preface.xml  ch10-world-peace-thru-svn.xml
$ ls ch0[3578]-*   ### the book chapters that Mike is responsible for
ch03-advanced-topics.xml   ch07-customizing-svn.xml
ch05-repository-admin.xml  ch08-embedding-svn.xml
$
</screen>
      </informalexample>

      <para>File pattern matching is a bit more complex than what
        we've described here, but this basic usage level tends to suit
        the majority of Subversion users.</para>

    </sidebar>

    <para>When found on a versioned directory, the
      <literal>svn:ignore</literal> property is expected to contain a
      list of newline-delimited file patterns that Subversion should
      use to determine ignorable objects in that
      <emphasis>same</emphasis> directory.
      These patterns do not override those found in the
      <literal>global-ignores</literal> runtime configuration option,
      but are instead appended to that list.  And it's worth noting
      again that, unlike the <literal>global-ignores</literal> option,
      the patterns found in the <literal>svn:ignore</literal>
      property apply only to the directory on which that property is
      set, and not to any of its subdirectories.  The
      <literal>svn:ignore</literal> property is a good way to tell
      Subversion to ignore files that are likely to be present in
      every user's working copy of that directory, such as compiler
      output or to use an example more appropriate to this
      book the HTML, PDF, or PostScript files generated as the
      result of a conversion of some source DocBook XML files to a
      more legible output format.</para>

    <para>Subversion 1.8 provides a more powerful version of the
      <literal>svn:ignore</literal> property, the
      <literal>svn:global-ignores</literal> property.  Like the
      <literal>svn:ignore</literal> property,
      <literal>svn:global-ignores</literal> can only be set
      on a directory and contains file patterns Subversion uses to
      determine ignorable objects.<footnote><para>The ignore patterns
      in the <literal>svn:global-ignores</literal> property may be
      delimited with any whitespace (similar to the
      <literal>global-ignores</literal> runtime configuration option),
      not just newlines (as with the <literal>svn:ignore</literal>
      property).</para></footnote> These ignore patterns are also
      appended to any patterns defined in the
      <literal>global-ignores</literal> runtime configuration option
      together with any <literal>svn:ignore</literal> defined patterns.
      Unlike <literal>svn:ignore</literal> however, the
      <literal>svn:global-ignores</literal> property is inheritable
      <footnote><para>Of course only a 1.8 or newer Subversion client
      will recognize the inheritability and special meaning of the
      <literal>svn:global-ignores</literal> property!</para></footnote>
      and applies to <emphasis>all</emphasis> paths under the directory on
      which the property is set, not just the immediate children of the
      directory.</para>

    <note>
      <para>Subversion's support for ignorable file patterns extends
        only to the one-time process of adding unversioned
        files and directories to version control.  Once an object is
        under Subversion's control, the ignore pattern mechanisms no
        longer apply to it.  In other words, don't expect Subversion
        to avoid committing changes you've made to a versioned file
        simply because that file's name matches an ignore
        pattern Subversion <emphasis>always</emphasis> notices
        all of its versioned objects.</para>
    </note>

    <sidebar>
      <title>Ignore Patterns for CVS Users</title>
    
      <para>The Subversion <literal>svn:ignore</literal> property is
        very similar in syntax and function to the CVS
        <filename>.cvsignore</filename> file.  In fact, if you are
        migrating a CVS working copy to Subversion, you can directly
        migrate the ignore patterns by using the
        <filename>.cvsignore</filename> file as input to the
        <command>svn propset</command> command:</para>
   
      <informalexample>
        <screen>
$ svn propset svn:ignore -F .cvsignore .
property 'svn:ignore' set on '.'
$
</screen>
      </informalexample>
    
      <para>There are, however, some differences in the ways that CVS
        and Subversion handle ignore patterns.  The two systems use
        the ignore patterns at some different times, and there are
        slight discrepancies in what the ignore patterns apply to.
        Also, Subversion does not recognize the use of the
        <literal>!</literal> pattern as a reset back to having no
        ignore patterns at all.</para>

    </sidebar>

    <para>The ignore patterns in the <literal>global-ignores</literal>
      runtime configuration option tend to be more a
      matter of personal taste<footnote><para>Despite being a matter
      of personal taste, if you don't explicitly set the
      <literal>global-ignores</literal> runtime
      configuration option either to your preferred set of
      patterns or to an empty string Subversion uses a default
      value.  See the <literal>global-ignores</literal> entry in
      <xref linkend="svn.advanced.confarea.opts.config"/></para>
      </footnote> and ties more closely to a user's particular tool
      chain than to the details of any particular working copy's needs.
      So, the rest of this section will focus
      on the <literal>svn:ignore</literal> and
      <literal>svn:global-ignores</literal> properies and their
      uses.</para>

    <para>Say you have the following output from <command>svn
      status</command>:</para>

    <informalexample>
      <screen>
$ svn status calc
 M      calc/button.c
?       calc/calculator
?       calc/data.c
?       calc/debug_log
?       calc/debug_log.1
?       calc/debug_log.2.gz
?       calc/debug_log.3.gz
</screen>
    </informalexample>
    
    <para>In this example, you have made some property modifications
      to <filename>button.c</filename>, but in your working copy, you
      also have some unversioned files: the latest
      <filename>calculator</filename> program that you've compiled
      from your source code, a source file named
      <filename>data.c</filename>, and a set of debugging output
      logfiles.  Now, you know that your build system always results
      in the <filename>calculator</filename> program being
      generated.<footnote><para>Isn't that the whole point of a build
      system?</para></footnote>  And you know that your test suite
      always leaves those debugging logfiles lying around.  These
      facts are true for all working copies of this project, not just
      your own.  And you know that you aren't interested in seeing
      those things every time you run
      <command>svn status</command>, and you are pretty sure that
      nobody else is interested in them either.  So you use
      <userinput>svn propedit svn:ignore calc</userinput> to add some
      ignore patterns to the <filename>calc</filename>
      directory.</para>

    <informalexample>
      <screen>
$ svn propget svn:ignore calc
calculator
debug_log*
$
</screen>
    </informalexample>
    
    <para>After you've added this property, you will now have a local
      property modification on the <filename>calc</filename>
      directory.  But notice what else is different about your
      <command>svn status</command> output:</para>

    <informalexample>
      <screen>
$ svn status
 M      calc
 M      calc/button.c
?       calc/data.c
</screen>
    </informalexample>
    
    <para>Now, all that cruft is missing from the output!  Your
      <filename>calculator</filename> compiled program and all those
      logfiles are still in your working copy; Subversion just isn't
      constantly reminding you that they are present and unversioned.
      And now with all the uninteresting noise removed from the
      display, you are left with more intriguing items such as
      that source code file <filename>data.c</filename> that you
      probably forgot to add to version control.</para>

    <para>Of course, this less-verbose report of your working copy
      status isn't the only one available.  If you actually want to
      see the ignored files as part of the status report, you can pass
      the <option>--no-ignore</option> option to Subversion:</para>

    <informalexample>
      <screen>
$ svn status --no-ignore
 M      calc
 M      calc/button.c
I       calc/calculator
?       calc/data.c
I       calc/debug_log
I       calc/debug_log.1
I       calc/debug_log.2.gz
I       calc/debug_log.3.gz
I       calc/wip.1.diff
</screen>
    </informalexample>

    <para>All of your previously hidden unversioned paths are once
      again shown, but now with the <literal>'I' Ignored</literal>
      status.  But wait, what about <filename>wip.1.diff</filename>?
      The <literal>svn:ignore</literal> property on
      <filename>calc</filename> doesn't include any pattern that
      matches that filename, so why is it ignored?<footnote><para>
      Let's assume that you don't have a matching pattern anywhere
      in your <literal>global-ignores</literal> runtime configuration.
      </para></footnote>  The answer lies in the third method by which
      Subversion can disregard unversioned paths, the inheritable
      <literal>svn:global-ignores</literal> property.  Using the
      <command>svn propget</command> subcommand with the
      <option>--show-inherited-props</option> option, you see that
      the <literal>svn:global-ignores</literal> property is set on the
      root of your working copy, and sure enough, it defines a
      matching ignore pattern:</para>

    <informalexample>
      <screen>
$ svn pg svn:global-ignores calc -v --show-inherited-props
Inherited properties on 'calc',
from '.':
  svn:global-ignores
    *.diff
    *.patch
</screen>
    </informalexample>
    
    <para>As mentioned earlier, the list of file patterns to ignore is
      also used by <command>svn add</command> and <command>svn
      import</command>.  Both of these operations involve asking
      Subversion to begin managing some set of files and directories.
      Rather than force the user to pick and choose which files in a
      tree she wishes to start versioning, Subversion uses the ignore
      patterns the global, per-directory, and inherited
      lists to determine which files should not be swept into
      the version control system as part of a larger recursive
      addition or import operation.  And here again, you can use the
      <option>--no-ignore</option> option to tell Subversion to disregard
      its ignores list and operate on all the files and directories
      present.</para>

    <tip>
      <para>Even if <literal>svn:ignore</literal> or
        <literal>svn:global-ignores</literal> is set, you may run
        into problems if you use shell wildcards in a command.  Shell
        wildcards are expanded into an explicit list of targets before
        Subversion operates on them, so running <userinput>svn
        <replaceable>SUBCOMMAND</replaceable> *</userinput> is just like
        running <userinput>svn <replaceable>SUBCOMMAND</replaceable>
        file1 file2 file3  </userinput>.  In the case of the
        <command>svn add</command> command, this has an effect similar
        to passing the <option>--no-ignore</option> option.  So
        instead of using a wildcard, use <userinput>svn add --force
        .</userinput> to do a bulk scheduling of unversioned things for
        addition.  The explicit target will ensure that the current
        directory isn't overlooked because of being already under
        version control, and the <option>--force</option> option will
        cause Subversion to crawl through that directory, adding
        unversioned files while still honoring the
        <literal>svn:ignore</literal> and
        <literal>svn:global-ignores</literal> properties and the
        <literal>global-ignores</literal> runtime configuration
        variable.  Be sure to also provide the <option>--depth
        files</option> option to the <command>svn add</command>
        command if you don't want a fully recursive crawl for things
        to add.</para>

      </tip>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.props.special.keywords">
    <title>Keyword Substitution</title>

    <para>
      <indexterm>
        <primary>keywords</primary>
      </indexterm>Subversion has the ability to substitute
      <firstterm>keywords</firstterm> pieces of useful,
      dynamic information about a versioned file into the
      contents of the file itself.  Keywords generally provide
      information about the last modification made to the file.
      Because this information changes each time the
      file changes, and more importantly, just
      <emphasis>after</emphasis> the file changes, it is a hassle
      for any process except the version control system to keep
      the data completely up to date.  Left to human authors, the
      information would inevitably grow stale.</para>

    <para>For example, say you have a document in which you would
      like to display the last date on which it was modified.  You
      could burden every author of that document to, just before
      committing their changes, also tweak the part of the
      document that describes when it was last changed.  But
      sooner or later, someone would forget to do that.  Instead,
      simply ask Subversion to perform keyword substitution on the
      <literal>LastChangedDate</literal> keyword.  You control
      where the keyword is inserted into your document by placing
      a <firstterm>keyword anchor</firstterm> at the desired
      location in the file.  This anchor is just a string of text
      formatted as
      <literal>$</literal><replaceable>KeywordName</replaceable><literal>$</literal>.</para>

    <para>Adding keyword anchor text alone to your file does nothing
      special.  Subversion will never attempt to perform textual
      substitutions on your file contents unless explicitly asked to
      do so.  After all, you might be writing a
      document<footnote><para>  or maybe even a section of a
      book  </para></footnote> about how to use keywords, and
      you don't want Subversion to substitute your beautiful examples
      of unsubstituted keyword anchors!</para>

    <para>To tell Subversion whether to substitute keywords
      on a particular file, we again turn to the property-related
      subcommands.  The <literal>svn:keywords</literal> property,
      when set on a versioned file, controls which keywords will
      be substituted on that file.  The value is a space-delimited
      list of keyword names or aliases.</para>

    <para>For example, say you have a versioned file named
      <filename>weather.txt</filename> that looks like
      this:</para>

    <informalexample>
      <programlisting>
Here is the latest report from the front lines.
$LastChangedDate$
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
    </informalexample>
        
    <para>With no <literal>svn:keywords</literal> property set on
      that file, Subversion will do nothing special.  Now, let's
      enable substitution of the
      <literal>LastChangedDate</literal> keyword.</para>

    <informalexample>
      <screen>
$ svn propset svn:keywords "Date Author" weather.txt
property 'svn:keywords' set on 'weather.txt'
$
</screen>
    </informalexample>
    
    <para>Now you have made a local property modification on the
      <filename>weather.txt</filename> file.  You will see no
      changes to the file's contents (unless you made some of your
      own prior to setting the property).  Notice that the file
      contained a keyword anchor for the <literal>Rev</literal>
      keyword, yet we did not include that keyword in the property
      value we set.  Subversion will happily ignore requests to
      substitute keywords that are not present in the file and
      will not substitute keywords that are not present in the
      <literal>svn:keywords</literal> property value.</para>

    <para>Immediately after you commit this property change,
      Subversion will update your working file with the new
      substitute text.  Instead of seeing your keyword anchor
      <literal>$LastChangedDate$</literal>, you'll see its
      substituted result.  That result also contains the name of
      the keyword and continues to be delimited by the dollar sign
      (<literal>$</literal>) characters.  And as we predicted, the
      <literal>Rev</literal> keyword was not substituted because
      we didn't ask for it to be.</para>

    <para>Note also that we set the <literal>svn:keywords</literal>
      property to <literal>Date Author</literal>, yet the keyword
      anchor used the alias <literal>$LastChangedDate$</literal>
      and still expanded correctly:</para>

    <informalexample>
      <programlisting>
Here is the latest report from the front lines.
$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $
$Rev$
Cumulus clouds are appearing more frequently as summer approaches.
</programlisting>
    </informalexample>
        
    <para>If someone else now commits a change to
      <filename>weather.txt</filename>, your copy of that file
      will continue to display the same substituted keyword value
      as before until you update your working copy.  At that
      time, the keywords in your <filename>weather.txt</filename>
      file will be resubstituted with information that
      reflects the most recent known commit to that file.</para>

    <para>All keywords are case-sensitive where they appear as
      anchors in files: you must use the correct capitalization
      for the keyword to be expanded.  You should consider the
      value of the <literal>svn:keywords</literal> property to be
      case-sensitive, too for the sake of backward
      compatibility, certain keyword names will be recognized
      regardless of case, but this behavior is deprecated.</para>

    <para>Subversion defines the list of keywords available for
      substitution.  That list contains the following keywords, 
      some of which have aliases that you can also use:</para>

    <variablelist>
      <indexterm>
        <primary>keywords</primary>
        <secondary>Date</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>LastChangedDate</secondary>
        <see>keywords, Date</see>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>Revision</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>LastChangedRevision</secondary>
        <see>keywords, Revision</see>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>Rev</secondary>
        <see>keywords, Revision</see>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>Author</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>LastChangedBy</secondary>
        <see>keywords, Author</see>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>HeadURL</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>URL</secondary>
        <see>keywords, HeadURL</see>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>Id</secondary>
      </indexterm>
      <indexterm>
        <primary>keywords</primary>
        <secondary>Header</secondary>
      </indexterm>

      <varlistentry>
        <term><literal>Date</literal></term>
        <listitem>
          <para>This keyword describes the last time the file was
            known to have been changed in the repository, and is of
            the form <literal>$Date: 2006-07-22 21:42:37 -0700 (Sat,
            22 Jul 2006) $</literal>.  It may also be specified as
            <literal>LastChangedDate</literal>.  Unlike the
            <literal>Id</literal> keyword, which uses UTC, the
            <literal>Date</literal> keyword displays dates using the
            local time zone.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Revision</literal></term>
        <listitem>
          <para>This keyword describes the last known revision in
            which this file changed in the repository, and looks
            something like <literal>$Revision: 144 $</literal>.  
            It may also be specified as
            <literal>LastChangedRevision</literal> or
            <literal>Rev</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Author</literal></term>
        <listitem>
          <para>This keyword describes the last known user to
            change this file in the repository, and looks
            something like <literal>$Author: harry $</literal>.  
            It may also be specified as 
            <literal>LastChangedBy</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>HeadURL</literal></term>
        <listitem>
          <para>This keyword describes the full URL to the latest
            version of the file in the repository, and looks
            something like <literal>$HeadURL:
            http://svn.example.com/repos/trunk/calc.c $</literal>.
            It may be abbreviated as
            <literal>URL</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Id</literal></term>
        <listitem>
          <para>This keyword is a compressed combination of the other
            keywords.  Its substitution looks something like
            <literal>$Id: calc.c 148 2006-07-28 21:30:43Z sally
            $</literal>, and is interpreted to mean that the file
            <filename>calc.c</filename> was last changed in revision
            148 on the evening of July 28, 2006 by the user
            <literal>sally</literal>.  The date displayed by this
            keyword is in UTC, unlike that of the
            <literal>Date</literal> keyword (which uses the local time
            zone).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Header</literal></term>
        <listitem>
          <para>This keyword is similar to the <literal>Id</literal>
            keyword but contains the full URL of the latest revision
            of the item, identical to <literal>HeadURL</literal>. 
            Its substitution looks something like <literal>$Header: 
            http://svn.example.com/repos/trunk/calc.c 
            148 2006-07-28 21:30:43Z sally $</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Several of the preceding descriptions use the phrase
      <quote>last known</quote> or similar wording.  Keep in mind that
      keyword expansion is a client-side operation, and your client
      <quote>knows</quote> only about changes that have occurred in
      the repository when you update your working copy to include
      those changes.  If you never update your working copy, your
      keywords will never expand to different values even if those
      versioned files are being changed regularly in the
      repository.</para>

    <sidebar>
      <title>Where's $GlobalRev$?</title>

      <para>New users are often confused by how the
        <literal>$Rev$</literal> keyword works.  Since the repository
        has a single, globally increasing revision number, many people
        assume that it is this number that is reflected by the
        <literal>$Rev$</literal> keyword's value.  But
        <literal>$Rev$</literal> expands to show the last revision in
        which the file <emphasis>changed</emphasis>, not the last
        revision to which it was updated.  Understanding this clears
        the confusion, but frustration often remains without the
        support of a Subversion keyword to do so, how can you
        automatically get the global revision number into your
        files?</para>

      <para>To do this, you need external processing.  Subversion
        ships with a tool called <command>svnversion</command>, which
        was designed for just this purpose.  It crawls your working
        copy and generates as output the revision(s) it finds.  You
        can use this program, plus some additional tooling, to embed
        that revision information into your files.  For more
        information on <command>svnversion</command>, see <xref
        linkend="svn.ref.svnversion"/>.</para>

    </sidebar>

    <para>In addition to previous set of stock keyword definitions and
      aliases, Subversion 1.8 allows you the freedom to define and use
      custom keywords.  To define a custom keyword, add a token to the
      value of the <literal>svn:keywords</literal> property which is
      of the form
      <userinput><replaceable>MyKeyword</replaceable>=<replaceable>FORMAT</replaceable></userinput>,
      where <replaceable>MyKeyword</replaceable> is the keyword name
      (which you'll use in the keyword anchor)
      and <replaceable>FORMAT</replaceable> is a format string into
      which information will be substituted when your keyword is
      expanded inside your file.</para>

    <para>The format string syntax used for custom keywords supports
      the following format codes:</para>

    <variablelist>
      <varlistentry>
        <term><literal>%a</literal></term>
        <listitem>
          <para>The author of the revision given
            by <literal>%r</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%b</literal></term>
        <listitem>
          <para>The basename of the URL of the file.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%d</literal></term>
        <listitem>
          <para>Short format of the date of the revision given by
            <literal>%r</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%D</literal></term>
        <listitem>
          <para>Long format of the date of the revision given by
            <literal>%r</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%P</literal></term>
        <listitem>
          <para>The file's path, relative to the repository
            root.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%r</literal></term>
        <listitem>
          <para>The last known revision in which this file changed in
          the repository.  (This is the same revision which would be
          substituted for the <literal>Revision</literal>
          keyword.)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%R</literal></term>
        <listitem>
          <para>The URL to the root of the repository.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%u</literal></term>
        <listitem>
          <para>The URL of the file.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%_</literal></term>
        <listitem>
          <para>A space character. (Keyword definitions cannot contain
            a literal space character.)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%%</literal></term>
        <listitem>
          <para>A literal percent sign ('<literal>%</literal>').</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%H</literal></term>
        <listitem>
          <para>Equivalent to <literal>%P%_%r%_%d%_%a</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>%I</literal></term>
        <listitem>
          <para>Equivalent to <literal>%b%_%r%_%d%_%a</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>As you can see, many of the individual format codes serve as
      placeholders for the same information available through the
      stock keywords.  But of course, the custom keyword format allows
      you to more flexibly string together multiple bits of
      information.  For example, you might wish to have a single
      keyword in your files which reports the repository relative path
      of the file and last-changed revision, formatted in a pleasant,
      human-readable way.  To do so, you'd first define your custom
      keyword:</para>

    <informalexample>
      <screen>
$ svn pset svn:keywords "PathRev=%P,%_r%r" calc/button.c
property 'svn:keywords' set on 'button.c'
$
</screen>
    </informalexample>

    <para>Next, you'd edit the file's contents to add the keyword
      anchor for your custom keyword, which in this case
      is <literal>$PathRev$</literal>.  After committing these
      changes, an examination of your file's contents will show that
      your custom keyword was substituted as you would
      expect where previously the file
      contained <literal>$PathRev$</literal>, it now reads
      <literal>$PathRev: trunk/calc/button.c, r23 $</literal>.</para>

    <note>
      <para>Subversion will automatically truncate any keyword
        expansions which exceed 255 bytes in length.  Also custom
        keywords defined with names that exceed 255 bytes will be
        ignored altogether.</para>
    </note>

    <para>You can also instruct Subversion to maintain a fixed length
      (in terms of the number of bytes consumed) for the substituted
      keyword.  By using a double colon (<literal>::</literal>) after
      the keyword name, followed by a number of space characters, you
      define that fixed width.  When Subversion goes to substitute
      your keyword for the keyword and its value, it will essentially
      replace only those space characters, leaving the overall width
      of the keyword field unchanged.  If the substituted value is
      shorter than the defined field width, there will be extra
      padding characters (spaces) at the end of the substituted field;
      if it is too long, it is truncated with a special hash
      (<literal>#</literal>) character just before the final dollar
      sign terminator.</para>

    <para>For example, say you have a document in which you have
      some section of tabular data reflecting the document's
      Subversion keywords.  Using the original Subversion keyword
      substitution syntax, your file might look something
      like:</para>

    <informalexample>
      <programlisting>
$Rev$:     Revision of last commit
$Author$:  Author of last commit
$Date$:    Date of last commit
</programlisting>
    </informalexample>
    
    <para>Now, that looks nice and tabular at the start of things.
      But when you then commit that file (with keyword substitution
      enabled, of course), you see:</para>

    <informalexample>
      <programlisting>
$Rev: 12 $:     Revision of last commit
$Author: harry $:  Author of last commit
$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit
</programlisting>
    </informalexample>
    
    <para>The result is not so beautiful.  And you might be
      tempted to then adjust the file after the substitution so
      that it again looks tabular.  But that holds only as long as
      the keyword values are the same width.  If the last
      committed revision rolls into a new place value (say, from
      99 to 100), or if another person with a longer username
      commits the file, stuff gets all crooked again.  However, if
      you are using Subversion 1.2 or later, you can use the new
      fixed-length keyword syntax and define some field widths that
      seem sane, so your file might look like this:</para>

    <informalexample>
      <programlisting>
$Rev::               $:  Revision of last commit
$Author::            $:  Author of last commit
$Date::              $:  Date of last commit
</programlisting>
    </informalexample>
    
    <para>You commit this change to your file.  This time,
      Subversion notices the new fixed-length keyword syntax and
      maintains the width of the fields as defined by the padding
      you placed between the double colon and the trailing dollar
      sign.  After substitution, the width of the fields is
      completely unchanged the short values for
      <literal>Rev</literal> and <literal>Author</literal> are
      padded with spaces, and the long <literal>Date</literal>
      field is truncated by a hash character:</para>

    <informalexample>
      <programlisting>
$Rev:: 13            $:  Revision of last commit
$Author:: harry      $:  Author of last commit
$Date:: 2006-03-15 0#$:  Date of last commit
</programlisting>
    </informalexample>

    <para>The use of fixed-length keywords is especially handy when
      performing substitutions into complex file formats that
      themselves use fixed-length fields for data, or for which the
      stored size of a given data field is overbearingly difficult to
      modify from outside the format's native application.  Of course,
      where binary file formats are concerned, you must always take great
      care that any keyword substitution you introduce fixed-length
      or otherwise does not violate the integrity of that format.
      While it might sound easy enough, this can be an astonishingly
      difficult task for most of the popular binary file formats in use
      today, and <emphasis>not</emphasis> something to be undertaken by
      the faint of heart!</para>

    <warning>
      <para>Be aware that because the width of a keyword field is
        measured in bytes, the potential for corruption of
        multibyte values exists.  For example, a username that
        contains some multibyte UTF-8 characters might suffer
        truncation in the middle of the string of bytes that make
        up one of those characters.  The result will be a mere
        truncation when viewed at the byte level, but will likely
        appear as a string with an incorrect or garbled final
        character when viewed as UTF-8 text.  It is conceivable
        that certain applications, when asked to load the file,
        would notice the broken UTF-8 text and deem the entire
        file corrupt, refusing to operate on the file
        altogether.  So, when limiting keywords to a fixed size,
        choose a size that allows for this type of byte-wise
        expansion.</para> 
    </warning>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.sparsedirs">
    <title>Sparse Directories</title>

    <para>
      <indexterm>
        <primary>sparse directories</primary>
      </indexterm>
      <indexterm>
        <primary>checkouts</primary>
        <secondary>shallow</secondary>
        <see>sparse directories</see>
      </indexterm>By default, most Subversion operations on
      directories act in a recursive manner.  For
      example, <command>svn checkout</command> creates a working copy
      with every file and directory in the specified area of the
      repository, descending recursively through the repository tree
      until the entire structure is copied to your local disk.
      Subversion 1.5 introduces a feature called <firstterm>sparse
      directories</firstterm> (or <firstterm>shallow
      checkouts</firstterm>) that allows you to easily check out a
      working copy or a portion of a working copy more
      shallowly than full recursion, with the freedom to bring in
      previously ignored files and subdirectories at a later
      time.</para>

    <para>For example, say we have a repository with a tree of files
      and directories with names of the members of a human family with
      pets.  (It's an odd example, to be sure, but bear with us.)  A
      regular <command>svn checkout</command> operation will give us a
      working copy of the whole tree:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos mom
A    mom/son
A    mom/son/grandson
A    mom/daughter
A    mom/daughter/granddaughter1
A    mom/daughter/granddaughter1/bunny1.txt
A    mom/daughter/granddaughter1/bunny2.txt
A    mom/daughter/granddaughter2
A    mom/daughter/fishie.txt
A    mom/kitty1.txt
A    mom/doggie1.txt
Checked out revision 1.
$
</screen>
    </informalexample>

    <para>Now, let's check out the same tree again, but this time
      we'll ask Subversion to give us only the topmost directory
      with none of its children at all:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1
$
</screen>
    </informalexample>
 
    <para>Notice that we added to our original <command>svn
      checkout</command> command line a new <option>--depth</option>
      option.  This option is present on many of Subversion's
      subcommands and is similar to the
      <option>--non-recursive</option> (<option>-N</option>) and
      <option>--recursive</option> (<option>-R</option>) options.  In
      fact, it combines, improves upon, supercedes, and ultimately
      obsoletes these two older options.  For starters, it expands the
      supported degrees of depth specification available to users,
      adding some previously unsupported (or inconsistently supported)
      depths.  Here are the depth values that you can request for a
      given Subversion operation:</para>

    <variablelist>

      <indexterm>
        <primary>depth</primary>
        <secondary>empty</secondary>
      </indexterm>
      <indexterm>
        <primary>depth</primary>
        <secondary>files</secondary>
      </indexterm>
      <indexterm>
        <primary>depth</primary>
        <secondary>immediates</secondary>
      </indexterm>
      <indexterm>
        <primary>depth</primary>
        <secondary>infinity</secondary>
      </indexterm>

      <varlistentry>
        <term><literal>--depth empty</literal></term>
        <listitem>
          <para>Include only the immediate target of the operation,
            not any of its file or directory children.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth files</literal></term>
        <listitem>
          <para>Include the immediate target of the operation and any
            of its immediate file children.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>--depth immediates</literal></term>
        <listitem>
          <para>Include the immediate target of the operation and any
            of its immediate file or directory children.  The directory
            children will themselves be empty.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry>
        <term><literal>--depth infinity</literal></term>
        <listitem>
          <para>Include the immediate target, its file and directory
            children, its children's children, and so on to full
            recursion.</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>
      <indexterm>
        <primary>depth</primary>
        <secondary>ambient</secondary>
      </indexterm>Of course, merely combining two existing options into one
      hardly constitutes a new feature worthy of a whole section in
      our book.  Fortunately, there is more to this story.  This idea
      of depth extends not just to the operations you perform with
      your Subversion client, but also as a description of a working
      copy citizen's <firstterm>ambient depth</firstterm>, which is
      the depth persistently recorded by the working copy for that
      item.  Its key strength is this very persistence the fact
      that it is <quote>sticky</quote>.  The working copy remembers
      the depth you've selected for each item in it until you later
      change that depth selection; by default, Subversion commands
      operate on the working copy citizens present, regardless of
      their selected depth settings.</para>

    <tip>
      <para>You can check the recorded ambient depth of a working copy
        using the <command>svn info</command> command.  If the ambient
        depth is anything other than infinite recursion, <command>svn
        info</command> will display a line describing that depth
        value:</para>

      <informalexample>
        <screen>
$ svn info mom-immediates | grep "^Depth:"
Depth: immediates
$
</screen>
      </informalexample>
    </tip>

    <para>Our previous examples demonstrated checkouts of infinite
      depth (the default for <command>svn checkout</command>) and
      empty depth.  Let's look now at examples of the other depth
      values:</para>

    <informalexample>
      <screen>
$ svn checkout file:///var/svn/repos mom-files --depth files
A    mom-files/kitty1.txt
A    mom-files/doggie1.txt
Checked out revision 1.
$ svn checkout file:///var/svn/repos mom-immediates --depth immediates
A    mom-immediates/son
A    mom-immediates/daughter
A    mom-immediates/kitty1.txt
A    mom-immediates/doggie1.txt
Checked out revision 1.
$
</screen>
    </informalexample>

    <para>As described, each of these depths is something more than
      only the target, but something less than full recursion.</para>

    <para>We've used <command>svn checkout</command> as an example
      here, but you'll find the <option>--depth</option> option
      present on many other Subversion commands, too.  In those other
      commands, depth specification is a way to limit the scope of an
      operation to some depth, much like the way the older
      <option>--non-recursive</option> (<option>-N</option>) and
      <option>--recursive</option> (<option>-R</option>) options
      behave.  This means that when operating on a working copy of
      some depth, while requesting an operation of a shallower depth,
      the operation is limited to that shallower depth.  In fact, we
      can make an even more general statement: given a working copy of
      any arbitrary even mixed ambient depth, and a
      Subversion command with some requested operational depth, the
      command will maintain the ambient depth of the working copy
      members while still limiting the scope of the operation to the
      requested (or default) operational depth.</para>

    <para>In addition to the <option>--depth</option> option, the
      <command>svn update</command> and <command>svn switch</command>
      subcommands also accept a second depth-related option:
      <option>--set-depth</option>.  It is with this option that you
      can change the sticky depth of a working copy item.  Watch what
      happens as we take our empty-depth checkout and gradually
      telescope it deeper using <userinput>svn update
      --set-depth <replaceable>NEW-DEPTH</replaceable> <replaceable>TARGET</replaceable></userinput>:</para>

    <informalexample>
      <screen>
$ svn update --set-depth files mom-empty
Updating 'mom-empty':
A    mom-empty/kittie1.txt
A    mom-empty/doggie1.txt
Updated to revision 1.
$ svn update --set-depth immediates mom-empty
Updating 'mom-empty':
A    mom-empty/son
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty
Updating 'mom-empty':
A    mom-empty/son/grandson
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
A    mom-empty/daughter/granddaughter2
A    mom-empty/daughter/fishie1.txt
Updated to revision 1.
$
</screen>
    </informalexample>

    <para>As we gradually increased our depth selection, the
      repository gave us more pieces of our tree.</para>

    <para>In our example, we operated only on the root of our working
      copy, changing its ambient depth value.  But we can
      independently change the ambient depth value of
      <emphasis>any</emphasis> subdirectory inside the working copy,
      too.  Careful use of this ability allows us to flesh out only
      certain portions of the working copy tree, leaving other
      portions absent altogether (hence the <quote>sparse</quote> bit
      of the feature's name).  Here's an example of how we might build
      out a portion of one branch of our family's tree, enable full
      recursion on another branch, and keep still other pieces pruned
      (absent from disk).</para>

    <informalexample>
      <screen>
$ rm -rf mom-empty
$ svn checkout file:///var/svn/repos mom-empty --depth empty
Checked out revision 1.
$ svn update --set-depth empty mom-empty/son
Updating 'mom-empty/son':
A    mom-empty/son
Updated to revision 1.
$ svn update --set-depth empty mom-empty/daughter
Updating 'mom-empty/daughter':
A    mom-empty/daughter
Updated to revision 1.
$ svn update --set-depth infinity mom-empty/daughter/granddaughter1
Updating 'mom-empty/daughter/granddaughter1':
A    mom-empty/daughter/granddaughter1
A    mom-empty/daughter/granddaughter1/bunny1.txt
A    mom-empty/daughter/granddaughter1/bunny2.txt
Updated to revision 1.
$
</screen>
    </informalexample>

    <para>Fortunately, having a complex collection of ambient depths
      in a single working copy doesn't complicate the way you interact
      with that working copy.  You can still make, revert, display,
      and commit local modifications in your working copy without
      providing any new options (including <option>--depth</option> and
      <option>--set-depth</option>) to the relevant subcommands.  Even
      <command>svn update</command> works as it does elsewhere when no
      specific depth is provided it updates the working copy
      targets that are present while honoring their sticky
      depths.</para>

    <para>You might at this point be wondering, <quote>So what?  When
      would I use this?</quote>  One scenario where this feature
      finds utility is tied to a particular repository layout,
      specifically where you have many related or codependent
      projects or software modules living as siblings in a single
      repository location (<filename>trunk/project1</filename>,
      <filename>trunk/project2</filename>,
      <filename>trunk/project3</filename>, etc.).  In such
      scenarios, it might be the case that you personally care 
      about only a handful of those projects maybe some primary
      project and a few other modules on which it depends.  You can
      check out individual working copies of all of these things, but
      those working copies are disjoint and, as a result, it can be
      cumbersome to perform operations across several or all of them
      at the same time.  The alternative is to use the sparse
      directories feature, building out a single working copy that
      contains only the modules you care about.  You'd start with an
      empty-depth checkout of the common parent directory of the
      projects, and then update with infinite depth only the items you
      wish to have, like we demonstrated in the previous example.
      Think of it like an opt-in system for working copy
      citizens.</para>

    <para>The original (Subversion 1.5) implementation of shallow
      checkouts was good, but didn't support de-telescoping of working
      copy items.  Subversion 1.6 remedied this problem.  For example,
      running <userinput>svn update --set-depth empty</userinput> in
      an infinite-depth working copy will discard everything but the
      topmost directory.<footnote><para>Safely, of course.  As in
      other situations, Subversion will leave on disk any files you've
      modified or which aren't versioned.</para></footnote>  Subversion
      1.6 also introduced another supported value for
      the <option>--set-depth</option>
      option: <literal>exclude</literal>.  Using <option>--set-depth
      exclude</option> with <command>svn update</command> will cause
      the update target to be removed from the working copy
      entirely a directory target won't even be left
      present-but-empty.  This is especially handy when there are more
      things that you'd like to keep in a working copy than things
      you'd like to <emphasis>not</emphasis> keep.</para>

    <para>Consider a directory with hundreds of subdirectories, one of
      which you would like to omit from your working copy.  Using
      an <quote>additive</quote> approach to sparse directories, you
      might check out the directory with an empty depth, then
      explicitly telescope (using <userinput>svn update --set-depth
      infinity</userinput>) each and every subdirectory of the
      directory except the one you don't care about.</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/repos/many-dirs --depth empty
 
$ svn update --set-depth infinity many-dirs/wanted-dir-1
 
$ svn update --set-depth infinity many-dirs/wanted-dir-2
 
$ svn update --set-depth infinity many-dirs/wanted-dir-3
 
### and so on, and so on, ...
</screen>
    </informalexample>

    <para>This could be quite tedious, especially since you don't even
      have stubs of these directories in your working copy to deal
      with.  Such a working copy would also have another
      characteristic that you might not expect or desire: if someone
      else creates any new subdirectories in this top-level directory,
      you won't receive those when you update your working
      copy.</para>

    <para>Beginning with Subversion 1.6, you can take a different
      approach.  First, check out the directory in full.  Then
      run <userinput>svn update --set-depth exclude</userinput> on the
      one subdirectory you don't care about.</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/repos/many-dirs
 
$ svn update --set-depth exclude many-dirs/unwanted-dir
D         many-dirs/unwanted-dir
$
</screen>
    </informalexample>

    <para>This approach leaves your working copy with the same stuff
      as in the first approach, but any new subdirectories which
      appear in the top-level directory would also show up when you
      update your working copy.  The downside of this approach is that
      you have to actually check out that whole subdirectory that you
      don't even want just so you can tell Subversion that you don't
      want it.  This might not even be possible if that subdirectory
      is too large to fit on your disk (which might, after all, be the
      very reason you don't want it in your working copy).</para>

    <note>
      <para>While the functionality for excluding an existing item
        from a working copy was hung off of the <command>svn
        update</command> command, you might have noticed that the
        output from <userinput>svn update --set-depth
        exclude</userinput> differs from that of a normal update
        operation.  This output betrays the fact that, under the hood,
        exclusion is a completely client-side operation, very much
        unlike a typical update.</para>
    </note>

    <para>In such a situation, you might consider a compromise
      approach.  First, check out the top-level directory
      with <option>--depth immediates</option>.  Then, exclude the
      directory you don't want using <userinput>svn update --set-depth
      exclude</userinput>.  Finally, telescope all the items that
      remain to infinite depth, which should be fairly easy to do
      because they are all addressable in your shell.</para>

    <informalexample>
    <screen>
$ svn checkout http://svn.example.com/repos/many-dirs --depth immediates
 
$ svn update --set-depth exclude many-dirs/unwanted-dir
D         many-dirs/unwanted-dir
$ svn update --set-depth infinity many-dirs/*
 
$
</screen>
    </informalexample>

    <para>Once again, your working copy will have the same stuff as in
      the previous two scenarios.  But now, any time a new file or
      subdirectory is committed to the top-level directory, you'll
      receive it at an empty depth when you update your
      working copy.  You can now decide what to do with such newly
      appearing working copy items: expand them into infinite depth,
      or exclude them altogether.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.locking">
    <title>Locking</title>

    <para>Subversion's copy-modify-merge version control model lives
      and dies on its data merging algorithms specifically on
      how well those algorithms perform when trying to resolve
      conflicts caused by multiple users modifying the same file
      concurrently.  Subversion itself provides only one such
      algorithm: a three-way differencing algorithm that is smart
      enough to handle data at a granularity of a single line of text.
      Subversion also allows you to supplement its content merge
      processing with external differencing utilities (as described in
      <xref linkend="svn.advanced.externaldifftools.diff3" /> and
      <xref linkend="svn.advanced.externaldifftools.merge" />), some
      of which may do an even better job, perhaps providing
      granularity of a word or a single character of text.  But common
      among those algorithms is that they generally work only on text
      files.  The landscape starts to look pretty grim when you start
      talking about content merges of nontextual file formats.  And
      when you can't find a tool that can handle that type of merging,
      you begin to run into problems with the copy-modify-merge
      model.</para>

    <para>Let's look at a real-life example of where this model runs
      aground.  Harry and Sally are both graphic designers working on
      the same project, a bit of marketing collateral for an
      automobile mechanic.  Central to the design of a particular
      poster is an image of a car in need of some bodywork, stored in
      a file using the PNG image format.  The poster's layout is
      almost finished, and both Harry and Sally are pleased with the
      particular photo they chose for their damaged car a baby
      blue 1967 Ford Mustang with an unfortunate bit of crumpling on
      the left front fender.</para>

    <para>Now, as is common in graphic design work, there's a change
      in plans, which causes the car's color to be a concern.  So Sally
      updates her working copy to <literal>HEAD</literal>, fires up
      her photo-editing software, and sets about tweaking the image so
      that the car is now cherry red.  Meanwhile, Harry, feeling
      particularly inspired that day, decides that the image would
      have greater impact if the car also appears to have suffered
      greater impact.  He, too, updates to <literal>HEAD</literal>,
      and then draws some cracks on the vehicle's windshield.  He
      manages to finish his work before Sally finishes hers, and after
      admiring the fruits of his undeniable talent, he commits the
      modified image.  Shortly thereafter, Sally is finished with the
      car's new finish and tries to commit her changes.  But, as
      expected, Subversion fails the commit, informing Sally that
      her version of the image is now out of date.</para>

    <para>Here's where the difficulty sets in.  If Harry and Sally
      were making changes to a text file, Sally would simply update
      her working copy, receiving Harry's changes in the process.  In
      the worst possible case, they would have modified the same
      region of the file, and Sally would have to work out by hand the
      proper resolution to the conflict.  But these aren't text
      files they are binary images.  And while it's a simple
      matter to describe what one would expect the results of this
      content merge to be, there is precious little chance that any
      software exists that is smart enough to examine the common
      baseline image that each of these graphic artists worked
      against, the changes that Harry made, and the changes that Sally
      made, and then spit out an image of a busted-up red Mustang with
      a cracked windshield!</para>

    <para>
      <indexterm>
        <primary>locks</primary>
      </indexterm>
      <indexterm>
        <primary>checkouts</primary>
        <secondary>reserved</secondary>
        <see>locking</see>
      </indexterm>Of course, things would have gone more smoothly if
      Harry and Sally had serialized their modifications to the
      image if, say, Harry had waited to draw his windshield
      cracks on Sally's now-red car, or if Sally had tweaked the color
      of a car whose windshield was already cracked.  As is discussed
      in <xref linkend="svn.basic.vsn-models.copy-merge" />, most of
      these types of problems go away entirely where perfect
      communication between Harry and Sally
      exists.<footnote><para>Communication wouldn't have been such bad
      medicine for Harry and Sally's Hollywood namesakes, either, for
      that matter.</para></footnote> But as one's version control
      system is, in fact, one form of communication, it follows that
      having that software facilitate the serialization of
      nonparallelizable editing efforts is no bad thing.  This is
      where Subversion's implementation of the lock-modify-unlock
      model steps into the spotlight.  This is where we talk about
      Subversion's <firstterm>locking</firstterm> feature, which is
      similar to the <quote>reserved checkouts</quote> mechanisms of
      other version control systems.</para>

    <para>Subversion's locking feature exists ultimately to minimize
      wasted time and effort.  By allowing a user to programmatically
      claim the exclusive right to change a file in the repository,
      that user can be reasonably confident that any energy he invests
      on unmergeable changes won't be wasted his commit of those
      changes will succeed.  Also, because Subversion communicates to
      other users that serialization is in effect for a particular
      versioned object, those users can reasonably expect that the
      object is about to be changed by someone else.  They, too, can
      then avoid wasting their time and energy on unmergeable changes
      that won't be committable due to eventual
      out-of-dateness.</para>

    <para>When referring to Subversion's locking feature, one is
      actually talking about a fairly diverse collection of behaviors,
      which include the ability to lock a versioned
      file<footnote><para>Subversion does not currently allow locks on
      directories.</para></footnote> (claiming the exclusive right to
      modify the file), to unlock that file (yielding that exclusive
      right to modify), to see reports about which files are locked
      and by whom, to annotate files for which locking before editing
      is strongly advised, and so on.  In this section, we'll cover
      all of these facets of the larger locking feature.</para>

    <sidebar id="svn.advanced.locking.meanings">
      <title>The Three Meanings of <quote>Lock</quote></title>

      <para>In this section, and almost everywhere in this book, the
        words <quote>lock</quote> and <quote>locking</quote> describe
        a mechanism for mutual exclusion between users to avoid
        clashing commits.  Unfortunately, there are two other sorts
        of <quote>lock</quote> with which Subversion, and therefore
        this book, sometimes needs to be concerned.</para>

      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>administrative</secondary>
        </indexterm>The second is <firstterm>administrative
        locks</firstterm>, used internally by Subversion to prevent
        clashes between multiple Subversion clients operating on the
        same working copy.  This is the sort of lock indicated by an
        <computeroutput>L</computeroutput> in the third column of
        <command>svn status</command> output, and removed by the
        <command>svn cleanup</command> command, as described in <xref
        linkend="svn.tour.cleanup"/>.</para>

      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>database</secondary>
        </indexterm>Third, there are <firstterm>database
        locks</firstterm>, used internally by the Berkeley DB backend
        to prevent clashes between multiple programs trying to access
        the database.  This is the sort of lock whose unwanted
        persistence after an error can cause a repository to
        be <quote>wedged,</quote> as described in
        <xref linkend="svn.reposadmin.maint.recovery" />.</para>

      <para>You can generally forget about these other kinds of locks
        until something goes wrong that requires you to care about
        them.  In this book, <quote>lock</quote> means the first sort
        unless the contrary is either clear from context or explicitly
        stated.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.creation">
      <title>Creating Locks</title>
      
      <para>
        <indexterm>
          <primary>locks</primary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>lock token</secondary>
        </indexterm>
        <indexterm>
          <primary>locking</primary>
          <secondary>lock owner</secondary>
        </indexterm>In the Subversion repository, a
        <firstterm>lock</firstterm> is a piece of metadata that
        grants exclusive access to one user to change a file.  This
        user is said to be the <firstterm>lock owner</firstterm>.
        Each lock also has a unique identifier, typically a long
        string of characters, known as the <firstterm>lock
        token</firstterm>.  The repository manages locks, ultimately
        handling their creation, enforcement, and removal.  If any
        commit transaction attempts to modify or delete a locked file
        (or delete one of the parent directories of the file), the
        repository will demand two pieces of information that
        the client performing the commit be authenticated as the lock
        owner, and that the lock token has been provided as part of
        the commit process as a form of proof that the client knows which
        lock it is using.</para>
      
      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>lock</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>creation</secondary>
        </indexterm>To demonstrate lock creation, let's refer back to
        our example of multiple graphic designers working on the same
        binary image files.  Harry has decided to change a JPEG image.
        To prevent other people from committing changes to the file
        while he is modifying it (as well as alerting them that he is
        about to change it), he locks the file in the repository using
        the <command>svn lock</command> command.</para>

      <informalexample>
        <screen>
$ svn lock banana.jpg -m "Editing file for tomorrow's release."
'banana.jpg' locked by user 'harry'.
$
</screen>
      </informalexample>

      <para>The preceding example demonstrates a number of new things.
        First, notice that Harry passed the
        <option>--message</option> (<option>-m</option>) option to
        <command>svn lock</command>.  Similar to <command>svn
        commit</command>, the <command>svn lock</command> command can
        take comments via either <option>--message</option>
        (<option>-m</option>) or <option>--file</option>
        (<option>-F</option>) to describe the reason for locking the
        file.  Unlike <command>svn commit</command>, however,
        <command>svn lock</command> will not demand a message by
        launching your preferred text editor.  Lock comments are
        optional, but still recommended to aid communication.</para>

      <para>Second, the lock attempt succeeded.  This means that the
        file wasn't already locked, and that Harry had the latest
        version of the file.  If Harry's working copy of the file had
        been out of date, the repository would have rejected the
        request, forcing Harry to <command>svn update</command> and
        reattempt the locking command.  The locking command would also
        have failed if the file had already been locked by someone
        else.</para>

      <para>As you can see, the <command>svn lock</command> command
        prints confirmation of the successful lock.  At this point,
        the fact that the file is locked becomes apparent in the
        output of the <command>svn status</command> and <command>svn
        info</command> reporting subcommands.</para>

      <informalexample>
        <screen>
$ svn status
     K  banana.jpg

$ svn info banana.jpg
Path: banana.jpg
Name: banana.jpg
Working Copy Root Path: /home/harry/project
URL: http://svn.example.com/repos/project/banana.jpg
Repository Root: http://svn.example.com/repos/project
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 2198
Node Kind: file
Schedule: normal
Last Changed Author: frank
Last Changed Rev: 1950
Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)
Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)
Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5
Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e
Lock Owner: harry
Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)
Lock Comment (1 line):
Editing file for tomorrow's release.

$
</screen>
      </informalexample>

      <para>The fact that the <command>svn info</command> command,
        which does not contact the repository when run against working
        copy paths, can display the lock token reveals an important
        piece of information about those tokens:  they are cached in
        the working copy.  The presence of the lock token is critical.
        It gives the working copy authorization to make use of the
        lock later on.  Also, the <command>svn status</command>
        command shows a <literal>K</literal> next to the file (short
        for locKed), indicating that the lock token is present.</para>

      <sidebar>
        <title>Regarding Lock Tokens</title>

        <para>A lock token isn't an authentication token, so much as
          an <emphasis>authorization</emphasis> token.  The token
          isn't a protected secret.  In fact, a lock's unique token is
          discoverable by anyone who runs <userinput>svn info
          <replaceable>URL</replaceable></userinput>.  A lock token is
          special only when it lives inside a working copy.  It's
          proof that the lock was created in that particular working
          copy, and not somewhere else by some other client.  Merely
          authenticating as the lock owner isn't enough to prevent
          accidents.</para>

        <para>
          <indexterm>
            <primary>locks</primary>
            <secondary>breaking</secondary>
          </indexterm>For example, suppose you lock a file using a
          computer at your office, but leave work for the day before
          you finish your changes to that file.  It should not be
          possible to accidentally commit changes to that same file
          from your home computer later that evening simply because
          you've authenticated as the lock's owner.  In other words,
          the lock token prevents one piece of Subversion-related
          software from undermining the work of another.  (In our
          example, if you really need to change the file from an
          alternative working copy, you would need
          to <firstterm>break</firstterm> the lock and relock the
          file.)</para>

      </sidebar>

      <para>Now that Harry has locked <filename>banana.jpg</filename>,
        Sally is unable to change or delete that file:</para>

      <informalexample>
        <screen>
$ svn delete banana.jpg
D         banana.jpg
$ svn commit -m "Delete useless file."
Deleting       banana.jpg
svn: E175002: Commit failed (details follow):
svn: E175002: Server sent unexpected return value (423 Locked) in response to 
DELETE request for '/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc
35d/banana.jpg'
$
</screen>
      </informalexample>

      <para>But Harry, after touching up the banana's shade of yellow,
        is able to commit his changes to the file.  That's because he
        authenticates as the lock owner and also because his working
        copy holds the correct lock token:</para>

      <informalexample>
        <screen>
$ svn status
M    K  banana.jpg
$ svn commit -m "Make banana more yellow"
Sending        banana.jpg
Transmitting file data .
Committed revision 2201.
$ svn status
$
</screen>
      </informalexample>

      <para>Notice that after the commit is finished, <command>svn
        status</command> shows that the lock token is no longer
        present in the working copy.  This is the standard behavior of
        <command>svn commit</command> it searches the working
        copy (or list of targets, if you provide such a list) for
        local modifications and sends all the lock tokens it
        encounters during this walk to the server as part of the
        commit transaction.  After the commit completes successfully,
        all of the repository locks that were mentioned are
        released <emphasis>even on files that weren't
        committed</emphasis>.  This is meant to discourage users from
        being sloppy about locking or from holding locks for too long.
        If Harry haphazardly locks 30 files in a directory named
        <filename>images</filename> because he's unsure of which files
        he needs to change, yet changes only four of those files, when he
        runs <userinput>svn commit images</userinput>, the process will
        still release all 30 locks.</para>

      <para>This behavior of automatically releasing locks can be
        overridden with the <option>--no-unlock</option> option to
        <command>svn commit</command>.  This is best used for those
        times when you want to commit changes, but still plan to make
        more changes and thus need to retain existing locks.  You can
        also make this your default behavior by setting the
        <literal>no-unlock</literal> runtime configuration option (see
        <xref linkend="svn.advanced.confarea" />).</para>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>unlock</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>releasing</secondary>
        </indexterm>Of course, locking a file doesn't oblige one to
        commit a change to it.  The lock can be released at any time
        with a simple <command>svn unlock</command> command:</para>

      <informalexample>
        <screen>
$ svn unlock banana.c
'banana.c' unlocked.
</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.discovery">
      <title>Discovering Locks</title>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>status</tertiary>
        </indexterm>
        <indexterm>
          <primary>locks</primary>
          <secondary>discovery</secondary>
        </indexterm>When a commit fails due to someone else's locks, it's
        fairly easy to learn about them.  The easiest way is to run
        <userinput>svn status -u</userinput>:</para>

      <informalexample>
        <screen>
$ svn status -u
M               23   bar.c
M    O          32   raisin.jpg
        *       72   foo.h
Status against revision:     105
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>info</tertiary>
        </indexterm>In this example, Sally can see not only that her copy of
        <filename>foo.h</filename> is out of date, but also that one of the
        two modified files she plans to commit is locked in the
        repository.  The <literal>O</literal> symbol stands for
        <quote>Other,</quote> meaning that a lock exists on the file
        and was created by somebody else.  If she were to attempt a
        commit, the lock on <filename>raisin.jpg</filename> would
        prevent it.  Sally is left wondering who made the lock, when,
        and why.  Once again, <command>svn info</command> has the
        answers:</para>

      <informalexample>
        <screen>
$ svn info ^/raisin.jpg
Path: raisin.jpg
Name: raisin.jpg
URL: http://svn.example.com/repos/project/raisin.jpg
Repository Root: http://svn.example.com/repos/project
Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec
Revision: 105
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 32
Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Lock Comment (1 line):
Need to make a quick tweak to this image.
$
</screen>
      </informalexample>

      <para>Just as you can use <command>svn info</command> to examine
        objects in the working copy, you can also use it to examine
        objects in the repository.  If the main argument to
        <command>svn info</command> is a working copy path, then all
        of the working copy's cached information is displayed; any
        mention of a lock means that the working copy is holding a
        lock token (if a file is locked by another user or in another
        working copy, <command>svn info</command> on a working copy
        path will show no lock information at all).  If the main
        argument to <command>svn info</command> is a URL, the
        information reflects the latest version of an object in the
        repository, and any mention of a lock describes the current
        lock on the object.</para>

      <para>So in this particular example, Sally can see that Harry
        locked the file on February 16 to <quote>make a quick
        tweak.</quote>  It being June, she suspects that he probably
        forgot all about the lock.  She might phone Harry to complain
        and ask him to release the lock.  If he's unavailable, she
        might try to forcibly break the lock herself or ask an
        administrator to do so.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.break-steal">
      <title>Breaking and Stealing Locks</title>

      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>breaking</secondary>
        </indexterm>A repository lock isn't sacred in Subversion's
        default configuration state, locks can be released not only by
        the person who created them, but by anyone.  When somebody
        other than the original lock creator destroys a lock, we refer
        to this as <firstterm>breaking the lock</firstterm>.</para>

      <para>From the administrator's chair, it's simple to break
        locks.  The <command>svnlook</command>
        and <command>svnadmin</command> programs have the ability to
        display and remove locks directly from the repository.  (For
        more information about these tools, see
        <xref linkend="svn.reposadmin.maint.tk"/>.)</para>

      <informalexample>
        <screen>
$ svnadmin lslocks /var/svn/repos
Path: /project2/images/banana.jpg
UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923
Owner: frank
Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)
Expires: 
Comment (1 line):
Still improving the yellow color.

Path: /project/raisin.jpg
UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Owner: harry
Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)
Expires: 
Comment (1 line):
Need to make a quick tweak to this image.

$ svnadmin rmlocks /var/svn/repos /project/raisin.jpg
Removed lock on '/project/raisin.jpg'.
$
</screen>
      </informalexample>

      <para>The more interesting option is to allow users to break
        each other's locks over the network.  To do this, Sally simply
        needs to pass the <option>--force</option> option to the
        <command>svn unlock</command> command:</para>

      <informalexample>
        <screen>
$ svn status -u
M               23   bar.c
M    O          32   raisin.jpg
        *       72   foo.h
Status against revision:     105
$ svn unlock raisin.jpg
svn: E195013: 'raisin.jpg' is not locked in this working copy
$ svn info raisin.jpg | grep URL
URL: http://svn.example.com/repos/project/raisin.jpg
$ svn unlock http://svn.example.com/repos/project/raisin.jpg
svn: warning: W160039: Unlock failed on 'raisin.jpg' (403 Forbidden)
$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg
'raisin.jpg' unlocked.
$
</screen>
      </informalexample>

      <para>Now, Sally's initial attempt to unlock failed because she
        ran <command>svn unlock</command> directly on her working copy
        of the file, and no lock token was present.  To remove the
        lock directly from the repository, she needs to pass a URL
        to <command>svn unlock</command>.  Her first attempt to unlock
        the URL fails, because she can't authenticate as the lock
        owner (nor does she have the lock token).  But when she
        passes <option>--force</option>, the authentication and
        authorization requirements are ignored, and the remote lock is
        broken.</para>
        
      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>stealing</secondary>
        </indexterm>Simply breaking a lock may not be enough.  In
        the running example, Sally may not only want to break Harry's
        long-forgotten lock, but relock the file for her own use.
        She can accomplish this by using <command>svn unlock</command>
        with <option>--force</option> and then <command>svn lock</command>
        back-to-back, but there's a small chance that somebody else
        might lock the file between the two commands.  The simpler thing
        to do is to <firstterm>steal</firstterm> the lock, which involves
        breaking and relocking the file all in one atomic step.  To
        do this, Sally passes the <option>--force</option> option
        to <command>svn lock</command>:</para>

      <informalexample>
        <screen>
$ svn lock raisin.jpg
svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h
arry' in filesystem '/var/svn/repos/db'
$ svn lock --force raisin.jpg
'raisin.jpg' locked by user 'sally'.
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>locks</primary>
          <secondary>defunct</secondary>
        </indexterm>In any case, whether the lock is broken or stolen,
        Harry may be in for a surprise.  Harry's working copy still
        contains the original lock token, but that lock no longer
        exists.  The lock token is said to
        be <firstterm>defunct</firstterm>.  The lock represented by
        the lock token has either been broken (no longer in the
        repository) or stolen (replaced with a different lock).
        Either way, Harry can see this by asking
        <command>svn status</command> to contact the
        repository:</para>

      <informalexample>
        <screen>
$ svn status
     K  raisin.jpg
$ svn status -u
     B          32   raisin.jpg
Status against revision:     105
$ svn update
Updating '.':
  B  raisin.jpg
Updated to revision 105.
$ svn status
$
</screen>
      </informalexample>

      <para>If the repository lock was broken, then <userinput>svn
        status --show-updates</userinput> (<option>-u</option>)
        displays a <literal>B</literal> (Broken) symbol next to the
        file.  If a new lock exists in place of the old one, then a
        <literal>T</literal> (sTolen) symbol is shown.  Finally,
        <command>svn update</command> notices any defunct lock tokens
        and removes them from the working copy.</para>

      <sidebar>
        <title>Locking Policies</title>
        
        <para>Different systems have different notions of how strict a
          lock should be.  Some folks argue that locks must be
          strictly enforced at all costs, releasable only by the
          original creator or administrator.  They argue that if
          anyone can break a lock, chaos runs rampant and the
          whole point of locking is defeated.  The other side argues
          that locks are first and foremost a communication tool.  If
          users are constantly breaking each other's locks, it
          represents a cultural failure within the team and the
          problem falls outside the scope of software enforcement.</para>

        <para>Subversion defaults to the <quote>softer</quote>
          approach, but still allows administrators to create stricter
          enforcement policies through the use of hook scripts.  In
          particular, the <filename>pre-lock</filename> and
          <filename>pre-unlock</filename> hooks allow administrators
          to decide when lock creation and lock releases are allowed
          to happen.  Depending on whether a lock already exists,
          these two hooks can decide whether to allow a certain user
          to break or steal a lock.  The
          <filename>post-lock</filename> and
          <filename>post-unlock</filename> hooks are also available,
          and can be used to send email after locking actions.  To
          learn more about repository hooks, see
          <xref linkend="svn.reposadmin.hooks" />.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.locking.lock-communication">
      <title>Lock Communication</title>

      <para>We've seen how <command>svn lock</command>
        and <command>svn unlock</command> can be used to create,
        release, break, and steal locks.  This satisfies the goal of
        serializing commit access to a file.  But what about the
        larger problem of preventing wasted time?</para>

      <para>For example, suppose Harry locks an image file and then
        begins editing it.  Meanwhile, miles away, Sally wants to do
        the same thing.  She doesn't think to run <userinput>svn status
        -u</userinput>, so she has no idea that Harry has
        already locked the file.  She spends hours editing the file,
        and when she tries to commit her change, she discovers that
        either the file is locked or that she's out of date.
        Regardless, her changes aren't mergeable with Harry's.  One of
        these two people has to throw away his or her work, and a lot of
        time has been wasted.</para>
      
      <para>Subversion's solution to this problem is to provide a
        mechanism to remind users that a file ought to be locked
        <emphasis>before</emphasis> the editing begins.  The mechanism
        is a special property:  <literal>svn:needs-lock</literal>.  If
        that property is attached to a file (regardless of its value,
        which is irrelevant), Subversion will try to use
        filesystem-level permissions to make the file read-only unless,
        of course, the user has explicitly locked the file.
        When a lock token is present (as a result of using
        <command>svn lock</command>), the file becomes read/write.
        When the lock is released, the file becomes read-only
        again.</para>

      <para>The theory, then, is that if the image file has this
        property attached, Sally would immediately notice
        something is strange when she opens the file for editing:
        many applications alert users immediately when a read-only
        file is opened for editing, and nearly all would
        prevent her from saving changes to the file.  This
        reminds her to lock the file before editing, whereby she
        discovers the preexisting lock:</para>

      <informalexample>
        <screen>
$ /usr/local/bin/gimp raisin.jpg
gimp: error: file is read-only!
$ ls -l raisin.jpg
-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg
$ svn lock raisin.jpg
svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h
arry' in filesystem '/var/svn/repos/db'
$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock
Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b
Lock Owner: harry
Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)
Lock Comment (1 line):
Making some tweaks.  Locking for the next two hours.
$
</screen>
      </informalexample>

      <tip>
        <para>Users and administrators alike are encouraged to attach
          the <literal>svn:needs-lock</literal> property to any file
          that cannot be contextually merged.  This is the primary
          technique for encouraging good locking habits and preventing
          wasted effort.</para>
      </tip>

      <para>Note that this property is a communication tool that
        works independently from the locking system.  In other words,
        any file can be locked, whether or not this property is
        present.  And conversely, the presence of this property
        doesn't make the repository require a lock when
        committing.</para>

      <para>Unfortunately, the system isn't flawless.  It's possible
        that even when a file has the property, the read-only reminder
        won't always work.  Sometimes applications misbehave and
        <quote>hijack</quote> the read-only file, silently allowing
        users to edit and save the file anyway.  There's not much that
        Subversion can do in this situation at the end of the
        day, there's simply no substitution for good interpersonal
        communication.<footnote><para>Except, perhaps, a classic
        Vulcan mind-meld.</para></footnote></para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externals">
    <title>Externals Definitions</title>
    
    <para>Sometimes it is useful to construct a working copy that is
      made out of a number of different checkouts.  For example, you
      may want different subdirectories to come from different
      locations in a repository or perhaps from different
      repositories altogether.  You could certainly set up such a
      scenario by hand using <command>svn checkout</command> to
      create the sort of nested working copy structure you are trying
      to achieve.  But if this layout is important for everyone who
      uses your repository, every other user will need to perform the
      same checkout operations that you did.</para>

    <para>
      <indexterm>
        <primary>externals definitions</primary>
      </indexterm>
      <indexterm>
        <primary>externals</primary>
        <see>externals definitions</see>
      </indexterm>
      <indexterm>
        <primary>properties</primary>
        <secondary>svn:externals</secondary>
      </indexterm>Fortunately, Subversion provides support for
      <firstterm>externals definitions</firstterm>.  An externals
      definition is a mapping of a local directory to the
      URL and ideally a particular revision of a versioned
      directory.  In Subversion, you declare externals definitions in
      groups using the <literal>svn:externals</literal> property.  You
      can create or modify this property using <command>svn
      propset</command> or <command>svn propedit</command> (see <xref
      linkend="svn.advanced.props.manip" />).  It can be set on any
      versioned directory, and its value describes both the external
      repository location and the client-side directory to which that
      location should be checked out.</para>

    <para>The convenience of the <literal>svn:externals</literal>
      property is that once it is set on a versioned directory,
      everyone who checks out a working copy with that directory also
      gets the benefit of the externals definition.  In other words,
      once one person has made the effort to define the nested working
      copy structure, no one else has to bother Subversion will,
      after checking out the original working copy, automatically also
      check out the external working copies.</para>

    <warning>
      <para>The relative target subdirectories of externals
        definitions <emphasis>must not</emphasis> already exist on
        your or other users' systems Subversion will create them
        when it checks out the external working copy.</para>
    </warning>

    <para>You also get in the externals definition design all the
      regular benefits of Subversion properties.  The definitions are
      versioned.  If you need to change an externals definition, you
      can do so using the regular property modification subcommands.
      When you commit a change to the <literal>svn:externals</literal>
      property, Subversion will synchronize the checked-out items
      against the changed externals definition when you next run
      <userinput>svn update</userinput>.  The same thing will happen when
      others update their working copies and receive your changes to
      the externals definition.</para>

    <tip>
      <para>Because the <literal>svn:externals</literal> property has
        a multiline value, we strongly recommend that you use
        <command>svn propedit</command> instead of <command>svn
        propset</command>.</para>
    </tip>

    <para>Subversion releases prior to 1.5 honor an externals
      definition format that is a multiline table of subdirectories
      (relative to the versioned directory on which the property is
      set), optional revision flags, and fully qualified, absolute
      Subversion repository URLs.  An example of this might look as
      follows:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
third-party/sounds             http://svn.example.com/repos/sounds
third-party/skins -r148        http://svn.example.com/skinproj
third-party/skins/toolkit -r21 http://svn.example.com/skin-maker
</screen>
    </informalexample>

    <para>When someone checks out a working copy of the
      <filename>calc</filename> directory referred to in the previous
      example, Subversion also continues to check out the items found
      in its externals definition.</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/repos/calc
A    calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Checked out revision 148.

Fetching external item into calc/third-party/sounds
A    calc/third-party/sounds/ding.ogg
A    calc/third-party/sounds/dong.ogg
A    calc/third-party/sounds/clang.ogg
 
A    calc/third-party/sounds/bang.ogg
A    calc/third-party/sounds/twang.ogg
Checked out revision 14.

Fetching external item into calc/third-party/skins
 
</screen>
    </informalexample>

    <para>As of Subversion 1.5, though, a new format of the
      <literal>svn:externals</literal> property is supported.
      Externals definitions are still multiline, but the order and
      format of the various pieces of information have changed.  The
      new syntax more closely mimics the order of arguments you might
      pass to <command>svn checkout</command>: the optional revision
      flags come first, then the external Subversion repository URL,
      and finally the relative local subdirectory.  Notice, though,
      that this time we didn't say <quote>fully qualified, absolute
      Subversion repository URLs.</quote> That's because the new
      format supports relative URLs and URLs that carry peg revisions.
      The previous example of an externals definition might, in
      Subversion 1.5, look like the following:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
      http://svn.example.com/repos/sounds third-party/sounds
-r148 http://svn.example.com/skinproj third-party/skins
-r21  http://svn.example.com/skin-maker third-party/skins/toolkit
</screen>
    </informalexample>

    <para>Or, making use of the peg revision syntax (which we describe
      in detail in <xref linkend="svn.advanced.pegrevs" />), it might
      appear as:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
http://svn.example.com/repos/sounds third-party/sounds
http://svn.example.com/skinproj@148 third-party/skins
http://svn.example.com/skin-maker@21 third-party/skins/toolkit
</screen>
    </informalexample>

    <tip>
      <para>You should seriously consider using explicit revision
        numbers in all of your externals definitions.  Doing so means
        that you get to decide when to pull down a different snapshot
        of external information, and exactly which snapshot to pull.
        Besides avoiding the surprise of getting changes to
        third-party repositories that you might not have any control
        over, using explicit revision numbers also means that as you
        backdate your working copy to a previous revision, your
        externals definitions will also revert to the way they looked
        in that previous revision, which in turn means that the
        external working copies will be updated to match the way
        <emphasis>they</emphasis> looked back when your repository was
        at that previous revision.  For software projects, this could
        be the difference between a successful and a failed build of
        an older snapshot of your complex codebase.</para>
    </tip>

    <para>For most repositories, these three ways of formatting the
      externals definitions have the same ultimate effect.  They all
      bring the same benefits.  Unfortunately, they all bring the same
      annoyances, too.  Since the definitions shown use absolute URLs,
      moving or copying a directory to which they are attached will
      not affect what gets checked out as an external (though the
      relative local target subdirectory will, of course, move with the
      renamed directory).  This can be confusing even
      frustrating in certain situations.  For example, say you
      have a top-level directory named
      <filename>my-project</filename>, and you've created an externals
      definition on one of its subdirectories
      (<filename>my-project/some-dir</filename>) that tracks the
      latest revision of another of its subdirectories
      (<filename>my-project/external-dir</filename>).</para>

    <informalexample>
      <screen>
$ svn checkout http://svn.example.com/projects .
A    my-project
A    my-project/some-dir
A    my-project/external-dir
 
Fetching external item into 'my-project/some-dir/subdir'
Checked out external at revision 11.

Checked out revision 11.
$ svn propget svn:externals my-project/some-dir
subdir http://svn.example.com/projects/my-project/external-dir

$
</screen>
    </informalexample>

    <para>Now you use <command>svn move</command> to rename the
      <filename>my-project</filename> directory.  At this point, your
      externals definition will still refer to a path under the
      <filename>my-project</filename> directory, even though that
      directory no longer exists.</para>

    <informalexample>
      <screen>
$ svn move -q my-project renamed-project
$ svn commit -m "Rename my-project to renamed-project."
Deleting       my-project
Adding         renamed-project

Committed revision 12.
$ svn update
Updating '.':

svn: warning: W200000: Error handling externals definition for 'renamed-projec
t/some-dir/subdir':
svn: warning: W170000: URL 'http://svn.example.com/projects/my-project/externa
l-dir' at revision 12 doesn't exist
At revision 12.
svn: E205011: Failure occurred processing one or more externals definitions
$
</screen>
    </informalexample>

    <para>Also, absolute URLs can cause problems with repositories
      that are available via multiple URL schemes.  For example, if
      your Subversion server is configured to allow everyone to check
      out the repository over <literal>http://</literal> or
      <literal>https://</literal>, but only allow commits to come in
      via <literal>https://</literal>, you have an interesting problem
      on your hands.  If your externals definitions use the
      <literal>http://</literal> form of the repository URLs, you
      won't be able to commit anything from the working copies created
      by those externals.  On the other hand, if they use the
      <literal>https://</literal> form of the URLs, anyone who might
      be checking out via <literal>http://</literal> because his
      client doesn't support <literal>https://</literal> will be
      unable to fetch the external items.  Be aware, too, that if you
      need to reparent your working copy (using <command>svn
      relocate</command>), externals definitions will
      <emphasis>not</emphasis> also be reparented.</para>

   <para>Subversion 1.5 takes a huge step in relieving these
     frustrations.  As mentioned earlier, the URLs used in the new
     externals definition format can be relative, and Subversion
     provides syntax magic for specifying multiple flavors of URL
     relativity.</para>

    <variablelist id="svn.advanced.externals.urlmagic">
      <indexterm>
        <primary>caret syntax</primary>
      </indexterm>

      <varlistentry>
        <term><literal>../</literal></term> 
        <listitem><para>Relative to the URL of the directory on which
          the <literal>svn:externals</literal> property is
          set</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>^/</literal></term> 
        <listitem><para>Relative to the root of the repository in
          which the <literal>svn:externals</literal> property is
          versioned</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>//</literal></term> 
        <listitem><para>Relative to the scheme of the URL of the
          directory on which the <literal>svn:externals</literal>
          property is set</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>/</literal></term>
        <listitem><para>Relative to the root URL of the server on
          which the <literal>svn:externals</literal> property is
          versioned</para></listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>^/../<replaceable>REPO-NAME</replaceable></literal></term> 
        <listitem><para>Relative to a sibling repository beneath the
          same <literal>SVNParentPath</literal> location as the
          repository in which the <literal>svn:externals</literal> is
          defined.</para></listitem>
      </varlistentry>
    </variablelist>

    <para>So, looking a fourth time at our previous externals
      definition example, and making use of the new absolute URL
      syntax in various ways, we might now see:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals calc
^/sounds third-party/sounds
/skinproj@148 third-party/skins
//svn.example.com/skin-maker@21 third-party/skins/toolkit
$
</screen>
    </informalexample>

    <para>Subversion 1.6 brought two more improvements to externals
      definitions.  First, it added a quoting and escape mechanism to
      the syntax so that the path of the external working copy may
      contain whitespace.  This was previously problematic, of course,
      because whitespace is used to delimit the fields in an externals
      definition.  Now you need only wrap such a path specification in
      double-quote (<literal>"<!-- " --></literal>) characters or
      escape the problematic characters in the path with a backslash
      (<literal>\</literal>) character.  Of course, if you have spaces
      in the <emphasis>URL</emphasis> portion of the external
      definition, you should use the standard URI-encoding mechanism
      to represent those.</para>

    <informalexample>
      <screen>
$ svn propget svn:externals paint
http://svn.thirdparty.com/repos/My%20Project "My Project"
http://svn.thirdparty.com/repos/%22Quotes%20Too%22 \"Quotes\ Too\"
$
</screen>
    </informalexample>

    <para>
      <indexterm>
        <primary>externals</primary>
        <secondary>file</secondary>
      </indexterm>Subversion 1.6 also introduced support for external
      definitions for files.  <firstterm>File externals</firstterm>
      are configured just like externals for directories and appear as
      a versioned file in the working copy.</para>
      
    <para>For example, let's say you had the file
      <filename>/trunk/bikeshed/blue.html</filename> in your repository,
      and you wanted this file, as it appeared in revision 40,
      to appear in your working copy of <filename>/trunk/www/</filename>
      as <filename>green.html</filename>.</para>

    <para>The externals definition required to achieve this should
      look familiar by now:</para>

    <informalexample>
      <screen>
$ svn propget svn:externals www/
^/trunk/bikeshed/blue.html@40 green.html
$ svn update
Updating '.':

Fetching external item into 'www'
E    www/green.html
Updated external to revision 40.

Update to revision 103.
$ svn status
    X   www/green.html
$
</screen>
    </informalexample>

    <para>As you can see in the previous output, Subversion denotes file
      externals with the letter <literal>E</literal> when they are
      fetched into the working copy, and with the letter
      <literal>X</literal> when showing the working copy status.</para>

    <!-- ### TODO: Is Subversion using 'E' in the update output to
         ### mean "external"?  Or is this 'E' an "exists" notification,
         ### the side-effect of the file externals implementation? -->

    <warning>
      <para>While directory externals can place the external
        directory at any depth, and any missing intermediate
        directories will be created, file externals must be placed
        into a working copy that is already checked out.</para>
    </warning>

    <para>When examining the file external with
      <command>svn info</command>, you can see the URL and revision
      the external is coming from:</para>

    <informalexample>
      <screen>
$ svn info www/green.html 
Path: www/green.html
Name: green.html
Working Copy Root Path: /home/harry/projects/my-project
URL: http://svn.example.com/projects/my-project/trunk/bikeshed/blue.html
Repository Root: http://svn.example.com/projects/my-project
Repository UUID: b2a368dc-7564-11de-bb2b-113435390e17
Revision: 40
Node kind: file
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 40
Last Changed Date: 2009-07-20 20:38:20 +0100 (Mon, 20 Jul 2009)
Text Last Updated: 2009-07-20 23:22:36 +0100 (Mon, 20 Jul 2009)
Checksum: 01a58b04617b92492d99662c3837b33b
$
</screen>
    </informalexample>

    <para>Because file externals appear in the working copy as
      versioned files, they can be modified and even committed
      if they reference a file at the HEAD revision. The committed
      changes will then appear in the external as well as the file
      referenced by the external. However, in our example, we pinned
      the external to an older revision, so attempting to commit
      the external fails:</para>

    <informalexample>
      <screen>
$ svn status
M   X   www/green.html
$ svn commit -m "change the color" www/green.html
Sending        www/green.html
svn: E155011: Commit failed (details follow):
svn: E155011: File '/trunk/bikeshed/blue.html' is out of date
$
</screen>
    </informalexample>

    <para>Keep this in mind when defining file externals.
      If you need the external to refer to a certain revision
      of a file you will not be able to modify the external.
      If you want to be able to modify the external, you cannot
      specify a revision other than the <literal>HEAD</literal>
      revision, which is implied if no revision is specified.</para>

    <para>Unfortunately, the support which exists for externals definitions
      in Subversion remains less than ideal.  Both file and directory
      externals have shortcomings. For either type of external, the
      local subdirectory part of the definition cannot contain
      <literal>..</literal> parent directory indicators (such as
      <filename>../../skins/myskin</filename>).  File externals cannot
      refer to files from other repositories. A file external's URL
      must always be in the same repository as the URL that the file
      external will be inserted into. Also, file externals cannot be
      moved or deleted. The <literal>svn:externals</literal> property
      must be modified instead. However, file externals can be copied.</para>

    <para>Perhaps most disappointingly, the working copies created via the
      externals definition support are still disconnected from the primary
      working copy (on whose versioned directories the
      <literal>svn:externals</literal> property was actually set).
      And Subversion still truly operates only on nondisjoint working
      copies.  So, for example, if you want to commit changes that
      you've made in one or more of those external working copies, you
      must run <command>svn commit</command> explicitly on those
      working copies committing on the primary working copy will
      not recurse into any external ones.</para>

    <para>We've already mentioned some of the additional shortcomings
      of the old <literal>svn:externals</literal> format and how the
      newer Subversion 1.5 format improves upon it.  But be careful
      when making use of the new format that you don't inadvertently
      introduce new problems.  For example, while the latest clients
      will continue to recognize and support the original externals
      definition format, pre-1.5 clients will <emphasis>not</emphasis>
      be able to correctly parse the new format.  If you change all
      your externals definitions to the newer format, you effectively
      force everyone who uses those externals to upgrade their
      Subversion clients to a version that can parse them.  Also, be
      careful to avoid naively relocating
      the <literal>-r<replaceable>NNN</replaceable></literal> portion
      of the definition the older format uses that revision as a
      peg revision, but the newer format uses it as an operative
      revision (with a peg revision of <literal>HEAD</literal> unless
      otherwise specified; see <xref linkend="svn.advanced.pegrevs" />
      for a full explanation of the distinction here).</para>

    <warning>
      <para>External working copies are still completely
        self-sufficient working copies.  You can operate directly on
        them as you would any other working copy.  This can be a handy
        feature, allowing you to examine an external working copy
        independently of any primary working copy
        whose <literal>svn:externals</literal> property caused its
        instantiation.  Be careful, though, that you don't
        inadvertently modify your external working copy in subtle ways
        that cause problems.  For example, while an externals
        definition might specify that the external working copy should
        be held at a particular revision number, if you
        run <command>svn update</command> directly on the external
        working copy, Subversion will oblige, and now your external
        working copy is out of sync with its declaration in the
        primary working copy.  Using <command>svn switch</command> to
        directly switch the external working copy (or some portion
        thereof) to another URL could cause similar problems if the
        contents of the primary working copy are expecting particular
        contents in the external content.</para>
    </warning>

    <para>
      <indexterm>
        <primary>working copies</primary>
        <secondary>disjoint</secondary>
      </indexterm>Besides the <command>svn checkout</command>, <command>svn
      update</command>, <command>svn switch</command>, and
      <command>svn export</command> commands which actually manage the
      <firstterm>disjoint</firstterm> (or disconnected) subdirectories
      into which externals are checked out, the <command>svn
      status</command> command also recognizes externals definitions.
      It displays a status code of <literal>X</literal> for the
      disjoint external subdirectories, and then recurses into those
      subdirectories to display the status of the external items
      themselves.  You can pass the
      <option>--ignore-externals</option> option to any of these
      subcommands to disable externals definition processing.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.changelists">
    <title>Changelists</title>

    <para>It is commonplace for a developer to find himself working at
      any given time on multiple different, distinct changes to a
      particular bit of source code.  This isn't necessarily due to
      poor planning or some form of digital masochism.  A software
      engineer often spots bugs in his peripheral vision while working
      on some nearby chunk of source code.  Or perhaps he's halfway
      through some large change when he realizes the solution he's
      working on is best committed as several smaller logical units.
      Often, these logical units aren't nicely contained in some
      module, safely separated from other changes.  The units might
      overlap, modifying different files in the same module, or even
      modifying different lines in the same file.</para>

    <para>Developers can employ various work methodologies
      to keep these logical changes organized.  Some use
      separate working copies of the same repository to hold each
      individual change in progress.  Others might choose to create
      short-lived feature branches in the repository and use a single
      working copy that is constantly switched to point to one such
      branch or another.  Still others use <command>diff</command> and
      <command>patch</command> tools to back up and restore uncommitted
      changes to and from patch files associated with each change.
      Each of these methods has its pros and cons, and to a large
      degree, the details of the changes being made heavily influence
      the methodology used to distinguish them.</para>

    <para>
      <indexterm>
        <primary>changelists</primary>
      </indexterm>Subversion provides a <firstterm>changelists</firstterm>
      feature that adds yet another method to the mix.  Changelists
      are basically arbitrary labels (currently at most one per file)
      applied to working copy files for the express purpose of
      associating multiple files together.  Users of many of Google's
      software offerings are familiar with this concept already.  For
      example, <ulink url="http://mail.google.com/">Gmail</ulink>
      doesn't provide the traditional folders-based email organization
      mechanism.  In Gmail, you apply arbitrary labels to emails, and
      multiple emails can be said to be part of the same group if they
      happen to share a particular label.  Viewing only a group of
      similarly labeled emails then becomes a simple user interface
      trick.  Many other Web 2.0 sites have similar
      mechanisms consider the <quote>tags</quote> used by sites
      such as <ulink url="http://www.youtube.com/">YouTube</ulink> and
      <ulink url="http://www.flickr.com/">Flickr</ulink>,
      <quote>categories</quote> applied to blog posts, and so on.
      Folks understand today that organization of data is critical,
      but that how that data is organized needs to be a flexible
      concept.  The old files-and-folders paradigm is too rigid for
      some applications.</para>

    <para>Subversion's changelist support allows you to create
      changelists by applying labels to files you want to be
      associated with that changelist, remove those labels, and limit
      the scope of the files on which its subcommands operate to only
      those bearing a particular label.  In this section, we'll look
      in detail at how to do these things.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.creating">
      <title>Creating and Modifying Changelists</title>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>        
        <indexterm>
          <primary>changelists</primary>
          <secondary>creating</secondary>
        </indexterm>You can create, modify, and delete changelists using the
        <command>svn changelist</command> command.  More accurately,
        you use this command to set or unset the changelist
        association of a particular working copy file.  A changelist
        is effectively created the first time you label a file with
        that changelist; it is deleted when you remove that label from
        the last file that had it.  Let's examine a usage scenario
        that demonstrates these concepts.</para>

      <para>Harry is fixing some bugs in the calculator application's
        mathematics logic.  His work leads him to change a couple of
        files:</para>

      <informalexample>
        <screen>
$ svn status
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <para>While testing his bug fix, Harry notices that his changes
        bring to light a tangentially related bug in the user
        interface logic found in <filename>button.c</filename>.  Harry
        decides that he'll go ahead and fix that bug, too, as a
        separate commit from his math fixes.  Now, in a small working
        copy with only a handful of files and few logical changes,
        Harry can probably keep his two logical change groupings
        mentally organized without any problem.  But today he's going
        to use Subversion's changelists feature as a special favor to
        the authors of this book.</para>

      <para>Harry first creates a changelist and associates with it
        the two files he's already changed.  He does this by using the
        <command>svn changelist</command> command to assign the same
        arbitrary changelist name to those files:</para>

      <informalexample>
        <screen>
$ svn changelist math-fixes integer.c mathops.c
A [math-fixes] integer.c
A [math-fixes] mathops.c
$ svn status

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <para>As you can see, the output of <command>svn
        status</command> reflects this new grouping.</para>

      <para>Harry now sets off to fix the secondary UI problem.  Since
        he knows which file he'll be changing, he assigns that path to
        a changelist, too.  Unfortunately, Harry carelessly assigns this
        third file to the same changelist as the previous two files:</para>

      <informalexample>
        <screen>
$ svn changelist math-fixes button.c
A [math-fixes] button.c
$ svn status

--- Changelist 'math-fixes':
        button.c
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>        
        <indexterm>
          <primary>changelists</primary>
          <secondary>removing</secondary>
        </indexterm>Fortunately, Harry catches his mistake.  At this
        point, he has two options.  He can remove the changelist
        association from <filename>button.c</filename>, and then
        assign a different changelist name:</para>

      <informalexample>
        <screen>
$ svn changelist --remove button.c
D [math-fixes] button.c
$ svn changelist ui-fix button.c
A [ui-fix] button.c
$
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>changelist</tertiary>
        </indexterm>        
        <indexterm>
          <primary>changelists</primary>
          <secondary>reassigning</secondary>
        </indexterm>Or, he can skip the removal and just assign a new
        changelist name.  In this case, Subversion will first warn
        Harry that <filename>button.c</filename> is being removed from
        the first changelist:</para>

      <informalexample>
        <screen>
$ svn changelist ui-fix button.c
D [math-fixes] button.c
A [ui-fix] button.c
$ svn status

--- Changelist 'ui-fix':
        button.c

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <para>Harry now has two distinct changelists present in his
        working copy, and <command>svn status</command> will group its
        output according to these changelist determinations.  Notice
        that even though Harry hasn't yet modified
        <filename>button.c</filename>, it still shows up in the output
        of <command>svn status</command> as interesting because it has
        a changelist assignment.  Changelists can be added to and
        removed from files at any time, regardless of whether they
        contain local modifications.</para>

      <para>Harry now fixes the user interface problem in
        <filename>button.c</filename>.</para>

      <informalexample>
        <screen>
$ svn status

--- Changelist 'ui-fix':
M       button.c

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.asfilters">
      <title>Changelists As Operation Filters</title>

      <para>The visual grouping that Harry sees in the output of
        <command>svn status</command> as shown in our previous section
        is nice, but not entirely useful.  The
        <command>status</command> command is but one of many
        operations that he might wish to perform on his working copy.
        Fortunately, many of Subversion's other operations understand
        how to operate on changelists via the use of the
        <option>--changelist</option> option.</para>

      <para>When provided with a <option>--changelist</option> option,
        Subversion commands will limit the scope of their operation to
        only those files to which a particular changelist name is
        assigned.  If Harry now wants to see the actual changes he's
        made to the files in his <literal>math-fixes</literal>
        changelist, he <emphasis>could</emphasis> explicitly list only
        the files that make up that changelist on the <command>svn
        diff</command> command line.</para>

      <informalexample>
        <screen>
$ svn diff integer.c mathops.c
Index: integer.c
===================================================================
--- integer.c	(revision 1157)
+++ integer.c	(working copy)
 
Index: mathops.c
===================================================================
--- mathops.c	(revision 1157)
+++ mathops.c	(working copy)
 
$
</screen>
      </informalexample>

      <para>That works okay for a few files, but what if Harry's
        change touched 20 or 30 files?  That would be an annoyingly
        long list of explicitly named files.  Now that he's using
        changelists, though, Harry can avoid explicitly listing the
        set of files in his changelist from now on, and instead
        provide just the changelist name:</para>

      <informalexample>
        <screen>
$ svn diff --changelist math-fixes
Index: integer.c
===================================================================
--- integer.c	(revision 1157)
+++ integer.c	(working copy)
 
Index: mathops.c
===================================================================
--- mathops.c	(revision 1157)
+++ mathops.c	(working copy)
 
$
</screen>
      </informalexample>

      <para>And when it's time to commit, Harry can again use the
        <option>--changelist</option> option to limit the scope of the
        commit to files in a certain changelist.  He might commit his
        user interface fix by doing the following:</para>

      <informalexample>
        <screen>
$ svn commit -m "Fix a UI bug found while working on math logic." \
             --changelist ui-fix
Sending        button.c
Transmitting file data .
Committed revision 1158.
$
</screen>
      </informalexample>

      <para>In fact, the <command>svn commit</command> command
        provides a second changelists-related option:
        <option>--keep-changelists</option>.  Normally, changelist
        assignments are removed from files after they are committed.
        But if <option>--keep-changelists</option> is provided,
        Subversion will leave the changelist assignment on the
        committed (and now unmodified) files.  In any case, committing
        files assigned to one changelist leaves other changelists
        undisturbed.</para>

      <informalexample>
        <screen>
$ svn status

--- Changelist 'math-fixes':
M       integer.c
M       mathops.c
$
</screen>
      </informalexample>

      <note>
        <para>The <option>--changelist</option> option acts only as a
          filter for Subversion command targets, and will not add
          targets to an operation.  For example, on a commit operation
          specified as <userinput>svn commit /path/to/dir</userinput>, the
          target is the directory <filename>/path/to/dir</filename>
          and its children (to infinite depth).  If you then add a
          changelist specifier to that command, only those files in
          and under <filename>/path/to/dir</filename> that are
          assigned that changelist name will be considered as targets
          of the commit the commit will not include files
          located elsewhere (such as in
          <filename>/path/to/another-dir</filename>), regardless of
          their changelist assignment, even if they are part of the
          same working copy as the operation's target(s).</para>
      </note>

      <para>Even the <command>svn changelist</command> command accepts
        the <option>--changelist</option> option.  This allows you to
        quickly and easily rename or remove a changelist:</para>

      <informalexample>
        <screen>
$ svn changelist math-bugs --changelist math-fixes --depth infinity .
D [math-fixes] integer.c
A [math-bugs] integer.c
D [math-fixes] mathops.c
A [math-bugs] mathops.c
$ svn changelist --remove --changelist math-bugs --depth infinity .
D [math-bugs] integer.c
D [math-bugs] mathops.c
$
</screen>
      </informalexample>

      <para>Finally, you can specify multiple instances of the
        <option>--changelist</option> option on a single command
        line.  Doing so limits the operation you are performing to
        files found in any of the specified changesets.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.changelists.limitations">
      <title>Changelist Limitations</title>

      <para>Subversion's changelist feature is a handy tool for
        grouping working copy files, but it does have a few limitations.
        Changelists are artifacts of a particular working copy, which
        means that changelist assignments cannot be propagated to the
        repository or otherwise shared with other users.  Changelists
        can be assigned only to files Subversion doesn't
        currently support the use of changelists with directories.
        Finally, you can have at most one changelist assignment on a
        given working copy file.  Here is where the blog post category
        and photo service tag analogies break down if you find
        yourself needing to assign a file to multiple changelists,
        you're out of luck.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.netmodel">
    <title>Network Model</title>

    <para>At some point, you're going to need to understand how your
      Subversion client communicates with its server.  Subversion's
      networking layer is abstracted, meaning that Subversion clients
      exhibit the same general behaviors no matter what sort of server
      they are operating against.  Whether speaking the HTTP protocol
      (<literal>http://</literal>) with the Apache HTTP Server or
      speaking the custom Subversion protocol
      (<literal>svn://</literal>) with <command>svnserve</command>,
      the basic network model is the same.  In this section, we'll
      explain the basics of that network model, including how
      Subversion manages authentication and authorization
      matters.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.reqresp">
      <title>Requests and Responses</title>

      <para>The Subversion client spends most of its time managing
        working copies.  When it needs information from a remote
        repository, however, it makes a network request, and the
        server responds with an appropriate answer.  The details of
        the network protocol are hidden from the user the client
        attempts to access a URL, and depending on the URL scheme, a
        particular protocol is used to contact the server (see <xref
        linkend="svn.advanced.reposurls"/>).</para>

      <tip>
        <para>Run <userinput>svn --version</userinput> to see which
          URL schemes and protocols the client knows how to use.</para>
      </tip>

      <para>
        <indexterm>
          <primary>authentication</primary>
          <secondary>credentials</secondary>
        </indexterm>When the server process receives a client request, it
        often demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <firstterm>credentials</firstterm> back
        to the server.  Once authentication is complete, the server
        responds with the original information that the client asked for.
        Notice that this system is different from systems such as CVS,
        where the client preemptively offers credentials (<quote>logs
        in</quote>) to the server before ever making a request.  In
        Subversion, the server <quote>pulls</quote> credentials by
        challenging the client at the appropriate moment, rather than
        the client <quote>pushing</quote> them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        the server will never issue an authentication challenge
        when a client attempts to <command>svn checkout</command>.</para>

      <para>If the particular network requests issued by the client
        result in a new revision being created in the repository
        (e.g., <command>svn commit</command>), Subversion uses the
        authenticated username associated with those requests as the
        author of the revision.  That is, the authenticated user's
        name is stored as the value of the
        <literal>svn:author</literal> property on the new revision
        (see <xref linkend="svn.advanced.props.ref"/>).  If the
        client was not authenticated (i.e., if the server never issued
        an authentication challenge), the revision's
        <literal>svn:author</literal> property is empty.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.netmodel.creds">
      <title>Client Credentials</title>

      <para>Many Subversion servers are configured to require
        authentication.  Sometimes anonymous read operations are
        allowed, while write operations must be authenticated.  In
        other cases, reads and writes alike require authentication.
        Subversion's different server options understand different
        authentication protocols, but from the user's point of view,
        authentication typically boils down to usernames and
        passwords.  Subversion clients offer several different ways to
        retrieve and store a user's authentication credentials, from
        interactive prompting for usernames and passwords to encrypted
        and non-encrypted on-disk data caches.</para>

      <para>The security-conscious reader will suspect immediately
        that there is reason for concern here.  <quote>Caching
        passwords on disk?  That's terrible!  You should never do
        that!</quote>  Don't worry it's not as bad as it sounds.
        The following sections discuss the various types of credential
        caches that Subversion uses, when it uses them, and how to
        disable that functionality in whole or in part.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.netmodel.credcache">
        <title>Caching credentials</title>

        <para>Subversion offers a remedy for the annoyance caused when
          users are forced to type their usernames and passwords over
          and over again.  By default, whenever the command-line
          client successfully responds to a server's authentication
          challenge, credentials are cached on disk and keyed on a
          combination of the server's hostname, port, and
          authentication realm.  This cache will then be automatically
          consulted in the future, avoiding the need for the user to
          re-type his or her authentication credentials.  If seemingly
          suitable credentials are not present in the cache, or if the
          cached credentials ultimately fail to authenticate, the
          client will, by default, fall back to prompting the user for
          the necessary information.</para>

        <para>The Subversion developers recognize that on-disk caches
          of authentication credentials can be a security risk.  To
          offset this, Subversion works with available mechanisms
          provided by the operating system and environment to try to
          minimize the risk of leaking this information.</para>

        <itemizedlist>

          <listitem>
            <para>On Windows, the Subversion client stores passwords
              in the <filename>%APPDATA%/Subversion/auth/</filename>
              directory.  On Windows 2000 and later, the standard
              Windows cryptography services are used to encrypt the
              password on disk.  Because the encryption key is managed
              by Windows and is tied to the user's own login
              credentials, only the user can decrypt the cached
              password.  (Note that if the user's Windows account
              password is reset by an administrator, all of the cached
              passwords become undecipherable.  The Subversion client
              will behave as though they don't exist, prompting for
              passwords when required.)</para>
          </listitem>

          <listitem>
            <para>Similarly, on Mac OS X, the Subversion client stores
              all repository passwords in the login keyring (managed
              by the Keychain service), which is protected by the
              user's account password.  User preference settings can
              impose additional policies, such as requiring that the
              user's account password be entered each time the
              Subversion password is used.</para>
          </listitem>

          <listitem>
            <para>For other Unix-like operating systems, no single
              standard <quote>keychain</quote> service exists.
              However, the Subversion client knows how to store
              passwords securely using the <quote>GNOME Keyring</quote>
              and <quote>KDE Wallet</quote> services.  Also, before
              storing unencrypted passwords in the
              <filename>~/.subversion/auth/</filename> caching area,
              the Subversion client will ask the user for permission
              to do so.  Note that the <filename>auth/</filename>
              caching area is still permission-protected so that only
              the user (owner) can read data from it, not the world at
              large.  The operating system's own file permissions protect
              the passwords from other non-administrative users on the
              same system, provided they have no direct physical access
              to the storage media of the home directory, or backups
              thereof.</para>
          </listitem>

        </itemizedlist>

        <para>Of course, for the truly paranoid, none of these
          mechanisms meets the test of perfection.  So for those folks
          willing to sacrifice convenience for the ultimate in security,
          Subversion provides various ways of disabling its credentials
          caching system altogether.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.disabling-password-caching">
        <title>Disabling password caching</title>

        <para>When you perform a Subversion operation that requires
          you to authenticate, by default Subversion tries to cache
          your authentication credentials on disk in encrypted form.
          On some systems, Subversion may be unable to encrypt your
          authentication data.  In those situations, Subversion will
          ask whether you want to cache your credentials to disk in
          plaintext:</para>
  
        <informalexample>
          <screen>
$ svn checkout https://host.example.com:443/svn/private-repo
-----------------------------------------------------------------------
ATTENTION!  Your password for authentication realm:

   &lt;https://host.example.com:443&gt; Subversion Repository

can only be stored to disk unencrypted!  You are advised to configure
your system so that Subversion can store passwords encrypted, if
possible.  See the documentation for details.

You can avoid future appearances of this warning by setting the value
of the 'store-plaintext-passwords' option to either 'yes' or 'no' in
'/tmp/servers'.
-----------------------------------------------------------------------
Store password unencrypted (yes/no)? 
</screen>
        </informalexample>

        <para>If you want the convenience of not having to continually
          reenter your password for future operations, you can
          answer <literal>yes</literal> to this prompt.  If you're
          concerned about caching your Subversion passwords in
          plaintext and do not want to be asked about it again and
          again, you can disable caching of plaintext passwords either
          permanently, or on a server-by-server basis.</para>

        <warning>
          <para>When considering how to use Subversion's password
            caching system, you'll want to consult any governing
            policies that are in place for your client
            computer many companies have strict rules about the
            ways that their employees' authentication credentials
            should be stored.</para>
        </warning>

        <para>To permanently disable caching of passwords in
          plaintext, add the line <literal>store-plaintext-passwords =
          no</literal> to the <literal>[global]</literal> section in
          the <filename>servers</filename> configuration file on the
          local machine.  To disable plaintext password caching for a
          particular server, use the same setting in the appropriate
          group section in the <filename>servers</filename>
          configuration file.  (See
          <xref linkend="svn.advanced.confarea.opts"/> in
          <xref linkend="svn.customization"/> for details.)</para>

        <para>To disable password caching entirely for any single
          Subversion command-line operation, pass
          the <option>--no-auth-cache</option> option to that command
          line.  To permanently disable caching entirely, add the
          line <literal>store-passwords = no</literal> to your local
          machine's Subversion configuration file.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.authn-cache-purge">
        <title>Removing cached credentials</title>
     
        <para>Sometimes users will want to remove specific credentials
          from the disk cache.  To do this, you need to navigate into
          the <filename>auth/</filename> area and manually delete the
          appropriate cache file.  Credentials are cached in individual
          files;  if you look inside each file, you will see keys and
          values.  The <literal>svn:realmstring</literal> key describes
          the particular server realm that the file is associated
          with:</para>

        <informalexample>
          <screen>
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</screen>
        </informalexample>

        <para>Once you have located the proper cache file, just delete
          it.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.different-user">
        <title>Command-line authentication</title>

        <para>All Subversion command-line operations accept
          the <option>--username</option>
          and <option>--password</option> options, which allow you to
          specify your username and password, respectively, so that
          Subversion isn't forced to prompt you for that information.
          This is especially handy if you need to invoke Subversion
          from a script and cannot rely on Subversion being able to
          locate valid cached credentials for you.  These options are
          also helpful when Subversion has already cached
          authentication credentials for you, but you know they aren't
          the ones you want it to use.  Perhaps several system users
          share a login to the system, but each have distinct
          Subversion identities.  You can omit
          the <option>--password</option> option from this pair if
          you wish Subversion to use only the provided username, but
          still prompt you for that username's password.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.tour.initial.authn-wrapup">
        <title>Authentication wrap-up</title>

        <para>One last word about <command>svn</command>'s
          authentication behavior, specifically regarding the
          <option>--username</option> and <option>--password</option>
          options.  Many client subcommands accept these options, but it
          is important to understand that using these options does
          <emphasis>not</emphasis> automatically send credentials to the
          server.  As discussed earlier, the server <quote>pulls</quote>
          credentials from the client when it deems necessary; the
          client cannot <quote>push</quote> them at will.  If a username
          and/or password are passed as options, they will be
          presented to the server only if the server requests them.  These
          options are typically used to authenticate as a different user
          than Subversion would have chosen by default (such as your
          system login name) or when trying to avoid interactive
          prompting (such as when calling <command>svn</command> from a
          script).</para>

        <note>
          <para>A common mistake is to misconfigure a server so
            that it never issues an authentication challenge.  When
            users pass <option>--username</option> and
            <option>--password</option> options to the client, they're
            surprised to see that they're never used; that is, new
            revisions still appear to have been committed
            anonymously!</para>
        </note>

        <para>Here is a final summary that describes how a Subversion
          client behaves when it receives an authentication
          challenge.</para>

        <orderedlist>
          <listitem>
            <para>First, the client checks whether the user specified
              any credentials as command-line options
              (<option>--username</option> and/or
              <option>--password</option>).  If so, the client will try
              to use those credentials to authenticate against the
              server.</para>
          </listitem>
          <listitem>
            <para>If no command-line credentials were provided, or the
              provided ones were invalid, the client looks up the server's
              hostname, port, and realm in the runtime configuration's
              <filename>auth/</filename> area, to see whether appropriate 
              credentials are cached there.  If so, it attempts to use
              those credentials to authenticate.</para>
          </listitem>
          <listitem>
            <para>Finally, if the previous mechanisms failed to
              successfully authenticate the user against the server, the
              client resorts to interactively prompting the user for
              valid credentials (unless instructed not to do so via the
              <option>--non-interactive</option> option or its
              client-specific equivalents).</para>
          </listitem>
        </orderedlist>

        <para>If the client successfully authenticates by any of these
          methods, it will attempt to cache the credentials on disk
          (unless the user has disabled this behavior, as mentioned
          earlier).</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.working-without-a-wc">
    <title>Working Without a Working Copy</title>

    <para>As we described in <xref linkend="svn.basic.in-action.wc"
      />, the Subversion working copy is a sort of staging area where
      a user can privately make changes to his or her versioned data
      and then when those changes are complete and ready for
      sharing with others commit them to the repository.  It
      should come as no surprise, then, that most of the interaction
      you will have with Subversion will be in the form of asking your
      Subversion client to do <emphasis>something</emphasis> to one or
      more items in a local working copy.  Even for those operations
      which don't manipulate the working copy data itself (such
      as <command>svn log</command>), it's often just easier to use a
      working copy file or directory as a convenient target for that
      operation.</para>

    <para>Clearly, the typical approach to making changes to
      your versioned data is via commits from a Subversion working
      copy.  Fortunately, it's not the only way.  Users of Subversion
      who need to make relatively simple changes to their versioned
      data can do so without the overhead of checking out a working
      copy.  We'll cover some of those supported operations in this
      section.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.working-without-a-wc.svn">
      <title>Remote command-line client operations</title>

      <para>The Subversion command-line client supports a number of
        operations which can be performed directly against repository
        URLs in order to make simple changes without a working copy.
        Some of these are described elsewhere in this book, but we
        provide an exhaustive list of them here for your
        convenience.</para>

      <para>Perhaps the most obvious remote commit-like operation is
        the <command>svn import</command> command.  We describe that
        command in <xref linkend="svn.tour.importing.import" /> as
        part of explaining how you can easily get a whole tree of
        unversioned information into your Subversion repository so you
        can start doing version-controlled operations on it.</para>

      <para>The <command>svn mkdir</command> and <command>svn
        delete</command> commands, when used with URL targets, are
        also remote commit-type operations.  These allow the user to
        create one or more new versioned directories or remove
        (recursively) one or more versioned files or directories,
        respectively, without the use of a working copy.  Each time
        you issue one of these commands, the client communicates with
        the server in a way that's similar to how it would describe
        the commit of a directory added or of an item removed from the
        working copy.  If there's no problem or conflict detected with
        the requested operation, the server commits the additions or
        removals in a single new revision.</para>

      <para>You can use <command>svn copy</command> or <command>svn
        move</command> with two URLs a copy/move source and a
        destination to commit a copies and moves of files and
        directories directly in the repository.  These operations tend
        to be some of the most expensive ones when performed within a
        working copy, but they complete in constant time when
        performed remotely using repository URLs.  In fact,
        the <command>svn copy</command> remote operation is commonly
        used to create branches in Subversion, as we discuss later in
        <xref linkend="svn.branchmerge.using.create" />.</para>

      <para>As with the regular <command>svn commit</command> command,
        you can supply a log message with any of these commands we've
        discussed so far to describe the changes you're making.  Use
        the <option>--file (-F)</option> or <option>--message
        (-m)</option> option, or otherwise allow the client to prompt
        you for the log message.</para>

      <para>Finally, there are a number of operations related to
        unversioned revision properties which can be performed
        directly against the repository.  In fact, revision properties
        are somewhat unique in this context, as they aren't stored in
        the working copy and therefore <emphasis>must</emphasis> be
        modified without working copy interaction.  See
        <xref linkend="svn.advanced.props" /> for a more detailed
        description of how to manage properties in Subversion.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.working-without-a-wc.svnmucc">
      <title>Using svnmucc</title>

      <para>One shortcoming of the remote commit operation support
        offered in the command-line client is that you are essentially
        limited to one operation or, really, one type of
        operation per commit.  For example, it's perfectly
        natural and supported to, say, use <command>svn
        delete</command> followed by <command>svn mkdir</command>
        within a working copy to replace an existing versioned
        directory with a brand new one.  When you commit the results
        of those operations, a single new revision is created in the
        repository, and that revision carries the full replacement of
        your directory.  You can't really do the same thing as remote
        operations using the command-line client while still
        preserving the it-happened-in-a-single-revision-ness of the
        change <command>svn
        delete <replaceable>URL</replaceable></command> would create a
        new revision that removed the directory; <command>svn
        mkdir <replaceable>URL</replaceable></command> would generate
        a second revision for the directory's re-creation.</para>

      <para>Fortunately, Subversion provides a separate tool which
        exists solely to allow users to string together a set of
        remote operations and commit them as one atomic change.  That
        tool is the <command>svnmucc</command> tool the
        Subversion Multiple URL Command Client:</para>

      <informalexample>
        <screen>
$ svnmucc --help
Subversion multiple URL command client
usage: svnmucc ACTION...

  Perform one or more Subversion repository URL-based ACTIONs, committing
  the result as a (single) new revision.

Actions:
  cp REV URL1 URL2       : copy URL1@REV to URL2
  mkdir URL              : create new directory URL
  mv URL1 URL2           : move URL1 to URL2
  rm URL                 : delete URL
  put SRC-FILE URL       : add or modify file URL with contents copied from
                           SRC-FILE (use "-" to read from standard input)
  propset NAME VAL URL   : set property NAME on URL to value VAL
  propsetf NAME VAL URL  : set property NAME on URL to value from file VAL
  propdel NAME URL       : delete property NAME from URL
 
</screen>
      </informalexample>

      <para><command>svnmucc</command> has been a part of the Subversion
        project's source code tree for many years
        (as <command>mucc</command> for most of that time), but it was
        only in Subversion 1.8 that it become a fully supported member
        of the Subversion command-line tool suite.</para>

      <para>The <command>svnmucc</command> tool can perform any
        transformation on your versioned data that <command>svn</command>
        itself can.  But unlike <command>svn</command>, the functionality
        that <command>svnmucc</command> offers isn't broken up into
        subcommands.  Rather, you provide a list of actions and
        operands in a single command line (or from a file stream, via
        the <option>--extra-args (-X)</option> option).  Some of the
        actions supported by <command>svnmucc</command> mimic those of
        the command-line client.  You'll notice in the previous
        command output actions such as <literal>cp</literal>,
        <literal>mkdir</literal>, <literal>mv</literal>,
        and <literal>rm</literal>, all of which are very similar to
        the commands we mentioned in
        <xref linkend="svn.advanced.working-without-a-wc.svn" />.  But
        remember, the key difference here is that you can use any
        number of these actions together in a single command
        invocation, resulting in a single committed revision in the
        repository.</para>

      <para>Let's take our previous example of trying to simply
        replace a remote directory.  Using <command>svnmucc</command>,
        you would accomplish this as follows:</para>

      <informalexample>
        <screen>
$ svnmucc rm http://svn.example.com/projects/sandbox \
          mkdir http://svn.example.com/projects/sandbox \
          -m "Replace my old sandbox with a fresh new one."
r22 committed by harry at 2013-01-15T21:45:26.442865Z
$ 
</screen>
      </informalexample>

      <para>As you can see, <command>svnmucc</command> accomplished in
        a single revision what <command>svn</command> without
        the benefit of a working copy required two revisions to
        complete.</para>

      <warning>
        <para>Another difference between <command>svnmucc</command>
          and <command>svn</command> is that the former currently will
          not prompt you for a commit log message if you fail to
          supply one via the command line.  Rather, it will use a
          stock (that is, relatively valueless) log message.</para>
      </warning>

      <para>The <command>svnmucc</command> tool is not limited to
        merely remixing actions that <command>svn</command> itself can
        perform.  It introduces some additional functionality not
        found in the command-line client.  For example, you can use
        the <command>put</command> action to add or modify a file in
        the repository, copying the file's intended new contents from
        either a file on your local machine or from data piped in via
        standard input.  The tool also offers <command>propset</command>,
        <command>propsetf</command>, and <command>propdel</command>
        actions, useful for setting properties on versioned files and
        directories (explicitly, or by copying the property's value
        from a local file) and for deleting properties on the same.
        Those actions are unsupported in the command-line client at
        this time.</para>

      <para>At this point, though, it seems prudent to discuss the
        difference between what <emphasis>can</emphasis> be done
        with <command>svnmucc</command> and what
        <emphasis>should</emphasis> be done.  A pair of notable quotes
        comes to mind:</para>

      <blockquote>
        <attribution>Jesus</attribution>
        <para><quote>To whom much has been given, much will be
          expected.</quote></para>
      </blockquote>

      <blockquote>
        <attribution>"Spiderman" Peter Parker's Uncle Ben</attribution>
        <para><quote>With great power comes great
          responsibility.</quote></para>
      </blockquote>

      <para>Inherent in working-copy-less modifications is the loss of
        the very conflict detection safeguards which make the use of a
        working copy so valuable.  When using <command>svn</command>
        in the typical way, changes are committed to the server
        against a specific base version of a file or directory so that
        you don't inadvertently overwrite contemporary changes made to
        the same item by another team member.  The server knows what
        version of the file you had before you changed it, and it
        knows if other folks have changed that same file since that
        revision was created.  That's all the information the server
        needs to deny your commit when it would clobber someone else's
        change, forcing you to integrate their change into your
        working copy and reconsider your own change.  Because there is
        no working copy in the mix here, <command>svnmucc</command>
        really gives you the power to bypass those safeguards and to
        act as if the current state of the repository is precisely the
        base state against which you are working.  But hopefully it is
        obvious to you that this is not a power you should cavalierly
        wield.</para>

      <para>Fortunately, <command>svnmucc</command> allows you to be
        more conservative in the way you use the tool.  In order to
        provide a safety mechanism similar to what is offered by the
        use of a working copy, <command>svnmucc</command> offers
        a <option>--revision (-r)</option> option.  With this option,
        you can manually specify a base revision for the changes you
        are attempting to commit.  The base revision you choose
        is ideally the most recent revision in your repository of
        which you can reasonably claim knowledge.</para>
      
      <warning>
        <para>Users are strongly encouraged to use, and to use
          correctly, the <option>--revision (-r)</option> option
          to <command>svnmucc</command>.</para>
      </warning>

      <para>Proper use of the <command>svnmucc put</command> action
        best demonstrates how this <option>--revision (-r)</option>
        option should be used.  Say Harry wishes to change the
        contents of a versioned <filename>README</filename> file
        without bothering with a full checkout of a working copy.
        (We'll assume that there is no other value in using a working
        copy for this operation, such as the presence of scripts Harry
        should run in advance of his commit to verify that it's a
        reasonable one.)  The first decision he has to make is which
        revision of the file he wants to work with.  Typically, users
        wish to modify the most recent version of a file.  So Harry
        queries the revision in which the file was last modified, and
        then uses that revision to fetch the contents of the file into
        a temporary local file:</para>

      <informalexample>
        <screen>
$ svn info http://svn.example.com/projects/sandbox/README
Path: README
URL: http://svn.example.com/projects/sandbox/README
Relative URL: ^/sandbox/README
Repository Root: http://svn.example.com/projects
Repository UUID: 13f79535-47bb-0310-9956-ffa450edef68
Revision: 22
Node Kind: file
Last Changed Author: sally
Last Changed Rev: 14
Last Changed Date: 2012-09-02 10:34:09 -0400 (Sun, 02 Sep 2012)

$ svn cat -r 14 http://svn.example.com/projects/sandbox/README \
      > README.tmpfile
$
</screen>
      </informalexample>

      <para>Harry now has a copy of the <filename>README</filename>
        file as it looked when it it was last modified.  He makes the
        edits he wishes to make to this copy of the file.  Naturally,
        when he's finished, he wishes to then commit those changes to
        the repository.</para>

      <para>Now, if Harry naively uses <userinput>svnmucc put
         </userinput> at this point to replace the contents of
        <filename>README</filename> in the repository with his locally
        modified contents, he has just abused the power
        that <command>svnmucc</command> affords.  What if, just
        microseconds prior to his commit, Sally had also modified
        the <filename>README</filename> file?  As with the
        <command>svn</command> program, <command>svnmucc</command>
        won't attempt some sort of server-side content merge in order
        to preserve both users' changes.  Rather,
        <command>svnmucc</command> will happily replace the current
        latest version of the file with the contents specified.  Harry
        will be oblivious.  Sally will be livid.</para>

      <informalexample>
        <screen>
$ svnmucc put README.tmpfile \
          http://svn.example.com/projects/sandbox/README \
          -m "Tweak the README file."
r24 committed by harry at 2013-01-21T16:21:23.100133Z
$
Message from sally@shell.example.com on pts/2 at 16:26 ...
We need to talk.  Now.
EOF
</screen>
      </informalexample>

      <para>Harry should instead recall the revision he originally
        used as the revision on which to base his changes, supplying
        that revision to <command>svnmucc</command> via
        the <option>--revision (-r)</option> option, and thus giving
        the server the opportunity to bounce his commit if, by his own
        (perhaps ignorant) admission, he's attempting to modify an
        out-of-date item:</para>

      <informalexample>
        <screen>
$ svnmucc -r 14 put README.tmpfile \
          http://svn.example.com/projects/sandbox/README \
          -m "Tweak the README file."
svnmucc: E170004: Item '/sandbox/README' is out of date
$
</screen>
      </informalexample>

      <para>Like other <command>svnmucc</command> options,
        the <option>--revision (-r)</option> option operates at a
        scope global to the whole command every action specified
        in that command.  This enables you to have the same sort of
        safeguards you would have if you had checked out a working
        copy of your entire repository (and thus had a working copy
        entirely at a single uniform revision), made changes to that
        working copy, and then committed all those changes at
        once.</para>

      <para>As you can see, <command>svnmucc</command> is a handy
        addition to the Subversion user's tool chest.  For a complete
        reference of this tool's offerings, see
        <xref linkend="svn.ref.svnmucc" />.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.summary">
    <title>Summary</title>

    <para>After reading this chapter, you should have a firm grasp on
      some of Subversion's features that, while perhaps not used
      <emphasis>every</emphasis> time you interact with your version
      control system, are certainly handy to know about.  But don't
      stop here!  Read on to the following chapter, where you'll learn
      about branches, tags, and merging.  Then you'll have nearly full
      mastery of the Subversion client.  Though our lawyers won't
      allow us to promise you anything, this additional knowledge
      could make you measurably more cool.<footnote><para>No purchase
      necessary.  Certains terms and conditions apply.  No guarantee
      of coolness implicit or otherwise exists.  Mileage
      may vary.</para></footnote></para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.branchmerge">
  <title>Branching and Merging</title>

  <blockquote>
    <attribution>Confucius</attribution>
    <para><quote>君子务本
      (It is upon the Trunk that a gentleman works.)</quote></para>
  </blockquote>

  <para>Branching and merging are fundamental aspects of version
    control, simple enough to explain conceptually but offering just
    enough complexity and nuance to merit their own chapter in this
    book.  Herein, we'll introduce you to the general ideas behind
    these operations as well as Subversion's somewhat unique approach
    to them.  If you've not familiarized yourself with Subversion's
    basic concepts (found in <xref linkend="svn.basic"/>), we
    recommend that you do so before reading this chapter.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.whatis">
    <title>What's a Branch?</title>

    <para>Suppose it's your job to maintain a document for a division
      in your company a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      <quote>tweaked</quote> for them, since they do things slightly
      differently.</para>

    <para>What do you do in this situation?  You do the obvious: make
      a second copy of your document and begin maintaining the two
      copies separately.  As each department asks you to make small
      changes, you incorporate them into one copy or the other.</para>

    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they differ only in
      small, specific ways.</para>

    <para>
      <indexterm>
        <primary>branches</primary>
      </indexterm>This is the basic concept of a branch namely,
      a line of development that exists independently of another line,
      yet still shares a common history if you look far enough back in
      time.  A branch always begins life as a copy of something, and
      moves on from there, generating its own history (see
      <xref linkend="svn.branchmerge.whatis.dia-1"/>).</para>

    <figure id="svn.branchmerge.whatis.dia-1">
      <title>Branches of development</title>
      <graphic fileref="images/ch04dia1.png"/>
    </figure>

    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches so that you can
      <quote>mix and match</quote> different lines of development in
      your daily work.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.using">
    <title>Using Branches</title>

    <para>At this point, you should understand how each commit creates
      a new state of the filesystem tree (called a <quote>revision</quote>)
      in the repository.  If you don't, go back and read about revisions in
      <xref linkend="svn.basic.in-action.revs"/>.</para>

    <para>Let's revisit the example from
      <xref linkend="svn.basic"/>.  Remember that you and your
      collaborator, Sally, are sharing a repository that contains two
      projects, <filename>paint</filename> and
      <filename>calc</filename>.  Notice that in <xref
      linkend="svn.branchmerge.using.dia-1"/>, however, each project
      directory now contains subdirectories named
      <filename>trunk</filename> and <filename>branches</filename>.
      The reason for this will soon become clear.</para>

    <figure id="svn.branchmerge.using.dia-1">
      <title>Starting repository layout</title>
      <graphic fileref="images/ch04dia2.png"/>
    </figure>

    <para>As before, assume that Sally and you both have working
      copies of the <quote>calc</quote> project.  Specifically, you
      each have a working copy of <filename>/calc/trunk</filename>.
      All the files for the project are in this subdirectory rather
      than in <filename>/calc</filename> itself, because your team has
      decided that <filename>/calc/trunk</filename> is where the
      <quote>main line</quote> of development is going to take
      place.</para>

    <para>Let's say that you've been given the task of implementing a
      large software feature.  It will take a long time to write, and
      will affect all the files in the project.  The immediate problem
      is that you don't want to interfere with Sally, who is in the
      process of fixing small bugs here and there.  She's depending on
      the fact that the latest version of the project (in
      <filename>/calc/trunk</filename>) is always usable.  If you
      start committing your changes bit by bit, you'll surely break
      things for Sally (and other team members as well).</para>

    <para>One strategy is to crawl into a hole: you can stop sharing
      information for a week or two, gutting and reorganizing all the
      files in your private working copy but not committing or
      updating until you're completely finished with your task.  There
      are a number of problems with this, though.  First, it's not
      very safe.  Should something bad happen to your working copy or
      computer, you risk losing all your changes.  Second, it's not
      very flexible.  Unless you manually replicate your changes
      across different working copies or computers, you're stuck trying
      to make your changes in a single working copy.  Similarly, it's
      difficult to share your work-in-progress with anyone else.  A
      common software development <quote>best practice</quote> is to
      allow your peers to review your work as you go.  If nobody sees
      your intermediate commits, you lose potential feedback and may
      end up going down the wrong path for weeks before another person
      on your team notices.  Finally, when you're finished with all
      your changes, you might find it very difficult to merge your
      completed work with the rest of the company's main body of code.
      Sally (or others) may have made many other changes in the
      repository that are difficult to incorporate into your working
      copy when you eventually run <command>svn update</command> after
      weeks of isolation.</para>

    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      not-yet-completed work frequently without interfering with
      others' changes and while still selectively sharing information
      with your collaborators.  You'll see exactly how this works as
      we continue.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.create">
      <title>Creating a Branch</title>

      <para>Creating a branch is very simple you make a copy of
        your project tree in the repository using the <command>svn
        copy</command> command.  Since your project's source code is
        rooted in the <filename>/calc/trunk</filename> directory, it's
        that directory that you'll copy.  Where should the new
        copy live?  Wherever you wish.  The repository location in
        which branches are stashed is left by Subversion as a matter
        of project policy.  Finally, your branch will need a name to
        distinguish it from other branches.  Once again, the name you
        choose is unimportant to Subversion you can use whatever
        name works best for you and your team.</para>

      <para>Let's assume that your team (like most) has a policy of
        creating branches in the <filename>branches</filename>
        directory that is a sibling of the project's trunk
        (the <filename>/calc/branches</filename> directory in our
        scenario).  Lacking inspiration, you settle
        on <literal>my-calc-branch</literal> as the name you wish to
        give your branch.  This means that you'll create a new
        directory, <filename>/calc/branches/my-calc-branch</filename>,
        which begins its life as a copy
        of <filename>/calc/trunk</filename>.</para>

      <para>
        <indexterm>
          <primary>copying</primary>
          <secondary>remote copies</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>copy</tertiary>
        </indexterm>
        <indexterm>
          <primary>branches</primary>
          <secondary>creating</secondary>
        </indexterm>You may already have seen <command>svn
        copy</command> used to copy one file to another within a
        working copy.  But it can also be used to do
        a <firstterm>remote copy</firstterm> a copy that
        immediately results in a newly committed repository revision
        and for which no working copy is required at all.  Just copy
        one URL to another:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/my-calc-branch \
           -m "Creating a private branch of /calc/trunk."

Committed revision 341.
$
</screen>
      </informalexample>

      <para>This command causes a near-instantaneous commit in the
        repository, creating a new directory in revision 341.  The new
        directory is a copy of <filename>/calc/trunk</filename>.  This
        is shown in <xref linkend="svn.branchmerge.using.create.dia-1"
        />.<footnote><para>Subversion does not support copying between
        different repositories.  When using URLs with <command>svn
        copy</command> or <command>svn move</command>, you can only
        copy items within the same repository.</para></footnote>  While
        it's also possible to create a branch by using <command>svn
        copy</command> to duplicate a directory within the working
        copy, this technique isn't recommended.  It can be quite slow,
        in fact!  Copying a directory on the client side is a
        linear-time operation, in that it actually has to duplicate
        every file and subdirectory within that working copy directory
        on the local disk.  Copying a directory on the server,
        however, is a constant-time operation, and it's the way most
        people create branches.  In addition, this practice raises the
        possibility of copying mixed-revision working copies.  This isn't
        inherently dangerous, but can cause unnecessary complications later
        during merging.  If you do choose to create a branch by copying a
        working copy path, you should be sure the source directory has no
        local modifications and is not at mixed-revisions.</para>
            
      <figure id="svn.branchmerge.using.create.dia-1">
        <title>Repository with new copy</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>

      <sidebar>
        <title>Cheap Copies</title>

        <para>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're an experienced Unix user, you'll recognize this as
          the same concept behind a hard link.  As further changes are
          made to files and directories beneath the copied directory,
          Subversion continues to employ this hard link concept where
          it can.  It duplicates data only when it is necessary to
          disambiguate different versions of objects.</para>

        <para>This is why you'll often hear Subversion users talk
          about <quote>cheap copies.</quote>  It doesn't matter how
          large the directory is it takes a very tiny, constant
          amount of time and space to make a copy of it.  In fact,
          this feature is the basis of how commits work in Subversion:
          each revision is a <quote>cheap copy</quote> of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's web site and read about
          the <quote>bubble up</quote> method in Subversion's design
          documents.)</para>

        <para>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and in space.  If you create a branch
          entirely within the repository (by running <userinput>svn copy
          <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput>),
          it's a quick, constant-time operation.  Make branches as
          often as you want.</para>
      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.work">
      <title>Working with Your Branch</title> 

      <para>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A    my-calc-branch/doc
A    my-calc-branch/src
A    my-calc-branch/doc/INSTALL
A    my-calc-branch/src/real.c
A    my-calc-branch/src/main.c
A    my-calc-branch/src/button.c
A    my-calc-branch/src/integer.c
A    my-calc-branch/Makefile
A    my-calc-branch/README
Checked out revision 341.

$
</screen>
      </informalexample>

      <para>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't see them when she
        updates, because her working copy is of
        <filename>/calc/trunk</filename>.  (Be sure to read <xref
        linkend="svn.branchmerge.switchwc"/> later in this chapter: the
        <command>svn switch</command> command is an alternative way of
        creating a working copy of a branch.)</para>

      <para>Let's pretend that a week goes by, and the following
        commits happen:</para>

      <itemizedlist>
        <listitem>
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/button.c</filename>,
            which creates revision 342.</para>
        </listitem>
        <listitem>
          <para>You make a change to
            <filename>/calc/branches/my-calc-branch/src/integer.c</filename>,
            which creates revision 343.</para>
        </listitem>
        <listitem>
          <para>Sally makes a change to
            <filename>/calc/trunk/src/integer.c</filename>, which creates
            revision 344.</para>
        </listitem>
      </itemizedlist>

      <para>Now two independent lines of development (shown
        in <xref linkend="svn.branchmerge.using.work.dia-1"/>) are happening on
        <filename>integer.c</filename>.</para>

      <figure id="svn.branchmerge.using.work.dia-1">
        <title>The branching of one file's history</title>
        <graphic width="4.81in" depth="2.18in" fileref="images/basic-branch.png" />
      </figure>

      <para>Things get interesting when you look at the history of
        changes made to your copy of <filename>integer.c</filename>:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn log -v src/integer.c
------------------------------------------------------------------------
r343 | user | 2013-02-15 14:11:09 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch/src/integer.c

* integer.c:  frozzled the wazjub.
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
------------------------------------------------------------------------
 
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Notice that Subversion is tracing the history of your
        branch's <filename>integer.c</filename> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <filename>integer.c</filename> was implicitly
        copied when all of <filename>/calc/trunk/</filename> was
        copied.  Now look at what happens when Sally runs the same
        command on her copy of the file:</para>

      <informalexample>
        <screen>
$ pwd
/home/sally/calc

$ svn log -v src/integer.c
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Refactor the bazzle functions.
------------------------------------------------------------------------
r154 | sally | 2013-01-30 04:20:03 -0500 (Wed, 30 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c:  changed a docstring.
------------------------------------------------------------------------
 
------------------------------------------------------------------------
r113 | sally | 2013-01-26 15:50:21 -0500 (Sat, 26 Jan 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/integer.c

* integer.c: Revise the fooplus API.
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013) | 1 line
Changed paths:
   A /calc/trunk/Makefile
   A /calc/trunk/README
   A /calc/trunk/doc/INSTALL
   A /calc/trunk/src/button.c
   A /calc/trunk/src/integer.c
   A /calc/trunk/src/main.c
   A /calc/trunk/src/real.c

Initial trunk code import for calc project.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <emphasis>does</emphasis> show that the two files share a
        common history.  Before the branch copy was made in revision
        341, the files used to be the same file.  That's why you and
        Sally both see the changes made between revisions 8 and
        154.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.using.concepts">
      <title>The Key Concepts Behind Branching</title> 

      <para>You should remember two important lessons
        from this section.  First, Subversion has no internal concept
        of a branch it knows only how to make copies.  When you
        copy a directory, the resultant directory is only
        a <quote>branch</quote> because <emphasis>you</emphasis>
        attach that meaning to it.  You may think of the directory
        differently, or treat it differently, but to Subversion it's
        just an ordinary directory that happens to carry some extra
        historical information.</para>

      <para>Second, because of this copy mechanism, Subversion's
        branches exist as <emphasis>normal filesystem
        directories</emphasis> in the repository.  This is different
        from other version control systems, where branches are
        typically defined by adding
        extra-dimensional <quote>labels</quote> to collections of
        files.  The location of your branch directory doesn't matter
        to Subversion.  Most teams follow a convention of putting all
        branches into a <filename>/branches</filename> directory, but
        you're free to invent any policy you wish.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.basicmerging">
    <title>Basic Merging</title>

    <para>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the trunk, or main line of development.</para>

    <para>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</para>

    <para>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the <quote>crawl in a hole</quote> strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</para>

    <para>
      <indexterm>
        <primary>merging</primary>
      </indexterm>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <quote>copy</quote> changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <firstterm>merging</firstterm>, and
      it is performed using various invocations of the <command>svn
      merge</command> subcommand.</para>

    <para>In the examples that follow, we're assuming that both your
      Subversion client and server are running Subversion 1.8 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won't track changes
      automatically, forcing you to use painful manual methods to
      achieve similar results.  That is, you'll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
      <xref linkend="svn.branchmerge.advanced.advancedsyntax"/> later
      in this chapter), and take special care to keep track of what's
      already been merged and what hasn't.  For this reason,
      we <emphasis>strongly</emphasis> recommend that you make sure your
      client and server are at least at version 1.5.</para>

    <sidebar id="svn.branchmerge.basicmerging.mergetracking">
      <title>Merge Tracking</title>
      <para>
        <indexterm>
          <primary>merge tracking</primary>
        </indexterm>Subversion 1.5 introduced the
        <firstterm>merge tracking</firstterm> feature to Subversion.
        Prior to this feature keeping track of merges required cumbersome
        manual procedures or the use of external tools. Subsequent
        releases of Subversion introduced many enhancements and bug
        fixes to merge tracking, which is why we recommend using the
        most recent versions for both your server and client.  Keep in
        mind that even if your server is running 1.5-1.7, you can still
        use a 1.8 client.  This is particularly important with regard to merge
        tracking, because the overwhelming majority of fixes and enhancements
        to it are on the client side.</para>
    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.changesets">
      <title>Changesets</title>

      <para>
        <indexterm>
          <primary>changesets</primary>
        </indexterm>Before we proceed further, we should warn you that there's
        a lot of discussion of <quote>changes</quote> in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms <quote>change</quote>
        and <quote>changeset</quote> interchangeably, and we should
        clarify what Subversion understands as
        a <firstterm>changeset</firstterm>.</para>

      <para>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let's say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</para>

      <para>In Subversion, a global revision
        number <replaceable>N</replaceable> names a tree in the
        repository: it's the way the repository looked after the
        <replaceable>N</replaceable>th commit.  It's also the name of
        an implicit changeset: if you compare
        tree <replaceable>N</replaceable> with
        tree <replaceable>N</replaceable>-1, you can derive the exact
        patch that was committed.  For this reason, it's easy to think
        of revision <replaceable>N</replaceable> as not just a tree,
        but a changeset as well.  If you use an issue tracker to
        manage bugs, you can use the revision numbers to refer to
        particular patches that fix bugs for example,
        <quote>this issue was fixed by r9238.</quote> Somebody
        can then run <userinput>svn log -r 9238</userinput> to read about
        the exact changeset that fixed the bug, and run
        <userinput>svn diff -c 9238</userinput> to see the patch itself.
        And (as you'll see shortly)
        Subversion's <command>svn merge</command> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <userinput>-c 9238</userinput>
        to <command>svn merge</command> would merge changeset r9238
        into your working copy.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.stayinsync">
      <title>Keeping a Branch in Sync</title>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>sync merges</secondary>
        </indexterm>
        <indexterm>
          <primary>svn</primary>
          <secondary>subcommands</secondary>
          <tertiary>merge</tertiary>
        </indexterm>Continuing with our running example, let's suppose
        that a week has passed since you started working on your
        private branch.  Your new feature isn't finished yet, but at
        the same time you know that other people on your team continue
        to make important changes in the
        project's <filename>/trunk</filename>.  It's in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  This is done
        by performing an <firstterm>automatic sync merge</firstterm> a
        merge operation designed to bring your branch up to date with
        any changes made to its ancestral parent branch since your
        branch was created.
        <indexterm>
          <primary>merging</primary>
          <secondary>automatic</secondary>
        </indexterm> An <quote>automatic</quote> merge is simply
        one in which you provide the bare minimum of information required
        for a merge (i.e. a single merge source and a working copy target)
        and let Subversion determine which changes need merging no
        changesets are passed to <command>svn merge</command> via the
        <option>-r</option> or <option>-c</option> options in an automatic
        merge.</para>

      <tip>
        <para>Frequently keeping your branch in sync with the main
          development line helps prevent <quote>surprise</quote>
          conflicts when the time comes for you to fold your changes
          back into the trunk.</para>
      </tip>

      <para>Subversion is aware of the history of your branch and
        knows when it split away from the trunk.  To perform a sync
        merge, first make sure your working copy of the branch
        is <quote>clean</quote> that it has no local
        modifications reported by <command>svn status</command>.  Then
        simply run:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/my-calc-branch

$ svn merge ^/calc/trunk
--- Merging r341 through r351 into '.':
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
--- Recording mergeinfo for merge of r341 through r351 into '.':
 U   .
 $
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>properties</primary>
          <secondary>svn:mergeinfo</secondary>
        </indexterm>This basic syntax <userinput>svn merge
        <replaceable>URL</replaceable></userinput> tells
        Subversion to merge all changes which have not been previously
        merged from the URL to the current working directory (which is
        typically the root of your working copy).  Notice that we're
        using the caret (<literal>^</literal>)
        syntax<footnote><para>This was introduced in svn
        1.6.</para></footnote> to avoid having to type out the
        entire <filename>/trunk</filename> URL.  Also note
        the <quote>Recording mergeinfo for merge </quote>
        notification.  This tells you that the merge is updating
        the <literal>svn:mergeinfo</literal> property. We'll discuss
        both this property and these notifications later in this
        chapter, in
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>.</para>

      <tip>
        <para>
          <indexterm>
            <primary>mergeinfo</primary>
          </indexterm>In this book and elsewhere (Subversion mailing
          lists, articles on merge tracking, etc.) you will frequently
          come across the term <firstterm>mergeinfo</firstterm>. This
          is simply shorthand for the <literal>svn:mergeinfo</literal>
          property.</para>
      </tip>

      <sidebar>
        <title>Keeping a Branch in Sync Without Merge Tracking</title>

        <para>You may not always be able to use Subversion's merge
          tracking feature, perhaps because your server is running
          Subversion 1.4 or earlier or you must use an older client.
          In such a scenario, you can of course still perform merges,
          but Subversion will need you to manually do many of the historical
          calculations that it automatically does on your behalf when the
          merge tracking feature is available.</para>

        <para>To replicate the most recent trunk changes you need to
          perform sync merges the <quote>old-fashioned</quote>
          way by specifying ranges of revisions you wish to
          merge.</para>

        <para>Using the ongoing example, you know that you branched
          <filename>/calc/trunk</filename> to 
          <filename>/calc/branches/my-calc-branch</filename> in revision
          341:</para>

        <informalexample>
          <screen>
$ svn log -v -r341
------------------------------------------------------------------------
r341 | user | 2013-02-15 07:41:25 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.
------------------------------------------------------------------------
</screen>
        </informalexample>

        <para>When you are ready to synchronize your branch with the
          ongoing changes from trunk, you specify the starting
          revision as the revision of <filename>/calc/trunk</filename>
          which the branch was copied from and the ending revision as
          the youngest change on <filename>/calc/trunk</filename>.  You
          can find the latter with the <command>svn log</command> command
          with the <option>-r</option> set to <literal>HEAD</literal>:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r340:351
U    doc/INSTALL
U    src/real.c
U    src/button.c
U    Makefile
</screen>
        </informalexample>

        <para>After any conflicts have been resolved, you can commit
          the merged changes to your branch.  Now, to avoid
          accidentally trying to merge these same changes into your
          branch again in the future, you'll need to record the fact
          that you've already merged them.  But where should that
          record be kept?  One of the simplest places to record this
          information is in the log message for the commit of the
          merge:</para>

        <informalexample>
          <screen>
$ svn ci -m "Sync the my-calc-branch with ^/calc/trunk through r351."
 
</screen>
        </informalexample>

        <para>The next time you sync
          <filename>/calc/branches/my-calc-branch</filename>  with
          <filename>/calc/trunk</filename> you repeat this process, except
          that the starting revision is the <emphasis>youngest</emphasis>
          revision that's already been merged in from the trunk.
          If you've been keeping good records of your merges in the
          commit log messages, you should be able to determine what
          that youngest revision was by reading the revision logs
          associated with your branch.  Once you know your starting
          revision, you can perform another sync merge:</para>

        <informalexample>
          <screen>
$ svn log -q -rHEAD http://svn.example.com/repos/calc/trunk
------------------------------------------------------------------------
r959 | sally | 2013-03-5 7:30:21 -0500 (Tue, 05 Mar 2013)
------------------------------------------------------------------------

$ svn merge http://svn.example.com/repos/calc/trunk -r351:959
 
</screen>
        </informalexample>

      </sidebar>

      <para>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</para>

      <informalexample>
        <screen>
$ svn status
 M      .
M       Makefile
M       doc/INSTALL
M       src/button.c
M       src/real.c
</screen>
      </informalexample>

      <para>At this point, the wise thing to do is look at the changes
        carefully with <command>svn diff</command>, and then build and
        test your branch.  Notice that the current working directory
        (<quote><filename>.</filename></quote>) has also been
        modified; <command>svn diff</command> shows that
        its <literal>svn:mergeinfo</literal> property has been created.
        </para>

      <informalexample>
        <screen>
$ svn diff --depth empty .
Index: .
===================================================================
--- .   (revision 351)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /calc/trunk:r341-351
</screen>
      </informalexample>

      <para>
        This new property is important merge-related metadata
        that you should <emphasis>not</emphasis> touch, since it is
        needed by future <command>svn merge</command> commands.
        (We'll learn more about this metadata later in the
        chapter.)</para>

      <para>After performing the merge, you might also need to resolve
        some conflicts just as you do with <command>svn
        update</command> or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <emphasis>syntactic</emphasis> conflicts doesn't mean there
        aren't any <emphasis>semantic</emphasis> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <userinput>svn revert . -R</userinput> (which
        will undo all local modifications) and starting a
        long <quote>what's going on?</quote> discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</para>

      <informalexample>
        <screen>
$ svn commit -m "Sync latest trunk changes to my-calc-branch."
Sending        .
Sending        Makefile
Sending        doc/INSTALL
Sending        src/button.c
Sending        src/real.c
Transmitting file data ....
Committed revision 352.
</screen>
      </informalexample>

      <para>At this point, your private branch is now <quote>in
        sync</quote> with the trunk, so you can rest easier knowing
        that as you continue to work in isolation, you're not drifting
        too far away from what everyone else is doing.</para>

      <sidebar>
        <title>Why Not Use Patches Instead?</title>

        <para>A question may be on your mind, especially if you're a
          Unix user: why bother to use <command>svn merge</command> at
          all?  Why not simply use <command>svn patch</command> or the
          operating system's <command>patch</command> command to
          accomplish the same job?  For example:</para>

        <informalexample>
          <screen>
$ cd my-calc-branch

$ svn diff -r 341:351 ^/calc/trunk > my-patch-file

$ svn patch my-patch-file
U         doc/INSTALL
U         src/real.c
U         src/button.c
U         Makefile
</screen>
        </informalexample>

        <para>In this particular example, there really isn't much
          difference.  But <command>svn merge</command> has special
          abilities that surpass the <command>patch</command> program.
          The file format used by <command>patch</command> is quite
          limited; it's able to tweak file contents only.  There's no
          way to represent changes to <emphasis>trees</emphasis>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <command>patch</command> program
          notice changes to properties.  If Sally's change had,
          say, added a new directory, the output of <command>svn
          diff</command> wouldn't have mentioned it at
          all.  <command>svn diff</command> outputs only the limited
          patch format, so there are some ideas it simply can't
          express.  Even Subversion's own <command>svn patch</command>
          subcommand, while more flexible than the patch program, still has
          similar limitations.</para>

        <para>The <command>svn merge</command> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/>).
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven't been merged
          yet.</para>

      </sidebar>

      <para>Suppose that another week has passed.  You've committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you want to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk
svn: E195020: Cannot merge into mixed-revision working copy [352:357]; try up\
dating first
$
</screen>
      </informalexample>

      <para>Well that was unexpected!  After making changes to your
        branch over the past week you now find yourself with a working
        copy that contains a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs"/>).  With Subversion
        1.7 and later, the <command>svn merge</command>
        subcommand disables merges into mixed-revision working copies
        by default.  Without going into too much detail, this is
        because of limitations in the way merges are tracked by the
        <literal>svn:mergeinfo</literal> property (see
        <xref linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details).  These limitations mean that merges into
        mixed-revision working copies can result in unexpected text
        and tree conflicts.<footnote><para>The <command>svn
        merge</command> subcommand
        option <option>--allow-mixed-revisions</option> allows you to
        override this prohibition, but you should only do so if you
        understand the ramifications and have a good reason for
        it.</para></footnote>  We don't want any needless conflicts, so
        we update the working copy and then reattempt the
        merge.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
At revision 361.

$ svn merge ^/calc/trunk
--- Merging r352 through r361 into '.':
U    src/real.c
U    src/main.c
--- Recording mergeinfo for merge of r352 through r361 into '.':
 U   .
</screen>
      </informalexample>

      <para>Subversion knows which trunk changes you previously
        replicated to your branch, so it carefully replicates only
        those changes you don't yet have.  And once again, you build,
        test, and <command>svn commit</command> the local modifications
        to your branch.</para>

      <sidebar id="svn.branchmerge.basicmerging.stayinsync.subtree">
        <title>Subtree Merges and Subtree Mergeinfo</title>
        <para>
          <indexterm>
            <primary>merging</primary>
            <secondary>subtree merge</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>subtree mergeinfo</secondary>
          </indexterm>In most of the examples in this chapter the
          merge target is the root directory of a branch (see
          <xref linkend="svn.branchmerge.whatis"/>). While this is a
          best practice, you may occasionally need to merge directly
          to some child of the branch root. This type of merge is
          called a <firstterm>subtree merge</firstterm> and the
          mergeinfo recorded to describe it is called
          <firstterm>subtree mergeinfo</firstterm>. There is nothing
          special about subtree merges or subtree mergeinfo.  In fact
          there is really only one important point to keep in mind
          about these concepts: the complete record of merges to a
          branch may not be contained solely in the mergeinfo on the
          branch root.  You may have to consider subtree mergeinfo
          to get a full accounting.  Fortunately Subversion does this
          for you and rarely will you need to concern yourself with
          it.  A brief example will help explain:</para>

        <informalexample>
          <screen>
# We need to merge r958 from trunk to branches/proj-X/doc/INSTALL,
# but that revision also affects main.c, which we don't want to merge:
$ svn log --verbose --quiet -r 958 ^/
------------------------------------------------------------------------
r958 | bruce | 2011-10-20 13:28:11 -0400 (Thu, 20 Oct 2011)
Changed paths:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
------------------------------------------------------------------------

# No problem, we'll do a subtree merge targeting the INSTALL file
# directly, but first take a note of what mergeinfo exists on the
# root of the branch:
$ cd branches/proj-X

$ svn propget svn:mergeinfo --recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652

# Now we perform the subtree merge, note that merge source
# and target both point to INSTALL:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
--- Merging r958 into 'doc/INSTALL':
U    doc/INSTALL
--- Recording mergeinfo for merge of r958 into 'doc/INSTALL':
 G   doc/INSTALL

# Once the merge is complete there is now subtree mergeinfo on INSTALL:
$ svn propget svn:mergeinfo --recursive
Properties on '.':
  svn:mergeinfo
    /trunk:651-652
Properties on 'doc/INSTALL':
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958

# What if we then decide we do want all of r958? Easy, all we need do is
# repeat the merge of that revision, but this time to the root of the
# branch, Subversion notices the subtree mergeinfo on INSTALL and doesn't
# try to merge any changes to it, only the changes to main.c are merged:
$ svn merge ^/subversion/trunk . -c 958
--- Merging r958 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r958 into '.':
 U   .
--- Eliding mergeinfo from 'doc/INSTALL':
 U   doc/INSTALL
</screen>
        </informalexample>

        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>elision</secondary>
          </indexterm>You might be wondering
          why <filename>INSTALL</filename> in the above example has
          mergeinfo for r651-652, when we only merged r958. This is
          due to mergeinfo inheritance, which we'll cover in the
          sidebar
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"
          />.  Also note that the subtree mergeinfo on
          <filename>doc/INSTALL</filename> was removed, or
          <quote>elided</quote>.  This is called
          <firstterm>mergeinfo elision</firstterm> and it occurs
          whenever Subversion detects redundant subtree mergeinfo.</para>

      </sidebar>

      <tip>
        <para>Prior to Subversion 1.7, merges unconditionally updated
          <emphasis>all</emphasis> of the subtree mergeinfo under the
          target to describe the merge. For users with a lot of subtree
          mergeinfo this meant that relatively <quote>simple</quote>
          merges (e.g. one which applied a diff to only a single file)
          resulted in changes to every subtree with mergeinfo, even
          those that were not parents of the affected path(s). This
          caused some level of confusion and frustration. Subversion 1.7
          and later addresses this problem by only updating the mergeinfo
          on subtrees which are parents of the paths modified by the merge
          (i.e. paths changed, added, or deleted by application of the
          difference, see
          <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>).
          The one exception to this behavior regards the actual merge
          target; the merge target's mergeinfo is always updated to
          describe the merge, even if the applied difference made no
          changes.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.reintegrate">
      <title>Reintegrating a Branch</title>

      <para>What happens when you finally finish your work, though?
        Your new feature is done, and you're ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch into sync with the trunk again, just as you've been
        doing all along<footnote><para>Since Subversion 1.7 you don't
        absolutely have to do all your sync merges to the root of your
        branch as we do in this example.  <emphasis>If</emphasis> your
        branch is effectively synced via a series of subtree
        merges then the reintegrate will work, but ask yourself, if the
        branch is effectively synced, then why are you doing subtree
        merges? Doing so is almost always needlessly
        complex.</para></footnote>:</para>

      <informalexample>
        <screen>
$ svn up # (make sure the working copy is up to date)
Updating '.':
At revision 378.

$ svn merge ^/calc/trunk
--- Merging r362 through r378 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r362 through r378 into '.':
 U   .

$ # build, test, ...

$ svn commit -m "Final merge of trunk changes to my-calc-branch."
Sending        .
Sending        src/main.c
Transmitting file data .
Committed revision 379.
</screen>
      </informalexample>

      <para>Now, use <command>svn merge</command> subcommand to automatically
        replicate your branch changes back into the trunk.  This type of
        merge is called an
        <indexterm>
          <primary>merging</primary>
          <secondary>reintegrate merges</secondary>
        </indexterm> <quote>automatic reintegrate</quote> merge.  You'll need
        a working copy of <filename>/calc/trunk</filename>.  You can get one
        by doing an <command>svn checkout</command>, dredging up an old trunk
        working copy from somewhere on your disk, or
        using <command>svn switch</command> (see
        <xref linkend="svn.branchmerge.switchwc" />).</para>

      <tip>
        <para>The term <quote>reintegrating</quote> comes from the
          <command>merge</command> option <option>--reintegrate</option>.
          This option is deprecated in Subversion 1.8 (which automatically
          detects when a reintegrate merge is needed), but is required
          for Subversion 1.5 through 1.7 clients when performing reintegrate
          merges.</para>
      </tip>

      <para>Your trunk working copy cannot have any local edits, switched
        paths, or contain a mixture of revisions (see
        <xref linkend="svn.basic.in-action.mixedrevs" />).  While
        these are typically best practices for merging anyway, they
        are <emphasis>required</emphasis> for automatic reintegrate
        merges.</para>

      <para>Once you have a clean working copy of the trunk, you're
        ready to merge your branch back into it:</para>

      <informalexample>
        <screen>
$ pwd
/home/user/calc-trunk

$ svn update
Updating '.':
At revision 379.

$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
U    src/real.c
U    src/main.c
U    Makefile
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .

$ # build, test, verify, ...

$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        Makefile
Sending        src/main.c
Sending        src/real.c
Transmitting file data ...
Committed revision 380.
</screen>
      </informalexample>

      <para>Congratulations, your branch-specific changes have now
        been merged back into the main line of development.  Notice that
        the automatic reintegrate merge did a different sort of work than
        what you've done up until now.  Previously, we were
        asking <command>svn merge</command> to grab the <quote>next
        set</quote> of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 341:351 from
        <filename>/calc/trunk</filename> to
        <filename>/calc/branches/my-calc-branch</filename>;
        later on, it continues by merging the next contiguously
        available range, 351:361.  When doing the final sync, it
        merges the range 361:378.</para>

      <para>When merging <filename>/calc/branches/my-calc-branch</filename>
        back to the <filename>/calc/trunk</filename>, however, the
        underlying mathematics are quite different.  Your feature
        branch is now a mishmash of both duplicated trunk changes and
        private branch changes, so there's no simple contiguous range
        of revisions to copy over.  By using an automatic merge, you're
        asking Subversion to carefully replicate <emphasis>only</emphasis>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</para>

      <para>Keep in mind that the automatic reintegrate merges only support
        the use case described above.  Because of this narrow focus, in
        addition to the requirements previously mentioned (up-to-date working
        copy <footnote><para>Automatic reintegrate merges are allowed if the
        target is a shallow checkout
        (see <xref linkend="svn.advanced.sparsedirs"/>) but any paths
        affected by the diff which are <quote>missing</quote> due to the
        sparse working copy will be skipped this is probably
        <emphasis>not</emphasis> what you intended!</para></footnote>
        with no mixed-revisions, switched paths or local changes) it will not
        function in combination with most of the other
        <command>svn merge</command> options. You'll get an error if you
        use any non-global options but these: <option>--accept</option>,
        <option>--dry-run</option>, <option>--diff3-cmd</option>,
        <option>--extensions</option>, or <option>--quiet</option>.</para>

      <para>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</para>

      <informalexample>
        <screen>
$ svn delete ^/calc/branches/my-calc-branch \
             -m "Remove my-calc-branch, reintegrated with trunk in r381."
 
</screen>
      </informalexample>

      <para>But wait!  Isn't the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <filename>/calc/branches</filename> directory, its
        existence is still an immutable part of the repository's
        history.  A simple <command>svn log</command> command on
        the <filename>/calc/branches</filename> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        <xref linkend="svn.branchmerge.basicmerging.resurrect"/>).</para>

      <para>If you choose not to delete your branch after reintegrating
        it to the trunk you may continue to perform sync merges from the
        trunk and then reintegrate the branch again<footnote><para>Only
        Subversion 1.8 supports this reuse of a feature branch.  Earlier
        versions require some special handling before a feature branch
        can be reintegrated more than once.  See the earlier version of
        this chapter for more information: <ulink
        url="http://svnbook.red-bean.com/en/1.7/svn.branchmerge.basicmerging.html#svn.branchemerge.basicmerging.reintegrate"
        /></para></footnote>. If you do this, only the changes made on your
        branch after the first reintegrate are merged to the trunk.</para>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.mergeinfo">
      <title>Mergeinfo and Previews</title>

      <para>The basic mechanism Subversion uses to track
        changesets that is, which changes have been merged to
        which branches is by recording data in versioned
        properties.  Specifically, merge data is tracked in
        the <literal>svn:mergeinfo</literal> property attached to
        files and directories.  (If you're not familiar with
        Subversion properties, see <xref linkend="svn.advanced.props"
        />.)</para>

      <para>You can examine the mergeinfo property, just like any other
        versioned property:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn pg svn:mergeinfo -v
Properties on '.':
  svn:mergeinfo
    /calc/trunk:341-378
</screen>
      </informalexample>

      <warning>
        <para>While it is possible to
          modify <literal>svn:mergeinfo</literal> just as you might
          any other versioned property, we strongly discourage doing
          so unless you <emphasis>really</emphasis> know what you're
          doing.</para>
      </warning>

      <tip>
        <para>The amount of <literal>svn:mergeinfo</literal> on a single
          path can get quite large, as can the output of a
          <command>svn propget --recursive</command> or
          <command>svn proplist --recursive</command> when dealing with
          large amounts of subtree mergeinfo. See
          <xref linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>
          . The formatted output produced by the
          <option>--verbose</option> option with either of these
          subcommands is often very helpful in these cases.</para>
      </tip>

      <para>The <literal>svn:mergeinfo</literal> property is
        automatically maintained by Subversion whenever you
        run <command>svn merge</command>.  Its value indicates which
        changes made to a given path have been replicated into the
        directory in question.  In our previous example, the path
        which is the source of the merged changes is
        <filename>/calc/trunk</filename> and the directory which has
        received the changes is
        <filename>/calc/branches/my-calc-branch</filename>.
        Earlier versions of Subversion maintained the
        <literal>svn:mergeinfo</literal> property silently. You could
        still detect the changes, after a merge completed, with the
        <command>svn diff</command> or <command>svn status</command>
        subcommands, but the merge itself gave no indication when it
        changed the <literal>svn:mergeinfo</literal> property. In
        Subversion 1.7 and later this is no longer true as there are
        several notifications to alert you when a merge updates the
        <literal>svn:mergeinfo</literal> property. These notifications
        all begin with <quote>--- Recording mergeinfo for</quote>
        and appear at the end of the merge.  Unlike other merge
        notifications, these don't describe the application of a
        difference to a working copy
        (see <xref linkend="svn.branchmerge.advanced.advancedsyntax"/>),
        but instead describe "housekeeping" changes made to keep
        track of what was merged.</para>

      <para>Subversion also provides a subcommand, <command>svn
        mergeinfo</command>, which is helpful in seeing the merge
        relationships between two branches; specifically which changesets
        a directory has absorbed or which changesets it's still eligible
        to receive.  The latter gives a sort of preview of which changes a
        subsequent <command>svn merge</command> operation would replicate
        to your branch.  By default, <command>svn mergeinfo</command> gives
        an graphical overview of the relationship between to branches.
        Returning to our earlier example, we use the subcommand to analyze
        the relationship between <filename>/calc/trunk</filename> and
        <filename>/calc/branches/my-calc-branch</filename>:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn mergeinfo ^/calc/trunk
    youngest common ancestor
    |         last full merge
    |         |        tip of branch
    |         |        |         repository path

    340                382
    |                  |
  -------| |------------         calc/trunk
     \          /
      \        /
       --| |------------         calc/branches/my-calc-branch
              |        |
              379      382
</screen>
      </informalexample>

      <para>The diagram shows that <filename>/calc/branches/my-calc-branch
      </filename> was copied from <filename>/calc/trunk@340</filename> and
      that most recent automatic merge was the reintegrate merge we made
      from the branch to the trunk in r380.  Notice that the diagram does
      <emphasis>not</emphasis> show the four automatic sync merges we made
      in revisions 352, 362, 372, and 379.  Only the most recent automatic
      merge, in either direction<footnote><para>By <quote>direction</quote>
      we mean either trunk-to-branch (automatic sync) or branch-to-trunk
      (automatic reintegrate) merges.</para></footnote>, is shown.  This
      default output is useful for obtaining an overview of the merges
      between two branches, but to see the specific revisions which were
      merged we use the <option>--show-revs=merged</option> option:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs merged
r344
r345
r346
 
r366
r367
r368
</screen>
      </informalexample>

      <para>Likewise, to see which changes are eligible to merge from the
        trunk to the branch we can use the <option>--show-revs=eligible
        </option> option:</para>
      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r380
r381
r382
</screen>
      </informalexample>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.operativerevs">
        <title>Operative and Inoperative Merge Revisions</title>

        <para>The revision lists produced by the <option>--show-revs
          </option> option include only revisions which made (or would make)
          changes when merged.  So while we have merged a contiguous range of
          revisions (i.e. r341-378) from <filename>/calc/trunk</filename> to
          <filename>/calc/branches/my-calc-branch</filename>, only the
          revisions listed with the <option>--show-revs=merged</option> option
          actually represent changes made on <filename>/calc/trunk</filename>.
          These revisions are described as <quote>operative</quote>
          revisions as regards merging, not to be confused with the
          operative revision used with the <option>-r</option> option, see
          <xref linkend="svn.advanced.pegrevs"/>.  Not suprisingly, the
          revisions in the range r341-378 that are <emphasis>not</emphasis>
          listed as merged are termed <quote>inoperative</quote> revisions.
        </para>
      </sidebar>

      <para>The <command>svn mergeinfo</command> command requires
        a <quote>source</quote> URL (where the changes come
        from), and takes an optional <quote>target</quote> URL (where
        the changes merge to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we're querying our
        branch working copy, the command assumes we're interested in
        receiving changes to <filename>/calc/branches/my-calc-branch
        </filename> from the specified trunk URL.</para>

      <para>Since Subversion 1.7, the
        <command>svn mergeinfo</command> subcommand can also account for
        subtree mergeinfo and non-inheritable mergeinfo.  It accounts for
        subtree mergeinfo by use of the <option>--recursive</option> or
        <option>--depth</option> options, while non-inheritable mergeinfo
        is considered by default.</para>

      <sidebar id="svn.branchmerge.basicmerging.mergeinfo.inheritance">
        <title>Mergeinfo Inheritance</title>

        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>inheritance</secondary>
          </indexterm>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>explicit</secondary>
          </indexterm>When a path has
          the <literal>svn:mergeinfo</literal> property set on it we
          say it has <firstterm>explicit mergeinfo</firstterm>.  This
          explicit mergeinfo describes not only what changes were
          merged into that particular directory, but also all the
          children of that directory (because those children inherit
          the mergeinfo of their parent path).  For example:</para>

        <informalexample>
          <screen>
# What explicit mergeinfo exists on a branch?
$ svn propget svn:mergeinfo ^/branches/proj-X --recursive
/trunk:651-652

# What children does proj-X have?
$ svn list --recursive ^/branches/proj-X
doc/
doc/INSTALL
README
src/main.c

# Ask what revs were merged to a file with no explicit mergeinfo
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

        <para>Notice from our first subcommand that only the root of
          <filename>/branches/proj-X</filename> has any explicit
          mergeinfo.  However, when we use
          <command>svn mergeinfo</command> to ask what was merged to
          <filename>/branches/proj-X/src/main.c</filename> it reports
          that the two revisions described in the explicit mergeinfo
          on <filename>/branches/proj-X</filename> were merged.  This is
          because <filename>/branches/proj-X/src/main.c</filename>, having
          no explicit mergeinfo of its own, inherits the mergeinfo from
          its nearest parent with explicit mergeinfo,
          <filename>/branches/proj-X</filename>.</para>

        <para>There are two cases in which mergeinfo is not inherited.
          First, if a path has explicit mergeinfo, then it never inherits
          mergeinfo. Another way to think of this is that explicit
          mergeinfo is always a complete record of the merges to a given
          path. Once it exists it overrides any mergeinfo that path might
          otherwise inherit. The second way is when dealing with
          non-inheritable mergeinfo, a special type of explicit mergeinfo
          that applies <emphasis>only</emphasis> to the directory on which
          the <literal>svn:mergeinfo</literal> property is set (and it's
          only directories, non-inheritable mergeinfo is never set on
          files). For example:</para>

        <informalexample>
          <screen>
# The '*' decorator indicates non-inheritable mergeinfo
$ svn propget svn:mergeinfo ^/branches/proj-X
/trunk:651-652,758*

# Revision 758 is non-inheritable, but still applies to the path it is
# set on. Here the '*' decorator signals that r758 is only partially
# merged from trunk. 
$ svn mergeinfo ^/trunk ^/branches/proj-X --show-revs merged
651
652
758*

# Revision 758 is not reported as merged because it is non-inheritable
# and applies only to ^/trunk
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c \
                --show-revs merged
651
652
</screen>
        </informalexample>

        <para>You might never have to think about mergeinfo inheritance
          or encounter non-inheritable mergeinfo in your own repository.
          A discussion of the full ramifications of mergeinfo inheritance
          are beyond the scope of this book.  If you have more questions
          check out some of the references mentioned in
          <xref linkend="svn.branchmerge.advanced.finalword"/></para>
      </sidebar>

      <para>Let's say we have a branch with both subtree and
        non-inheritable mergeinfo:</para>

        <informalexample>
          <screen>
$ svn pg svn:mergeinfo -vR
# Non-inheritable mergeinfo
Properties on '.':
  svn:mergeinfo
    /calc/trunk:354,385-388*
# Subtree mergeinfo
Properties on 'Makefile':
  svn:mergeinfo
    /calc/trunk/Makefile:354,380
</screen>
        </informalexample>

      <para>From the above mergeinfo we see that r385-388 has only been
        merged into the root of the branch, but not any of the root's
        children.  We also see that r380 has only been merged to
        <filename>Makefile</filename>.
        When we use <command>svn mergeinfo</command> with the
        <option>--recursive</option> option to see what has been merged
        from <filename>/calc/trunk</filename> to this branch, we see three
        revisions are flagged with the <literal>*</literal> marker:</para>
      
        <informalexample>
          <screen>
$ svn mergeinfo -R --show-revs=merged ^/calc/trunk .
r354
r380*
r385
r386
r387*
r388*
</screen>
        </informalexample>

      <para>The <literal>*</literal> indicates revisions that are only
        <emphasis>partially</emphasis> merged to the target in question
        (the meaning is the same if we are checking for eligible
        revisions).  What this means in this example is that if we tried
        to merge r380, r387, or r388 from <filename>^/trunk</filename> then
        more changes would result. Likewise, because r354, r385 and r386 are
        <emphasis>not</emphasis> flagged with a <literal>*</literal>,
        we know that re-merging those revisions would have no result.
        <footnote><para>This is a good example of inoperative merge
        revisions.</para></footnote></para>

      <para>Another way to get a more precise preview of a merge
        operation is to use the <option>--dry-run</option>
        option:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk paint-feature-branch --dry-run
--- Merging r290 through r383 into 'paint-feature-branch':
U    paint-feature-branch/src/palettes.c
U    paint-feature-branch/src/brushes.c
U    paint-feature-branch/Makefile

$ svn status
#  nothing printed, working copy is still unchanged.
</screen>
      </informalexample>

      <para>The <option>--dry-run</option> option doesn't actually
        apply any local changes to the working copy.  It shows only
        status codes that <emphasis>would</emphasis> be printed in a
        real merge.  It's useful for getting a <quote>high-level</quote>
        preview of the potential merge, for those times
        when running <command>svn diff</command> gives too much
        detail.</para>

      <tip>
        <para>After performing a merge operation, but before
          committing the results of the merge, you can use
          <userinput>svn diff --depth=empty <replaceable>
          /path/to/merge/target</replaceable></userinput> to see only the
          changes to the immediate target of your merge.  If your merge
          target was a directory, only property differences are displayed.
          This is a handy way to see the changes to the
          <literal>svn:mergeinfo</literal> property recorded by the
          merge operation, which will remind you about what you've
          just merged.</para>
      </tip>

      <para>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <command>svn merge</command>
        isn't an inherently risky thing (unless you've made local
        modifications to your working copy but we already
        stressed that you shouldn't merge into such an
        environment).  If you don't like the results of the merge,
        simply run <userinput>svn revert . -R</userinput> to revert
        the changes from your working copy and retry the command with
        different options.  The merge isn't final until you
        actually <command>svn commit</command> the results.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.undo">
      <title>Undoing Changes</title>

      <para>An extremely common use for <command>svn merge</command>
        is to roll back a change that has already been committed.
        Suppose you're working away happily on a working copy of
        <filename>/calc/trunk</filename>, and you discover that the
        change made back in revision 392, which changed
        several code files, is completely wrong.  It never
        should have been committed.  You can use <command>svn
        merge</command> to <quote>undo</quote> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <emphasis>reverse</emphasis> difference.  (You can do this by
        specifying <option>--revision 392:391</option>, or by an
        equivalent <option>--change -392</option>.)</para>


      <informalexample>
        <screen>
$ svn merge ^/calc/trunk . -c-392
--- Reverse-merging r392 into '.':
U    src/real.c
U    src/main.c
U    src/button.c
U    src/integer.c
--- Recording mergeinfo for reverse merge of r392 into '.':
 U   .

$ svn st
M       src/button.c
M       src/integer.c
M       src/main.c
M       src/real.c

$ svn diff
 
# verify that the change is removed
 

$ svn commit -m "Undoing erroneous change committed in r392."
Sending        src/button.c
Sending        src/integer.c
Sending        src/main.c
Sending        src/real.c
Transmitting file data ....
Committed revision 399.
</screen>
      </informalexample>

      <para>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <option>-r</option> option, you can ask <command>svn
        merge</command> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <command>svn merge</command> to apply
        changeset r392 to our working copy
        <emphasis>backward</emphasis>.</para>

      <para>Keep in mind that rolling back a change like this is just
        like any other <command>svn merge</command> operation, so you
        should use <command>svn status</command> and <command>svn
        diff</command> to confirm that your work is in the state you
        want it to be in, and then use <command>svn commit</command>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <literal>HEAD</literal> revision.</para>

      <para>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 392.
        If somebody checks out a version of the
        <filename>calc</filename> project between revisions 392 and
        398, she'll still see the bad change, right?</para>

      <para>Yes, that's true.  When we talk about
        <quote>removing</quote> a change, we're really talking about
        removing it from the <literal>HEAD</literal> revision.  The
        original change still exists in the repository's history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <literal>HEAD</literal> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.<footnote><para>The
        Subversion project has plans, however, to someday implement a
        command that would accomplish the task of permanently deleting
        information.  In the meantime, see
        <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/> for a
        possible workaround.</para></footnote></para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.basicmerging.resurrect">
      <title>Resurrecting Deleted Items</title>

      <para>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <literal>HEAD</literal>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <quote>How
        do I get my old file or directory back?</quote></para>

      <para>The first step is to define
        exactly <emphasis>which</emphasis> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        is defined by a specific coordinate pair.  (Remember the
        <quote>peg revision</quote>
        syntax foo.c@224 mentioned back in
        <xref linkend="svn.advanced.pegrevs"/>.)</para>

      <para>First, you might need to use <command>svn log</command> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <userinput>svn log --verbose</userinput>
        in a directory that used to contain your deleted item.  The
        <option>--verbose</option> (<option>-v</option>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <command>grep</command>, or
        perhaps via an incremental search in an editor).  If you know that
        the item in question was recently deleted you might also use
        the <option>--limit</option> option to keep the log output brief
        enough to examine manually.</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn log -v --limit 3
------------------------------------------------------------------------
r401 | sally | 2013-02-19 23:15:44 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/main.c

Follow-up to r400: Fix typos in help text.
------------------------------------------------------------------------
r400 | bill | 2013-02-19 20:55:08 -0500 (Tue, 19 Feb 2013) | 4 lines
Changed paths:
   M /calc/trunk/src/main.c
   D /calc/trunk/src/real.c

* calc/trunk/src/main.c: Update help text.

* calc/trunk/src/real.c: Remove this file, none of the APIs
  implemented here are used anymore.
------------------------------------------------------------------------
r399 | sally | 2013-02-19 20:05:14 -0500 (Tue, 19 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/button.c
   M /calc/trunk/src/integer.c
   M /calc/trunk/src/main.c
   M /calc/trunk/src/real.c

Undoing erroneous change committed in r392.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>In the example, we're assuming that you're looking for a
        deleted file <filename>real.c</filename>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 400.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <filename>/calc/trunk/real.c</filename> from revision
        399.</para>

      <para>That was the hard part the research.  Now that you
        know what you want to restore, you have two different
        choices.</para>

      <para>One option is to use <command>svn merge</command> to apply
        revision 400 <quote>in reverse.</quote> (We already
        discussed how to undo changes in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.)  This
        would have the effect of re-adding <filename>real.c</filename>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <literal>HEAD</literal>.</para>

      <para>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 400 would not
        only schedule <filename>real.c</filename> for addition, but
        the log message indicates that it would also undo certain
        changes to <filename>main.c</filename>, which you don't
        want.  Certainly, you could reverse-merge revision 400 and
        then <command>svn revert</command> the local modifications to
        <filename>main.c</filename>, but this technique doesn't
        scale well.  What if 90 files were changed in revision
        400?</para>

      <para>A second, more targeted strategy is not to use
        <command>svn merge</command> at all, but rather to use the
        <command>svn copy</command> command.  Simply copy the exact
        revision and path <quote>coordinate pair</quote> from the
        repository to your working copy:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ./real.c
A         real.c

$ svn st
A  +    real.c

# Commit the resurrection.
 
</screen>
      </informalexample>

      <para>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition <quote>with history.</quote>  Subversion remembers
        where it was copied from.  In the future, running <command>svn
        log</command> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 399.  In other words, this new
        <filename>real.c</filename> isn't really new; it's a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <emphasis>without</emphasis>
        maintaining a historical link to the old file, this technique
        works just as well:</para>

      <informalexample>
        <screen>
$ svn cat ^/calc/trunk/src/real.c@399 &gt; ./real.c

$ svn add real.c
A         real.c

# Commit the resurrection.
 
</screen>
      </informalexample>

      <para>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn't
        have to happen in your working copy it can happen
        entirely in the repository:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk/src/real.c@399 ^/calc/trunk/src/real.c \
           -m "Resurrect real.c from revision 399."

Committed revision 402.

$ svn up
Updating '.':
A    real.c
Updated to revision 402.
</screen>
      </informalexample>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.advanced">
    <title>Advanced Merging</title>

    <para>Here ends the automated magic.  Sooner or later, once you
      get the hang of branching and merging, you're going to have to
      ask Subversion to merge <emphasis>specific</emphasis> changes
      from one place to another.  To do this, you're going to
      have to start passing more complicated arguments to <command>svn
      merge</command>.  The next section describes the fully expanded
      syntax of the command and discusses a number of common
      scenarios that require it.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.cherrypicking">
      <title>Cherrypicking</title>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>cherrypicking</secondary>
        </indexterm>Just as the term <quote>changeset</quote> is often used in
        version control systems, so is the term
        <firstterm>cherrypicking</firstterm>.  This word refers to
        the act of choosing <emphasis>one</emphasis> specific
        changeset from a branch and replicating it to another.
        Cherrypicking may also refer to the act of duplicating a
        particular set of (not necessarily contiguous!) changesets
        from one branch to another.  This is in contrast to more
        typical merging scenarios, where the <quote>next</quote>
        contiguous range of revisions is duplicated
        automatically.</para>

      <para>Why would people want to replicate just a single change?
        It comes up more often than you'd think.  For example, let's
        assume you've created a new feature branch <filename>
        /calc/branches/my-calc-feature-branch</filename> copied from
        <filename>/calc/trunk</filename>:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/new-calc-feature-branch -v -r403
------------------------------------------------------------------------
r403 | user | 2013-02-20 03:26:12 -0500 (Wed, 20 Feb 2013) | 1 line
Changed paths:
   A /calc/branches/new-calc-feature-branch (from /calc/trunk:402)

Create a new calc branch for Feature 'X'.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>At the water cooler, you get word that Sally made an interesting
        change to <filename>main.c</filename> on the trunk.
        Looking over the history of commits to the trunk, you see that
        in revision 413 she fixed a critical bug that directly
        impacts the feature you're working on.  You might not be ready
        to merge all the trunk changes to your branch just yet, but
        you certainly need that particular bug fix in order to continue
        your work.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/trunk -r413 -v
------------------------------------------------------------------------
r413 | sally | 2013-02-21 01:57:51 -0500 (Thu, 21 Feb 2013) | 3 lines
Changed paths:
   M /calc/trunk/src/main.c

Fix issue #22 'Passing a null value in the foo argument
of bar() should be a tolerated, but causes a segfault'.
------------------------------------------------------------------------

$ svn diff ^/calc/trunk -c413
Index: src/main.c
===================================================================
--- src/main.c  (revision 412)
+++ src/main.c  (revision 413)
@@ -34,6 +34,7 @@
 
# Details of the fix
 
</screen>
      </informalexample>

      <para>Just as you used <command>svn diff</command> in the prior
        example to examine revision 413, you can pass the same option
        to <command>svn merge</command>:</para>

      <informalexample>
        <screen>
$ cd new-calc-feature-branch

$ svn merge ^/calc/trunk -c413
--- Merging r413 into '.':
U    src/main.c
--- Recording mergeinfo for merge of r413 into '.':
 U   .

$ svn st
 M      .
M       src/main.c
</screen>
      </informalexample>

      <para>You can now go through the usual testing procedures before
        committing this change to your branch.  After the commit,
        Subversion updates the <literal>svn:mergeinfo</literal> on your
        branch to reflect that r413 was been merged to the branch.  This
        prevents future automatic sync merges from attempting to merge
        r413 again.  (Merging the same change to the same branch almost
        always results in a conflict!) Notice also the mergeinfo <literal>
        /calc/branches/my-calc-branch:341-379</literal>.  This was
        recorded during the earlier reintegrate merge to <filename>
        /calc/trunk</filename> from the <filename>
        /calc/branches/my-calc-branch</filename> branch which we made in
        r380.  When we created the <filename>my-calc-branch</filename>
        branch in r403, this mergeinfo was carried along with the copy.
        </para>

      <informalexample>
        <screen>
$ svn pg svn:mergeinfo -v
Properties on '.':
  svn:mergeinfo
    /calc/branches/my-calc-branch:341-379
    /calc/trunk:413
</screen>
      </informalexample>

      <para>Notice too that the <command>mergeinfo</command> doesn't list r413
        as "eligible" to merge, because it's already been merged:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r404
r405
r406
r407
r409
r410
r411
r412
r414
r415
r416
 
r455
r456
r457
</screen>
      </informalexample>

      <para>The preceding means that when the time finally comes to do an
        automatic sync merge, Subversion breaks the merge into two parts.
        First it merges all eligible merges up to revision 412.  Then it
        merges all eligible revisions from revisions 414 to the <literal>HEAD
        </literal> revision.  Because we already cherrypicked r413, that
        change is skipped:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk
--- Merging r403 through r412 into '.':
U    doc/INSTALL
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
--- Merging r414 through r458 into '.':
G    doc/INSTALL
G    src/main.c
G    src/integer.c
G    Makefile
--- Recording mergeinfo for merge of r403 through r458 into '.':
 U   .
</screen>
      </informalexample>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>backporting</secondary>
        </indexterm>This use case of replicating
        (or <firstterm>backporting</firstterm>) bug fixes from one
        branch to another is perhaps the most popular reason for
        cherrypicking changes; it comes up all the time, for example,
        when a team is maintaining a <quote>release branch</quote> of
        software.  (We discuss this pattern in
        <xref linkend="svn.branchmerge.commonpatterns.release"/>.)</para>

      <warning>
        <para>Did you notice how, in the last example, the merge
          invocation merged two distinct ranges?
          The <command>svn merge</command> command applied
          two independent patches to your working copy to skip over
          changeset 413, which your branch already contained.  There's
          nothing inherently wrong with this, except that it has the
          potential to make conflict resolution trickier.  If the
          first range of changes creates conflicts,
          you <emphasis>must</emphasis> resolve them interactively for
          the merge process to continue and apply the second range of
          changes.  If you postpone a conflict from the first wave of
          changes, the whole merge command will bail out with an error
          message and you must resolve the conflict before running the
          merge a second time to get the remainder of the changes.</para>
      </warning>

      <para>A word of warning: while <command>svn diff</command> and
        <command>svn merge</command> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in <xref linkend="svn.ref.svn"/> for details, or ask
        <command>svn help</command>.  For example, <command>svn
        merge</command> requires a working copy path as a target, that is,
        a place where it should apply the generated patch.  If the
        target isn't specified, it assumes you are trying to perform
        one of the following common operations:</para>

      <itemizedlist>
        <listitem>
          <para>You want to merge directory changes into your current
            working directory.</para>
        </listitem>
        <listitem>
          <para>You want to merge the changes in a specific file into
            a file by the same name that exists in your current working
            directory.</para>
        </listitem>
      </itemizedlist>

      <para>If you are merging a directory and haven't specified a
        target path, <command>svn merge</command> assumes the first
        case and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a
        file by the same name) exists in your current working
        directory,
        <command>svn merge</command> assumes the second case and tries
        to apply the changes to a local file with the same name.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.advancedsyntax">
      <title>Merge Syntax: Full Disclosure</title>

      <para>You've now seen some examples of the <command>svn
        merge</command> command, and you're about to see several more.
        If you're feeling confused about exactly how merging works,
        you're not alone.  Many users (especially those new to version
        control) are initially perplexed about the proper syntax of
        the command and about how and when the feature should be
        used.  But fear not, this command is actually much simpler
        than you think!  There's a very easy technique for
        understanding exactly how <command>svn merge</command>
        behaves.</para>

      <para>The main source of confusion is the
        <emphasis>name</emphasis> of the command.  The term
        <quote>merge</quote> somehow denotes that branches are
        combined together, or that some sort of mysterious
        blending of data is going on.  That's not the case.  A better
        name for the command might have been <command>svn
        diff-and-apply</command>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</para>

      <para>If you're using <command>svn merge</command> to do basic
        copying of changes between branches, an automatic merge will
        generally do the right thing.  For example, a command such as the
        following,</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/some-branch
</screen>
      </informalexample>

      <para>will attempt to duplicate any changes made
        on <filename>some-branch</filename> into your current working
        directory, which is presumably a working copy that shares some
        historical connection to the branch.  The command is smart
        enough to only duplicate changes that your working copy
        doesn't yet have.  If you repeat this command once a week, it
        will only duplicate the <quote>newest</quote> branch changes
        that happened since you last merged.</para>

      <para>If you choose to use the <command>svn merge</command>
        command in all its full glory by giving it specific revision
        ranges to duplicate, the command takes three main
        arguments:</para>

      <orderedlist>
        <indexterm>
          <primary>merging</primary>
          <secondary>left side</secondary>
        </indexterm>
        <indexterm>
          <primary>merging</primary>
          <secondary>right side</secondary>
        </indexterm>
        <indexterm>
          <primary>merging</primary>
          <secondary>target</secondary>
        </indexterm>

        <listitem>
          <para>An initial repository tree (often called the
            <firstterm>left side</firstterm> of the comparison)</para>
        </listitem>
        <listitem>
          <para>A final repository tree (often called the
            <firstterm>right side</firstterm> of the
            comparison)</para>
        </listitem>
        <listitem>
          <para>A working copy to accept the differences as local
            changes (often called the <firstterm>target</firstterm> of
            the merge)</para>
        </listitem>
      </orderedlist>

      <para>Once these three arguments are specified, then the two trees
        are compared and the differences applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files or run various <command>svn
        add</command> or <command>svn delete</command> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <command>svn
        revert</command> all of the changes.</para>

      <para>The syntax of <command>svn merge</command> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</para>

      <informalexample>
        <screen>
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</screen>
      </informalexample>

      <para>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <emphasis>URL@REV</emphasis> and
        naming the working copy target.  The second syntax is used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.
        <indexterm>
          <primary>merging</primary>
          <secondary>2-URL</secondary>
        </indexterm> This type of merge is referred to (for obvious
        reasons) as a <quote>2-URL</quote> merge. The last syntax shows
        how the working copy argument is optional; if omitted, it
        defaults to the current directory.</para>

      <para>While the first example shows the <quote>full</quote>
        syntax of <command>svn merge</command>, use it
        very carefully;  it can result in merges which do not record
        any <literal>svn:mergeinfo</literal> metadata at all.  The
        next section talks a bit more about this.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.nomergedata">
      <title>Merges Without Mergeinfo</title>

      <para>Subversion tries to generate merge metadata whenever it
        can, to make future invocations of <command>svn
        merge</command> smarter.  There are still situations, however,
        where <literal>svn:mergeinfo</literal> data is not created or
        changed.  Remember to be a bit wary of these scenarios:</para>

      <variablelist>
        <varlistentry>
          <term>Merging unrelated sources</term>
          <listitem>
            <para>If you ask <command>svn merge</command> to compare
              two URLs that aren't related to each other, a patch is
              still generated and applied to your working copy, but
              no merging metadata is created.  There's no common
              history between the two sources, and
              future <quote>smart</quote> merges depend on that common
              history.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Merging from foreign repositories</term>
          <listitem>
            <para>While it's possible to run a command such
              as <userinput>svn merge -r 100:200
              <replaceable>http://svn.foreignproject.com/repos/trunk</replaceable></userinput>,
              the resultant patch also lacks any historical merge
              metadata.  At the time of this writing, Subversion has no
              way of representing different repository URLs within
              the <literal>svn:mergeinfo</literal> property.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Using <option>--ignore-ancestry</option></term>
          <listitem>
            <para>If this option is passed to <command>svn
              merge</command>, it causes the merging logic to
              mindlessly generate differences the same way
              that <command>svn diff</command> does, ignoring any
              historical relationships.  We discuss this later in this
              chapter in
              <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Applying reverse merges from a target's natural history</term>
          <listitem>
            <para>Earlier in this chapter
              (<xref linkend="svn.branchmerge.basicmerging.undo"/>) we
              discussed how to use <command>svn merge</command> to
              apply a <quote>reverse patch</quote> as a way of rolling
              back changes.  If this technique is used to undo a
              change to an object's personal history (e.g., commit r5
              to the trunk, then immediately roll back r5
              using <userinput>svn merge . -c -5</userinput>), this
              sort of merge doesn't affect the recorded
              mergeinfo.<footnote><para>Interestingly, after rolling
              back a revision like this, we wouldn't be able to
              reapply the revision using <userinput>svn merge . -c
              5</userinput>, since the mergeinfo would already list r5
              as being applied.  We would have to use
              the <option>--ignore-ancestry</option> option to make
              the merge command ignore the existing
              mergeinfo!</para></footnote></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <!-- TODO: We might need to introduce a glossary of merge
                 tracking terms into this chapter.  Here we use
                 "mergeinfo" to help defined "natural history", but
                 we've not really defined "mergeinfo" either.  -->

      <sidebar id="svn.branchmerge.nomergedata.impicit.mergeinfo">
        <title>Natural History and Implicit Mergeinfo</title>

        <para>
          <indexterm>
            <primary>mergeinfo</primary>
            <secondary>implicit</secondary>
          </indexterm>
          <indexterm>
            <primary>natural history</primary>
            <see>mergeinfo, implicit</see>
          </indexterm>As we mentioned earlier when discussing
          <xref linkend="svn.branchmerge.basicmerging.mergeinfo.inheritance"/>,
          a path that has the
          <literal>svn:mergeinfo</literal> property set on it is said to
          have <quote>explicit</quote> mergeinfo.  Yes, this implies a
          path can have <quote>implicit</quote> mergeinfo, too!  Implicit
          mergeinfo, or <firstterm>natural history</firstterm>, is
          simply a path's own history (see
          <xref linkend="svn.tour.history" />) interpreted as mergeinfo.
          While implicit mergeinfo is largely
          an implementation detail, it can be a useful abstraction for
          understanding merge tracking behavior.</para>

        <para>Let's say you created <filename>^/trunk</filename> in
          revision 100 and then later, in revision 201,
          created <filename>^/branches/feature-branch</filename> as
          a copy of <filename>^/trunk@200</filename>.  The natural
          history of <filename>^/branches/feature-branch</filename>
          contains all the repository paths and revision ranges
          through which the history of the new branch has ever
          passed:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201
</literallayout>
        </informalexample>

        <para>With each new revision added to the repository, the
          natural history and thus, implicit mergeinfo of
          the branch continues to expand to include those revisions
          until the day the branch is deleted.  Here's what the
          implicit mergeinfo of our branch would look like when
          the <literal>HEAD</literal> revision of the repository had
          grown to 234:</para>

        <informalexample>
          <literallayout>
/trunk:100-200
/branches/feature-branch:201-234
</literallayout>
        </informalexample>

        <para>Implicit mergeinfo does not actually show up in the
          <literal>svn:mergeinfo</literal> property, but Subversion
          acts as if it does.  This is why if you check out
          <filename>^/branches/feature-branch</filename> and then
          run <userinput>svn merge ^/trunk -c 58</userinput> in the
          resulting working copy, nothing happens.  Subversion knows
          that the changes committed to <filename>^/trunk</filename>
          in revision 58 are already present in the target's natural
          history, so there's no need to try to merge them again.
          After all, avoiding repeated merges of
          changes <emphasis>is</emphasis> the primary goal of
          Subversion's merge tracking feature!</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.mergeconflicts">
      <title>More on Merge Conflicts</title>

      <para>Just like the <command>svn update</command> command,
        <command>svn merge</command> applies changes to your working
        copy.  And therefore it's also capable of creating
        conflicts.  The conflicts produced by <command>svn
          merge</command>, however, are sometimes different, and this
        section explains those differences.</para>

      <para>To begin with, assume that your working copy has no
        local edits.  When you <command>svn update</command> to a
        particular revision, the changes sent by the server
        always apply <quote>cleanly</quote> to your working copy.
        The server produces the delta by comparing two trees: a
        virtual snapshot of your working copy, and the revision tree
        you're interested in.  Because the left hand side of the
        comparison is exactly equal to what you already have, the
        delta is guaranteed to correctly convert your working copy
        into the right hand tree.</para>

      <para>But <command>svn merge</command> has no such guarantees
        and can be much more chaotic: the advanced user can ask the
        server to compare <emphasis>any</emphasis> two trees at all,
        even ones that are unrelated to the working copy!  This means
        there's large potential for human error.  Users will sometimes
        compare the wrong two trees, creating a delta that doesn't
        apply cleanly. The <command>svn merge</command> subcommand does
        its best to apply as much of the delta as possible, but some
        parts may be impossible. A common sign that you merged the wrong
        delta is unexpected tree conflicts:</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/trunk -r104:115
--- Merging r105 through r115 into '.':
   C doc
   C src/button.c
   C src/integer.c
   C src/real.c
   C src/main.c
--- Recording mergeinfo for merge of r105 through r115 into '.':
 U   .
Summary of conflicts:
  Tree conflicts: 5

$ svn st
 M      .
!     C doc
      >   local dir missing, incoming dir edit upon merge
!     C src/button.c
      >   local file missing, incoming file edit upon merge
!     C src/integer.c
      >   local file missing, incoming file edit upon merge
!     C src/main.c
      >   local file missing, incoming file edit upon merge
!     C src/real.c
      >   local file missing, incoming file edit upon merge
Summary of conflicts:
  Tree conflicts: 5
</screen>
      </informalexample>

      <para>In the previous example, it might be the case that
        <filename>doc</filename> and the four <filename>*.c</filename>
        files all exist in both snapshots of the
        branch being compared.  The resultant delta wants to change
        the contents of the corresponding paths in your working copy,
        but those paths don't exist in the working copy.  Whatever the
        case, the preponderance of tree conflicts most likely means that
        the user compared the wrong two trees or that you are merging to
        the wrong working copy target; both are classic signs of user
        error.  When this happens, it's easy to recursively revert all
        the changes created by the merge
        (<userinput>svn revert . --recursive</userinput>), delete any
        unversioned files or directories left behind after the
        revert, and rerun <command>svn merge</command> with the
        correct arguments.</para>

      <para>Also keep in mind that a merge into a working copy with no
        local edits can still produce text conflicts.</para>

      <informalexample>
        <screen>
$ svn st

$ svn merge ^/paint/trunk -r289:291
--- Merging r290 through r291 into '.':
C    Makefile
--- Recording mergeinfo for merge of r290 through r291 into '.':
 U   .
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'Makefile'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: p

$ svn st
 M      .
C       Makefile
?       Makefile.merge-left.r289
?       Makefile.merge-right.r291
?       Makefile.working
Summary of conflicts:
  Text conflicts: 1
</screen>
      </informalexample>

      <para>How can a conflict possibly happen?  Again, because the user
        can request <command>svn merge</command> to define and apply any
        old delta to the working copy, that delta may contain textual
        changes that don't cleanly apply to a working file, even if
        the file has no local modifications.</para>

      <para>Another small difference between <command>svn
        update</command> and <command>svn merge</command> is the names
        of the full-text files created when a conflict happens.  In
        <xref linkend="svn.tour.cycle.resolve"/>, we saw that an
        update produces files named
        <filename>filename.mine</filename>,
        <filename>filename.rOLDREV</filename>, and
        <filename>filename.rNEWREV</filename>.  When <command>svn
        merge</command> produces a conflict, though, it creates three
        files named <filename>filename.working</filename>,
        <filename>filename.merge-left.rOLDREV</filename>, and
        <filename>filename.merge-right.rNEWREV</filename>.  In this case,
        the terms <quote>merge-left</quote> and <quote>merge-right</quote>
        are describing which side of the double-tree comparison the file
        came from, <quote>rOLDREV</quote> describes the revision of the
        left side, and <quote>rNEWREV</quote> the revision of the right
        side. In any case, these differing names help you distinguish
        between conflicts that happened as a result of an  update and
        ones that happened as a result of a merge.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.blockchanges">
      <title>Blocking Changes</title>

      <para>Sometimes there's a particular changeset that you don't
        want automatically merged.  For example, perhaps your
        team's policy is to do new development work on
        <filename>/trunk</filename>, but is more conservative about
        backporting changes to a stable branch you use for releasing
        to the public.  On one extreme, you can manually cherrypick
        single changesets from the trunk to the branch just the
        changes that are stable enough to pass muster.  Maybe things
        aren't quite that strict, though; perhaps most of the time
        you just let <command>svn merge</command>
        automatically merge most changes from trunk to branch.  In
        this case, you want a way to mask a few specific changes
        out, that is, prevent them from ever being automatically
        merged.</para>

      <para>To block a changeset you must make Subversion believe that the
        change has <emphasis>already</emphasis> been merged.  To do this,
        invoke the merge subcommand with the <option>--record-only</option>
        option.  The option makes Subversion record mergeinfo as if it had
        actually performed the merge, but no difference is actually
        applied:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn merge ^/calc/trunk -r386:388 --record-only
--- Recording mergeinfo for merge of r387 through r388 into '.':
 U   .

# Only the mergeinfo is changed
$ svn st
 M      .

$ svn pg svn:mergeinfo -vR
Properties on '.':
  svn:mergeinfo
    /calc/trunk:341-378,387-388

$ svn commit -m "Block r387-388 from being merged to my-calc-branch."
Sending        .

Committed revision 461.
</screen>
      </informalexample>

      <para>Since Subversion 1.7, <option>--record-only</option>
        merges are transitive.  This means that, in addition to recording
        mergeinfo describing the blocked revision(s), any
        <literal>svn:mergeinfo</literal> property differences in the
        merge source are also applied.  For example, let's say we want to
        block the 'paint-python-wrapper' feature from ever being merged from
        <filename>^/paint/trunk</filename> to the
        <filename>^/paint/branches/paint-1.0.x</filename> branch.  We know
        the work on this feature was done on its own branch, which was
        reintegrated to <filename>/paint/trunk</filename> in revision
        465:</para>
      
      <informalexample>
        <screen>
$ svn log -v -r465 ^/paint/trunk
------------------------------------------------------------------------
r465 | joe | 2013-02-25 14:05:12 -0500 (Mon, 25 Feb 2013) | 1 line
Changed paths:
   M /paint/trunk
   A /paint/trunk/python (from /paint/branches/paint-python-wrapper/python:464)

Reintegrate Paint Python wrapper.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Because revision 465 was a reintegrate merge we know
        that mergeinfo was recorded describing the merge:</para>

      <informalexample>
        <screen>
$ svn diff ^/paint/trunk --depth empty -c465
Index: .
===================================================================
--- .   (revision 464)
+++ .   (revision 465)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
</screen>
      </informalexample>

      <para>Now simply blocking merges of revision 465 from
        <filename>/paint/trunk</filename> isn't foolproof since someone could
        merge r462:464 directly from
        <filename>/paint/branches/paint-python-wrapper</filename>.
        Fortunately the transitive nature
        of <option>--record-only</option> merges prevents this; the
        <option>--record-only</option> merge
        applies the <literal>svn:mergeinfo</literal> diff from
        revision 465, thus blocking merges of that change directly from
        <filename>/paint/trunk</filename> <emphasis>and</emphasis> indirectly
        from <filename>/paint/branches/paint-python-wrapper</filename>:
        </para>

      <informalexample>
        <screen>
$ cd paint/branches/paint-1.0.x

$ svn merge ^/paint/trunk --record-only -c465
--- Merging r465 into '.':
 U   .
--- Recording mergeinfo for merge of r465 into '.':
 G   .

$ svn diff --depth empty
Index: .
===================================================================
--- .   (revision 462)
+++ .   (working copy)

Property changes on: .
___________________________________________________________________
Added: svn:mergeinfo
   Merged /paint/branches/paint-python-wrapper:r463-464
   Merged /paint/trunk:r465

$ svn ci -m "Block the Python wrappers from the first release of paint."
Sending        .

Committed revision 466.
</screen>
      </informalexample>

      <para>Now any subsequent attempts to merge the feature to <filename>
        /paint/trunk</filename> are inoperative:</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465
--- Recording mergeinfo for merge of r465 into '.':
 U   .

$ svn st # No change!

$ svn merge ^/paint/branches/paint-python-wrapper -r462:464
--- Recording mergeinfo for merge of r463 through r464 into '.':
 U   .

$ svn st  # No change!

$
</screen>
      </informalexample>

      <para>If at a later time you realize that you actually <emphasis>do
        </emphasis> need the blocked feature merged to <filename>/paint/trunk
        </filename> you have a couple of choices.  You can reverse merge r466,
        (the revision you blocked the feature), as we discussed in
        <xref linkend="svn.branchmerge.basicmerging.undo"/>.  Once you commit
        that change you can repeat the merge of r465 from <filename>
        /paint/trunk</filename>.  Alternatively, you can simply repeat the
        merge of r465 from <filename>/paint/trunk</filename> using the
        <option>--ignore-ancestry</option> option, which will cause the merge
        to disregard any mergeinfo and simply apply the requested diff, see
        <xref linkend="svn.branchmerge.advanced.ancestry"/>.</para>

      <informalexample>
        <screen>
$ svn merge ^/paint/trunk -c465 --ignore-ancestry
--- Merging r465 into '.':
A    python
A    python/paint.py
 G   .
</screen>
      </informalexample>

      <para>Blocking changes with <option>--record-only</option>
        works, but it's also a little bit
        dangerous.  The main problem is that we're not clearly
        differentiating between the ideas of <quote>I already have
        this change</quote> and <quote>I don't have this change, but
        don't currently want it.</quote> We're effectively lying to
        the system, making it think that the change was previously
        merged.  This puts the responsibility on you the
        user to remember that the change wasn't actually merged,
        it just wasn't wanted.  There's no way to ask Subversion for a
        list of <quote>blocked changelists.</quote> If you want to
        track them (so that you can unblock them someday) you'll need
        to record them in a text file somewhere, or perhaps in an
        invented property.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.logblame">
      <title>Merge-Sensitive Logs and Annotations</title>

      <para>One of the main features of any version control system is
        to keep track of who changed what, and when they did it.
        The <command>svn log</command> and <command>svn
        blame</command> subcommands are just the tools for this: when
        invoked on individual files, they show not only the history of
        changesets that affected the file, but also exactly which user
        wrote which line of code, and when she did it.</para>

      <para>When changes start getting replicated between branches,
        however, things start to get complicated.  For example, if you
        were to ask <command>svn log</command> about the history of
        your feature branch, it would show exactly every revision that ever
        affected the branch:</para>

      <informalexample>
        <screen>
$ cd my-calc-branch

$ svn log -q
------------------------------------------------------------------------
r461 | user | 2013-02-25 05:57:48 -0500 (Mon, 25 Feb 2013)
------------------------------------------------------------------------
r379 | user | 2013-02-18 10:56:35 -0500 (Mon, 18 Feb 2013)
------------------------------------------------------------------------
r378 | user | 2013-02-18 09:48:28 -0500 (Mon, 18 Feb 2013)
------------------------------------------------------------------------
 
------------------------------------------------------------------------
r8 | sally | 2013-01-17 16:55:36 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
r7 | bill | 2013-01-17 16:49:36 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
r3 | bill | 2013-01-17 09:07:04 -0500 (Thu, 17 Jan 2013)
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>But is this really an accurate picture of all the changes
        that happened on the branch?  What's left out here is
        the fact that revisions 352, 362, 372 and 379 were actually the
        results of merging changes from the trunk.  If you look at one
        of these logs in detail, the multiple trunk changesets that
        comprised the branch change are nowhere to be seen:</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v
------------------------------------------------------------------------
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>We happen to know that this merge to the branch was
        nothing but a merge of trunk changes.  How can we see those
        trunk changes as well?  The answer is to use the
        <option>--use-merge-history</option> (<option>-g</option>)
        option.  This option expands those <quote>child</quote>
        changes that were part of the merge.</para>

      <informalexample>
        <screen>
$ svn log ^/calc/branches/my-calc-branch -r352 -v -g
------------------------------------------------------------------------
r352 | user | 2013-02-16 09:35:18 -0500 (Sat, 16 Feb 2013) | 1 line
Changed paths:
   M /calc/branches/my-calc-branch
   M /calc/branches/my-calc-branch/Makefile
   M /calc/branches/my-calc-branch/doc/INSTALL
   M /calc/branches/my-calc-branch/src/button.c
   M /calc/branches/my-calc-branch/src/real.c

Sync latest trunk changes to my-calc-branch.
------------------------------------------------------------------------
r351 | sally | 2013-02-16 08:04:22 -0500 (Sat, 16 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/src/real.c
Merged via: r352

Trunk work on calc project.
------------------------------------------------------------------------
 
------------------------------------------------------------------------
r345 | sally | 2013-02-15 16:51:17 -0500 (Fri, 15 Feb 2013) | 2 lines
Changed paths:
   M /calc/trunk/Makefile
   M /calc/trunk/src/integer.c
Merged via: r352

Trunk work on calc project.
------------------------------------------------------------------------
r344 | sally | 2013-02-15 16:44:44 -0500 (Fri, 15 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c
Merged via: r352

Refactor the bazzle functions.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>By making the log operation use merge history, we see not
        just the revision we queried (r352), but also the other revisions
        that came along on the ride with it Sally's work on trunk.
        This is a much more complete picture of history!</para>

      <para>The <command>svn blame</command> command also takes the
        <option>--use-merge-history</option> (<option>-g</option>)
        option.  If this option is neglected, somebody looking at
        a line-by-line annotation of <filename>Makefile</filename> may
        get the mistaken impression that you were responsible for a
        particular change:</para>

      <informalexample>
        <screen>
$ svn blame src/button.c
 
   352    user    retval = inverse_func(button, path);
   352    user    return retval;
   352    user    }
 
</screen>
      </informalexample>

      <para>And while it's true that you did actually commit those
        three lines in revision 352, two of them were actually written
        by Sally back in revision 348 and were brought into your branch
        via a sync merge:</para>

      <informalexample>
        <screen>
$ svn blame button.c -g
 
G    348    sally   retval = inverse_func(button, path);
G    348    sally   return retval;
     352    user    }
 
</screen>
      </informalexample>

      <para>Now we know who to <emphasis>really</emphasis> blame for
        those two lines of code!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.ancestry">
      <title>Noticing or Ignoring Ancestry</title>

      <para>
        <indexterm>
          <primary>ancestry</primary>
        </indexterm>When conversing with a Subversion developer, you
        might very likely hear reference to the term
        <firstterm>ancestry</firstterm>.  This word is used to
        describe the relationship between two objects in a
        repository: if they're related to each other, one
        object is said to be an ancestor of the other.</para>

      <para>For example, suppose you commit revision 100, which
        includes a change to a file <filename>foo.c</filename>.
        Then <filename>foo.c@99</filename> is an
        <quote>ancestor</quote> of <filename>foo.c@100</filename>.
        On the other hand, suppose you commit the deletion of
        <filename>foo.c</filename> in revision 101, and then add a
        new file by the same name in revision 102.  In this case,
        <filename>foo.c@99</filename> and
        <filename>foo.c@102</filename> may appear to be related
        (they have the same path), but in fact are completely
        different objects in the repository.  They share no history
        or <quote>ancestry.</quote></para>

      <para>The reason for bringing this up is to point out an
        important difference between <command>svn diff</command> and
        <command>svn merge</command>.  The former command ignores
        ancestry, while the latter command is quite sensitive to it.
        For example, if you asked <command>svn diff</command> to
        compare revisions 99 and 102 of <filename>foo.c</filename>,
        you would see line-based diffs; the <command>diff</command>
        command is blindly comparing two paths.  But if you asked
        <command>svn merge</command> to compare the same two objects,
        it would notice that they're unrelated and first attempt to
        delete the old file, then add the new file;  the output would
        indicate a deletion followed by an add:</para>

      <informalexample>
        <screen>
D    foo.c
A    foo.c
</screen>
      </informalexample>

      <para>Most merges involve comparing trees that are ancestrally
        related to one another; therefore, <command>svn
        merge</command> defaults to this behavior.  Occasionally,
        however, you may want the <command>merge</command> command to
        compare two unrelated trees.  For example, you may have
        imported two source-code trees representing different vendor
        releases of a software project (see
        <xref linkend="svn.advanced.vendorbr"/>).  If you ask
        <command>svn merge</command> to compare the two trees, you'd
        see the entire first tree being deleted, followed by an add
        of the entire second tree!  In these situations, you'll want
        <command>svn merge</command> to do a path-based comparison
        only, ignoring any relations between files and directories.
        Add the <option>--ignore-ancestry</option> option to your
        <command>merge</command> command, and it will behave just
        like <command>svn diff</command>.  (And conversely, the
        <option>--notice-ancestry</option> option will cause
        <command>svn diff</command> to behave like the
        <command>svn merge</command> command.)</para>

      <tip>
        <para>
        <indexterm>
          <primary>merge tracking</primary>
          <secondary>disabling</secondary>
        </indexterm>
        The <option>--ignore-ancestry</option> option also disables
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This means that <literal>svn:mergeinfo</literal> is not considered
        when <command>svn merge</command> is determining what revisions
        to merge, nor is <literal>svn:mergeinfo</literal> recorded to
        describe the merge.</para>
      </tip>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.moves">
      <title>Merges and Moves</title>

      <para>A common desire is to refactor source code, especially
        in Java-based software projects.  Files and directories are
        shuffled around and renamed, often causing great disruption
        to everyone working on the project.  Sounds like a perfect
        case to use a branch, doesn't it?  Just create a branch,
        shuffle things around, and then merge the branch back to the
        trunk, right?</para>

      <para>Alas, this scenario doesn't work so well right now and
        is considered one of Subversion's current weak spots.  The
        problem is that Subversion's <command>svn merge</command>
        command isn't as robust as it should be, particularly when
        dealing with copy and move operations.</para>

      <para>When you use <command>svn copy</command> to duplicate a
        file, the repository remembers where the new file came from,
        but it fails to transmit that information to the client which
        is running <command>svn update</command> or <command>svn
        merge</command>.  Instead of telling the client, <quote>Copy
        that file you already have to this new location,</quote> it
        sends down an entirely new file.  This can lead to
        problems, particularly tree conflicts in the case of renames,
        which involve not only the new copy, but a deletion of the old
        path a lesser-known fact about Subversion is that
        it lacks <quote>true renames</quote> the <command>svn
        move</command> command is nothing more than an aggregation
        of <command>svn copy</command> and <command>svn
        delete</command>.</para>

      <para>For example, suppose that you want to make some changes on
        your private branch <filename>/calc/branch/my-calc-branch
        </filename>.  First you perform an automatic sync merge with
        <filename>/calc/trunk</filename> and commit that in r470:</para>

      <informalexample>
        <screen>
$ cd calc/trunk

$ svn merge ^/calc/trunk
--- Merging differences between repository URLs into '.':
U    doc/INSTALL
A    FAQ
U    src/main.c
U    src/button.c
U    src/integer.c
U    Makefile
U    README
 U   .
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .

$ svn ci -m "Sync all changes from ^/calc/trunk through r469."
Sending        .
Sending        Makefile
Sending        README
Sending        FAQ
Sending        doc/INSTALL
Sending        src/main.c
Sending        src/button.c
Sending        src/integer.c
Transmitting file data ....
Committed revision 470.
</screen>
      </informalexample>

      <para>Then you rename <filename>integer.c</filename> to <filename>
        whole.c</filename> in r471 and then make some edits to the same
        file in r473.  Effectively you've created a new file in your branch
        (that is a copy of the original file plus some edits) and deleted
        the original file.  Meanwhile, back on <filename>/calc/trunk
        </filename>, Sally has committed some improvements of her own to
        <filename>integer.c</filename> in r472:</para>

      <informalexample>
        <screen>
$ svn log -v -r472 ^/calc/trunk
------------------------------------------------------------------------
r472 | sally | 2013-02-26 07:05:18 -0500 (Tue, 26 Feb 2013) | 1 line
Changed paths:
   M /calc/trunk/src/integer.c

Trunk work on integer.c.
------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>Now you decide to merge your branch back to the trunk.
        How will Subversion combine the rename and edits you made
        with Sally's edits?</para>

      <informalexample>
        <screen>
$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
   C src/integer.c
 U   src/real.c
A    src/whole.c
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .
Summary of conflicts:
  Tree conflicts: 1

$ svn st
 M      .
      C src/integer.c
      >   local file edit, incoming file delete upon merge
 M      src/real.c
A  +    src/whole.c
Summary of conflicts:
  Tree conflicts: 1
</screen>
      </informalexample>

      <para>The answer is that Subversion <emphasis>won't</emphasis>
        combine those changes, but rather raises a tree conflict<footnote>
        <para>If Sally hadn't made her change in r472, then Subversion would
        notice that <filename>integer.c</filename> in the
        target working copy is identical to <filename>integer.c</filename>
        in the left-side of the merge and would allow your rename to
        succeed without a tree conflict:</para>
        <informalexample>
          <screen>
$ svn merge ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
 U   src/real.c
A    src/whole.c
D    src/integer.c
--- Recording mergeinfo for merge between repository URLs into '.':
 U   .
</screen>
      </informalexample></footnote>because it needs your help
        to figure out what part of your changes and what part of Sally's
        changes should ultimately end up in <filename>whole.c</filename>
        or even if the rename should take place at all!</para>

      <para>You will need to resolve this tree conflict before committing
        the merge and this may require some manual intervention on your
        part, see <xref linkend="svn.tour.treeconflicts"/>.  The moral of
        this story is that until Subversion improves, be careful about
        merging copies and renames from one branch to another and when you
        do, be prepared for some manual resolution.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.pre1.5clients">
      <title>Blocking Merge Tracking Unaware Clients</title>

      <para>If you've just upgraded your server to Subversion 1.5 or
        later, there's a risk that pre-1.5 Subversion
        clients can cause problems with
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>.
        This is because pre-1.5 clients don't support this feature;
        when one of these older clients performs <command>svn
        merge</command>, it doesn't modify the value of
        the <literal>svn:mergeinfo</literal> property at all.  So the
        subsequent commit, despite being the result of a merge,
        doesn't tell the repository about the duplicated
        changes that information is lost.  Later on,
        when <quote>merge-aware</quote> clients attempt automatic
        merging, they're likely to run into all sorts of conflicts
        resulting from repeated merges.</para>

      <para>If you and your team are relying on the merge-tracking
        features of Subversion, you may want to configure your
        repository to prevent older clients from committing changes.
        The easy way to do this is by inspecting
        the <quote>capabilities</quote> parameter in
        the <literal>start-commit</literal> hook script.  If the
        client reports itself as having <literal>mergeinfo</literal>
        capabilities, the hook script can allow the commit to start.
        If the client doesn't report that capability, have the hook
        deny the commit.
        <xref linkend="svn.branchmerge.advanced.hook-ex1" /> gives an
        example of such a hook script:</para>

      <example id="svn.branchmerge.advanced.hook-ex1">
        <title>Merge-tracking gatekeeper start-commit hook script</title>

        <programlisting>
#!/usr/bin/env python
import sys

# The start-commit hook is invoked immediately after a Subversion txn is
# created and populated with initial revprops in the process of doing a
# commit. Subversion runs this hook by invoking a program (script, 
# executable, binary, etc.) named 'start-commit' (for which this file
# is a template) with the following ordered arguments:
#
#   [1] REPOS-PATH   (the path to this repository)
#   [2] USER         (the authenticated user attempting to commit)
#   [3] CAPABILITIES (a colon-separated list of capabilities reported
#                     by the client; see note below)
#   [4] TXN-NAME     (the name of the commit txn just created)

capabilities = sys.argv[3].split(':')
if "mergeinfo" not in capabilities:
  sys.stderr.write("Commits from merge-tracking-unaware clients are "
                   "not permitted.  Please upgrade to Subversion 1.5 "
                   "or newer.\n")
  sys.exit(1)
sys.exit(0)
</programlisting>
      </example>

      <para>For more information about hook scripts, see
        <xref linkend="svn.reposadmin.hooks" />.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.advanced.finalword">
      <title>The Final Word on Merge Tracking</title>

      <para>The bottom line is that Subversion's merge-tracking
        feature has an complex internal implementation, and
        the <literal>svn:mergeinfo</literal> property is the only
        window the user has into the machinery.</para>

      <para>How and when mergeinfo is recorded by a merge can sometimes
        be difficult to understand.  Furthermore, the management of
        mergeinfo metadata has a whole set of taxonomies and behaviors
        around it, such as <quote>explicit</quote> versus <quote>implicit
        </quote> mergeinfo, <quote>operative</quote>
        versus <quote>inoperative</quote> revisions, specific
        mechanisms of mergeinfo <quote>elision,</quote> and
        even <quote>inheritance</quote> from parent to child
        directories.</para>

      <para>We've chosen to only briefly cover, if at all, these detailed
        topics for a couple of reasons.  First, the level of detail is
        overwhelming for a typical user.  Second, and more
        importantly, the typical user <emphasis>doesn't</emphasis> need
        to understand these concepts; typically they remain in the
        background as implementation details.  All that said, if you
        enjoy this sort of thing, you can get a fantastic overview in a
        paper posted at CollabNet's website: <ulink
        url="http://www.open.collab.net/community/subversion/articles/merge-info.html"
        />.</para>

      <para>For now, if you want to steer clear of the complexities of
        merge tracking, we recommend that you follow these simple best
        practices:</para>

      <itemizedlist>
        <listitem>
          <para>For short-term feature branches, follow the simple
            procedure described throughout
            <xref linkend="svn.branchmerge.basicmerging"/>.</para>
        </listitem>
        <listitem>
          <para>Avoid subtree merges and subtree mergeinfo. Perform
            merges only on the root of your branches, not on
            subdirectories or files (see <xref
            linkend="svn.branchmerge.basicmerging.stayinsync.subtree"/>)
            .</para>
        </listitem>
        <listitem>
          <para>Don't ever edit the <literal>svn:mergeinfo</literal>
            property directly; use <command>svn
            merge</command> with the <option>--record-only</option> option
            to effect a desired change to the metadata (as demonstrated in
            <xref linkend="svn.branchmerge.advanced.blockchanges"/>).</para>
        </listitem>
        <listitem>
          <para>Your merge target should be a working copy which
            represents the root of a <emphasis>complete</emphasis> tree
            representing a <emphasis>single</emphasis> location in the
            repository at a single point in time:
            <itemizedlist>
              <listitem>
                <para>Update before you merge!  Don't use the <option>
                --allow-mixed-revisions</option> option to merge into
                mixed-revision working copies.</para>
              </listitem>
              <listitem>
                <para>Don't merge to targets with <quote>switched</quote>
                subdirectories (as described next in
                <xref linkend="svn.branchmerge.switchwc"/>).</para>
              </listitem>
              <listitem>
                <para>Avoid merges to targets with sparse directories.
                  Likewise, don't merge to depths other than
                  <option>--depth=infinity</option></para>
              </listitem>
              <listitem>
                <para>Be sure you have read access to all of the merge
                  source and read/write access to all of the merge
                  target.</para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
      </itemizedlist>

      <para>Of course sometimes you may need to violate some of these
        best practices.  Don't worry if you need to, just be sure you
        understand the ramifications of doing so.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.switchwc">
    <title>Traversing Branches</title>

    <para>The <command>svn switch</command> command transforms an
      existing working copy to reflect a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut.  In one of our earlier examples,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/calc/trunk</filename> to mirror the new branch
      location:</para>

    <informalexample>
      <screen>
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch ^/calc/branches/my-calc-branch
U    integer.c
U    button.c
U    Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</screen>
    </informalexample>

    <para><quote>Switching</quote> a working copy that has no local
      modifications to a different branch results in the working copy
      looking just as it would if you'd done a fresh checkout of the
      directory.  It's usually more efficient to
      use this command, because often branches differ by only a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</para>

    <para>The <command>svn switch</command> command also takes a
      <option>--revision</option> (<option>-r</option>) option, so you
      need not always move your working copy to the
      <literal>HEAD</literal> of the branch.</para>

    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example, and contain multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</para>

    <orderedlist>
      <listitem>
        <para>Copy the project's entire <quote>trunk</quote> to a new
          branch directory.</para>
      </listitem>
      <listitem>
        <para>Switch only <emphasis>part</emphasis> of the trunk
          working copy to mirror the branch.</para>
      </listitem>
    </orderedlist>

    <para>In other words, if a user knows that the branch work needs
      to happen on only a specific subdirectory, she uses
      <command>svn switch</command> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, the user can continue to
      receive normal <quote>trunk</quote> updates to most of her
      working copy, but the switched portions will remain immune
      (unless someone commits a change to her branch).  This feature
      adds a whole new dimension to the concept of a <quote>mixed
      working copy</quote> not only can working copies contain a
      mixture of working revisions, but they can also contain a
      mixture of repository locations as well.</para>

    <tip>
      <para>Typically switched subdirectories share common ancestry with
        the location which is switched <quote>away</quote> from.  However
        <command>svn switch</command> can switch a subdirectory to mirror
        a repository location which it shares no common ancestry with.
        To do this you need to use the
        <option>--ignore-ancestry</option> option.
    </para>
    </tip>

    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes are still
      applied as a single, atomic change to the repository.</para>

    <para>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <emphasis>same</emphasis> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that feature is planned for the
      future.<footnote><para>You <emphasis>can</emphasis>, however,
      use <command>svn relocate</command> if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See <xref linkend="svn.ref.svn.c.relocate"/> in
      <xref linkend="svn.ref.svn"/> for more information and an
      example.</para></footnote></para>

    <tip>
      <para>Administrators who need to change the URL of a repository
        which is accessed via HTTP are encouraged to add to
        their <filename>httpd.conf</filename> configuration file a
        permanent redirect from the old URL location to the new one
        (via the <literal>RedirectPermanent</literal> directive).
        Subversion clients will generally display the new repository
        URL in error messages generated when the user attempts to use
        working copies which still reflect the old URL location.  Since
        Subversion 1.7 clients will go a step further,
        automatically relocating the working copy to the new
        URL.</para>
    </tip>

    <sidebar>
      <title>Switches and Updates</title>

      <para>Have you noticed that the output of <command>svn
        switch</command> and <command>svn update</command> looks the
        same?  The switch command is actually a superset of the update
        command.</para>

      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        latter command always compares two identical repository
        paths.</para>

      <para>That is, if your working copy is a mirror of
        <filename>/calc/trunk</filename>, <command>svn
        update</command> will automatically compare your working copy
        of <filename>/calc/trunk</filename> to
        <filename>/calc/trunk</filename> in the
        <literal>HEAD</literal> revision.  If you're switching your
        working copy to a branch, <command>svn switch</command>
        will compare your working copy of
        <filename>/calc/trunk</filename> to some
        <emphasis>other</emphasis> branch directory in the
        <literal>HEAD</literal> revision.</para>

      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
    </sidebar>

    <para>Because <command>svn switch</command> is essentially a
      variant of <command>svn update</command>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.</para>

    <tip>
      <para>Have you ever found yourself making some complex edits (in
        your <filename>/trunk</filename> working copy) and suddenly
        realized, <quote>Hey, these changes ought to be in their own
        branch?</quote> There is a great two step technique to do
        this:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \
           -m "Create branch 'newbranch'."
Committed revision 353.
$ svn switch ^/calc/branches/newbranch
At revision 353.
</screen>
      </informalexample>

      <para>The <command>svn switch</command> command, like
        <command>svn update</command>, preserves your local edits.  At
        this point, your working copy is now a reflection of the newly
        created branch, and your next <command>svn commit</command>
        invocation will send your changes there.</para>
    </tip>

  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.tags">
    <title>Tags</title>

    <para>
      <indexterm>
        <primary>tags</primary>
      </indexterm>
      Another common version control concept is a tag.  A tag is
      just a <quote>snapshot</quote> of a project in time.  In
      Subversion, this idea already seems to be everywhere.  Each
      repository revision is exactly that a snapshot of the
      filesystem after each commit.</para>

    <para>However, people often want to give more human-friendly names
      to tags, such as <literal>release-1.0</literal>.  And they want
      to make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release 1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mksimple">
      <title>Creating a Simple Tag</title>

      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/calc/trunk</filename> exactly as it looks in the
        <literal>HEAD</literal> revision, make a copy of it:</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
           -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 902.
</screen>
      </informalexample>

      <para>This example assumes that a
        <filename>/calc/tags</filename> directory already exists.  (If
        it doesn't, you can create it using <command>svn
        mkdir</command>.)  After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the <filename>/trunk</filename> directory
        looked in the <literal>HEAD</literal> revision at the time you
        made the copy.  Of course, you might want to be more precise
        about exactly which revision you copy, in case somebody else
        may have committed changes to the project when you weren't
        looking.  So if you know that revision 901 of
        <filename>/calc/trunk</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r 901</option> to
        the <command>svn copy</command> command.</para>

      <para>But wait a moment: isn't this tag creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a <quote>tag</quote> is because
        <emphasis>humans</emphasis> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</para>

      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is <quote>hands off</quote>: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy.  (That is, make sure
        they know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags area (see
        <xref linkend="svn.serverconfig"/>).  The paranoid approach,
        however, isn't usually necessary.  If a user accidentally
        commits a change to a tag directory, you can simply undo the
        change as discussed in the previous section.  This is version
        control, after all!</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.tags.mkcomplex">
      <title>Creating a Complex Tag</title>

      <para>Sometimes you may want a <quote>snapshot</quote> that is
        more complicated than a single directory at a single
        revision.</para>

      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <command>svn
        update</command> with the <option>-r</option> option
        liberally), by switching files and directories to particular
        branches (making use of <command>svn switch</command>), or
        even just by making a bunch of local changes.  When you're
        done, your working copy is a hodgepodge of repository
        locations from different revisions.  But after testing, you
        know it's the precise combination of data you need to
        tag.</para>

      <para>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <command>svn copy</command> actually has four
        different uses (see <xref linkend="svn.ref.svn.c.copy"/> in <xref
        linkend="svn.ref.svn"/>), including the ability to copy a
        working copy tree to the repository:</para>

      <informalexample>
        <screen>
$ ls
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \
           -m "Tag my existing working copy state."

Committed revision 940.
</screen>
      </informalexample>

      <para>Now there is a new directory in the repository,
        <filename>/calc/tags/mytag</filename>, which is an exact
        snapshot of your working copy mixed revisions, URLs,
        local changes, and all.</para>

      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patch file (which won't capture
        directory or symlink changes), you can
        use <command>svn copy</command> to <quote>upload</quote> your
        working copy to a private area of the repository.  Your
        collaborator can then either check out a verbatim copy of your
        working copy or use <command>svn merge</command> to receive
        your exact changes.</para>

      <para>While this is a nice method for uploading a quick snapshot
        of your working copy, note that this is <emphasis>not</emphasis>
        a good way to initially create a branch.  Branch creation should
        be an event unto itself, and this method conflates the creation
        of a branch with extra changes to files, all within a single revision.
        This makes it very difficult (later on) to identify a single
        revision number as a branch point.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.maint">
    <title>Branch Maintenance</title>

    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.layout">
      <title>Repository Layout</title>

      <para>There are some standard, recommended ways to organize the
        contents of a repository.  Most people create a
        <filename>trunk</filename> directory to hold the <quote>main
        line</quote> of development, a <filename>branches</filename>
        directory to contain branch copies, and
        a <filename>tags</filename> directory to contain tag copies.
        If a repository holds only one project, often people create
        these top-level directories:</para>

      <informalexample>
        <literallayout>
/
   trunk/
   branches/
   tags/
</literallayout>
      </informalexample>

      <para>If a repository contains multiple projects, admins
        typically index their layout by project.  See <xref
        linkend="svn.reposadmin.projects.chooselayout"/> to read more about
        <quote>project roots</quote>, but here's an example of such a
        layout:</para>

      <informalexample>
        <literallayout>
/
   paint/
      trunk/
      branches/
      tags/
   calc/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <para>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <command>svn move</command> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</para>

      <para>Remember, though, that while moving directories is
        easy to do, you need to be considerate of other users as well.
        Your juggling can disorient users with existing
        working copies.  If a user has a working copy of a particular
        repository directory and your <command>svn move</command>
        subcommand removes the path from the latest revision, then
        when the user next runs <command>svn update</command>, she is
        told that her working copy represents a path that no
        longer exists.  She is then forced to <command>svn
        switch</command> to the new location.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.maint.lifetime">
      <title>Data Lifetimes</title>

      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/calc/trunk</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>

      <informalexample>
        <screen>
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 474.
</screen>
      </informalexample>

      <tip>
        <para>Recall from the previous section that if the repository
          location your working copy refers to is deleted, then when
          you try to update you will receive an error:</para>
        <informalexample>
          <screen>
$ svn up
Updating '.':
svn: E160005: Target path '/calc/branches/my-calc-branch' does not exist
</screen>
        </informalexample>

        <para>All you need to do in this situation is switch your working
          copy to a location that still exits:</para>

        <informalexample>
          <screen>
$ svn sw ^/calc/trunk
D    src/whole.c
 U   src/real.c
A    src/integer.c
 U   .
Updated to revision 474.
</screen>
        </informalexample>
      </tip>

      <para>And now your branch is gone.  Of course, it's not really
        gone: the directory is simply missing from the
        <literal>HEAD</literal> revision, no longer distracting
        anyone.  If you use <command>svn checkout</command>,
        <command>svn switch</command>, or <command>svn list</command>
        to examine an earlier revision, you can still see
        your old branch.</para>

      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <literal>HEAD</literal>, simply
        use <command>svn copy</command> to copy it from the old
        revision:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/branches/my-calc-branch@473 \
           ^/calc/branches/my-calc-branch \
           -m "Restore my-calc-branch."

Committed revision 475.
</screen>
      </informalexample>

      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two <quote>main</quote> branches running side by side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <filename>calc</filename> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a <quote>stable</quote> branch of the software that won't
        change much:</para>

      <informalexample>
        <screen>
$ svn copy ^/calc/trunk ^/calc/branches/stable-1.0 \
           -m "Creating stable branch of calc project."

Committed revision 476.
</screen>
      </informalexample>

      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/calc/trunk</filename>, and you can declare a
        project policy that only bug fixes are to be committed to
        <filename>/calc/branches/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        cherrypicks bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time that is, as long
        as you continue to support that release for customers.  We'll
        discuss this more in the next section.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.commonpatterns">
    <title>Common Branching Patterns</title>

    <para>There are many different uses for branching and <command>svn
        merge</command>, and this section describes the most
        common.</para>

    <para>Version control is most often used for software
      development, so here's a quick peek at two of the most common
      branching/merging patterns used by teams of programmers.  If
      you're not using Subversion for software development, feel
      free to skip this section.  If you're a software developer
      using version control for the first time, pay close attention,
      as these patterns are often considered best practices by
      experienced folk.  These processes aren't specific to
      Subversion; they're applicable to any version control system.
      Still, it may help to see them described in Subversion
      terms.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.release">
      <title>Release Branches</title>

      <para>Most software has a typical life cycle: code, test,
        release, repeat.  There are two problems with this process.
        First, developers need to keep writing new features while
        quality assurance teams take time to test supposedly stable
        versions of the software.  New work cannot halt while the
        software is tested.  Second, the team almost always needs to
        support older, released versions of software; if a bug is
        discovered in the latest code, it most likely exists in
        released versions as well, and customers will want to get
        that bug fix without having to wait for a major new
        release.</para>

      <para>Here's where version control can help.  The typical
        procedure looks like this:</para>

      <orderedlist>

        <listitem>
          <para><emphasis>Developers commit all new work to the
            trunk.</emphasis>  Day-to-day changes are committed to
            <filename>/trunk</filename>: new features, bug fixes, and
            so on.</para>
        </listitem>
        <listitem>
          <para><emphasis>The trunk is copied to a
            <quote>release</quote> branch.</emphasis>  When the team
            thinks the software is ready for release (say, a 1.0
            release), <filename>/trunk</filename> might be copied to
            <filename>/branches/1.0</filename>.</para>
        </listitem>
        <listitem>
          <para><emphasis>Teams continue to work in
            parallel.</emphasis>  One team begins rigorous testing of
            the release branch, while another team continues new work
            (say, for version 2.0) on <filename>/trunk</filename>.  If
            bugs are discovered in either location, fixes are cherrypicked
            back and forth as necessary.  At some point, however, even
            that process stops.  The branch is <quote>frozen</quote>
            for final testing right before a release.</para>
        </listitem>
        <listitem>
          <para><emphasis>The branch is tagged and
            released.</emphasis>  When testing is complete,
            <filename>/branches/1.0</filename> is copied to
            <filename>/tags/1.0.0</filename> as a reference
            snapshot.  The tag is packaged and released to
            customers.</para>
        </listitem>
        <listitem>
          <para><emphasis>The branch is maintained over
            time.</emphasis>  While work continues
            on <filename>/trunk</filename> for version 2.0, bug fixes
            continue to be ported from <filename>/trunk</filename> to
            <filename>/branches/1.0</filename>.  When enough
            bug fixes have accumulated, management may decide to do a
            1.0.1 release: <filename>/branches/1.0</filename> is
            copied to <filename>/tags/1.0.1</filename>, and the tag
            is packaged and released.</para>
        </listitem>

      </orderedlist>

      <para>This entire process repeats as the software matures:
        when the 2.0 work is complete, a new 2.0 release branch is
        created, tested, tagged, and eventually released.  After
        some years, the repository ends up with a number of release
        branches in <quote>maintenance</quote> mode, and a number
        of tags representing final shipped versions.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.branchmerge.commonpatterns.feature">
      <title>Feature Branches</title>

      <para>
        <indexterm>
          <primary>branches</primary>
          <secondary>feature branches</secondary>
        </indexterm>A <firstterm>feature branch</firstterm> is the sort of
        branch that's been the dominant example in this chapter (the
        one you've been working on while Sally continues to work on
        <filename>/trunk</filename>).  It's a temporary branch created
        to work on a complex change without interfering with the
        stability of <filename>/trunk</filename>.  Unlike release
        branches (which may need to be supported forever), feature
        branches are born, used for a while, merged back to the trunk,
        and then ultimately deleted.  They have a finite span of
        usefulness.</para>

      <para>Again, project policies vary widely concerning exactly
        when it's appropriate to create a feature branch.  Some
        projects never use feature branches at all: commits to
        <filename>/trunk</filename> are a free-for-all.  The
        advantage to this system is that it's simple nobody
        needs to learn about branching or merging.  The disadvantage
        is that the trunk code is often unstable or unusable.  Other
        projects use branches to an extreme: no change is
        <emphasis>ever</emphasis> committed to the trunk directly.
        Even the most trivial changes are created on a short-lived
        branch, carefully reviewed, and merged to the trunk.  Then
        the branch is deleted.  This system guarantees an
        exceptionally stable and usable trunk at all times, but at
        the cost of tremendous process overhead.</para>

      <para>Most projects take a middle-of-the-road approach.  They
        commonly insist that <filename>/trunk</filename> compile and
        pass regression tests at all times.  A feature branch is
        required only when a change requires a large number of
        destabilizing commits.  A good rule of thumb is to ask this
        question: if the developer worked for days in isolation and
        then committed the large change all at once (so that
        <filename>/trunk</filename> were never destabilized), would it
        be too large a change to review?  If the answer to that
        question is <quote>yes,</quote> the change should be
        developed on a feature branch.  As the developer commits
        incremental changes to the branch, they can be easily reviewed
        by peers.</para>

      <para>Finally, there's the issue of how to best keep a feature
        branch in <quote>sync</quote> with the trunk as work
        progresses.  As we mentioned earlier, there's a great risk to
        working on a branch for weeks or months; trunk changes may
        continue to pour in, to the point where the two lines of
        development differ so greatly that it may become a nightmare
        trying to merge the branch back to the trunk.</para>

      <para>This situation is best avoided by regularly running an
        automatic merge from trunk to the branch.  Make up a policy:
        once a week, merge the last week's worth of trunk changes to
        the branch.</para>

      <para>When you are eventually ready to merge the
        <quote>synchronized</quote> feature branch back to the trunk,
        begin by doing a final automatic merge of the latest trunk
        changes to the branch.  When that's done, the latest versions
        of branch and trunk are absolutely identical except for
        your branch changes.  You can then run an automatic reintegrate
        merge from the branch back to the trunk:</para>

      <informalexample>
        <screen>
$ cd trunk-working-copy

$ svn update
Updating '.':
At revision 1910.

$ svn merge ^/calc/branches/mybranch
--- Merging differences between repository URLs into '.':
U    real.c
U    integer.c
A    newdirectory
A    newdirectory/newfile
 U   .
 
</screen>
      </informalexample>

      <para>Another way of thinking about this pattern is that your
        weekly sync of trunk to branch is analogous to running
        <command>svn update</command> in a working copy, while the
        final merge step is analogous to running <command>svn
        commit</command> from a working copy.  After all, what else
        <emphasis>is</emphasis> a working copy but a very shallow
        private branch?  It's a branch that's capable of
        storing only one change at a time.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.vendorbr">
    <title>Vendor Branches</title>

    <para>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>
      <indexterm>
        <primary>branches</primary>
        <secondary>vendor branches</secondary>
      </indexterm>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</para>

    <para>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see <xref linkend="svn.developer.usingapi.apr" />).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the <quote>bleeding edge</quote> of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</para>

    <para>Now, if your project depends on someone else's information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions of
      that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively <quote>pin down</quote> specific
      versions of that information to some location in your own
      working copy (see <xref linkend="svn.advanced.externals"
      />).</para>

    <para>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</para>

    <para>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</para>

    <para>
      <indexterm>
        <primary>vendor drop</primary>
      </indexterm>The solution to this problem is to
      use <firstterm>vendor branches</firstterm>.  A vendor branch is
      a directory tree in your own version control system that
      contains information provided by a third-party entity, or
      vendor.  Each version of the vendor's data that you decide to
      absorb into your project is called a <firstterm>vendor
      drop</firstterm>.</para>

    <para>Vendor branches provide two benefits.  First, by storing the
      currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need
      to question whether they have the right version of the vendor's
      data.  They simply receive that correct version as part of their
      regular working copy updates.  Second, because the data lives in
      your own Subversion repository, you can store your custom
      changes to it in-place you have no more need of an
      automated (or worse, manual) method for swapping in your
      customizations.</para>

    <para>Unfortunately, there is no single best way to manage vendor
      branches in Subversion.  The flexibility of the system offers
      several different approaches, each of which has its advantages
      and disadvantages, and none of which can be clearly considered
      a <quote>silver bullet</quote> for the problem.  We'll cover a
      few of these approaches at a high level in the following
      sections, using the common example of a software project which
      depends on a third-party library.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.general">
      <title>General Vendor Branch Management Procedure</title>

      <para>Maintaining customizations to a third-party library
        involves three data sources: the version of the third-party
        library upon which your modifications were last based, the
        customized version (that is, the actual vendor branch) of that
        library which is used by your project, and any new version of
        the vendor's library to which you may be hoping to upgrade.
        Managing the vendor branch (which should live within your
        source code repository per our definition of the thing), then,
        essentially boils down to performing merge operations (in the
        general sense).  But different teams take different approaches
        to the other data sources the pristine versions of the
        third-party library code.  Thus, there are likewise different
        specific ways to perform the requisite merges.</para>

      <para>Strictly speaking, there are a couple of different ways
        that those merges can be performed in the general sense.  For
        the sake of simplicity and with the goal of at least providing
        <emphasis>something</emphasis> concrete in this section of the
        book, we'll assume that there is but a single vendor branch
        which is upgraded to each successive new release of the
        third-party library by receiving updates that describe the
        differences between the current and new pristine versions of
        that library.</para>

      <note>
        <para>Another approach is to create new vendor branches for
          each successive pristine library version, applying the
          differences between the current pristine library and the
          customized version thereof (from the current vendor branch)
          to the new branch.  There's nothing wrong with that
          approach we just don't feel compelled to document
          every legitimate possibility in this space.</para>
      </note>

      <para>The following sections examine how to create and manage a
        vendor branch in a few different scenarios.  In the examples
        which follow, we'll assume that the third-party library is
        called libcomplex, and that we will be implementing a vendor
        branch based on libcomplex 1.0.0 which lives in our repository
        at <filename>^/vendor/libcomplex-custom</filename>.  We'll
        then look at how we can upgrade to libcomplex 1.0.1 while
        still preserving our customizations to the library.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.foreign-repos">
      <title>Vendor Branches from Foreign Repositories</title>

      <para>Let's look first at a vendor branch management approach
        that is possible when the original third-party library is
        itself Subversion-accessible.  For the sake of the example,
        we'll assume that the libcomplex library we previously
        discussed is developed in a publicly accessible Subversion
        repository, and that its developers use sane release
        procedures which include the creation of tags for each stable
        release version.</para>

      <para>
        <indexterm>
          <primary>merging</primary>
          <secondary>foreign repository merges</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository merges</primary>
          <see>merging, foreign repository merges</see>
        </indexterm>
        <indexterm>
          <primary>copying</primary>
          <secondary>foreign repository copies</secondary>
        </indexterm>
        <indexterm>
          <primary>foreign repository copies</primary>
          <see>copying, foreign repository copies</see>
        </indexterm>Since Subversion 1.5, <command>svn merge</command>
        has been able to perform so-called <firstterm>foreign
        repository merges</firstterm>, where the sources of the merge
        live in a different repository than the repository from which
        the merge target working copy was checked out.  And in
        Subversion 1.8, the behavior of <command>svn copy</command>
        was changed so that when you perform a copy from a foreign
        repository into an existing working copy, the resulting tree
        is incorporated into that working copy and scheduled for
        addition.  It's this <firstterm>foreign repository
        copy</firstterm> functionality that we'll use to bootstrap our
        vendor branch.</para>

      <para>So let's create our vendor branch.  We'll begin by
        creating a placeholder directory for all such vendor branches
        in our repository, and then checking out a working copy of
        that location.</para>

      <informalexample>
        <screen>
$ svn mkdir http://svn.example.com/projects/vendor \
            -m "Create a container for vendor branches."
Committed revision 1160.
$ svn checkout http://svn.example.com/projects/vendor \
               /path/to/vendor
Checked out revision 1160.
$
</screen>
      </informalexample>

      <para>Now, we'll take advantage of Subversion's foreign
        repository copy support to get an exact copy of libcomplex
        1.0.0 including any Subversion properties stored on its
        files and directories from the vendor repository.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn copy http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
           libcomplex-custom
--- Copying from foreign repository URL 'http://svn.othervendor.com/repos/lib\
complex/tags/1.0.0':
A    libcomplex-custom
A    libcomplex-custom/README
A    libcomplex-custom/LICENSE
 
A    libcomplex-custom/src/code.c
A    libcomplex-custom/tests
A    libcomplex-custom/tests/TODO
$ svn commit -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
 
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1161.
$
</screen>
      </informalexample>

      <note>
        <para>If you happen to be using an older version of
          Subversion, the closest available approximation of the new
          foreign repository copy support in <command>svn
          copy</command> is to instead import (via <command>svn
          import</command>) a working copy of the vendor's tag,
          including the <option>--no-auto-props</option>
          and <option>--no-ignore</option> options so that the
          complete tree and any of its versioned properties are
          accurately replicated in your own repository.</para>
      </note>

      <para>Now that we have a vendor branch based on libcomplex 1.0.0,
        we can begin making the customizations to libcomplex required
        for our purposes, committing them directly to the vendor
        branch we've created.  And of course, we can begin using
        libcomplex in our own application.</para>

      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  Here is where Subversion's
        foreign repository merge operation is useful.  We have in our
        vendor branch the original libcomplex 1.0.0 plus our
        customizations to it.  What we need now is to get the set of
        changes the vendor has made between 1.0.0 and 1.0.1 into our
        vendor branch, ideally without clobbering our own
        customizations.  This is precisely what the 2-URL form of
        the <command>svn merge</command> command is for.</para>

      <informalexample>
        <screen>
$ cd /path/to/vendor
$ svn merge http://svn.othervendor.com/repos/libcomplex/tags/1.0.0 \
            http://svn.othervendor.com/repos/libcomplex/tags/1.0.1 \
            libcomplex-custom
--- Merging differences between foreign repository URLs into '.':
U    libcomplex-custom/src/code.h
C    libcomplex-custom/src/code.c
U    libcomplex-custom/README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'libcomplex-custom/src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: 
</screen>
      </informalexample>

      <para>As you can see, <command>svn merge</command> has merged
        the changes required to make libcomplex 1.0.0 look like
        libcomplex 1.0.1 into our working copy.  In our example, it has
        even noticed and flagged a conflict on one file.   It seems
        the vendor modified a region of one of the files we also
        customized.  Subversion safely detects this conflict, and
        gives us the opportunity to resolve it so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  (See <xref linkend="svn.tour.cycle.resolve" />
        for more on resolving conflicts of this sort.)</para>

      <para>Once we've resolved the conflicts and performed any
        testing or review we need, we can commit the changes to our
        vendor branch.</para>

      <informalexample>
        <screen>
$ svn status libcomplex-custom
M       libcomplex-custom/src/code.h
M       libcomplex-custom/src/code.c
M       libcomplex-custom/README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-custom
Sending        libcomplex-custom/README
Sending        libcomplex-custom/src/code.h
Sending        libcomplex-custom/src/code.c
Transmitting file data ...
Committed revision 1282.
$
</screen>
      </informalexample>

      <para>That, in a nutshell, is how to manage vendor branches when
        the original source is Subversion-accessible.  There are some
        notable shortcomings, though.  First, foreign repository
        merges are not automatically tracked by Subversion itself like
        same-repository merges are.  This means the burden falls to
        the user to know which merges have been performed on their
        vendor branch, and just how to construct the next merge when
        upgrading that branch.  Also, as is the case for all of
        Subversion's merge support, renames in the merge sources can
        cause no small amount of complication and frustration.
        Unfortunately, at this time, we don't have a particularly
        solid recommendation to offer to alleviate that pain.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.vendorbr.mirrored-sources">
      <title>Vendor Branches from Mirrored Sources</title>

      <para>In the previous section
        (<xref linkend="svn.advanced.vendorbr.foreign-repos" />) we
        looked at how to implement and maintain a vendor branch when
        the vendor drops are accessible via Subversion, which is the
        ideal scenario when it comes to vendor branches.  Subversion
        is pretty good at handling merges of stuff that's been
        Subversion-managed.  Unfortunately, it's not always the case
        that third-party libraries are publicly accessible via
        Subversion.  Many times, a project depends on a library which
        is delivered via only non-Subversion mechanisms, such as a
        source code release distribution tarball.  In such
        circumstances, we strongly recommend that you do all you can
        to get that non-Subversion information into Subversion as
        cleanly as possible.  So let's examine an approach to vendor
        branches in which the third-party library's various releases
        are mirrored within our own repository.</para>

      <para>Setting up the vendor branch the first time is pretty
        simple, really.  For our example, we'll assume that libcomplex
        1.0.0 is delivered via the common tarball mechanism.  To
        create our vendor branch, we'll first get the contents of the
        libcomplex 1.0.0 tarball into our repository as a read-only
        (by convention only) vendor tag of sorts.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.0.tar.gz
libcomplex-1.0.0/
libcomplex-1.0.0/README
libcomplex-1.0.0/LICENSE
 
libcomplex-1.0.0/src/code.c
libcomplex-1.0.0/tests
libcomplex-1.0.0/tests/TODO
$ svn import libcomplex-1.0.0 \
             http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
             --no-ignore --no-auto-props \
             -m "Import libcomplex 1.0.0 sources."
Adding         libcomplex-custom
Adding         libcomplex-custom/README
Adding         libcomplex-custom/LICENSE
 
Adding         libcomplex-custom/src
Adding         libcomplex-custom/src/code.h
Adding         libcomplex-custom/src/code.c
Transmitting file data .......................................
Committed revision 1160.
$
</screen>
      </informalexample>

      <para>Note that in our example, we used
        the <option>--no-ignore</option> option during import so that
        Subversion is sure to pick up every file in the vendor drop
        and not to omit any of them.  We also supply
        the <option>--no-auto-props</option> option so that our client
        doesn't manufacture property information which isn't present
        in the vendor drop.<footnote><para>Technically, we could let
        the auto-props feature do its thing, but the key to making
        that work well is ensuring that each vendor drop gets
        identical auto-prop treatment.</para></footnote>.</para>
       
      <para>Now that the first vendor release drop is present in our
        repository, we can create our vendor branch from it just as we
        would create any other branch using <command>svn
        copy</command>.</para>

      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-custom \
           -m "Initialize libcomplex vendor branch from libcomplex 1.0.0."
Committed revision 1161.
$
</screen>
      </informalexample>

      <para>Okay.  At this point we have a vendor branch based on
        libcomplex 1.0.0.  We are now poised to begin making the
        customizations to libcomplex required for our
        purposes committing them directly to the vendor branch
        we've created and then to start using our customized
        libcomplex in our own application.</para>

      <para>Some time later, libcomplex 1.0.1 is released.  After
        reviewing its changes, we decide we'd like to upgrade our
        vendor branch to the new version.  In order to perform that
        upgrade on our branch, we need to essentially apply the same
        set of changes the vendor has made between 1.0.0 and 1.0.1 to
        our vendor branch without clobbering our own customizations.
        The safest way to perform that application is to first get
        libcomplex 1.0.1 into our repository <emphasis>as a delta
        against the libcomplex 1.0.0 code in our
        repository</emphasis>.  Afterwards, we'll use the 2-URL form
        of the <command>svn merge</command> command to replicate those
        same changes into our vendor branch.</para>

      <para>As it turns out, there are several different approaches we
        can take to to get libcomplex 1.0.1 into our repository in the
        right way.<footnote><para>Using another <command>svn
        import</command> operation would be
        an <emphasis>incorrect</emphasis> approach, as the libcomplex
        1.0.0 and 1.0.1 branches would not have any common
        ancestry.</para></footnote>  The approach we'll describe here
        is relatively rudimentary, but it will serve our illustrative
        needs.</para>

      <para>Remember, we want our mirror of the libcomplex 1.0.1
        vendor drop to share ancestry with our 1.0.0 vendor drop,
        which will produce the best results later when we need to
        merge the changes between those drops to our vendor branch.
        So we'll start by creating a libcomplex-1.0.1 branch as copy
        of our previously created libcomplex-1.0.0 <quote>vendor
        tag</quote> a copy which will eventually become a
        replica of libcomplex 1.0.1.</para>
        
      <informalexample>
        <screen>
$ svn copy http://svn.example.com/projects/vendor/libcomplex-1.0.0 \
           http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
           -m "Setup a construction zone for libcomplex 1.0.1."
Committed revision 1282.
$
</screen>
      </informalexample>

      <para>What we need now is to make a working copy of our
        libcomplex-1.0.1 branch, and then to make it actually look
        like libcomplex 1.0.1.  To do this, we'll take advantage of
        the fact that <command>svn checkout</command> can overlay an
        existing directory and, if the <option>--force</option> option
        is provided, do so in manner that allows the differences
        between the checked-out tree and the target tree that the
        checkout overlayed to remain as local modifications in the new
        working copy.</para>

      <informalexample>
        <screen>
$ tar xvfz libcomplex-1.0.1.tar.gz
libcomplex-1.0.1/
libcomplex-1.0.1/README
libcomplex-1.0.1/LICENSE
 
libcomplex-1.0.1/src/code.c
libcomplex-1.0.1/tests
libcomplex-1.0.1/tests/TODO
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-1.0.1 \
               libcomplex-1.0.1 \
               --force
E    libcomplex-1.0.1/README
E    libcomplex-1.0.1/LICENSE
E    libcomplex-1.0.1/INSTALL
 
E    libcomplex-1.0.1/src/code.c
E    libcomplex-1.0.1/tests
E    libcomplex-1.0.1/tests/TODO
Checked out revision 1282.
$ svn status libcomplex-1.0.1
M       libcomplex-1.0.1/src/code.h
M       libcomplex-1.0.1/src/code.c
M       libcomplex-1.0.1/README
$
</screen>
      </informalexample>

      <para>As you can see, after checking out what was really
        libcomplex 1.0.0 atop the libcomplex 1.0.1 exploded tarball,
        we are left with a working copy that contains local
        modifications those modifications required to morph our
        previous vendor release drop into our new one.</para>

      <para>Admittedly, this is a pretty simple example.  The changes
        required to perform this particular upgrade involved merely
        content changes to existing files.  In reality, new versions
        of third-party libraries might also add or remove files or
        directories, might rename files or directories, and so on.  In
        those situations, it can be much more challenging to morph the
        new vendor tag into a state where it accurately reflects the
        vendor drop it claims to reflect.  We'll leave the details of
        such transformations as an exercise to the
        reader.<footnote><para>Here's a hint, though: <userinput>svn
        add --force /path/to/working-copy --no-ignore
        --no-auto-props</userinput> is super handy for adding any new
        vendor drop items to version control in this
        situation.</para></footnote></para>

      <para>However we make it happen, once our new vendor tag working
        copy is reconciled with the original source distribution, we
        can commit those changes to our repository.</para>

      <informalexample>
        <screen>
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1." \
             libcomplex-1.0.1
Sending        libcomplex-1.0.1/README
Sending        libcomplex-1.0.1/src/code.h
Sending        libcomplex-1.0.1/src/code.c
Transmitting file data ...
Committed revision 1283.
$
</screen>
      </informalexample>

      <para>We're finally ready to upgrade our vendor branch.
        Remember, our goal is to get the changes made by the vendor
        between the 1.0.0 and 1.0.1 releases of their library into our
        vendor branch.  There is where a 2-URL <command>svn
        merge</command> operation, applied to a working copy of our
        vendor branch, comes into play.</para>

      <informalexample>
        <screen>
$ svn checkout http://svn.example.com/projects/vendor/libcomplex-custom \
               libcomplex-custom
E    libcomplex-custom/README
E    libcomplex-custom/LICENSE
E    libcomplex-custom/INSTALL
 
E    libcomplex-custom/src/code.c
E    libcomplex-custom/tests
E    libcomplex-custom/tests/TODO
Checked out revision 1283.
$ cd libcomplex-custom
$ svn merge ^/vendor/libcomplex-1.0.0 \
            ^/vendor/libcomplex-1.0.1
--- Merging differences between repository URLs into '.':
U    src/code.h
C    src/code.c
U    README
Summary of conflicts:
  Text conflicts: 1
Conflict discovered in file 'src/code.c'.
Select: (p) postpone, (df) diff-full, (e) edit, (m) merge,
        (mc) mine-conflict, (tc) theirs-conflict, (s) show all options: 
</screen>
      </informalexample>

      <para>As you can see, <command>svn merge</command> has merged
        the requisite changes into our working copy, flagging a
        conflict where the vendor modified the same region of one of
        the files as we did during our customizations.  Subversion
        detects this conflict, and gives us the opportunity to resolve
        it (using the methods described in
        <xref linkend="svn.tour.cycle.resolve" />) so that our
        customizations to what is now libcomplex 1.0.1 continue to
        make sense.  Once we've resolved the conflicts and performed
        any testing or review we need, we can commit the changes to
        our vendor branch.</para>

      <informalexample>
        <screen>
$ svn status
M       src/code.h
M       src/code.c
M       README
$ svn commit -m "Upgrade vendor branch to libcomplex 1.0.1."
Sending        README
Sending        src/code.h
Sending        src/code.c
Transmitting file data ...
Committed revision 1284.
$
</screen>
      </informalexample>

      <para>Our vendor branch upgrade is complete.  And the next time
        we need to upgrade that branch, we'll follow the same
        procedure we used to upgrade it this time.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.when">
    <title>To Branch or Not to Branch?</title>

    <para>To branch or not to branch that is an interesting
      question.  This chapter has provided thus far a pretty deep dive
      into the waters of branching and merging, topics which have
      historically been the premier source of Subversion user
      confusion.  As if the rote actions involved in branching and
      branch management aren't sometimes tricky enough, some users get
      hung up on deciding whether they need to branch at all.  As
      you've learned, Subversion can handle common branching and
      branch management scenarios.  So, the decision of whether or not
      to branch a project's history is rarely a technical one.
      Rather, the social impact of the decision often carries more
      weight.  Let's examine some of the benefits and costs of using
      branches in a software project.</para>

    <para>The most obvious benefit of working on a branch is
      isolation.  Changes made to the branch don't affect the other
      lines of development in the project; changes made to those other
      lines don't affect the branch.  In this way, a branch can serve
      as a great place to experiment with new features, complex bug
      fixes, major code rewrites, and so on.  No matter how much stuff
      Sally breaks on her branch, Harry and the rest of the team can
      continue with their work unhindered outside the branch.</para>

    <para>Branches also provide a great way to organize related
      changes into readily identifiable collections.  For example, the
      changes which comprise the complete solution to a particular bug
      might be a list of non-sequential revision numbers.  You might
      describe them in human language as <quote>revisions 1534, 1543,
      1587 and 1588</quote>.  You'd probably reproduce those numbers
      manually (or otherwise) in the issue tracker artifact which
      tracks the bug.  When porting the bug fix to other product
      versions, you'd need to make sure to port all those revisions.
      But had those changes been made on a unique branch, you'd find
      yourself referring only to that branch by its name in
      conversation, in issue tracker comments, and when porting
      changes.</para>

    <para>The unfortunate downside of branches, though, is that the
      very isolation that makes them so
      useful <emphasis>can</emphasis> be at odds with the
      collaborative needs of the project team.  Depending on the work
      habits of your project peers, changes made to branches might not
      get the kind of constructive review, criticism, and testing that
      changes made to the main line of development do.  The isolation
      of a branch can encourage users to forsake certain version
      control <quote>best practices</quote>, leading to version
      history which is difficult to review <foreignphrase>post
      facto</foreignphrase>.  Developers on long-lived branches
      sometimes need to work extra hard to ensure that the
      evolutionary direction of their isolated copy of the codebase is
      in harmony with the direction their peers are steering the main
      code lines.  Now, these drawbacks might be less of an issue for
      true exploratory branches aimed at experimenting with the future
      of a codebase with no expectation of reintegrating the results
      back into the main development lines mere policy needn't
      be a vision-killer!  But the simple fact remains that projects
      generally benefit from an orderly approach to version control
      where code and code changes enjoy the review and comprehension
      of more than one team member.</para>

    <para>That's not to say that there are no technical penalties to
      branching.  Pardon us while we <quote>go meta</quote> for a bit
      here.  If you think about it, every time you checkout a
      Subversion working copy, you're creating a branch of sorts of
      your project.  It's a special sort of branch.  It lives only on
      your client machine; not in the repository.  You synchronize
      this branch with changes made in the repository
      using <command>svn update</command> which acts almost like
      a special-cased, simplified form of an <command>svn
      merge</command> command.<footnote><para>Actually, you
      <emphasis>could</emphasis> use <userinput>svn merge
      -r<replaceable>LAST_UPDATED_REV</replaceable>:HEAD .</userinput>
      in your working copy to quite literally merge in all the
      repository changes since your last update if really wanted
      to!</para></footnote> You effectively reintegrate your branch
      each time you run <command>svn commit</command>.  So, in that
      special sense, Subversion users deal with branches and merges
      all the time.  Given the similarities between updating and
      merging, it's no surprise, then, that the areas in which
      Subversion seems to have the most shortcomings namely,
      handling file and directory renames and dealing with tree
      conflicts in general are problematic for both
      the <command>svn update</command> and <command>svn
      merge</command> operations.  Unfortunately, <command>svn
      merge</command> has a harder time of it precisely because of the
      fact that, for every way in which <command>svn update</command>
      is a special-cased, simplified kind of generic merge operation,
      a true Subversion merge is neither special-cased nor simplified.
      For this reason, merges perform much more slowly than updates,
      require explicit tracking (via
      the <literal>svn:mergeinfo</literal> property we've discussed in
      this chapter) and history-crunching arithmetic, and generally
      offer more opportunities for something to go awry.</para>

    <para>To branch or not to branch?  Ultimately, that depends on
      what your team needs in order to find that sweet balance of
      collaboration and isolation.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.branchmerge.summary">
    <title>Summary</title>

    <para>We covered a lot of ground in this chapter.  We
      discussed the concepts of tags and branches and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We showed how
      to use <command>svn merge</command> to copy changes from one
      branch to another or roll back bad changes.  We went over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>

    <para>Remember the Subversion mantra: branches and tags are cheap.
      So don't be afraid to use them when needed!</para>

    <para>As a helpful reminder of all the operations we discussed,
      here is handy reference table you can consult as
      you begin to make use of branches.</para>

    <table id="svn.branchmerge.summary.tbl-1">
      <title>Branching and merging commands</title>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Action</entry>
            <entry>Command</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Create a branch or tag</entry>
            <entry><userinput>svn copy <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Switch a working copy to a branch or tag</entry>
            <entry><userinput>svn switch <replaceable>URL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Synchronize a branch with trunk</entry>
            <entry><userinput>svn merge <replaceable>trunkURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>See merge history or eligible changesets</entry>
            <entry><userinput>svn mergeinfo <replaceable>SOURCE</replaceable> <replaceable>TARGET</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Merge a branch back into trunk</entry>
            <entry><userinput>svn merge <replaceable>branchURL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Merge one specific change</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Merge a range of changes</entry>
            <entry><userinput>svn merge -r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Block a change from automatic merging</entry>
            <entry><userinput>svn merge -c <replaceable>REV</replaceable> --record-only <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Preview a merge</entry>
            <entry><userinput>svn merge <replaceable>URL</replaceable> --dry-run</userinput></entry>
          </row>

          <row>
            <entry>Abandon merge results</entry>
            <entry><userinput>svn revert -R .</userinput></entry>
          </row>

          <row>
            <entry>Resurrect something from history</entry>
            <entry><userinput>svn copy <replaceable>URL</replaceable>@<replaceable>REV</replaceable> <replaceable>localPATH</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Undo a committed change</entry>
            <entry><userinput>svn merge -c -<replaceable>REV</replaceable> <replaceable>URL</replaceable>; svn commit</userinput></entry>
          </row>

          <row>
            <entry>Examine merge-sensitive history</entry>
            <entry><userinput>svn log -g; svn blame -g</userinput></entry>
          </row>

          <row>
            <entry>Create a tag from a working copy</entry>
            <entry><userinput>svn copy . <replaceable>tagURL</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Rearrange a branch or tag</entry>
            <entry><userinput>svn move <replaceable>URL1</replaceable> <replaceable>URL2</replaceable></userinput></entry>
          </row>

          <row>
            <entry>Remove a branch or tag</entry>
            <entry><userinput>svn delete <replaceable>URL</replaceable></userinput></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->


<!-- -*- sgml -*- -->

<chapter id="svn.reposadmin">
  <title>Repository Administration</title>

  <para>The Subversion repository is the central storehouse of all
    your versioned data.  As such, it becomes an obvious candidate for
    all the love and attention an administrator can offer.  While the
    repository is generally a low-maintenance item, it is important to
    understand how to properly configure and care for it so that
    potential problems are avoided, and so actual problems are safely
    resolved.</para>

  <para>In this chapter, we'll discuss how to create and configure a
    Subversion repository.  We'll also talk about repository
    maintenance, providing examples of how and when to use various
    related tools provided with Subversion.  We'll address some common
    questions and mistakes and give some suggestions on how to arrange
    the data in the repository.</para>

  <para>If you plan to access a Subversion repository only in the role
    of a user whose data is under version control (i.e., via a
    Subversion client), you can skip this chapter altogether.
    However, if you are, or wish to become, a Subversion repository
    administrator,<footnote><para>This may sound really prestigious
    and lofty, but we're just talking about anyone who is interested
    in that mysterious realm beyond the working copy where everyone's
    data hangs out.</para></footnote> this chapter is for you.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.basics">
    <title>The Subversion Repository, Defined</title>

    <para>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a literal, OS-level perspective how a repository looks and
      acts with respect to non-Subversion tools and from a
      logical perspective dealing with how data is represented
      <emphasis>inside</emphasis> the repository.</para>

    <para>Seen through the eyes of a typical file browser application
      (such as Windows Explorer) or command-line based filesystem
      navigation tools, the Subversion repository is just another
      directory full of stuff.  There are some subdirectories with
      human-readable configuration files in them, some subdirectories
      with some not-so-human-readable data files, and so on.  As in
      other areas of the Subversion design, modularity is given high
      regard, and hierarchical organization is preferred to cluttered
      chaos.  So a shallow glance into a typical repository from a
      nuts-and-bolts perspective is sufficient to reveal the basic
      components of the repository:</para>

    <informalexample>
      <screen>
$ ls repos
conf/  db/  format  hooks/  locks/  README.txt
</screen>
    </informalexample>

    <para>Here's a quick fly-by overview of what exactly you're seeing
      in this directory listing.  (Don't get bogged down in the
      terminology detailed coverage of these components exists
      elsewhere in this and other chapters.)</para>

    <variablelist>
      <varlistentry>
        <term>conf/</term>
        <listitem>
          <para>This directory is a container for configuration
            files.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>db/</term>
        <listitem>
          <para>This directory contains the data store for all of your
            versioned data.<footnote><para>Strictly speaking,
            Subversion doesn't dictate that the versioned data live
            here, and there are known (albeit proprietary) alternative
            backend storage implementations which do not, in fact,
            store data in this directory.</para></footnote></para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>format</term>
        <listitem>
          <para>This file describes the repository's internal
            organizational scheme.  (As it turns out,
            the <filename>db/</filename> subdirectory sometimes also
            contains a <filename>format</filename> file which
            describes only the contents of that subdirectory and which
            is not to be confused with this file.)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>hooks/</term>
        <listitem>
          <para>This directory contains hook script templates and
            hook scripts, if any have been installed.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>locks/</term>
        <listitem>
          <para>Subversion uses this directory to house repository
            lock files, used for managing concurrent access to the
            repository.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>README.txt</term>
        <listitem>
          <para>This is a brief text file containing merely a notice
            to readers that the directory they are looking in is a
            Subversion repository.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>

        <indexterm>
          <primary>WebDAV</primary>
          <secondary>activities</secondary>
        </indexterm>Prior to Subversion 1.5, the on-disk repository
        structure also always contained a <filename>dav</filename>
        subdirectory. <filename>mod_dav_svn</filename> used this
        directory to store information about
        WebDAV <firstterm>activities</firstterm> mappings of
        high-level WebDAV protocol concepts to Subversion commit
        transactions.  Subversion 1.5 changed that behavior, moving
        ownership of the activities directory, and the ability to
        configure its location, into <filename>mod_dav_svn</filename>
        itself.  Now, new repositories will not necessarily have
        a <filename>dav</filename> subdirectory
        unless <filename>mod_dav_svn</filename> is in use and hasn't
        been configured to store its activities database elsewhere.
        See <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn" />
        for more information.</para>

    </note>

    <para>Of course, when accessed via the Subversion libraries, this
      otherwise unremarkable collection of files and directories
      suddenly becomes an implementation of a virtual, versioned
      filesystem, complete with customizable event triggers.  This
      filesystem has its own notions of directories and files, very
      similar to the notions of such things held by real filesystems
      (such as NTFS, FAT32, ext3, etc.).  But this is a special
      filesystem it hangs these directories and files from
      revisions, keeping all the changes you've ever made to them
      safely stored and forever accessible.  This is where the
      entirety of your versioned data lives.</para>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.planning">
    <title>Strategies for Repository Deployment</title>

    <para>Due largely to the simplicity of the overall design of the
      Subversion repository and the technologies on which it relies,
      creating and configuring a repository are fairly straightforward
      tasks.  There are a few preliminary decisions you'll want to
      make, but the actual work involved in any given setup of a
      Subversion repository is pretty basic, tending toward
      mindless repetition if you find yourself setting up multiples of
      these things.</para>

    <para>Some things you'll want to consider beforehand, though, are:</para>

    <itemizedlist>
      <listitem>
        <para>What data do you expect to live in your repository (or
          repositories), and how will that data be organized?</para>
      </listitem>
      <listitem>
        <para>Where will your repository live, and how will it be
          accessed?</para>
      </listitem>
      <listitem>
        <para>What types of access control and repository event
          reporting do you need?</para>
      </listitem>
      <listitem>
        <para>Which of the available types of data store do you want
          to use?</para>
      </listitem>
    </itemizedlist>

    <para>In this section, we'll try to help you answer those
      questions.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.projects.chooselayout">
      <title>Planning Your Repository Organization</title>

      <para>While Subversion allows you to move around versioned files
        and directories without any loss of information, and even
        provides ways of moving whole sets of versioned history from
        one repository to another, doing so can greatly disrupt the
        workflow of those who access the repository often and come to
        expect things to be at certain locations.  So before creating
        a new repository, try to peer into the future a bit; plan
        ahead before placing your data under version control.  By
        conscientiously <quote>laying out</quote> your repository or
        repositories and their versioned contents ahead of time, you
        can prevent many future headaches.</para>

      <para>Let's assume that as repository administrator, you will be
        responsible for supporting the version control system for
        several projects.  Your first decision is whether to use a
        single repository for multiple projects, or to give each
        project its own repository, or some compromise of these
        two.</para>

      <para>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook programs, one thing to routinely back up, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, without losing any historical versioning
        information.</para>

      <para>The downside of using a single repository is that
        different projects may have different requirements in terms of
        the repository event triggers, such as needing to send commit
        notification emails to different mailing lists, or having
        different definitions about what does and does not constitute
        a legitimate commit.  These aren't insurmountable problems, of
        course it just means that all of your hook scripts have
        to be sensitive to the layout of your repository rather than
        assuming that the whole repository is associated with a single
        group of people.  Also, remember that Subversion uses
        repository-global revision numbers.  While those numbers don't
        have any particular magical powers, some folks still don't
        like the fact that even though no changes have been made to
        their project lately, the youngest revision number for the
        repository keeps climbing because other projects are actively
        adding new revisions.<footnote><para>Whether founded in
        ignorance or in poorly considered concepts about how to derive
        legitimate software development metrics, global revision
        numbers are a silly thing to fear,
        and <emphasis>not</emphasis> the kind of thing you should
        weigh when deciding how to arrange your projects and
        repositories.</para></footnote></para>

      <para>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</para>

      <para>
        <indexterm>
          <primary>project root</primary>
        </indexterm>

        After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies within the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <xref linkend="svn.branchmerge"/>), the
        Subversion community recommends that you choose a repository
        location for each project
        root the <quote>topmost</quote> directory
        that contains data related to that project and then
        create three subdirectories beneath that root:
        <filename>trunk</filename>, meaning the directory under which
        the main project development occurs;
        <filename>branches</filename>, which is a directory in which
        to create various named branches of the main development line;
        and <filename>tags</filename>, which is a collection of tree
        snapshots that are created, and perhaps destroyed, but never
        changed.<footnote><para>The <filename>trunk</filename>,
        <filename>tags</filename>, and <filename>branches</filename>
        trio is sometimes referred to as <quote>the TTB
        directories.</quote></para></footnote></para>

      <para>For example, your repository might look like this:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
    
</literallayout>
      </informalexample>

      <para>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like this:</para>

      <informalexample>
        <literallayout>
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
       
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
       
</literallayout>
      </informalexample>

      <para>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a particular layout in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</para>

      <para>In the name of full disclosure, though, we'll mention
        another very common layout.  In this layout, the
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories live in the root
        directory of your repository, and your projects are in
        subdirectories beneath those, like so:</para>

      <informalexample>
        <literallayout>
/
   trunk/
      calc/
      calendar/
      spreadsheet/
       
   tags/
      calc/
      calendar/
      spreadsheet/
       
   branches/
      calc/
      calendar/
      spreadsheet/
       
</literallayout>
      </informalexample>

      <para>There's nothing particularly incorrect about such a
        layout, but it may or may not seem as intuitive for your
        users.  Especially in large, multiproject situations with
        many users, those users may tend to be familiar with only one
        or two of the projects in the repository.  But the
        projects-as-branch-siblings approach tends to deemphasize project
        individuality and focus on the entire set of projects as a
        single entity.  That's a social issue, though.  We like our
        originally suggested arrangement for purely practical
        reasons it's easier to ask about (or modify, or migrate
        elsewhere) the entire history of a single project when there's
        a single repository path that holds the entire
        history past, present, tagged, and branched for
        that project and that project alone.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.hosting">
      <title>Deciding Where and How to Host Your Repository</title>

      <para>Before creating your Subversion repository, an obvious
        question you'll need to answer is where the thing is going to
        live.  This is strongly connected to myriad other
        questions involving how the repository will be accessed (via a
        Subversion server or directly), by whom (users behind your
        corporate firewall or the whole world out on the open
        Internet), what other services you'll be providing around
        Subversion (repository browsing interfaces, email-based
        commit notification, etc.), your data backup strategy, and so
        on.</para>

      <para>We cover server choice and configuration in <xref
        linkend="svn.serverconfig" />, but the point we'd like to
        briefly make here is simply that the answers to some of these
        other questions might have implications that force your hand
        when deciding where your repository will live.  For example,
        certain deployment scenarios might require accessing the
        repository via a remote filesystem from multiple computers, in
        which case (as you'll read in the next section) your choice of
        a repository backend data store turns out not to be a choice
        at all because only one of the available backends will work
        in this scenario.</para>

      <para>Addressing each possible way to deploy
        Subversion is both impossible and outside the scope of this
        book.  We simply encourage you to evaluate your options using
        these pages and other sources as your reference material and to
        plan ahead.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.backends">
      <title>Choosing a Data Store</title>

      <para>
        <indexterm>
          <primary>FSFS</primary>
        </indexterm>
        <indexterm>
          <primary>Berkeley DB</primary>
        </indexterm>
        <indexterm>
          <primary>BDB</primary>
          <see>Berkeley DB</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem</secondary>
        </indexterm>Subversion provides two options for the
        type of underlying data store often referred to as
        <quote>the backend</quote> or, somewhat confusingly,
        <quote>the (versioned) filesystem</quote> that each
        repository uses.  One type of data store keeps everything in a
        Berkeley DB (or BDB) database environment; repositories that
        use this type are often referred to as being
        <quote>BDB-backed.</quote> The other type stores data in
        ordinary flat files, using a custom format.  Subversion
        developers have adopted the habit of referring to this latter
        data storage mechanism
        as <firstterm>FSFS</firstterm><footnote><para>Often
        pronounced <quote>fuzz-fuzz,</quote> if Jack Repenning has
        anything to say about it.  (This book, however, assumes that
        the reader is
        thinking <quote>eff-ess-eff-ess.</quote>)</para></footnote> a
        versioned filesystem implementation that uses the native OS
        filesystem directly rather than via a database library
        or some other abstraction layer to store data.</para>

      <para><xref linkend="svn.reposadmin.basics.backends.tbl-1" />
        gives a comparative overview of Berkeley DB and FSFS
        repositories.</para>

      <table id="svn.reposadmin.basics.backends.tbl-1">
        <title>Repository data store comparison</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Category</entry>
              <entry>Feature</entry>
              <entry>Berkeley DB</entry>
              <entry>FSFS</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">Reliability</entry>
              <entry>Data integrity</entry>
              <entry>When properly deployed, extremely reliable;
                Berkeley DB 4.4 brings auto-recovery</entry>
              <entry>Older versions had some rarely demonstrated, but
                data-destroying bugs</entry>
            </row>
            <row>
              <entry>Sensitivity to interruptions</entry>
              <entry>Very; crashes and permission problems can leave the
                database <quote>wedged,</quote> requiring journaled
                recovery procedures</entry>
              <entry>Quite insensitive</entry>
            </row>
            <row>
              <entry morerows="3">Accessibility</entry>
              <entry>Usable from a read-only mount</entry>
              <entry>No</entry>
              <entry>Yes</entry>
            </row>
            <row>
              <entry>Platform-independent storage</entry>
              <entry>No</entry>
              <entry>Yes</entry>
            </row>
            <row>
              <entry>Usable over network filesystems</entry>
              <entry>Generally, no</entry>
              <entry>Yes</entry>
            </row>
            <row>
              <entry>Group permissions handling</entry>
              <entry>Sensitive to user umask problems; best if accessed
                by only one user</entry>
              <entry>Works around umask problems</entry>
            </row>
            <row>
              <entry morerows="2">Scalability</entry>
              <entry>Repository disk usage</entry>
              <entry>Larger (especially if logfiles aren't purged)</entry>
              <entry>Smaller</entry>
            </row>
            <row>
              <entry>Number of revision trees</entry>
              <entry>Database; no problems</entry>
              <entry>Some older native filesystems don't scale well with
                thousands of entries in a single directory</entry>
            </row>
            <row>
              <entry>Directories with many files</entry>
              <entry>Slower</entry>
              <entry>Faster</entry>
            </row>
            <row>
              <entry morerows="1">Performance</entry>
              <entry>Checking out latest revision</entry>
              <entry>No meaningful difference</entry>
              <entry>No meaningful difference</entry>
            </row>
            <row>
              <entry>Large commits</entry>
              <entry>Slower overall, but cost is amortized across the
                lifetime of the commit</entry>
              <entry>Faster overall, but finalization delay may cause 
                client timeouts</entry>
            </row>
          </tbody>
        </tgroup>      
      </table>

      <para>There are advantages and disadvantages to each of these
        two backend types.  Neither of them is more
        <quote>official</quote> than the other, though the newer FSFS
        is the default data store as of Subversion 1.2.  Both are
        reliable enough to trust with your versioned data.  But as you
        can see in <xref
        linkend="svn.reposadmin.basics.backends.tbl-1" />, the FSFS
        backend provides quite a bit more flexibility in terms of its
        supported deployment scenarios.  More flexibility means you
        have to work a little harder to find ways to deploy it
        incorrectly.  Those reasons plus the fact that not using
        Berkeley DB means there's one fewer component in the
        system largely explain why today almost everyone uses
        the FSFS backend when creating new repositories.</para>

      <para>Fortunately, most programs that access Subversion
        repositories are blissfully ignorant of which backend data
        store is in use.  And you aren't even necessarily stuck with
        your first choice of a data store in the event that you
        change your mind later, Subversion provides ways of migrating
        your repository's data into another repository that uses a
        different backend data store.  We talk more about that later
        in this chapter.</para>

      <para>The following subsections provide a more detailed look at
        the available backend data store types.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.bdb">
        <title>Berkeley DB</title>
        
        <para>
          <indexterm>
            <primary>Berkeley DB</primary>
          </indexterm>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open source license,
          transaction support, reliability, performance, API
          simplicity, thread safety, support for cursors, and so
          on.</para>

        <para>Berkeley DB provides real transaction
          support perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database not a database that
          is constantly changing at the hand of some other
          process and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as though
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</para>

        <para>Another great feature of Berkeley DB is <firstterm>hot
          backups</firstterm> the ability to back up the
          database environment without taking it
          <quote>offline.</quote> We'll discuss how to back up your
          repository later in this chapter (in <xref
          linkend="svn.reposadmin.maint.backup"/>), but the benefits
          of being able to make fully functional copies of your
          repositories without any downtime should be obvious.</para>

        <para>Berkeley DB is also a very reliable database system when
          properly used.  Subversion uses Berkeley DB's logging
          facilities, which means that the database first writes to
          on-disk logfiles a description of any modifications it is
          about to make, and then makes the modification itself.  This
          is to ensure that if anything goes wrong, the database
          system can back up to a previous
          <firstterm>checkpoint</firstterm> a location in the
          logfiles known not to be corrupt and replay
          transactions until the data is restored to a usable state.
          See <xref linkend="svn.reposadmin.maint.diskspace"/> later
          in this chapter for more about Berkeley DB logfiles.</para>

        <para>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture-independent,
          other aspects of the environment are not.
          Second, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems if you need to house
          a BDB-backed repository on a Windows machine, stick with
          Windows 2000 or later.</para>

        <para>While Berkeley DB promises to behave correctly on
          network shares that meet a particular set of
          specifications,<footnote><para>Berkeley DB requires that the
          underlying filesystem implement strict POSIX locking
          semantics, and more importantly, the ability to map files
          directly into process memory.</para></footnote> most
          networked filesystem types and appliances do
          <emphasis>not</emphasis> actually meet those requirements.
          And in no case can you allow a BDB-backed repository that
          resides on a network share to be accessed by multiple
          clients of that share at once (which quite often is the
          whole point of having the repository live on a network share
          in the first place).</para>

        <warning>
          <para>If you attempt to use Berkeley DB on a noncompliant
            remote filesystem, the results are unpredictable you
            may see mysterious errors right away, or it may be months
            before you discover that your repository database is
            subtly corrupted.  You should strongly consider using the
            FSFS data store for repositories that need to live on a
            network share.</para>
        </warning>
          
        <para>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and cleans up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to <quote>wedge</quote>
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.</para>

        <note>
          <para>Berkeley DB 4.4 brings (to Subversion 1.4 and later)
            the ability for Subversion to automatically and
            transparently recover Berkeley DB environments in need of
            such recovery.  When a Subversion process attaches to a
            repository's Berkeley DB environment, it uses some process
            accounting mechanisms to detect any unclean disconnections
            by previous processes, performs any necessary recovery,
            and then continues on as though nothing happened.  This
            doesn't completely eliminate instances of repository
            wedging, but it does drastically reduce the amount of
            human interaction required to recover from them.</para>
        </note>

        <para>So while a Berkeley DB repository is quite fast and
          scalable, it's best used by a single server process running
          as one user such as Apache's <command>httpd</command>
          or <command>svnserve</command> (see <xref
          linkend="svn.serverconfig"/>) rather than accessing it
          as many different users via <literal>file://</literal> or
          <literal>svn+ssh://</literal> URLs.  If you're accessing a Berkeley
          DB repository directly as multiple users, be sure to read
          <xref linkend="svn.serverconfig.multimethod"/> later in this
          chapter.</para>

      </sect3>
      
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.basics.backends.fsfs">
        <title>FSFS</title>

        <para>
          <indexterm>
            <primary>FSFS</primary>
          </indexterm>In mid-2004, a second type of repository storage
          system one that doesn't use a database at
          all came into being.  An FSFS repository stores the
          changes associated with a revision in a single file, and so
          all of a repository's revisions can be found in a single
          subdirectory full of numbered files.  Transactions are
          created in separate subdirectories as individual files.
          When complete, the transaction file is renamed and moved
          into the revisions directory, thus guaranteeing that commits
          are atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          <quote>hot,</quote> just like a BDB-backed
          repository.</para>

        <sidebar id="svn.reposadmin.basics.backends.fsfs.revfiles">
          <title>Revision files and shards</title>

          <para>FSFS repositories contain files that describe the
            changes made in a single revision, and files that contain
            the revision properties associated with a single revision.
            Repositories created in versions of Subversion prior to
            1.5 keep these files in two directories one for each
            type of file.  As new revisions are committed to the
            repository, Subversion drops more files into these two
            directories over time, the number of these files in
            each directory can grow to be quite large.  This has been
            observed to cause performance problems on certain
            network-based filesystems.</para>

          <para>
            <indexterm>
              <primary>FSFS</primary>
              <secondary>sharding</secondary>
            </indexterm>Subversion 1.5 creates FSFS-backed
            repositories using a slightly modified layout in which the
            contents of these two directories
            are <firstterm>sharded</firstterm>, or scattered across
            several subdirectories.  This can greatly reduce the time
            it takes the system to locate any one of these files, and
            therefore increases the overall performance of Subversion
            when reading from the repository.</para>

          <para>
            <indexterm>
              <primary>FSFS</primary>
              <secondary>packing</secondary>
            </indexterm>Subversion 1.6 and later takes the sharded
            layout one step further, allowing administrators to
            optionally <firstterm>pack</firstterm> each of their
            repository shards up into a single multi-revision file.
            This can have both performance and disk usage benefits.
            See
            <xref linkend="svn.reposadmin.maint.diskspace.fsfspacking"/>
            for more information.</para>

        </sidebar>

        <para>The FSFS revision files describe a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          no journaling or shared-memory files are being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means the overall repository
          size is a bit smaller.</para>

        <para>FSFS has different performance characteristics, too.
          When committing a directory with a huge number of files,
          FSFS is able to more quickly append directory entries.  On
          the other hand, FSFS has a longer delay when finalizing a
          commit while it performs tasks that the BDB backend
          amortizes across the lifetime of the commit, which could in
          extreme cases cause clients to time out while waiting for a
          response.</para>

        <para>The most important distinction, however, is FSFS's
          imperviousness to wedging when something goes wrong.  If a
          process using a Berkeley DB database runs into a permissions
          problem or suddenly crashes, the database can be left in an
          unusable state until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</para>

      </sect3>
    </sect2>

  </sect1>
 
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.create">
    <title>Creating and Configuring Your Repository</title>

    <para>Earlier in this chapter (in
      <xref linkend="svn.reposadmin.planning" />), we looked at some
      of the important decisions that should be made before creating
      and configuring your Subversion repository.  Now, we finally get
      to get our hands dirty!  In this section, we'll see how to
      actually create a Subversion repository and configure it to
      perform custom actions when special repository events
      occur.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.basics.creating">
      <title>Creating the Repository</title>
   
      <para>Subversion repository creation is an incredibly simple
        task.  The <command>svnadmin</command> utility that comes with
        Subversion provides a subcommand (<command>svnadmin
        create</command>) for doing just that.</para>

      <informalexample>
        <screen>
$ # Create a repository
$ svnadmin create /var/svn/repos
$
</screen>
      </informalexample>
          
      <para>Assuming that the parent directory 
        <filename>/var/svn</filename> exists and that you have
        sufficient permissions to modify that directory, the previous
        command creates a new repository in the directory
        <filename>/var/svn/repos</filename>, and with the default
        filesystem data store (FSFS).  You can explicitly choose the
        filesystem type using the <option>--fs-type</option> argument,
        which accepts as a parameter either <literal>fsfs</literal> or
        <literal>bdb</literal>.</para>

      <informalexample>
        <screen>
$ # Create an FSFS-backed repository
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</screen>
      </informalexample>

      <informalexample>
        <screen>
# Create a Berkeley-DB-backed repository
$ svnadmin create --fs-type bdb /var/svn/repos
$
</screen>
      </informalexample>
              
      <para>After running this simple command, you have a Subversion
        repository.  Depending on how users will access this new
        repository, you might need to fiddle with its filesystem
        permissions.  But since basic system administration is rather
        outside the scope of this text, we'll leave further
        exploration of that topic as an exercise to the reader.</para>

      <tip>
        <para>The path argument to <command>svnadmin</command> is just
          a regular filesystem path and not a URL like the
          <command>svn</command> client program uses when referring to
          repositories.  Both <command>svnadmin</command> and
          <command>svnlook</command> are considered server-side
          utilities they are used on the machine where the
          repository resides to examine or modify aspects of the
          repository, and are in fact unable to perform tasks across a
          network.  A common mistake made by Subversion newcomers is
          trying to pass URLs (even <quote>local</quote>
          <literal>file://</literal> ones) to these two programs.</para>
      </tip>

      <para>Present in the <filename>db/</filename> subdirectory of
        your repository is the implementation of the versioned
        filesystem.  Your new repository's versioned filesystem begins
        life at revision 0, which is defined to consist of nothing but
        the top-level root (<filename>/</filename>) directory.
        Initially, revision 0 also has a single revision property,
        <literal>svn:date</literal>, set to the time at which the
        repository was created.</para>

      <para>Now that you have a repository, it's time to customize
        it.</para>

      <warning>
        <para>While some parts of a Subversion repository such
          as the configuration files and hook scripts are meant
          to be examined and modified manually, you shouldn't (and
          shouldn't need to) tamper with the other parts of the
          repository <quote>by hand.</quote>  The
          <command>svnadmin</command> tool should be sufficient for
          any changes necessary to your repository, or you can look to
          third-party tools (such as Berkeley DB's tool suite) for
          tweaking relevant subsections of the repository.  Do
          <emphasis>not</emphasis> attempt manual manipulation of your
          version control history by poking and prodding around in
          your repository's data store files!</para>
      </warning>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.hooks">
      <title>Implementing Repository Hooks</title>

      <para>
        <indexterm>
          <primary>hook scripts</primary>
        </indexterm>
        <indexterm>
          <primary>hooks</primary>
          <see>hook scripts</see>
        </indexterm>
        <indexterm>
          <primary>repositories</primary>
          <secondary>hooks</secondary>
          <see>hook scripts</see>
        </indexterm>A <firstterm>hook</firstterm> is a program
        triggered by some repository event, such as the creation of a
        new revision or the modification of an unversioned property.
        Some hooks (the so-called <quote>pre hooks</quote>) run in
        advance of a repository operation and provide a means by which
        to both report what is about to happen and prevent it from
        happening at all.  Other hooks (the <quote>post hooks</quote>)
        run after the completion of a repository event and are useful
        for performing tasks that examine but don't
        modify the repository.  Each hook is handed enough
        information to tell what that event is (or was), the specific
        repository changes proposed (or completed), and the username
        of the person who triggered the event.</para>
            
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks:</para>

      <informalexample>
        <screen>
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</screen>
      </informalexample>
            
      <para>There is one template for each hook that the Subversion
        repository supports; by examining the contents of those
        template scripts, you can see what triggers each script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory,
        which can be executed as the name (such as
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>

      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <filename>.tmpl</filename> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <filename>.exe</filename> for programs and
        <filename>.bat</filename> for batch files.</para>

      <para>Subversion executes hooks as the same user who owns the
        process that is accessing the Subversion repository.  In most
        cases, the repository is being accessed via a Subversion
        server, so this user is the same user as whom the server
        runs on the system.  The hooks themselves will need to be
        configured with OS-level permissions that allow that user to
        execute them.  Also, this means that any programs or files
        (including the Subversion repository) accessed directly
        or indirectly by the hook will be accessed as the same user.
        In other words, be alert to potential permission-related
        problems that could prevent the hook from performing the tasks
        it is designed to perform.</para>

      <para>There are several hooks implemented by the Subversion
        repository, and you can get details about each of them in
        <xref linkend="svn.ref.reposhooks" />.  As a repository
        administrator, you'll need to decide which hooks you wish
        to implement (by way of providing an appropriately named and
        permissioned hook program), and how.  When you make this
        decision, keep in mind
        the big picture of how your repository is deployed.
        For example, if you are using server configuration
        to determine which users are permitted to commit
        changes to your repository, you don't need to do this
        sort of access control via the hook system.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.configuration">
        <title>Hook script environment configuration</title>

        <para>By default, Subversion executes hook scripts with an
          empty environment that is, no environment variables
          are set at all, not even <literal>$PATH</literal>
          (or <literal>%PATH%</literal>, under Windows).  Because of
          this, many administrators are baffled when their hook
          program runs fine by hand, but doesn't work when invoked by
          Subversion.  Administrators have historically worked around
          this problem by manually setting all the environment
          variables their hook scripts need in the scripts
          themselves.</para>

        <para>Subversion 1.8 introduces a new way to manage the
          environment of Subversion-executed hook scripts the
          hook script environment configuration file.  If a Subversion
          server finds a file named <filename>hooks-env</filename> in
          the repository's <filename>conf/</filename> subdirectory, it
          parses that file as an INI-formatted configuration file and
          applies the option names and variables found therein to the
          hook script's execution environment as environment
          variables.</para>

        <para>The syntax of the <filename>hooks-env</filename> file is
          pretty straightforward: each section name is the name of a
          hook script (such as <literal>pre-commit</literal>
          or <literal>post-revprop-change</literal>, and the
          configuration items inside that section are treated as
          mappings of environment variable names to desired values.
          Additionally, there is a
          special <literal>[default]</literal> section, which can be
          used to configure environment variable mappings that should
          be applied to <emphasis>all</emphasis> hook scripts (unless
          explicitly overridden by per-hook-script settings).  See
          <xref linkend="svn.reposadmin.hooks.configuration.ex-1" />
          for a sample <filename>hooks-env</filename> configuration
          file.</para>

        <example id="svn.reposadmin.hooks.configuration.ex-1">
          <title>hooks-env (custom hook script environment
            configuration)</title>

          <programlisting>
# All scripts should use a UTF-8 locale and have our hook script
# utilities directory on the search path.

[default]
LANG = en_US.UTF-8
PATH = /usr/local/svn/tools:/usr/bin


# The post-commit and post-revprop-change scripts want to run
# programs from our custom synctools replication software suite, too.

[post-commit]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s

[post-revprop-change]
PATH = /usr/local/synctools-1.1/bin:%(PATH)s
</programlisting>
        </example>

        <note>
          <para><xref linkend="svn.reposadmin.hooks.configuration.ex-1"
            /> also demonstrates the nifty string substitution syntax
            found in Subversion's configuration file parser.  In this
            example, the value of the <literal>PATH</literal>
            option pulled from the <literal>[default]</literal>
            section of the file is substituted in place of
            the <literal>%(PATH)s</literal> placeholder text in the
            per-hook sections.  For more about this special syntax,
            see the <filename>README.txt</filename> file which lives
            in the Subversion runtime configuration directory.  (And
            for more information about that directory, see
            <xref linkend="svn.advanced.confarea" />.)</para>
        </note>

        <para>Of course, having exact duplicates of your custom hook
          script environment configuration files in every single
          repository's <filename>conf/</filename> directory could get
          cumbersome, especially when you need to make changes to them
          all.  So Subversion's servers allow you to specify an
          alternate (possibly shared) location for this configuration
          information.</para>

        <!-- ### TODO:  Add cross reference for the above! -->

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.uses">
        <title>Common uses for hook scripts</title>

        <para>Repository hook scripts can offer a wide range of
          utility, but most tend to fall into a few basic categories:
          notification, validation, and replication.</para>

        <para>Notification scripts are those which tell someone that
          something happened.  The most common of these found in a
          Subversion service offering involve programs which send
          commit and revision property change notification emails to
          project members, driven by the post-commit and
          post-revprop-change hooks, respectively.  There are numerous
          other notification approaches, from issue tracker integration
          scripts to scripts which operate as IRC bots to announce
          that something's changed in the repository.</para>

        <para>On the validation side of things, the start-commit and
          pre-commit hooks are widely used to allow or disallow
          commits based on various criteria: the author of the commit,
          the formatting and/or content of the log message which describes the
          commit, and even the low-level details of the changes made
          to files and directories in the commit.  Likewise, the
          pre-revprop-change hook acts as the gateway to revision
          property changes, which is an especially valuable role
          considering the fact that revision properties are not
          themselves versioned, and can therefore only be modified
          destructively.</para>
        
        <para>One special class of change validation that has seen
          widespread use since Subversion 1.5 was released is
          validation of the committing client software itself.  When
          Subversion's merge tracking feature (described extensively
          in <xref linkend="svn.branchmerge" />) was introduced in
          that release, Subversion administrators needed a way to
          ensure that once users of their repositories started using
          the new feature that <emphasis>all</emphasis> their merges
          were tracked.  To reduce the chance of someone committing an
          untracked merge to the repository, they used start-commit
          hooks to examine the feature capabilities string advertised
          by Subversion clients.  If the committing client didn't
          advertise support for merge tracking, the commit was denied
          with instructions to the user to immediately update their
          Subversion client!
          <xref linkend="svn.reposadmin.hooks.uses.ex-1" /> provides
          an example of a start-commit script which does precisely
          this.</para>

        <example id="svn.reposadmin.hooks.uses.ex-1">
          <title>start-commit hook to require merge tracking
            support</title>

          <programlisting>
#!/usr/bin/env python
import sys

# sys.argv[3] is a colon-delimited capabilities list
if 'mergeinfo' not in sys.argv[3].split(':'):
  sys.stderr.write("""\
ERROR: Commits to this repository must be made using Subversion
clients which support the merge tracking feature.  Please upgrade
your client to at least Subversion 1.5.0.
""")
  sys.exit(1)
</programlisting>
        </example>
        
        <para>
          <indexterm>
            <primary>properties</primary>
            <secondary>ephemeral transaction properties</secondary>
          </indexterm>Beginning in Subversion 1.8, clients committing
          against a Subversion 1.8 server will still provide the
          feature capabilities string, but will also provide
          additional information about themselves by way
          of <firstterm>ephemeral transaction properties</firstterm>.
          Ephemeral transaction properties are essentially revision
          properties which are set on the commit transaction by the
          client at the earliest opportunity while committing, but
          which are automatically removed by the server immediately
          prior to the transaction becoming a finalized revision.  You
          can inspect these properties using the same tools with which
          you'd inspect other unversioned properties set on commit
          transactions during the timeframe between which the
          start-commit and pre-commit repository hook scripts would
          operate.</para>

        <para>The following are the ephemeral transaction properties
          which Subversion currently provides and implements:</para>

        <variablelist>
  
          <varlistentry>
            <term><literal>svn:txn-client-compat-version</literal></term>
            <listitem>
              <para>Carries the Subversion library version string with
                which the committing client claims compatibility.
                This is useful for deciding whether the client
                supports the minimal feature set required for proper
                handling of the repository data.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>svn:txn-user-agent</literal></term>
            <listitem>
              <para>Carries the <quote>user agent</quote> string which
                describes the committing client program.  Subversion's
                libraries define the initial portion of this string,
                but third-party consumers of the API (GUI clients,
                etc.) can append custom information to it.</para>
            </listitem>
          </varlistentry>
  
        </variablelist>

        <!-- ### TODO: Show an example of these being used?  Or ### -->
        <!-- ###       do so in ch07 - Customizing Subversion   ### -->
        <!-- ###       with a cross-reference here.             ### -->

        <note>
          <para>While most clients will transmit ephemeral transaction
            properties early enough in the commit process that they
            may be inspected by the start-commit hook script, some
            configurations of Subversion will cause those properties
            to not be set on the transaction until later in the commit
            process.  Administrators should consider performing any
            validation based on ephemeral transaction properties in
            both the start-commit and pre-commit hooks the
            former to rule out invalid clients before those clients
            transmit the commit payload; the latter <quote>just in
            case</quote> the validation checks couldn't be performed
            by the start-commit hook.</para>
        </note>

        <para>As noted before, ephemeral transaction properties are
          removed from the transaction just before it is promoted to a
          new revision.  Some administrators may wish to preserve the
          information in those properties indefinitely.  We suggest
          that you do so by using the pre-commit hook script to copy
          the values of those properties to new property names.  In
          fact, the Subversion source code distribution provides a
          <filename>persist-ephemeral-txnprops.py</filename> script
          (in the <filename>tools/hook-scripts/</filename>
          subdirectory) for doing precisely that.</para>

        <para>The third common type of hook script usage is for the
          purpose of replication.  Whether you are driving a simple
          backup process or a more involved remote repository
          mirroring scenario, hook scripts can be critical.  See
          <xref linkend="svn.reposadmin.maint.backup" /> and
          <xref linkend="svn.reposadmin.maint.replication" /> for more
          information about these aspects of repository
          maintenance.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.hooks.summary">
        <title>Finding hook scripts or rolling your own</title>

        <para>As you might imagine, there is no shortage of Subversion
          hook programs and scripts that are freely available either
          from the Subversion community itself or elsewhere.  In fact,
          the Subversion distribution provides several commonly used
          hook scripts in its <filename>tools/hook-scripts/</filename>
          subdirectory.  However, if you are unable to find one that
          meets your specific needs, you might consider writing your
          own.  See <xref linkend="svn.developer" /> for information
          about developing software using Subversion's public
          APIs.</para>

        <warning>
          <para>While hook scripts can do almost anything, there is
            one dimension in which hook script authors should show
            restraint: do <emphasis>not</emphasis> modify a commit
            transaction using hook scripts.  While it might be
            tempting to use hook scripts to automatically correct
            errors, shortcomings, or policy violations present in the
            files being committed, doing so can cause problems.
            Subversion keeps client-side caches of certain bits of
            repository data, and if you change a commit transaction in
            this way, those caches become indetectably stale.  This
            inconsistency can lead to surprising and unexpected
            behavior.  Instead of modifying the transaction, you
            should simply <emphasis>validate</emphasis> the
            transaction in the <filename>pre-commit</filename> hook
            and reject the commit if it does not meet the desired
            requirements.  As a bonus, your users will learn the value
            of careful, compliance-minded work habits.</para>
        </warning>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.bdb">
      <title>Berkeley DB Configuration</title>

      <para>A Berkeley DB environment is an encapsulation of one or
        more databases, logfiles, region files, and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things such as the number of database
        locks allowed to be taken out at any given time, the maximum
        size of the journaling logfiles, and so on.  Subversion's
        filesystem logic additionally chooses default values for some
        of the Berkeley DB configuration options.  However, sometimes
        your particular repository, with its unique collection of data
        and access patterns, might require a different set of
        configuration option values.</para>

      <para>The producers of Berkeley DB understand that different
        applications and database environments have different
        requirements, so they have provided a mechanism for overriding
        at runtime many of the configuration values for the Berkeley
        DB environment.  BDB checks for the presence of a file named
        <filename>DB_CONFIG</filename> in the environment directory
        (namely, the repository's <filename>db</filename>
        subdirectory), and parses the options found in that file.
        Subversion itself creates this file when it creates the rest
        of the repository.  The file initially contains some default
        options, as well as pointers to the Berkeley DB online
        documentation so that you can read about what those options do.  Of
        course, you are free to add any of the supported Berkeley DB
        options to your <filename>DB_CONFIG</filename> file.  Just be
        aware that while Subversion never attempts to read or
        interpret the contents of the file and makes no direct use of
        the option settings in it, you'll want to avoid any
        configuration changes that may cause Berkeley DB to behave in
        a fashion that is at odds with what Subversion might expect.
        Also, changes made to <filename>DB_CONFIG</filename> won't
        take effect until you recover the database environment (using
        <command>svnadmin recover</command>).</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.create.fsfs">
      <title>FSFS Configuration</title>

      <para>As of Subversion 1.6, FSFS filesystems have several
        configurable parameters which an administrator can use to
        fine-tune the performance or disk usage of their repositories.
        You can find these options and the documentation for
        them in the <filename>db/fsfs.conf</filename> file in
        the repository.</para>

    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint">
    <title>Repository Maintenance</title>

    <para>Maintaining a Subversion repository can be daunting, mostly
      due to the complexities inherent in systems that have a database
      backend.  Doing the task well is all about knowing the
      tools what they are, when to use them, and how.  This
      section will introduce you to the repository administration
      tools provided by Subversion and discuss how to wield them to
      accomplish tasks such as repository data migration, upgrades,
      backups, and cleanups.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.tk">
      <title>An Administrator's Toolkit</title>

      <para>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying, and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnadmin">
        <title>svnadmin</title>

        <para>
          <indexterm>
            <primary>svnadmin</primary>
          </indexterm>The <command>svnadmin</command> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <command>svnadmin</command> is similar to that of other
          Subversion command-line programs:</para>

        <informalexample>
          <screen>
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnadmin --version' to see the program version and FS modules.

Available subcommands:
   crashtest
   create
   deltify
 
</screen>
        </informalexample>

        <para>Previously in this chapter (in <xref
          linkend="svn.reposadmin.basics.creating"/>), we were
          introduced to the <command>svnadmin create</command>
          subcommand.  Most of the other <command>svnadmin</command>
          subcommands we will cover later in this chapter.  And you
          can consult <xref linkend="svn.ref.svnadmin" /> for a full
          rundown of subcommands and what each of them offers.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnlook">
        <title>svnlook</title>
            
        <para>
          <indexterm>
            <primary>svnlook</primary>
          </indexterm>
          <indexterm>
            <primary>revisions</primary>
            <secondary>inspection</secondary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
          </indexterm>
          <indexterm>
            <primary>transactions</primary>
            <secondary>inspection</secondary>
          </indexterm><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          <firstterm>transactions</firstterm> (which are revisions
          in the making) in a repository.  No part of this program
          attempts to change the repository.  <command>svnlook</command>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</para>
            
        <para><command>svnlook</command> has a straightforward
          syntax:</para>

        <informalexample>
          <screen>
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnlook --version' to see the program version and FS modules.
 
</screen>
        </informalexample>

        <para>Most of <command>svnlook</command>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <option>--revision</option>
          (<option>-r</option>) and <option>--transaction</option>
          (<option>-t</option>) options to specify which revision or
          transaction, respectively, to examine.  In the absence of
          both the <option>--revision</option> (<option>-r</option>)
          and <option>--transaction</option> (<option>-t</option>)
          options, <command>svnlook</command> will examine the
          youngest (or <literal>HEAD</literal>) revision in the
          repository.  So the following two commands do exactly the
          same thing when 19 is the youngest revision in the
          repository located at
          <filename>/var/svn/repos</filename>:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</screen>
        </informalexample>

        <para>One exception to these rules about subcommands is
          the <command>svnlook youngest</command> subcommand, which
          takes no options and simply prints out the repository's
          youngest revision number:</para>

        <informalexample>
          <screen>
$ svnlook youngest /var/svn/repos
19
$
</screen>
        </informalexample>

        <note>
          <para>Keep in mind that the only transactions you can browse
            are uncommitted ones.  Most repositories will have no such
            transactions because transactions are usually either
            committed (in which case, you should access them as
            revision with the <option>--revision</option>
            (<option>-r</option>) option) or aborted and
            removed.</para>
        </note>
            
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  Take, as an example, the
          output of the <command>svnlook info</command> subcommand:</para>

        <informalexample>
          <screen>
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
$
</screen>
        </informalexample>

        <para>The output of <command>svnlook info</command> consists
          of the following, in the order given:</para>

        <orderedlist>
          <listitem>
            <para>The author, followed by a newline</para>
          </listitem>
          <listitem>
            <para>The date, followed by a newline</para>
          </listitem>
          <listitem>
            <para>The number of characters in the log message,
              followed by a newline</para>
          </listitem>
          <listitem>
            <para>The log message itself, followed by a newline</para>
          </listitem>
        </orderedlist>

        <para>This output is human-readable, meaning items such as the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tastee Freez guy drove by).  But the
          output is also machine-parsable because the log
          message can contain multiple lines and be unbounded in
          length, <command>svnlook</command> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</para>

        <para><command>svnlook</command> can perform a variety of
          other queries:  displaying subsets of bits of information
          we've mentioned previously, recursively listing versioned
          directory trees, reporting which paths were modified in a
          given revision or transaction, showing textual and property
          differences made to files and directories, and so on.  See
          <xref linkend="svn.ref.svnlook" /> for a full reference of
          <command>svnlook</command>'s features.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svndumpfilter">
        <title>svndumpfilter</title>

        <para>While it won't be the most commonly used tool at the
          administrator's disposal, <command>svndumpfilter</command>
          provides a very particular brand of useful
          functionality the ability to quickly and easily modify
          streams of Subversion repository history data by acting as a
          path-based filter.</para>

        <para>The syntax of <command>svndumpfilter</command> is as
          follows:</para>

        <informalexample>
          <screen>
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type 'svndumpfilter help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svndumpfilter --version' to see the program version.
  
Available subcommands:
   exclude
   include
   help (?, h)
</screen>
        </informalexample>

        <para>There are only two interesting subcommands:
          <command>svndumpfilter exclude</command> and
          <command>svndumpfilter include</command>.  They allow you to
          make the choice between implicit or explicit inclusion of
          paths in the stream.  You can learn more about these
          subcommands and <command>svndumpfilter</command>'s unique
          purpose later in this chapter, in <xref
          linkend="svn.reposadmin.maint.filtering" />.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnrdump">
        <title>svnrdump</title>

        <para>The <command>svnrdump</command> program is, to put it
          simply, essentially just network-aware flavors of
          the <command>svnadmin dump</command> and <command>svnadmin
          load</command> subcommands, rolled up into a separate
          program.</para>

        <informalexample>
          <screen>
$ svnrdump help
general usage: svnrdump SUBCOMMAND URL [-r LOWER[:UPPER]]
Type 'svnrdump help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnrdump --version' to see the program version and RA modules.

Available subcommands:
   dump
   load
   help (?, h)

$
</screen>
        </informalexample>

        <para>We discuss the use of <command>svnrdump</command> and
          the aforementioned <command>svnadmin</command> commands
          later in this chapter (see
          <xref linkend="svn.reposadmin.maint.migrate" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.svnsync">
        <title>svnsync</title>

        <para>The <command>svnsync</command> program provides all the
          functionality required for maintaining a read-only mirror of
          a Subversion repository.  The program really has one
          job to transfer one repository's versioned history
          into another repository.  And while there are few ways to do
          that, its primary strength is that it can operate
          remotely the <quote>source</quote> and
          <quote>sink</quote><footnote><para>Or is that,
          the <quote>sync</quote>?</para></footnote> repositories may
          be on different computers from each other and
          from <command>svnsync</command> itself.</para>

        <para>As you might expect, <command>svnsync</command> has a
          syntax that looks very much like every other program we've
          mentioned in this chapter:</para>

        <informalexample>
          <screen>
$ svnsync help
general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]
Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.
Type 'svnsync --version' to see the program version and RA modules.

Available subcommands:
   initialize (init)
   synchronize (sync)
   copy-revprops
   info
   help (?, h)
$
</screen>
        </informalexample>

        <para>We talk more about replicating repositories with
          <command>svnsync</command> later in this chapter (see <xref
          linkend="svn.reposadmin.maint.replication" />).</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.fsfsreshard">
        <title>fsfs-reshard.py</title>

        <para>While not an official member of the Subversion
          toolchain, the <command>fsfs-reshard.py</command> script
          (found in the <filename>tools/server-side</filename>
          directory of the Subversion source distribution) is a useful
          performance tuning tool for administrators of FSFS-backed
          Subversion repositories.  As described in the sidebar
          <xref linkend="svn.reposadmin.basics.backends.fsfs.revfiles"/>,
          FSFS repositories use individual files to house information
          about each revision.  Sometimes these files all live in a
          single directory; sometimes they are sharded across many
          directories.  But the neat thing is that the number of
          directories used to house these files is configurable.
          That's where <command>fsfs-reshard.py</command> comes
          in.</para>

        <para><command>fsfs-reshard.py</command> reshuffles the
          repository's file structure into a new arrangement that
          reflects the requested number of sharding subdirectories and
          updates the repository configuration to preserve this
          change.  When used in conjunction with the <command>svnadmin
          upgrade</command> command, this is especially useful for
          upgrading a pre-1.5 Subversion (unsharded) repository to the
          latest filesystem format and sharding its data files (which
          Subversion will not automatically do for you).  This script
          can also be used for fine-tuning an already sharded
          repository.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.tk.bdbutil">
        <title>Berkeley DB utilities</title>

        <para>If you're using a Berkeley DB repository, all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <filename>db/</filename>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory and can therefore
          be used in conjunction with any of the Berkeley database
          tools, typically provided as part of the Berkeley DB
          distribution.</para>

        <para>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <command>svnadmin</command> tool.  For example,
          <command>svnadmin list-unused-dblogs</command> and
          <command>svnadmin list-dblogs</command> perform a
          subset of what is provided by the Berkeley
          <command>db_archive</command> utility, and <command>svnadmin
          recover</command> reflects the common use cases of the
          <command>db_recover</command> utility.</para>
            
        <para>However, there are still a few Berkeley DB utilities
          that you might find useful.  The <command>db_dump</command>
          and <command>db_load</command> programs write and read,
          respectively, a custom file format that describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  As we describe later in this chapter, you
          can also use <command>svnadmin dump</command> and
          <command>svnadmin load</command> for similar purposes, but
          <command>db_dump</command> and <command>db_load</command>
          can do certain jobs just as well and much faster.  They can
          also be useful if the experienced Berkeley DB hacker needs
          to do in-place tweaking of the data in a BDB-backed
          repository for some reason, which is something Subversion's
          utilities won't allow.  Also, the <command>db_stat</command>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</para>

        <para>For more information on the Berkeley DB tool chain,
          visit the documentation section of the Berkeley DB section
          of Oracle's web site, located at <ulink
          url="http://www.oracle.com/technology/documentation/berkeley-db/db/"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.setlog">
      <title>Commit Log Message Correction</title>
            
      <para>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <literal>pre-revprop-change</literal> hook; see
        <xref linkend="svn.reposadmin.hooks" />) to accept changes to
        this log message after the commit is finished, the user
        can <quote>fix</quote> her log message remotely using
        <command>svn propset</command> (see <xref
        linkend="svn.ref.svn.c.propset"/> in
        <xref linkend="svn.ref.svn"/>).  However, because of the
        potential to lose information forever, Subversion repositories
        are not, by default, configured to allow changes to
        unversioned properties except by an
        administrator.</para>

      <para>If a log message needs to be changed by an administrator,
        this can be done using <command>svnadmin setlog</command>.
        This command changes the log message (the
        <literal>svn:log</literal> property) on a given revision of a
        repository, reading the new value from a provided file.</para>

      <informalexample>
        <screen>
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</screen>
      </informalexample>
      
      <para>The <command>svnadmin setlog</command> command, by
        default, is still bound by the same protections against
        modifying unversioned properties as a remote client
        is the <literal>pre-revprop-change</literal> and
        <literal>post-revprop-change</literal> hooks are still
        triggered, and therefore must be set up to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <option>--bypass-hooks</option>
        option to the <command>svnadmin setlog</command> command.</para>
 
      <warning>
        <para>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems that track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</para>
      </warning>


    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.diskspace">
      <title>Managing Disk Space</title>

      <para>While the cost of storage has dropped incredibly in the
        past few years, disk usage is still a valid concern for
        administrators seeking to version large amounts of data.
        Every bit of version history information stored in the live
        repository needs to be backed up
        elsewhere, perhaps multiple times as part of rotating backup
        schedules.  It is useful to know what pieces of Subversion's
        repository data need to remain on the live site, which need to
        be backed up, and which can be safely removed.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deltas">
        <title>How Subversion saves disk space</title>

        <para>
          <indexterm>
            <primary>deltification</primary>
          </indexterm>To keep the repository small, Subversion uses
          <firstterm>deltification</firstterm> (or delta-based storage)
          within the repository itself.  Deltification involves
          encoding the representation of a chunk of data as a
          collection of differences against some other chunk of data.
          If the two pieces of data are very similar, this
          deltification results in storage savings for the deltified
          chunk rather than taking up space equal to the size of
          the original data, it takes up only enough space to
          say, <quote>I look just like this other piece of data over
          here, except for the following couple of changes.</quote>
          The result is that most of the repository data that tends to
          be bulky namely, the contents of versioned
          files is stored at a much smaller size than the
          original full-text representation of that data.</para>

        <para>
          <indexterm>
            <primary>representation sharing</primary>
          </indexterm>While deltified storage has been a part of Subversion's
          design since the very beginning, there have been additional
          improvements made over the years.  Subversion repositories
          created with Subversion 1.4 or later benefit from
          compression of the full-text representations of file
          contents.  Repositories created with Subversion 1.6 or later
          further enjoy the disk space savings afforded by
          <firstterm>representation sharing</firstterm>, a feature
          which allows multiple files or file revisions with identical
          file content to refer to a single shared instance of that data
          rather than each having their own distinct copy thereof.</para>

        <note>
          <para>Because all of the data that is subject to
            deltification in a BDB-backed repository is stored in a
            single Berkeley DB database file, reducing the size of the
            stored values will not immediately reduce the size of the
            database file itself.  Berkeley DB will, however, keep
            internal records of unused areas of the database file and
            consume those areas first before growing the size of the
            database file.  So while deltification doesn't produce
            immediate space savings, it can drastically slow future
            growth of the database.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.deadtxns">
        <title>Removing dead transactions</title>

        <para>Though they are uncommon, there are circumstances in
          which a Subversion commit process might fail, leaving behind
          in the repository the remnants of the revision-to-be that
          wasn't an uncommitted transaction and all the file and
          directory changes associated with it.  This could happen for
          several reasons:  perhaps the client operation was
          inelegantly terminated by the user, or a network failure
          occurred in the middle of an operation.
          Regardless of the reason, dead transactions can happen.
          They don't do any real harm, other than consuming disk
          space.  A fastidious administrator may nonetheless wish to
          remove them.</para>

        <para>You can use the <command>svnadmin lstxns</command>
          command to list the names of the currently outstanding
          transactions:</para>

        <informalexample>
          <screen>
$ svnadmin lstxns myrepos
19
3a1
a45
$
</screen>
        </informalexample>

        <para>Each item in the resultant output can then be used with
          <command>svnlook</command> (and its
          <option>--transaction</option> (<option>-t</option>) option)
          to determine who created the transaction, when it was
          created, what types of changes were made in the
          transaction information that is helpful in determining
          whether the transaction is a safe candidate for
          removal!  If you do indeed want to remove a transaction, its
          name can be passed to <command>svnadmin rmtxns</command>,
          which will perform the cleanup of the transaction.  In fact,
          <command>svnadmin rmtxns</command> can take its input
          directly from the output of
          <command>svnadmin lstxns</command>!</para>

        <informalexample>
          <screen>
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</screen>
        </informalexample>

        <para>If you use these two subcommands like this, you should
          consider making your repository temporarily inaccessible to
          clients.  That way, no one can begin a legitimate
          transaction before you start your cleanup.  <xref
          linkend="svn.reposadmin.maint.diskspace.deadtxns.ex-1" />
          contains a bit of shell-scripting that can quickly generate
          information about each outstanding transaction in your
          repository.</para>

        <example id="svn.reposadmin.maint.diskspace.deadtxns.ex-1">
          <title>txn-info.sh (reporting outstanding transactions)</title>

          <programlisting>
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</programlisting>
        </example>

        <para>The output of the script is basically a concatenation of
          several chunks of <command>svnlook info</command> output
          (see <xref linkend="svn.reposadmin.maint.tk.svnlook"/>) and
          will look something like this:</para>

        <informalexample>
          <screen>
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</screen>
        </informalexample>

        <para>A long-abandoned transaction usually represents some
          sort of failed or interrupted commit.  A transaction's
          datestamp can provide interesting information for
          example, how likely is it that an operation begun nine
          months ago is still active?</para>

        <para>In short, transaction cleanup decisions need not be made
          unwisely.  Various sources of information including
          Apache's error and access logs, Subversion's operational
          logs, Subversion revision history, and so on can be
          employed in the decision-making process.  And of course, an
          administrator can often simply communicate with a seemingly
          dead transaction's owner (via email, e.g.) to verify
          that the transaction is, in fact, in a zombie state.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.bdblogs">
        <title>Purging unused Berkeley DB logfiles</title>

        <para>Until recently, the largest offender of disk space usage
          with respect to BDB-backed Subversion repositories were the
          logfiles in which Berkeley DB performs its prewrites before
          modifying the actual database files.  These files capture
          all the actions taken along the route of changing the
          database from one state to another while the database
          files, at any given time, reflect a particular state, the
          logfiles contain all of the many changes along the way
          <emphasis>between</emphasis> states.  Thus, they can grow
          and accumulate quite rapidly.</para>

        <para>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused logfiles automatically.  Any
          repositories created using <command>svnadmin</command>
          when compiled against Berkeley DB version 4.2 or later
          will be configured for this automatic logfile removal.  If
          you don't want this feature enabled, simply pass the
          <option>--bdb-log-keep</option> option to the
          <command>svnadmin create</command> command.  If you forget
          to do this or change your mind at a later time, simply edit
          the <filename>DB_CONFIG</filename> file found in your
          repository's <filename>db</filename> directory, comment out
          the line that contains the <literal>set_flags
          DB_LOG_AUTOREMOVE</literal> directive, and then run
          <command>svnadmin recover</command> on your repository to
          force the configuration changes to take effect.  See <xref
          linkend="svn.reposadmin.create.bdb"/> for more information about
          database configuration.</para>

        <para>Without some sort of automatic logfile removal in
          place, logfiles will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system you should be able to recreate your entire
          database using nothing but the logfiles, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the logfiles that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <command>svnadmin
          list-unused-dblogs</command> command to list the unused
          logfiles:</para>

        <informalexample>
          <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
 
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## disk space reclaimed!
</screen>
        </informalexample>

        <warning>
          <para>BDB-backed repositories whose logfiles are used as
            part of a backup or disaster recovery plan should
            <emphasis>not</emphasis> make use of the logfile
            autoremoval feature.  Reconstruction of a repository's
            data from logfiles can only be accomplished only when
            <emphasis>all</emphasis> the logfiles are available.  If
            some of the logfiles are removed from disk before the
            backup system has a chance to copy them elsewhere, the
            incomplete set of backed-up logfiles is essentially
            useless.</para> </warning>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.diskspace.fsfspacking">
        <title>Packing FSFS filesystems</title>

        <para>As described in the sidebar
          <xref linkend="svn.reposadmin.basics.backends.fsfs.revfiles"/>,
          FSFS-backed Subversion repositories create, by default, a
          new on-disk file for each revision added to the repository.
          Having thousands of these files present on your Subversion
          server even when housed in separate shard
          directories can lead to inefficiencies.</para>

        <para>The first problem is that the operating system has to
          reference many different files over a short period of time.
          This leads to inefficient use of disk caches and, as a
          result, more time spent seeking across large disks.  Because
          of this, Subversion pays a performance penalty when
          accessing your versioned data.</para>

        <para>The second problem is a bit more subtle.  Because of the
          ways that most filesystems allocate disk space, each file
          claims more space on the disk than it actually uses.  The
          amount of extra space required to house a single file can
          average anywhere from 2 to 16 kilobytes <emphasis>per
          file</emphasis>, depending on the underlying
          filesystem in use.  This translates directly
          into a per-revision disk usage penalty for FSFS-backed
          repositories.  The effect is most pronounced in repositories
          which have many small revisions, since the overhead involved
          in storing the revision file quickly outgrows the size of
          the actual data being stored.</para>

        <para>To solve these problems, Subversion 1.6 introduced the
          <command>svnadmin pack</command> command.  By concatenating
          all the files of a completed shard into a single <quote>pack</quote> file
          and then removing the original per-revision
          files, <command>svnadmin pack</command> reduces the file
          count within a given shard down to just a single file.  In
          doing so, it aids filesystem caches and reduces (to one) the
          number of times a file storage overhead penalty is
          paid.</para>

        <para>Subversion can pack existing sharded repositories which
          have been upgraded to the 1.6 filesystem format or later (see
          <xref linkend="svn.ref.svnadmin.c.upgrade"/>) in
          <xref linkend="svn.ref.svnadmin"/>.  To do so, just
          run <command>svnadmin pack</command> on the
          repository:</para>

        <informalexample>
          <screen>
$ svnadmin pack /var/svn/repos
Packing shard 0...done.
Packing shard 1...done.
Packing shard 2...done.
 
Packing shard 34...done.
Packing shard 35...done.
Packing shard 36...done.
$
</screen>
        </informalexample>

        <para>Because the packing process obtains the required locks
          before doing its work, you can run it on live repositories,
          or even as part of a post-commit hook.  Repacking packed
          shards is legal, but will have no effect on the disk usage
          of the repository.</para>

        <para><command>svnadmin pack</command> has no effect on
          BDB-backed Subversion repositories.</para>

      </sect3>
    </sect2>
        
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.recovery">
      <title>Berkeley DB Recovery</title>

      <para>As mentioned in <xref
        linkend="svn.reposadmin.basics.backends.bdb"/>, a Berkeley DB
        repository can sometimes be left in a frozen state if not closed
        properly.  When this happens, an administrator needs to rewind
        the database back into a consistent state.  This is unique to
        BDB-backed repositories, though if you are using
        FSFS-backed ones instead, this won't apply to you.  And for
        those of you using Subversion 1.4 with Berkeley DB 4.4 or
        later, you should find that Subversion has become much more
        resilient in these types of situations.  Still, wedged
        Berkeley DB repositories do occur, and an administrator needs
        to know how to safely deal with this circumstance.</para>

      <para>To protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.  (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; we try to clear up the confusion caused by
        this terminology collision in the sidebar <xref
        linkend="svn.advanced.locking.meanings" />.)</para>

      <para>In the course of using your Subversion repository, fatal
        errors or interruptions can prevent a process from having the
        chance to remove the locks it has placed in the database.  The
        result is that the backend database system gets
        <quote>wedged.</quote>  When this happens, any attempts to
        access the repository hang indefinitely (since each new
        accessor is waiting for a lock to go away which isn't
        going to happen).</para>

      <para>If this happens to your repository, don't panic.  The
        Berkeley DB filesystem takes advantage of database
        transactions, checkpoints, and prewrite journaling to ensure
        that only the most catastrophic of events<footnote><para>For
        example, hard drive + huge electromagnet =
        disaster.</para></footnote> can permanently destroy a database
        environment.  A sufficiently paranoid repository administrator
        will have made off-site backups of the repository data in some
        fashion, but don't head off to the tape backup storage closet
        just yet.</para>

      <para>Instead, use the following recipe to attempt to
        <quote>unwedge</quote> your repository:</para>
   
      <orderedlist>
        <listitem>
          <para>Make sure no processes are accessing (or
            attempting to access) the repository.  For networked
            repositories, this also means shutting down the Apache HTTP
            Server or svnserve daemon.</para>
        </listitem>
        <listitem> 
          <para>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            <quote>unwedged.</quote></para>
        </listitem>
        <listitem>
          <para>Run the command <userinput>svnadmin recover
            /var/svn/repos</userinput>.  You should see output such as
            this:</para>

          <informalexample>
            <screen>
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</screen>
          </informalexample>
          <para>This command may take many minutes to complete.</para>
        </listitem>
        <listitem>
          <para>Restart the server process.</para>
        </listitem>
      </orderedlist>
            
      <para>This procedure fixes almost every case of repository
        wedging.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <literal>root</literal>.  Part of the recovery process might
        involve re-creating from scratch various database files (shared
        memory regions, e.g.).  Recovering as
        <literal>root</literal> will create those files such that they
        are owned by <literal>root</literal>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</para>

      <para>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository directory aside
        (perhaps by renaming it to something like
        <filename>repos.BROKEN</filename>) and then restore your
        latest backup of it.  Then, send an email to the Subversion
        users mailing list (at <email>users@subversion.apache.org</email>)
        describing your problem in detail.  Data integrity is an
        extremely high priority to the Subversion developers.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.migrate">
      <title>Migrating Repository Data Elsewhere</title>
    
      <para>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</para>

      <para>
        <indexterm>
          <primary>repository dump streams</primary>
        </indexterm>
        <indexterm>
          <primary>dump files</primary>
          <see>repository dump streams</see>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>dump</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnadmin</primary>
          <secondary>subcommands</secondary>
          <tertiary>load</tertiary>
        </indexterm>
        <indexterm>
          <primary>svnrdump</primary>
        </indexterm>Subversion provides such functionality by way of
        <firstterm>repository dump streams</firstterm>.  A repository
        dump stream (often referred to as a <quote>dump file</quote>
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history in whole or in part, with or without
        modification between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <command>svnadmin dump</command> and
        <command>svnadmin load</command> subcommands, respectively,
        and the <command>svnrdump</command> program.</para>

      <warning>
        <para>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <emphasis>not</emphasis> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</para>
      </warning>

      <para>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <xref
        linkend="svn.reposadmin.maint.filtering" />) purging versioned
        data from repository history.</para>

      <note>
        <para>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</para>
      </note>

      <para>The Subversion repository dump format also enables
        conversion from a different storage mechanism or version
        control system altogether.  Because the dump file format is,
        for the most part, human-readable, it should be relatively
        easy to describe generic sets of changes each of which
        should be treated as a new revision using this file
        format.  In fact, the <command>cvs2svn</command> utility (see
        <xref linkend="svn.forcvs.convert" />) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</para>

      <para>For now, we'll concern ourselves only with migration of
        repository data between Subversion repositories, which we'll
        describe in detail in the sections which follow.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnadmin">
        <title>Repository data migration using svnadmin</title>

        <para>Whatever your reason for migrating repository history,
          using the <command>svnadmin dump</command> and
          <command>svnadmin load</command> subcommands is
          straightforward.  <command>svnadmin dump</command> will output
          a range of repository revisions that are formatted using
          Subversion's custom filesystem dump format.  The dump format
          is printed to the standard output stream, while informative
          messages are printed to the standard error stream.  This
          allows you to redirect the output stream to a file while
          watching the status output in your terminal window.  For
          example:</para>

        <informalexample>
          <screen>
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
 
* Dumped revision 25.
* Dumped revision 26.
</screen>
        </informalexample>

        <para>At the end of the process, you will have a single file
          (<filename>dumpfile</filename> in the previous example) that
          contains all the data stored in your repository in the
          requested range of revisions.  Note that <command>svnadmin
          dump</command> is reading revision trees from the repository
          just like any other <quote>reader</quote> process would
          (e.g., <command>svn checkout</command>), so it's safe
          to run this command at any time.</para>

        <para>The other subcommand in the pair, <command>svnadmin
          load</command>, parses the standard input stream as a
          Subversion repository dump file and effectively replays those
          dumped revisions into the target repository for that
          operation.  It also gives informative feedback, this time
          using the standard output stream:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
      
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

 

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</screen>
        </informalexample>

        <para>The result of a load is new revisions added to a
          repository the same thing you get by making commits
          against that repository from a regular Subversion client.
          Just as in a commit, you can use hook programs to perform
          actions before and after each of the commits made during a
          load process.  By passing the
          <option>--use-pre-commit-hook</option> and
          <option>--use-post-commit-hook</option> options to
          <command>svnadmin load</command>, you can instruct
          Subversion to execute the pre-commit and post-commit hook
          programs, respectively, for each loaded revision.  You might
          use these, for example, to ensure that loaded revisions pass
          through the same validation steps that regular commits pass
          through.  Of course, you should use these options with
          care if your post-commit hook sends emails to a
          mailing list for each new commit, you might not want to spew
          hundreds or thousands of commit emails in rapid succession
          at that list!  You can read more about the use of hook
          scripts in <xref linkend="svn.reposadmin.hooks" />.</para>

        <para>Note that because <command>svnadmin</command> uses
          standard input and output streams for the repository dump and
          load processes, people who are feeling especially saucy can try
          things such as this (perhaps even using different versions of
          <command>svnadmin</command> on each side of the pipe):</para>

        <informalexample>
          <screen>
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</screen>
        </informalexample>

        <para>By default, the dump file will be quite large much
          larger than the repository itself.  That's because by default
          every version of every file is expressed as a full text in the
          dump file.  This is the fastest and simplest behavior, and
          it's nice if you're piping the dump data directly into some other
          process (such as a compression program, filtering program, or
          loading process).  But if you're creating a dump file
          for longer-term storage, you'll likely want to save disk space
          by using the <option>--deltas</option> option.  With this
          option, successive revisions of files will be output as
          compressed, binary differences just as file revisions
          are stored in a repository.  This option is slower, but it
          results in a dump file much closer in size to the original
          repository.</para>

        <para>We mentioned previously that <command>svnadmin
          dump</command> outputs a range of revisions.  Use the
          <option>--revision</option> (<option>-r</option>) option to
          specify a single revision, or a range of revisions, to dump.
          If you omit this option, all the existing repository revisions
          will be dumped.</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</screen>
        </informalexample>

        <para>As Subversion dumps each new revision, it outputs only
          enough information to allow a future loader to re-create that
          revision based on the previous one.  In other words, for any
          given revision in the dump file, only the items that were
          changed in that revision will appear in the dump.  The only
          exception to this rule is the first revision that is dumped
          with the current <command>svnadmin dump</command>
          command.</para>

        <para>By default, Subversion will not express the first dumped
          revision as merely differences to be applied to the previous
          revision.  For one thing, there is no previous revision in the
          dump file!  And second, Subversion cannot know the state of
          the repository into which the dump data will be loaded (if it
          ever is).  To ensure that the output of each
          execution of <command>svnadmin dump</command> is
          self-sufficient, the first dumped revision is, by default, a
          full representation of every directory, file, and property in
          that revision of the repository.</para>

        <para>However, you can change this default behavior.  If you add
          the <option>--incremental</option> option when you dump your
          repository, <command>svnadmin</command> will compare the first
          dumped revision against the previous revision in the
          repository the same way it treats every other revision that
          gets dumped.  It will then output the first revision exactly
          as it does the rest of the revisions in the dump
          range mentioning only the changes that occurred in that
          revision.  The benefit of this is that you can create several
          small dump files that can be loaded in succession, instead of
          one large one, like so:</para>

        <informalexample>
          <screen>
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</screen>
        </informalexample>

        <para>These dump files could be loaded into a new repository
          with the following command sequence:</para>

        <informalexample>
          <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>
        </informalexample>

        <para>Another neat trick you can perform with this
          <option>--incremental</option> option involves appending to an
          existing dump file a new range of dumped revisions.  For
          example, you might have a <literal>post-commit</literal> hook
          that simply appends the repository dump of the single revision
          that triggered the hook.  Or you might have a script that runs
          nightly to append dump file data for all the revisions that
          were added to the repository since the last time the script
          ran.  Used like this, <command>svnadmin dump</command> can be
          one way to back up changes to your repository over time in case
          of a system crash or some other catastrophic event.</para>

        <para>The dump format can also be used to merge the contents of
          several different repositories into a single repository.  By
          using the <option>--parent-dir</option> option of
          <command>svnadmin load</command>, you can specify a new
          virtual root directory for the load process.  That means if
          you have dump files for three repositories say
          <filename>calc-dumpfile</filename>,
          <filename>cal-dumpfile</filename>, and
          <filename>ss-dumpfile</filename> you can first create a new
          repository to hold them all:</para>

        <informalexample>
          <screen>
$ svnadmin create /var/svn/projects
$
</screen>
        </informalexample>

        <para>Then, make new directories in the repository that will
          encapsulate the contents of each of the three previous
          repositories:</para>

        <informalexample>
          <screen>
$ svn mkdir -m "Initial project roots" \
            file:///var/svn/projects/calc \
            file:///var/svn/projects/calendar \
            file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</screen>
        </informalexample>

        <para>Lastly, load the individual dump files into their
          respective locations in the new repository:</para>

        <informalexample>
          <screen>
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
 
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
 
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
 
$
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.migrate.svnrdump">
        <title>Repository data migration using svnrdump</title>

        <para>In Subversion 1.7, <command>svnrdump</command> joined
          the set of stock Subversion tools.  It offers fairly
          specialized functionality, essentially as a network-aware
          version of the <command>svnadmin dump</command>
          and <command>svnadmin load</command> commands which we
          discuss in depth in
          <xref linkend="svn.reposadmin.maint.migrate.svnadmin"
          />.  <command>svnrdump dump</command> will generate a dump
          stream from a remote repository, spewing it to standard
          output; <command>svnrdump load</command> will read a dump
          stream from standard input and load it into a remote
          repository.  Using <command>svnrdump</command>, you can
          generate incremental dumps just as you might
          with <command>svnadmin dump</command>.  You can even dump a
          subtree of the repository something
          that <command>svnadmin dump</command> cannot do.</para>

        <para>The primary difference is that instead of requiring
          direct access to the repository, <command>svnrdump</command>
          operates remotely, using the very same Repository Access
          (RA) protocols that the Subversion client does.  As such,
          you might need to provide authentication credentials.  Also,
          your remote interactions are subject to any authorization
          limitations configured on the Subversion server.</para>

        <note>
          <para><command>svnrdump dump</command> requires that the
            remote server be running Subversion 1.4 or newer.  It
            currently generates dump streams only of the sort which
            are created when you pass the <option>--deltas</option>
            option to <command>svnadmin dump</command>.  This isn't
            interesting in the typical use-cases, but might impact
            specific types of custom transformations you might wish to
            apply to the resulting dump stream.</para>
        </note>

        <note>
          <para>Because it modifies revision properties after
            committing new revisions, <command>svnrdump load</command>
            requires that the target repository have revision property
            changes enabled via the pre-revprop-change hook.  See
            <xref linkend="svn.ref.reposhooks.pre-revprop-change" /> in
            <xref linkend="svn.ref.reposhooks"/> for details.</para>
        </note>

        <para>As you might expect, you can use
          <command>svnadmin</command> and <command>svnrdump</command>
          in concert.  You can, for example, use <command>svnrdump
          dump</command> to generate a dump stream from a remote
          repository, and pipe the results thereof through
          <command>svnadmin load</command> to copy all that repository
          history into a local repository.  Or you can do the reverse,
          copying history from a local repository into a remote
          one.</para>

        <tip>
          <para>By using <literal>file://</literal>
            URLs, <command>svnrdump</command> can also access local
            repositories, but it will be doing so via Subversion's
            Repository Access (RA) abstraction layer you'll get
            better performance out of <command>svnadmin</command> in
            such situations.</para>
        </tip>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.filtering">
      <title>Filtering Repository History</title>

      <para>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion generally
        doesn't provide an easy way to remove that
        data.<footnote><para>That's rather the reason you use version
        control at all, right?</para></footnote>  But inevitably, there
        will be times when you would like to manipulate the history of
        your repository.  You might need to strip out all instances of
        a file that was accidentally added to the repository (and
        shouldn't be there for whatever
        reason).<footnote><para>Conscious, cautious removal of certain
        bits of versioned data is actually supported by real use
        cases.  That's why an <quote>obliterate</quote> feature has
        been one of the most highly requested Subversion features, and
        one which the Subversion developers hope to soon
        provide.</para></footnote>  Or, perhaps you have multiple
        projects sharing a single repository, and you decide to split
        them up into their own repositories.  To accomplish tasks such
        as these, administrators need a more manageable and malleable
        representation of the data in their repositories the
        Subversion repository dump format.</para>

      <para>As we described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <command>svnadmin dump</command> or <command>svnrdump
        dump</command> command to generate the dump data,
        and <command>svnadmin load</command> or <command>svnrdump
        load</command> to populate a new repository with it.  The
        great thing about the human-readability aspect of the dump
        format is that, if you aren't careless about it, you can
        manually inspect and modify it.  Of course, the downside is
        that if you have three years' worth of repository activity
        encapsulated in what is likely to be a very large dump file,
        it could take you a long, long time to manually inspect and
        modify it.</para>

      <para>That's where <command>svndumpfilter</command> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</para>

      <para>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <xref
        linkend="svn.reposadmin.projects.chooselayout"/>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</para>

      <para>Our imaginary repository contains three projects:
        <literal>calc</literal>, <literal>calendar</literal>, and
        <literal>spreadsheet</literal>.  They have been living
        side-by-side in a layout like this:</para>

      <informalexample>
        <literallayout>
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</literallayout>
      </informalexample>

      <para>To get these three projects into their own repositories,
        we first dump the whole repository:</para>

      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
 
$
</screen>
      </informalexample>

      <para>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</para>

      <informalexample>
        <screen>
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
 
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
 
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
 
$
</screen>
      </informalexample>

      <para>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <literal>calc</literal> project, that repository
        would still have a top-level directory named
        <filename>calc</filename>.  If you want your
        <filename>trunk</filename>, <filename>tags</filename>, and
        <filename>branches</filename> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers so that they no
        longer have that first <filename>calc/</filename> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <filename>calc</filename> directory.  It
        will look something like the following:</para>

      <informalexample>
        <programlisting>
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</programlisting>
      </informalexample>

      <warning>
        <para>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <literal>\r\n</literal> to
          <literal>\n</literal>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</para>
      </warning>

      <para>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</para>

      <informalexample>
        <screen>
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
 
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
 
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
 
$
</screen>
      </informalexample>

      <para>Both of <command>svndumpfilter</command>'s subcommands
        accept options for deciding how to deal with
        <quote>empty</quote> revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <command>svndumpfilter</command> provides
        the following command-line options:</para>

      <variablelist>
        <varlistentry>
          <term><option>--drop-empty-revs</option></term>
          <listitem>
            <para>Do not generate empty revisions at all just
              omit them.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--renumber-revs</option></term>
          <listitem>
            <para>If empty revisions are dropped (using the
              <option>--drop-empty-revs</option> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><option>--preserve-revprops</option></term>
          <listitem>
            <para>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <command>svndumpfilter</command>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      <para>While <command>svndumpfilter</command> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <literal>Node-path</literal> and
        <literal>Node-copyfrom-path</literal> headers.</para>

      <informalexample>
        <programlisting>
 
Node-path: spreadsheet/Makefile
 
</programlisting>
      </informalexample>

      <para>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <command>svndumpfilter include</command> and
        <command>svndumpfilter exclude</command> (and if they don't,
        you shouldn't).  Further, if your dump file has an
        inconsistent usage of leading slashes for some
        reason,<footnote><para>While <command>svnadmin dump</command>
        has a consistent leading slash policy (to not include them),
        other programs that generate dump data might not be so
        consistent.</para></footnote> you should probably normalize
        those paths so that they all have, or all lack, leading
        slashes.</para> <!-- ### FIXME: Is this still accurate?
                             Surely we've fixed ### this by now! -->

      <para>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <command>svndumpfilter</command> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <command>svndumpfilter</command> needs to still show the
        addition of the new path including the contents of any
        files created by the copy and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</para>

      <para>Finally, <command>svndumpfilter</command> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <filename>trunk/my-project</filename> and move it into a
        repository of its own, you would, of course, use the
        <command>svndumpfilter include</command> command to keep all
        the changes in and under
        <filename>trunk/my-project</filename>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <filename>trunk/my-project</filename> directory, but it will
        <emphasis>not</emphasis> contain directives that would
        create the <filename>trunk</filename> directory itself
        (because <filename>trunk</filename> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</para>

    </sect2>
  
    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.replication">
      <title>Repository Replication</title>

      <para>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</para>

      <para>Subversion provides a program for managing scenarios such
        as these.  <command>svnsync</command> works by essentially
        asking the Subversion server to <quote>replay</quote>
        revisions, one at a time.  It then uses that revision
        information to mimic a commit of the same to another
        repository.  Neither repository needs to be locally accessible
        to the machine on which <command>svnsync</command> is
        running its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</para>

      <note>
        <para>When using <command>svnsync</command> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</para>
      </note>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync">
        <title>Replication with svnsync</title>

        <para>Assuming you already have a source repository that you'd
          like to mirror, the next thing you need is a target repository
          that will actually serve as that mirror.  This target
          repository can use either of the available filesystem
          data-store backends (see
          <xref linkend="svn.reposadmin.basics.backends"
          />) Subversion's abstraction layers ensure that such
          details don't matter.  But by default, it must
          not yet have any version history in it.  (We'll discuss an
          exception to this later in this section.)</para>
  
        <para>The protocol that <command>svnsync</command> uses to
          communicate revision information is highly sensitive to
          mismatches between the versioned histories contained in the
          source and target repositories.  For this reason,
          while <command>svnsync</command>
          cannot <emphasis>demand</emphasis> that the target repository
          be read-only,<footnote><para>In fact, it can't truly be
          read-only, or <command>svnsync</command> itself would have a
          tough time copying revision history into it.</para></footnote>
          allowing the revision history in the target repository to
          change by any mechanism other than the mirroring process is a
          recipe for disaster.</para>

        <warning>
          <para>Do <emphasis>not</emphasis> modify a mirror repository
            in such a way as to cause its version history to deviate
            from that of the repository it mirrors.  The only commits
            and revision property modifications that ever occur on that
            mirror repository should be those performed by the
            <command>svnsync</command> tool.</para>
        </warning>

        <para>Another requirement of the target repository is that the
          <command>svnsync</command> process be allowed to modify
          revision properties.  Because <command>svnsync</command> works
          within the framework of that repository's hook system, the
          default state of the repository (which is to disallow revision
          property changes; see <xref
          linkend="svn.ref.reposhooks.pre-revprop-change" /> in
          <xref linkend="svn.ref.reposhooks"/>) is insufficient.
          You'll need to explicitly implement the pre-revprop-change
          hook, and your script must allow <command>svnsync</command>
          to set and change revision properties.  With those
          provisions in place, you are ready to start mirroring
          repository revisions.</para>

        <tip>
          <para>It's a good idea to implement authorization measures
            that allow your repository replication process to perform
            its tasks while preventing other users from modifying the
            contents of your mirror repository at all.</para>
        </tip>

        <para>Let's walk through the use of <command>svnsync</command>
          in a somewhat typical mirroring scenario.  We'll pepper this
          discourse with practical recommendations, which you are free to
          disregard if they aren't required by or suitable for your
          environment.</para>

        <para>We will be mirroring the public Subversion repository
          which houses the source code for this very book and exposing
          that mirror publicly on the Internet, hosted on a different
          machine than the one on which the original Subversion source
          code repository lives.  This remote host has a global
          configuration that permits anonymous users to read the
          contents of repositories on the host, but requires users to
          authenticate to modify those repositories.  (Please forgive
          us for glossing over the details of Subversion server
          configuration for the moment those are covered
          thoroughly in <xref linkend="svn.serverconfig" />.)  And for
          no other reason than that it makes for a more interesting
          example, we'll be driving the replication process from a
          third machine the one that we currently find ourselves
          using.</para>

        <para>First, we'll create the repository which will be our
          mirror.  This and the next couple of steps do require shell
          access to the machine on which the mirror repository will
          live.  Once the repository is all configured, though, we
          shouldn't need to touch it directly again.</para>

        <informalexample>
          <screen>
$ ssh admin@svn.example.com "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</screen>
        </informalexample>

        <para>At this point, we have our repository, and due to our
          server's configuration, that repository is now
          <quote>live</quote> on the Internet.  Now, because we don't
          want anything modifying the repository except our replication
          process, we need a way to distinguish that process from other
          would-be committers.  To do so, we use a dedicated username
          for our process.  Only commits and revision property
          modifications performed by the special username
          <literal>syncuser</literal> will be allowed.</para>

        <para>We'll use the repository's hook system both to allow the
          replication process to do what it needs to do and to enforce
          that only it is doing those things.  We accomplish this by
          implementing two of the repository event
          hooks pre-revprop-change and start-commit.  Our
          <filename>pre-revprop-change</filename> hook script is found
          in <xref
          linkend="svn.reposadmin.maint.replication.pre-revprop-change"
          />, and basically verifies that the user attempting the
          property changes is our <literal>syncuser</literal> user.  If
          so, the change is allowed; otherwise, it is denied.</para>

        <example id="svn.reposadmin.maint.replication.pre-revprop-change">
          <title>Mirror repository's pre-revprop-change hook script</title>
          <programlisting>
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</programlisting>
        </example>

        <para>That covers revision property changes.  Now we need to
          ensure that only the <literal>syncuser</literal> user is
          permitted to commit new revisions to the repository.  We do
          this using a <filename>start-commit</filename> hook script
          such as the one in <xref
          linkend="svn.reposadmin.maint.replication.start-commit"
          />.</para>

        <example id="svn.reposadmin.maint.replication.start-commit">
          <title>Mirror repository's start-commit hook script</title>
  
          <programlisting>
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</programlisting>
        </example>

        <para>After installing our hook scripts and ensuring that they
          are executable by the Subversion server, we're finished with
          the setup of the mirror repository.  Now, we get to actually
          do the mirroring.</para>

        <para>The first thing we need to do with
          <command>svnsync</command> is to register in our target
          repository the fact that it will be a mirror of the source
          repository.  We do this using the <command>svnsync
          initialize</command> subcommand.  The URLs we provide point
          to the root directories of the target and source
          repositories, respectively.  In Subversion 1.4, this is
          required only full mirroring of repositories is
          permitted.  Beginning with Subversion 1.5, though, you can
          use <command>svnsync</command> to mirror only some subtree
          of the repository, too.</para>

        <informalexample>
          <screen>
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
 
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svnbook.googlecode.com/svn \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0 (svn:sync-* properties skipped).
NOTE: Normalized svn:* properties to LF line endings (1 rev-props, 0 node-props).
$
</screen>
        </informalexample>

        <para>Our target repository will now remember that it is a
          mirror of the public Subversion source code repository.
          Notice that we provided a username and password as arguments
          to <command>svnsync</command> that was required by the
          pre-revprop-change hook on our mirror repository.</para>

        <note>
          <para>In Subversion 1.4, the values given to
            <command>svnsync</command>'s <option>--username</option> and
            <option>--password</option> command-line options were used
            for authentication against both the source and destination
            repositories.  This caused problems when a user's
            credentials weren't exactly the same for both repositories,
            especially when running in noninteractive mode (with the
            <option>--non-interactive</option> option).  This was
            fixed in Subversion 1.5 with the introduction of two new
            pairs of options.  Use
            <option>--source-username</option> and
            <option>--source-password</option> to provide authentication
            credentials for the source repository; use
            <option>--sync-username</option> and
            <option>--sync-password</option> to provide credentials for
            the destination repository.  (The old
            <option>--username</option> and <option>--password</option>
            options still exist for compatibility, but we advise against
            using them.)</para>
        </note>

        <para>And now comes the fun part.  With a single subcommand, we
          can tell <command>svnsync</command> to copy all the
          as-yet-unmirrored revisions from the source repository to the
          target.<footnote><para>Be forewarned that while it will take
          only a few seconds for the average reader to parse this
          paragraph and the sample output that follows it, the actual
          time required to complete such a mirroring operation is, shall
          we say, quite a bit longer.</para></footnote> The
          <command>svnsync synchronize</command> subcommand will peek
          into the special revision properties previously stored on the
          target repository and determine how much of the source
          repository has been previously mirrored in this case,
          the most recently mirrored revision is r0.  Then it will query
          the source repository and determine what the latest revision
          in that repository is.  Finally, it asks the source
          repository's server to start replaying all the revisions
          between 0 and that latest revision.  As
          <command>svnsync</command> gets the resultant response from
          the source repository's server, it begins forwarding those
          revisions to the target repository's server as new
          commits.</para>

        <informalexample>
          <screen>
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL [SOURCE_URL]

Transfer all pending revisions to the destination from the source
with which it was initialized.
 
$ svnsync synchronize http://svn.example.com/svn-mirror \
                      http://svnbook.googlecode.com/svn
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .
Committed revision 3.
Copied properties for revision 3.
 
Transmitting file data .
Committed revision 4063.
Copied properties for revision 4063.
Transmitting file data .
Committed revision 4064.
Copied properties for revision 4064.
Transmitting file data ....
Committed revision 4065.
Copied properties for revision 4065.
$
</screen>
        </informalexample>

        <para>Of particular interest here is that for each mirrored
          revision, there is first a commit of that revision to the
          target repository, and then property changes follow.  This
          two-phase replication is required because the initial commit
          is performed by (and attributed to) the user
          <literal>syncuser</literal> and is datestamped with the time
          as of that revision's creation.  <command>svnsync</command>
          has to follow up with an immediate series of property
          modifications that copy into the target repository all the
          original revision properties found for that revision in the
          source repository, which also has the effect of fixing the
          author and datestamp of the revision to match that of the
          source repository.</para>

        <para>Also noteworthy is that <command>svnsync</command>
          performs careful bookkeeping that allows it to be safely
          interrupted and restarted without ruining the integrity of the
          mirrored data.  If a network glitch occurs while mirroring a
          repository, simply repeat the <command>svnsync
          synchronize</command> command, and it will happily pick up
          right where it left off.  In fact, as new revisions appear in
          the source repository, this is exactly what you do
          to keep your mirror up to date.</para>

        <warning>
          <para>As part of its bookkeeping, <command>svnsync</command>
            records in the mirror repository the URL with which the
            mirror was initialized.  Because of this, invocations of
            <command>svnsync</command> which follow the initialization
            step do not <emphasis>require</emphasis> that you provide
            the source URL on the command line again.  However, for
            security purposes, we recommend that you continue to do so.
            Depending on how it is deployed, it may not be safe for
            <command>svnsync</command> to trust the source URL which it
            retrieves from the mirror repository, and from which it
            pulls versioned data.</para>
        </warning>

        <sidebar>
          <title>svnsync Bookkeeping</title>

          <para><command>svnsync</command> needs to be able to set and
            modify revision properties on the mirror repository because
            those properties are part of the data it is tasked with
            mirroring.  As those properties change in the source
            repository, those changes need to be reflected in the mirror
            repository, too.  But <command>svnsync</command> also uses a
            set of custom revision properties stored in revision 0
            of the mirror repository for its own internal
            bookkeeping.  These properties contain information such as
            the URL and UUID of the source repository, plus some
            additional state-tracking information.</para>

          <para>One of those pieces of state-tracking information is a
            flag that essentially just means <quote>there's a
            synchronization in progress right now.</quote> This is used
            to prevent multiple <command>svnsync</command> processes
            from colliding with each other while trying to mirror data
            to the same destination repository.  Now, generally you
            won't need to pay any attention whatsoever to
            <emphasis>any</emphasis> of these special properties (all of
            which begin with the prefix <literal>svn:sync-</literal>).
            Occasionally, though, if a synchronization fails
            unexpectedly, Subversion never has a chance to remove this
            particular state flag.  This causes all future
            synchronization attempts to fail because it appears that a
            synchronization is still in progress when, in fact, none is.
            Fortunately, recovering from this situation is easy to do.
            In Subversion 1.7, you can use the newly introduced
            <option>--steal-lock</option> option with
            <command>svnsync</command>'s commands.  In previous
            Subversion versions, you need only to remove the
            <literal>svn:sync-lock</literal> property which serves as
            this flag from revision 0 of the mirror repository:</para>

          <informalexample>
            <screen>
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</screen>
          </informalexample>

          <para>Also, <command>svnsync</command> stores the source
            repository URL provided at mirror initialization time in a
            bookkeeping property on the mirror repository.  Future
            synchronization operations against that mirror which omit
            the source URL at the command line will consult the
            special <literal>svn:sync-from-url</literal> property
            stored on the mirror itself to know where to synchronize
            from.  This value is used literally by the synchronization
            process, though.  Be wary of using non-fully-qualified
            domain names (such as referring
            to <literal>svnbook.red-bean.com</literal> as
            simply <literal>svnbook</literal> because that happens to
            work when you are connected directly to
            the <literal>red-bean.com</literal> network), domain names
            which don't resolve or resolve differently depending on
            where you happen to be operating from, or IP addresses
            (which can change over time).  But here again, if you need
            an existing mirror to start referring to a different URL
            for the same source repository, you can change the
            bookkeeping property which houses that information.  Users
            of Subversion 1.7 or better can use <command>svnsync init
            --allow-non-empty</command> to reinitialize their mirrors
            with new source URL:</para>

          <informalexample>
            <screen>
$ svnsync initialize --allow-non-empty http://svn.example.com/svn-mirror \
                                       <replaceable>NEW-SOURCE-URL</replaceable>
Copied properties for revision 4065.
$
</screen>
          </informalexample>

          <para>If you are running an older version of Subversion,
            you'll need to manually tweak
            the <literal>svn:sync-from-url</literal> bookkeeping
            property:</para>
          
          <informalexample>
            <screen>
$ svn propset --revprop -r0 svn:sync-from-url <replaceable>NEW-SOURCE-URL</replaceable> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</screen>
          </informalexample>

          <para>Another interesting thing about these special
            bookkeeping properties is that <command>svnsync</command>
            will not attempt to mirror any of those properties when they
            are found in the source repository.  The reason is probably
            obvious, but basically boils down to
            <command>svnsync</command> not being able to distinguish the
            special properties it has merely copied from the source
            repository from those it needs to consult and maintain for
            its own bookkeeping needs.  This situation could occur if,
            for example, you were maintaining a mirror of a mirror of a
            third repository.  When <command>svnsync</command> sees its
            own special properties in revision 0 of the source
            repository, it simply ignores them.</para>

          <para>An <command>svnsync info</command> subcommand was
            added in Subversion 1.6 to easily display the special
            bookkeeping properties in the destination
            repository.</para>

          <informalexample>
            <screen>
$ svnsync help info
info: usage: svnsync info DEST_URL

Print information about the synchronization destination repository
located at DEST_URL.
 
$ svnsync info http://svn.example.com/svn-mirror
Source URL: http://svnbook.googlecode.com/svn
Source Repository UUID: 931749d0-5854-0410-9456-f14be4d6b398
Last Merged Revision: 4065
$
</screen>
          </informalexample>
        </sidebar>

        <para>There is, however, one bit of inelegance in the process.
          Because Subversion revision properties can be changed at any
          time throughout the lifetime of the repository, and because
          they don't leave an audit trail that indicates when they were
          changed, replication processes have to pay special attention
          to them.  If you've already mirrored the first 15 revisions of
          a repository and someone then changes a revision property on
          revision 12, <command>svnsync</command> won't know to go back
          and patch up its copy of revision 12.  You'll need to tell it
          to do so manually by using (or with some additional tooling
          around) the <command>svnsync copy-revprops</command>
          subcommand, which simply rereplicates all the revision
          properties for a particular revision or range thereof.</para>

        <informalexample>
          <screen>
$ svnsync help copy-revprops
copy-revprops: usage:

    1. svnsync copy-revprops DEST_URL [SOURCE_URL]
    2. svnsync copy-revprops DEST_URL REV[:REV2]

 
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</screen>
        </informalexample>

        <para>That's repository replication
          via <command>svnsync</command> in a nutshell.  You'll likely
          want some automation around such a process.  For example,
          while our example was a pull-and-push setup, you might wish to
          have your primary repository push changes to one or more
          blessed mirrors as part of its post-commit and
          post-revprop-change hook implementations.  This would enable
          the mirror to be up to date in as near to real time as is
          likely possible.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-partial">
        <title>Partial replication with svnsync</title>

        <para><command>svnsync</command> isn't limited to full copies
          of everything which lives in a repository.  It can handle
          various shades of partial replication, too.  For example,
          while it isn't very commonplace to do so,
          <command>svnsync</command> does gracefully mirror repositories
          in which the user as whom it authenticates has only partial
          read access.  It simply copies only the bits of the repository
          that it is permitted to see.  Obviously, such a mirror is not
          useful as a backup solution.</para>

        <para>As of Subversion 1.5, <command>svnsync</command> also
          has the ability to mirror a subset of a repository rather than
          the whole thing.  The process of setting up and maintaining
          such a mirror is exactly the same as when mirroring a whole
          repository, except that instead of specifying the source
          repository's root URL when running <command>svnsync
          init</command>, you specify the URL of some subdirectory
          within that repository.  Synchronization to that mirror will
          now copy only the bits that changed under that source
          repository subdirectory.  There are some limitations to this
          support, though.  First, you can't mirror multiple disjoint
          subdirectories of the source repository into a single mirror
          repository you'd need to instead mirror some parent
          directory that is common to both.  Second, the filtering
          logic is entirely path-based, so if the subdirectory you are
          mirroring was renamed at some point in the past, your mirror
          would contain only the revisions since the directory appeared
          at the URL you specified.  And likewise, if the source
          subdirectory is renamed in the future, your synchronization
          processes will stop mirroring data at the point that the
          source URL you specified is no longer valid.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.svnsync-init-nonempty">
        <title>A quick trick for mirror creation</title>

        <para>We mentioned previously the cost of setting up an
          initial mirror of an existing repository.  For many folks,
          the sheer cost of transmitting thousands or
          millions of revisions of history to a new mirror
          repository via <command>svnsync</command> is a show-stopper.
          Fortunately, Subversion 1.7 provides a workaround by way of
          a new <option>--allow-non-empty</option> option to
          <command>svnsync initialize</command>.  This option allows
          you to initialize one repository as a mirror of another
          while bypassing the verification that the to-be-initialized
          mirror has no version history present in it.  Per our
          previous warnings about the sensitivity of this whole
          replication process, you should rightly discern that this is
          an option to be used only with great caution.  But it's
          wonderfully handy when you have administrative access to the
          source repository, where you can simply make a physical copy
          of the repository and then initialize that copy as a new
          mirror:</para>

        <informalexample>
          <screen>
$ svnadmin hotcopy /path/to/repos /path/to/mirror-repos
$ ### create /path/to/mirror-repos/hooks/pre-revprop-change
$ svnsync initialize file:///path/to/mirror-repos \
                     file:///path/to/repos
svnsync: E000022: Destination repository already contains revision history; co
nsider using --allow-non-empty if the repository's revisions are known to mirr
or their respective revisions in the source repository
$ svnsync initialize --allow-non-empty file:///path/to/mirror-repos \
                                       file:///path/to/repos
Copied properties for revision 32042.
$
</screen>
        </informalexample>

        <para>Admins who are running a version of Subversion prior to
          1.7 (and thus do not have access to <command>svnsync
          initialize</command>'s <option>--allow-non-empty</option>
          feature) can accomplish effectively the same thing that that
          feature does through <emphasis>careful</emphasis>
          manipulation of the r0 revision properties on the copy of
          the repository which is slated to become a mirror of the
          original.  Use <command>svnadmin setrevprop</command> to
          create the same bookkeeping properties
          that <command>svnsync</command> would have created
          there.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.reposadmin.maint.replication.wrapup">
        <title>Replication wrap-up</title>

        <para>We've discussed a couple of ways to replicate revision
          history from one repository to another.  So let's look now
          at the user end of these operations.  How does replication
          and the various situations which call for it affect
          Subversion clients?</para>

        <para>As far as user interaction with repositories and mirrors
          goes, it <emphasis>is</emphasis> possible to have a single
          working copy that interacts with both, but you'll have to
          jump through some hoops to make it happen.  First, you need
          to ensure that both the primary and mirror repositories have
          the same repository UUID (which is not the case by default).
          See <xref linkend="svn.reposadmin.maint.uuids" /> later in
          this chapter for more about this.</para>
        
        <para>Once the two repositories have the same UUID, you can use
          <command>svn relocate</command> to point your working
          copy to whichever of the repositories you wish to operate
          against, a process that is described in
          <xref linkend="svn.ref.svn.c.relocate" /> in
          <xref linkend="svn.ref.svn"/>.  There is a possible danger here,
          though, in that if the primary and mirror repositories
          aren't in close synchronization, a working copy up to date
          with, and pointing to, the primary repository will, if
          relocated to point to an out-of-date mirror, become confused
          about the apparent sudden loss of revisions it fully expects
          to be present, and it will throw errors to that effect.  If
          this occurs, you can relocate your working copy back to the
          primary repository and then either wait until the mirror
          repository is up to date, or backdate your working copy to a
          revision you know is present in the sync repository, and
          then retry the relocation.</para>

        <para>Finally, be aware that the revision-based replication
          provided by <command>svnsync</command> is only
          that replication of revisions.  Only the kinds of
          information carried by the Subversion repository dump file
          format are available for replication.  As such, tools such
          as <command>svnsync</command>
          (and <command>svnrdump</command>, which we discuss in
          <xref linkend="svn.reposadmin.maint.migrate.svnrdump" />)
          are limited in ways similar to that of the repository dump
          stream.  They do not include in their replicated information
          such things as the hook implementations, repository or
          server configuration data, uncommitted transactions, or
          information about user locks on repository paths.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.backup">
      <title>Repository Backup</title>

      <para>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic how to make backup copies of your repository
        data.</para>

      <para>There are two types of backup methods available for
        Subversion repository administrators full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</para>

      <para>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <command>svnadmin hotcopy</command> command takes care of the
        minutiae involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <command>cp</command> or Windows <command>copy</command>
        operations:</para>

      <informalexample>
        <screen>
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</screen>
      </informalexample>

      <para>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</para>

      <para>When making copies of a Berkeley DB repository, you can
        even instruct <command>svnadmin hotcopy</command> to purge any
        unused Berkeley DB logfiles (see <xref
        linkend="svn.reposadmin.maint.diskspace.bdblogs" />) from the
        original repository upon completion of the copy.  Simply
        provide the <option>--clean-logs</option> option on the
        command line.</para>

      <informalexample>
        <screen>
$ svnadmin hotcopy --clean-logs /var/svn/bdb-repos /var/svn/bdb-repos-backup
</screen>
      </informalexample>

      <para>Additional tooling around this command is available, too.
        The <filename>tools/backup/</filename> directory of the
        Subversion source distribution holds the
        <command>hot-backup.py</command> script.  This script adds a
        bit of backup management atop <command>svnadmin
        hotcopy</command>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will <quote>rotate off</quote> older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <command>hot-backup.py</command> from a program scheduler
        (such as <command>cron</command> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</para>

      <para>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <xref linkend="svn.reposadmin.maint.migrate" />
        how to use <command>svnadmin dump</command> with
        the <option>--incremental</option> option to perform an
        incremental backup of a given revision or range of revisions.
        And of course, you can achieve a full backup variation of this
        by omitting the <option>--incremental</option> option to that
        command.  There is some value in these methods, in that the
        format of your backed-up information is flexible it's
        not tied to a particular platform, versioned filesystem type,
        or release of Subversion or Berkeley DB.  But that flexibility
        comes at a cost, namely that restoring that data can take a
        long time longer with each new revision committed to
        your repository.  Also, as is the case with so many of the
        various backup methods, revision property changes that are
        made to already backed-up revisions won't get picked up by a
        nonoverlapping, incremental dump generation.  For these
        reasons, we recommend against relying solely on dump-based
        backup approaches.</para>

      <para>Beginning with Subversion 1.8, <command>svnadmin hotcopy</command>
        accepts <option>--incremental</option> option and supports incremental
        hotcopy mode for FSFS repositories.  In incremental hotcopy mode,
        revision data which has already been copied from the source to the
        destination repository will not be copied again. When
        <option>--incremental</option> option is used with
        <command>svnadmin hotcopy</command>, Subversion will only copy new
        revisions, and revisions which have changed in size or had their
        modification time stamp changed since the previous hotcopy
        operation.  Moreover, unlike with <command>svnsync</command> or
        <command>svnadmin dump --incremental</command>, performance of
        <command>svnadmin hotcopy --incremental</command> is only limited to
        disk I/O.  Therefore, incremental hotcopy can be a huge
        time saver when making a backup of a large repository.</para>

      <para>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</para>

      <para>The <command>svnsync</command> program (see <xref
        linkend="svn.reposadmin.maint.replication" />) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <emphasis>inside</emphasis> the repository's virtual versioned
        filesystem are not handled by <command>svnsync</command>.</para>

      <para>In any backup scenario, repository administrators need to
        be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change
        hooks.<footnote><para><command>svnadmin setlog</command> can
        be called in a way that bypasses the hook interface
        altogether.</para></footnote>  And since you can change
        revision properties without respect to chronological
        order you can change any revision's properties at any
        time an incremental backup of the latest few revisions
        might not catch a property modification to a revision that was
        included as part of a previous backup.</para>

      <para>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data protect it
        as much as you'd like.</para>
            
      <para>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <command>hot-backup.py</command> and an off-site
        <command>rsync</command> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <command>svnsync</command>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of
        Fate,<footnote><para>You know the collective term for
        all of her <quote>fickle fingers.</quote></para></footnote> it
        should certainly help you recover from those trying
        times.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.reposadmin.maint.uuids">
      <title>Managing Repository UUIDs</title>

      <para>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</para>

      <para>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <xref
        linkend="svn.reposadmin.maint.migrate" />), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</para>

      <para>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <command>svnadmin
        setuuid</command> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</para>

      <informalexample>
        <screen>
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <para>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <userinput>svnadmin load --force-uuid
        <replaceable>REPOS-PATH</replaceable></userinput>.</para>

      <informalexample>
        <screen>
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</screen>
      </informalexample>

      <para>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.maint.moving-and-removing">
    <title>Moving and Removing Repositories</title>

    <para>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories <command>mv</command>, <command>cp
      -a</command>, and <command>rm -r</command> on Unix platforms;
      <command>copy</command>, <command>move</command>, and
      <command>rmdir /s /q</command> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</para>

    <para>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</para>

    <para>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way including
      their UUIDs.  In some circumstances, this might be desirable.
      But in the instances where it is not, you'll need to generate a
      new UUID for one of these identical repositories.  See
      <xref linkend="svn.reposadmin.maint.uuids" /> for more about
      managing repository UUIDs.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.reposadmin.summary">
    <title>Summary</title>

    <para>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</para>

    <para>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</para>

  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.serverconfig">
  <title>Server Configuration</title>

  <para>A Subversion repository can be accessed simultaneously by
    clients running on the same machine on which the repository
    resides using URLs carrying the <literal>file://</literal> scheme.
    But the typical Subversion setup involves a single server machine
    being accessed from clients on computers all over the
    office or, perhaps, all over the world.</para>

  <para>This chapter describes how to get your Subversion repository
    exposed outside its host machine for use by remote clients.  We
    will cover Subversion's currently available server mechanisms,
    discussing the configuration and use of each.  After reading this
    chapter, you should be able to decide which networking setup is
    right for your needs, as well as understand how to enable such a
    setup on your host computer.</para>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.overview">

    <title>Overview</title>

    <para>
      <indexterm>
        <primary>API</primary>
        <secondary>layers</secondary>
        <tertiary>Repository Access (RA) Layer</tertiary>
      </indexterm>Subversion was designed with an abstract repository
      access layer.  This means that a repository can be
      programmatically accessed by any sort of server process, and the
      client <quote>repository access</quote> API allows programmers
      to write plug-ins that speak relevant network protocols.  In
      theory, Subversion can use an infinite number of network
      implementations.  In practice, there are only two Subversion
      servers in widespread use today.</para>

    <para>
      <indexterm>
        <primary>httpd</primary>
      </indexterm>
      <indexterm>
        <primary>Apache HTTP Server</primary>
        <see>httpd</see>
      </indexterm>Apache HTTP Server (also known
      as <command>httpd</command>) is an extremely popular web server;
      using the <command>mod_dav_svn</command> module, Apache can
      access a repository and make it available to clients via the
      WebDAV/DeltaV protocol, which is an extension of HTTP.  Because
      Apache is an extremely extensible server, it provides a number
      of features <quote>for free,</quote> such as encrypted SSL
      communication, logging, integration with a number of third-party
      authentication systems, and limited built-in web browsing of
      repositories.</para>

    <para>
      <indexterm>
        <primary>svnserve</primary>
      </indexterm>In the other corner is <command>svnserve</command>:
      a small, lightweight server program that speaks a custom
      protocol with clients.  Because its protocol is explicitly
      designed for Subversion and is stateful (unlike HTTP), it
      provides significantly faster network operations but at
      the cost of some features as well.  While it can use SASL to
      provide a variety of authentication and encryption options, it
      has no logging or built-in web browsing.  It is, however,
      extremely easy to set up and is often the best option for small
      teams just starting out with Subversion.</para>

    <para>The network protocol which <command>svnserve</command>
      speaks may also be tunneled over an SSH connection.  This
      deployment option for <command>svnserve</command> differs quite
      a bit in features from a traditional <command>svnserve</command>
      deployment.  SSH is used to encrypt all communication.  SSH is
      also used exclusively to authenticate, so real system accounts
      are required on the server host (unlike
      vanilla <command>svnserve</command>, which has its own private
      user accounts).  Finally, because this setup requires that each
      user spawn a private, temporary <command>svnserve</command>
      process, it's equivalent (from a permissions point of view) to
      allowing a group of local users to all access the repository
      via <literal>file://</literal> URLs.  Path-based access control
      has no meaning, since each user is accessing the repository
      database files directly.</para>

    <para><xref linkend="svn.serverconfig.overview.tbl-1"/> provides a
      quick summary of the three typical server deployments.</para>

    <table id="svn.serverconfig.overview.tbl-1">
      <title>Comparison of Subversion server options</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Feature</entry>
            <entry>Apache + mod_dav_svn</entry>
            <entry>svnserve</entry>
            <entry>svnserve over SSH</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>Authentication options</entry>
            <entry>HTTP Basic or Digest auth, X.509 certificates, LDAP,
              NTLM, or any other mechanism available to Apache httpd</entry>
            <entry>CRAM-MD5 by default;  LDAP, NTLM, or any other mechanism
              available to SASL</entry>
            <entry>SSH</entry>
          </row>
          <row>
            <entry>User account options</entry>
            <entry>Private <quote>users</quote> file, or other mechanisms
            available to Apache httpd (LDAP, SQL, etc.)</entry>
            <entry>Private <quote>users</quote> file, or other
              mechanisms available to SASL (LDAP, SQL, etc.)</entry>
            <entry>System accounts</entry>
          </row>
          <row>
            <entry>Authorization options</entry>
            <entry>Read/write access can be granted over the whole
              repository, or specified per path</entry>
            <entry>Read/write access can be granted over the whole
              repository, or specified per path</entry>
            <entry>Read/write access only grantable over the whole
              repository</entry>
          </row>
          <row>
            <entry>Encryption</entry>
            <entry>Available via optional SSL (https)</entry>
            <entry>Available via optional SASL features</entry>
            <entry>Inherent in SSH connection</entry>
          </row>
          <row>
            <entry>Logging</entry>
            <entry>High-level operational logging of Subversion
              operations plus detailed logging at the
              per-HTTP-request level</entry>
            <entry>High-level operational logging only</entry>
            <entry>High-level operational logging only</entry>
          </row>
          <row>
            <entry>Interoperability</entry>
            <entry>Accessible by other WebDAV clients</entry>
            <entry>Talks only to svn clients</entry>
            <entry>Talks only to svn clients</entry>
          </row>
          <row>
            <entry>Web viewing</entry>
            <entry>Limited built-in support, or via third-party tools
              such as ViewVC</entry>
            <entry>Only via third-party tools such as ViewVC</entry>
            <entry>Only via third-party tools such as ViewVC</entry>
          </row>
          <row>
            <entry>Master-slave server replication</entry>
            <entry>Transparent write-proxying available from slave to
              master</entry>
            <entry>Can only create read-only slave servers</entry>
            <entry>Can only create read-only slave servers</entry>
          </row>
          <row>
            <entry>Speed</entry>
            <entry>Somewhat slower</entry>
            <entry>Somewhat faster</entry>
            <entry>Somewhat faster</entry>
          </row>
          <row>
            <entry>Initial setup</entry>
            <entry>Somewhat complex</entry>
            <entry>Extremely simple</entry>
            <entry>Moderately simple</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

  </sect1>

  <sect1 id="svn.serverconfig.choosing">

    <title>Choosing a Server Configuration</title>

    <para>So, which server should you use?  Which is best?</para>

    <para>Obviously, there's no right answer to that question.  Every
      team has different needs, and the different servers all
      represent different sets of trade-offs.  The Subversion project
      itself doesn't endorse one server or another, or consider either
      server more <quote>official</quote> than another.</para>

    <para>Here are some reasons why you might choose one deployment
      over another, as well as reasons you
      might <emphasis>not</emphasis> choose one.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.svnserve">

      <title>The svnserve Server</title>

      <variablelist>
        <varlistentry>
          <term>Why you might want to use it:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>Quick and easy to set up.</para>
              </listitem>
              <listitem>
                <para>Network protocol is stateful and noticeably
                  faster than WebDAV.</para>
              </listitem>
              <listitem>
                <para>No need to create system accounts on
                  server.</para>
              </listitem>
              <listitem>
                <para>Password is not passed over the network.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Why you might want to avoid it:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>By default, only one authentication method is
                  available, the network protocol is not encrypted,
                  and the server stores clear text passwords.  (All
                  these things can be changed by configuring SASL, but
                  it's a bit more work to do.)</para>
              </listitem>
              <listitem>
                <para>No advanced logging facilities.</para>
              </listitem>
              <listitem>
                <para>No built-in web browsing.  (You'd have to
                  install a separate web server and repository
                  browsing software to add this.)</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.svn-ssh">

      <title>svnserve over SSH</title>

      <variablelist>
        <varlistentry>
          <term>Why you might want to use it:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>The network protocol is stateful and noticeably
                  faster than WebDAV.</para>
              </listitem>
              <listitem>
                <para>You can take advantage of existing SSH accounts
                  and user infrastructure.</para>
              </listitem>
              <listitem>
                <para>All network traffic is encrypted.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Why you might want to avoid it:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>Only one choice of authentication method is
                  available.</para>
              </listitem>
              <listitem>
                <para>No advanced logging facilities.</para>
              </listitem>
              <listitem>
                <para>It requires users to be in the same system
                  group, or use a shared SSH key.</para>
              </listitem>
              <listitem>
                <para>If used improperly, it can lead to file
                  permission problems.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.apache">

      <title>The Apache HTTP Server</title>

      <variablelist>
        <varlistentry>
          <term>Why you might want to use it:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>It allows Subversion to use any of the
                  numerous authentication systems already integrated
                  with Apache.</para>
              </listitem>
              <listitem>
                <para>There is no need to create system accounts on
                  the server.</para>
              </listitem>
              <listitem>
                <para>Full Apache logging is available.</para>
              </listitem>
              <listitem>
                <para>Network traffic can be encrypted via SSL.</para>
              </listitem>
              <listitem>
                <para>HTTP(S) can usually go through corporate
                firewalls.</para>
              </listitem>
              <listitem>
                <para>Built-in repository browsing is available via
                  web browser.</para>
              </listitem>
              <listitem>
                <para>The repository can be mounted as a network
                  drive for transparent version control (see <xref
                  linkend="svn.webdav.autoversioning"/>).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Why you might want to avoid it:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>Noticeably slower than <command>svnserve</command>,
                  because HTTP is a stateless protocol and requires
                  more network turnarounds.</para>
              </listitem>
              <listitem>
                <para>Initial setup can be complex.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>

      </variablelist>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.choosing.recommendations">

      <title>Recommendations</title>

      <para>In general, the authors of this book recommend a vanilla
        <command>svnserve</command> installation for small teams just
        trying to get started with a Subversion server; it's the
        simplest to set up and has the fewest maintenance issues.
        You can always switch to a more complex server
        deployment as your needs change.</para>

      <para>Here are some general recommendations and tips, based on
        years of supporting users:</para>

      <itemizedlist>
        <listitem>
          <para>If you're trying to set up the simplest possible server
            for your group, a vanilla <command>svnserve</command>
            installation is the easiest, fastest route.  Note,
            however, that your repository data will be transmitted in
            the clear over the network.  If your deployment is
            entirely within your company's LAN or VPN, this isn't an
            issue.  If the repository is exposed to the wide-open
            Internet, you might want to make sure that either the
            repository's contents aren't sensitive (e.g., it contains
            only open source code), or that you go the extra mile in
            configuring SASL to encrypt network communications.</para>
        </listitem>

        <listitem>
          <para>If you need to integrate with existing legacy identity
            systems (LDAP, Active Directory, NTLM, X.509, etc.),
            you must use either the Apache-based server
            or <command>svnserve</command> configured with SASL.</para>
        </listitem>

        <listitem>
          <para>If you've decided to use either Apache or stock
            <command>svnserve</command>, create a single
            <command>svn</command> user on your system and run the
            server process as that user.  Be sure to make the
            repository directory wholly owned by the
            <command>svn</command> user as well.  From a security
            point of view, this keeps the repository data nicely
            siloed and protected by operating system filesystem
            permissions, changeable by only the Subversion server
            process itself.</para> </listitem>

        <listitem>
          <para>If you have an existing infrastructure that is heavily based
            on SSH accounts, and if your users already have system
            accounts on your server machine, it makes sense to
            deploy an <command>svnserve</command>-over-SSH solution.
            Otherwise, we don't widely recommend this option to the
            public.  It's generally considered safer to have your
            users access the repository via (imaginary) accounts
            managed by <command>svnserve</command> or Apache, rather
            than by full-blown system accounts.  If your deep desire
            for encrypted communication still draws you to this
            option, we recommend using Apache with SSL or
            <command>svnserve</command> with SASL encryption
            instead.</para> </listitem>

        <listitem>
          <para>Do <emphasis>not</emphasis> be seduced by the simple
            idea of having all of your users access a repository
            directly via <literal>file://</literal> URLs.  Even if the
            repository is readily available to everyone via a network
            share, this is a bad idea.  It removes any layers of
            protection between the users and the repository: users can
            accidentally (or intentionally) corrupt the repository
            database, it becomes hard to take the repository offline
            for inspection or upgrade, and it can lead to a mess of
            file permission problems (see <xref
            linkend="svn.serverconfig.multimethod"/>).  Note that this
            is also one of the reasons we warn against accessing
            repositories via <literal>svn+ssh://</literal>
            URLs from a security standpoint, it's effectively
            the same as local users accessing via
            <literal>file://</literal>, and it can entail all the same
            problems if the administrator isn't careful.</para>
            </listitem> </itemizedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.svnserve">

    <title>svnserve, a Custom Server</title>

    <para>
      <indexterm>
        <primary>svnserve</primary>
      </indexterm>The <command>svnserve</command> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <command>svnserve</command> server by using URLs that begin with
      the <literal>svn://</literal> or <literal>svn+ssh://</literal>
      scheme.  This section will explain the different ways of running
      <command>svnserve</command>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.invoking">
      <title>Invoking the Server</title>

      <para>
        <indexterm>
          <primary>svnserve</primary>
          <secondary>running</secondary>
        </indexterm>There are a few different ways to run the
        <command>svnserve</command> program:</para>

      <itemizedlist>
        <listitem>
          <para>Run <command>svnserve</command> as a standalone
            daemon, listening for requests.</para>
        </listitem>
        <listitem>
          <para>Have the Unix <command>inetd</command> daemon
            temporarily spawn <command>svnserve</command> whenever a
            request comes in on a certain port.</para>
        </listitem>
        <listitem>
          <para>Have SSH invoke a temporary <command>svnserve</command>
            over an encrypted tunnel.</para>
        </listitem>
        <listitem>
          <para>Run <command>svnserve</command> as a Microsoft Windows
            service.</para>
        </listitem>
        <listitem>
          <para>Run <command>svnserve</command> as a launchd job.</para>
        </listitem>
      </itemizedlist>

      <para>The following sections will cover in detail these various
        deployment options for <command>svnserve</command>.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.daemon">
        <title>svnserve as daemon</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>daemon mode</tertiary>
          </indexterm>The easiest option is to run <command>svnserve</command>
          as a standalone <quote>daemon</quote> process.  Use the
          <option>-d</option> option for this:</para>

        <informalexample>
          <screen>
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</screen>
        </informalexample>

        <para>When running <command>svnserve</command> in daemon mode,
          you can use the <option>--listen-port</option> and
          <option>--listen-host</option> options to customize the
          exact port and hostname to <quote>bind</quote> to.</para>

        <para>Once we successfully start <command>svnserve</command>
          as explained previously, it makes every repository on your
          system available to the network.  A client needs to specify
          an <emphasis>absolute</emphasis> path in the repository URL.
          For example, if a repository is located at
          <filename>/var/svn/project1</filename>, a client would reach
          it via <uri>svn://host.example.com/var/svn/project1</uri>.
          To increase security, you can pass the <option>-r</option>
          option to <command>svnserve</command>, which restricts it to
          exporting only repositories below that path.  For
          example:</para>

        <informalexample>
          <screen>
$ svnserve -d -r /var/svn
 
</screen>
        </informalexample>

        <para>Using the <option>-r</option> option effectively
          modifies the location that the program treats as the root of
          the remote filesystem space.  Clients then use URLs that
          have that path portion removed from them, leaving much
          shorter (and much less revealing) URLs:</para>

        <informalexample>
          <screen>
$ svn checkout svn://host.example.com/project1
 
</screen>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.inetd">
        <title>svnserve via inetd</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>via inetd</tertiary>
          </indexterm>
          <indexterm>
            <primary>inetd</primary>
          </indexterm>If you want <command>inetd</command> to launch the
          process, you need to pass the <option>-i</option>
          (<option>--inetd</option>) option.  In the following
          example, we've shown the output from running
          <literal>svnserve -i</literal> at the command line, but note
          that this isn't how you actually start the daemon; see the
          paragraphs following the example for how to configure
          <command>inetd</command> to start
          <command>svnserve</command>.</para>

        <informalexample>
          <screen>
$ svnserve -i
( success ( 2 2 ( ) ( edit-pipeline svndiff1 absent-entries commit-revprops d\
epth log-revprops atomic-revprops partial-replay ) ) )
</screen>
        </informalexample>

        <para>When invoked with the <option>--inetd</option> option,
          <command>svnserve</command> attempts to speak with a
          Subversion client via <filename>stdin</filename> and
          <filename>stdout</filename> using a custom protocol.  This
          is the standard behavior for a program being run via
          <command>inetd</command>.  The IANA has reserved port 3690
          for the Subversion protocol, so on a Unix-like system you
          can add lines to <filename>/etc/services</filename> such as
          these (if they don't already exist):</para>

        <informalexample>
          <programlisting>
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</programlisting>
        </informalexample>

        <para>If your system is using a classic Unix-like
          <command>inetd</command> daemon, you can add this line to
          <filename>/etc/inetd.conf</filename>:</para>

        <informalexample>
          <programlisting>
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</programlisting>
        </informalexample>

        <para>Make sure <quote>svnowner</quote> is a user that has
          appropriate permissions to access your repositories.  Now,
          when a client connection comes into your server on port
          3690, <command>inetd</command> will spawn an
          <command>svnserve</command> process to service it.  Of
          course, you may also want to add <option>-r</option> to the
          configuration line as well, to restrict which repositories
          are exported.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.xinetd">
        <title>svnserve via xinetd</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>via xinetd</tertiary>
          </indexterm>
          <indexterm>
            <primary>xinetd</primary>
          </indexterm>Some operating systems provide the <command>xinetd</command> 
          daemon as an alternative to <command>inetd</command>.
          Fortunately, you can configure <command>svnserve</command> for
          use with <command>xinetd</command>, too.  To do so, you'll need to
          create a configuration file <filename>/etc/xinetd.d/svn</filename>
          with the following contents:</para>

        <informalexample>
          <programlisting>
# default: on
# description: Subversion server for the svn protocol
service svn
{
  disabled        = no
  port            = 3690
  socket_type     = stream
  protocol        = tcp
  wait            = no
  user            = subversion
  server          = /usr/local/bin/svnserve
  server_args     = -i -r <replaceable>/path/to/repositories</replaceable>
}
</programlisting>
        </informalexample>

        <para>Be sure that your <filename>/etc/services</filename>
          configuration file contains the definition of the port used
          for the <literal>svn</literal> protocol (as described in
          <xref linkend="svn.serverconfig.svnserve.invoking.xinetd"
          />), otherwise the daemon will not start correctly.</para>

        <para>In Redhat-based distributions, you then need to activate
          the new service using <command>chkconfig --add
          svn</command>.  After doing so, you will be able to enable
          and disable the server using the graphical configuration
          tools.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.tunnel">
        <title>svnserve over a tunnel</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>tunnel mode</tertiary>
          </indexterm>Another way to invoke <command>svnserve</command> is in
          tunnel mode, using the <option>-t</option> option.  This
          mode assumes that a remote-service program such as
          <command>rsh</command> or <command>ssh</command> has
          successfully authenticated a user and is now invoking a
          private <command>svnserve</command> process <emphasis>as
          that user</emphasis>.  (Note that you, the user, will
          rarely, if ever, have reason to invoke
          <command>svnserve</command> with the <option>-t</option> at
          the command line; instead, the SSH daemon
          does so for you.)  The <command>svnserve</command> program
          behaves normally (communicating via
          <filename>stdin</filename> and <filename>stdout</filename>)
          and assumes that the traffic is being automatically
          redirected over some sort of tunnel back to the client.
          When <command>svnserve</command> is invoked by a tunnel
          agent like this, be sure that the authenticated user has
          full read and write access to the repository database files.
          It's essentially the same as a local user accessing the
          repository via <literal>file://</literal> URLs.</para>

        <para>This option is described in much more detail later in
          this chapter in <xref
          linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.winservice">
        <title>svnserve as a Windows service</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>as Windows service</tertiary>
          </indexterm>If your Windows system is a descendant of Windows NT
          (Windows 2000 or newer), you can
          run <command>svnserve</command> as a standard Windows
          service.  This is typically a much nicer experience than
          running it as a standalone daemon with
          the <option>--daemon</option> (<option>-d</option>) option.
          Using daemon mode requires launching a console, typing a
          command, and then leaving the console window running
          indefinitely.  A Windows service, however, runs in the
          background, can start at boot time automatically, and can be
          started and stopped using the same consistent administration
          interface as other Windows services.</para>

        <para>You'll need to define the new service using the
          command-line tool <command>SC.EXE</command>.  Much like
          the <command>inetd</command> configuration line, you must
          specify an exact invocation of <command>svnserve</command>
          for Windows to run at startup time:</para>

        <informalexample>
          <screen>
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</screen>
        </informalexample>

        <para>This defines a new Windows service named
          <literal>svn</literal> which executes a particular
          <command>svnserve.exe</command> command when started (in
          this case, rooted at <filename>C:\repos</filename>).  There
          are a number of caveats in the prior example,
          however.</para>

        <para>First, notice that the <command>svnserve.exe</command>
          program must always be invoked with the
          <option>--service</option> option.  Any other options to
          <command>svnserve</command> must then be specified on the
          same line, but you cannot add conflicting options such as
          <option>--daemon</option>
          (<option>-d</option>), <option>--tunnel</option>,
          or <option>--inetd</option> (<option>-i</option>).  Options
          such as <option>-r</option>
          or <option>--listen-port</option> are fine, though.  Second,
          be careful about spaces when invoking
          the <command>SC.EXE</command> command: the <literal>key=
          value</literal> patterns must have no spaces between
          <literal>key=</literal> and must have exactly one space
          before the <literal>value</literal>.  Lastly, be careful
          about spaces in your command line to be invoked.  If a
          directory name contains spaces (or other characters that
          need escaping), place the entire inner value of
          <literal>binpath</literal> in double quotes, by escaping
          them:</para>

        <informalexample>
          <screen>
C:\&gt; sc create svn
        binpath= "\"C:\program files\svn\bin\svnserve.exe\" --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</screen>
        </informalexample>

        <para>Also note that the word <literal>binpath</literal> is
          misleading its value is a <emphasis>command
          line</emphasis>, not the path to an executable.  That's why
          you need to surround it with quotes if it contains
          embedded spaces.</para>

        <para>Once the service is defined, it can be stopped, started,
          or queried using standard GUI tools (the Services
          administrative control panel), or at the command
          line:</para>

        <informalexample>
          <screen>
C:\&gt; net stop svn
C:\&gt; net start svn
</screen>
        </informalexample>

        <para>The service can also be uninstalled (i.e., undefined) by
          deleting its definition:  <userinput>sc delete svn</userinput>.
          Just be sure to stop the service first!
          The <command>SC.EXE</command> program has many other
          subcommands and options; run <userinput>sc /?</userinput> to
          learn more about it.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.invoking.launchd">
        <title>svnserve as a launchd job</title>

        <para>
          <indexterm>
            <primary>svnserve</primary>
            <secondary>running</secondary>
            <tertiary>via launchd</tertiary>
          </indexterm>
          <indexterm>
            <primary>launchd</primary>
          </indexterm>Mac OS X (10.4 and higher) uses <command>launchd</command>
          to manage processes (including daemons) both system-wide and
          per-user.  A <command>launchd</command> job is specified by
          parameters in an XML property list file, and
          the <command>launchctl</command> command is used to manage
          the lifecycle of those jobs.</para>

        <para>When configured to run as a <command>launchd</command>
          job, <command>svnserve</command> is automatically launched
          on demand whenever incoming Subversion
          <literal>svn://</literal> network traffic needs to be
          handled.  This is far more convenient than a configuration
          which requires you to manually invoke
          <command>svnserve</command> as a long-running
          background process.</para>

        <para>To configure <command>svnserve</command> as
          a <command>launchd</command> job, first create a job
          definition file named
          <filename>/Library/LaunchDaemons/org.apache.subversion.svnserve.plist</filename>.
          <xref linkend="svn.serverconfig.svnserve.invoking.launchd.ex-1"/>
          provides an example of such a file.</para>

        <example id="svn.serverconfig.svnserve.invoking.launchd.ex-1">
          <title>A sample svnserve launchd job definition</title>
          <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;Label&lt;/key&gt;
        &lt;string&gt;org.apache.subversion.svnserve&lt;/string&gt;
        &lt;key&gt;ServiceDescription&lt;/key&gt;
        &lt;string&gt;Host Subversion repositories using svn:// scheme&lt;/string&gt;
        &lt;key&gt;ProgramArguments&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;/usr/bin/svnserve&lt;/string&gt;
            &lt;string&gt;--inetd&lt;/string&gt;
            &lt;string&gt;--root=/var/svn&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;UserName&lt;/key&gt;
        &lt;string&gt;svn&lt;/string&gt;
        &lt;key&gt;GroupName&lt;/key&gt;
        &lt;string&gt;svn&lt;/string&gt;
        &lt;key&gt;inetdCompatibility&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Wait&lt;/key&gt;
            &lt;false/&gt;
        &lt;/dict&gt;
        &lt;key&gt;Sockets&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;Listeners&lt;/key&gt;
            &lt;array&gt;
                &lt;dict&gt;
                    &lt;key&gt;SockServiceName&lt;/key&gt;
                    &lt;string&gt;svn&lt;/string&gt;
                    &lt;key&gt;Bonjour&lt;/key&gt;
                    &lt;true/&gt;
                &lt;/dict&gt;
            &lt;/array&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</programlisting>
        </example>

        <warning>
          <para>The <command>launchd</command> system can be somewhat
            challenging to learn.  Fortunately, documentation exists
            for the commands described in this section. For example,
            run <userinput>man launchd</userinput> from the command
            line to see the manual page for <command>launchd</command>
            itself, <userinput>man launchd.plist</userinput> to read
            about the job definition format, etc.</para>
        </warning>

        <para>Once your job definition file is created, you can
          activate the job using <command>launchctl load</command>:</para>

        <informalexample>
          <screen>
$ sudo launchctl load \
       -w /Library/LaunchDaemons/org.apache.subversion.svnserve.plist
</screen>
        </informalexample>

        <para>To be clear, this action doesn't actually launch
          <command>svnserve</command> yet.  It simply tells
          <command>launchd</command> how to fire up
          <command>svnserve</command> when incoming networking traffic
          arrives on the <literal>svn</literal> network port; it will
          be terminated it after the traffic has been handled.</para>

        <note>
          <para>Because we want <command>svnserve</command> to be a
            system-wide daemon process, we need to
            use <command>sudo</command> to manage this job as an
            administrator.  Note also that the
            <literal>UserName</literal>
            and <literal>GroupName</literal> keys in the definition
            file are optional if omitted, the job will run as
            the user who loaded the job.</para>
        </note>

        <para>Deactivating the job is just as easy to do use
          <command>launchctl unload</command>:</para>

        <informalexample>
          <screen>
$ sudo launchctl unload \
       -w /Library/LaunchDaemons/org.apache.subversion.svnserve.plist
</screen>
        </informalexample>

        <para><command>launchctl</command> also provides a way for you
          to query the status of jobs.  If the job is loaded, there
          will be line which matches the <literal>Label</literal>
          specified in the job definition file:</para>

        <informalexample>
          <screen>
$ sudo launchctl list | grep org.apache.subversion.svnserve
-       0       org.apache.subversion.svnserve
$
</screen>
        </informalexample>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.auth">
      <title>Built-in Authentication and Authorization</title>

      <para>
        <indexterm>
          <primary>svnserve</primary>
          <secondary>authentication</secondary>
        </indexterm>
        <indexterm>
          <primary>svnserve</primary>
          <secondary>authorization</secondary>
        </indexterm>When a client connects to an <command>svnserve</command>
        process, the following things happen:</para>

      <itemizedlist>
        <listitem>
          <para>The client selects a specific repository.</para>
        </listitem>
        <listitem>
          <para>The server processes the repository's
            <filename>conf/svnserve.conf</filename> file and begins to
            enforce any authentication and authorization policies it
            describes.</para>
        </listitem>
        <listitem>
          <para>Depending on the defined policies, one of the
            following may occur:</para>
          <itemizedlist>
            <listitem>
              <para>The client may be allowed to make requests
                anonymously, without ever receiving an authentication
                challenge.</para>
            </listitem>
            <listitem>
              <para>The client may be challenged for authentication at
                any time.</para>
            </listitem>
            <listitem>
              <para>If operating in tunnel mode, the client will
                declare itself to be already externally authenticated
                (typically by SSH).</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>The <command>svnserve</command> server, by default, knows
        only how to send a CRAM-MD5<footnote><para>See RFC
        2195.</para></footnote> authentication challenge.  In essence,
        the server sends a small amount of data to the client.  The
        client uses the MD5 hash algorithm to create a fingerprint of
        the data and password combined, and then sends the fingerprint
        as a response.  The server performs the same computation with
        the stored password to verify that the result is identical.
        <emphasis>At no point does the actual password travel over the
        network.</emphasis></para>

      <para>If your <command>svnserve</command> server was built with
        SASL support, it not only knows how to send CRAM-MD5 challenges,
        but also likely knows a whole host of other authentication
        mechanisms.  See <xref
        linkend="svn.serverconfig.svnserve.sasl"/> later in this
        chapter to learn how to configure SASL authentication and
        encryption.</para>

      <para>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <command>ssh</command>.  In that case, the server simply
        examines the user it's running as, and uses this name as the
        authenticated username.  For more on this, see the later
        section, <xref
        linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

      <para>As you've already guessed, a repository's
        <filename>svnserve.conf</filename> file is the central
        mechanism for controlling authentication and authorization
        policies.  The file has the same format as other configuration
        files (see <xref linkend="svn.advanced.confarea"/>):
        section names are marked by square brackets
        (<literal>[</literal> and <literal>]</literal>), comments
        begin with hashes (<literal>#</literal>), and each section
        contains specific variables that can be set (<literal>variable
        = value</literal>).  Let's walk through these files and learn
        how to use them.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.users">
        <title>Create a users file and realm</title>

        <para>For now, the <literal>[general]</literal> section of
          <filename>svnserve.conf</filename> has all the variables you
          need.  Begin by changing the values of those variables:
          choose a name for a file that will contain your usernames
          and passwords and choose an authentication realm:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm
</programlisting>
        </informalexample>

        <para>The <literal>realm</literal> is a name that you define.
          It tells clients which sort of <quote>authentication
          namespace</quote> they're connecting to; the Subversion
          client displays it in the authentication prompt and uses it
          as a key (along with the server's hostname and port) for
          caching credentials on disk (see <xref
          linkend="svn.serverconfig.netmodel.credcache"/>).  The
          <literal>password-db</literal> variable points to a separate
          file that contains a list of usernames and passwords, using
          the same familiar format.  For example:</para>

        <informalexample>
          <programlisting>
[users]
harry = foopassword
sally = barpassword
</programlisting>
        </informalexample>

        <para>The value of <literal>password-db</literal> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <filename>conf/</filename> area of the repository, alongside
          <filename>svnserve.conf</filename>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Wherever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <command>svnserve</command> will run
          as, restrict read access to the users file as necessary.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.auth.general">
        <title>Set access controls</title>

        <para>There are two more variables to set in the
          <filename>svnserve.conf</filename> file: they determine what
          unauthenticated (anonymous) and authenticated users are
          allowed to do.  The variables <literal>anon-access</literal>
          and <literal>auth-access</literal> can be set to the value
          <literal>none</literal>, <literal>read</literal>, or
          <literal>write</literal>.  Setting the value to
          <literal>none</literal> prohibits both reading and writing;
          <literal>read</literal> allows read-only access to the
          repository, and <literal>write</literal> allows complete
          read/write access to the repository.  For example:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</programlisting>
        </informalexample>

        <para>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</programlisting>
        </informalexample>

        <para>The server process understands not only
          these <quote>blanket</quote> access controls to the
          repository, but also finer-grained access restrictions
          placed on specific files and directories within the
          repository.  To make use of this feature, you need to define
          a file containing more detailed rules, and then set
          the <literal>authz-db</literal> variable to point to
          it:</para>

        <informalexample>
          <programlisting>
[general]
password-db = userfile
realm = example realm

# Specific access rules for specific locations
authz-db = authzfile
</programlisting>
        </informalexample>

        <para>We discuss the syntax of the <filename>authzfile</filename> file
          in detail later in this chapter, in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.  Note
          that the <literal>authz-db</literal> variable isn't mutually
          exclusive with the <literal>anon-access</literal>
          and <literal>auth-access</literal> variables;  if all the
          variables are defined at once, <emphasis>all</emphasis>
          of the rules must be satisfied before access is allowed.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sasl">
      <title>Using svnserve with SASL</title>

      <para>For many teams, the built-in CRAM-MD5 authentication is
        all they need from <command>svnserve</command>.  However, if
        your server (and your Subversion clients) were built with the
        Cyrus Simple Authentication and Security Layer (SASL) library,
        you have a number of authentication and encryption
        options available to you.</para>

      <sidebar>
        <title>What Is SASL?</title>

        <para>The Cyrus Simple Authentication and Security Layer is
          open source software written by Carnegie Mellon University.
          It adds generic authentication and encryption capabilities
          to any network protocol, and as of Subversion 1.5 and later,
          both the <command>svnserve</command> server
          and <command>svn</command> client know how to make use of
          this library.  It may or may not be available to you: if
          you're building Subversion yourself, you'll need to have at
          least version 2.1 of SASL installed on your system, and
          you'll need to make sure that it's detected during
          Subversion's build process.  The Subversion command-line
          client will report the availability of Cyrus SASL when you
          run <userinput>svn --version</userinput>; if you're using
          some other Subversion client, you might need to check with
          the package maintainer as to whether SASL support was
          compiled in.</para>

        <para>SASL comes with a number of pluggable modules that
          represent different authentication systems: Kerberos
          (GSSAPI), NTLM, One-Time-Passwords (OTP), DIGEST-MD5, LDAP,
          Secure-Remote-Password (SRP), and others.  Certain
          mechanisms may or may not be available to you; be sure to
          check which modules are provided.</para>

        <para>You can download Cyrus SASL (both code and
          documentation) from
          <ulink url="http://asg.web.cmu.edu/sasl/sasl-library.html"
          />.</para>

      </sidebar>

      <para>Normally, when a subversion client connects to
        <command>svnserve</command>, the server sends a greeting that
        advertises a list of the capabilities it supports, and the
        client responds with a similar list of capabilities.  If the
        server is configured to require authentication, it then sends
        a challenge that lists the authentication mechanisms
        available; the client responds by choosing one of the
        mechanisms, and then authentication is carried out in some
        number of round-trip messages.  Even when SASL capabilities
        aren't present, the client and server inherently know how to
        use the CRAM-MD5 and ANONYMOUS mechanisms (see
        <xref linkend="svn.serverconfig.svnserve.auth"/>).  If server
        and client were linked against SASL, a number of other
        authentication mechanisms may also be available.  However,
        you'll need to explicitly configure SASL on the server side to
        advertise them.</para>

      <sect3 id="svn.serverconfig.svnserve.sasl.authn">
        <title>Authenticating with SASL</title>

        <para>To activate specific SASL mechanisms on the server,
          you'll need to do two things.  First, create
          a <literal>[sasl]</literal> section in your
          repository's <filename>svnserve.conf</filename> file with an
          initial key-value pair:</para>

        <informalexample>
          <programlisting>
[sasl]
use-sasl = true
</programlisting>
        </informalexample>

        <para>Second, create a main SASL configuration file
          called <filename>svn.conf</filename> in a place where the
          SASL library can find it typically in the directory
          where SASL plug-ins are located.  You'll have to locate the
          plug-in directory on your particular system, such
          as <filename>/usr/lib/sasl2/</filename>
          or <filename>/etc/sasl2/</filename>.  (Note that this
          is <emphasis>not</emphasis>
          the <filename>svnserve.conf</filename> file that lives
          within a repository!)</para>

        <para>On a Windows server, you'll also have to edit the system
          registry (using a tool such as <command>regedit</command>)
          to tell SASL where to find things.  Create a registry key
          named <literal>[HKEY_LOCAL_MACHINE\SOFTWARE\Carnegie
          Mellon\Project Cyrus\SASL Library]</literal>, and place two
          keys inside it: a key called <literal>SearchPath</literal>
          (whose value is a path to the directory containing the SASL
          <filename>sasl*.dll</filename> plug-in libraries), and a key
          called
          <literal>ConfFile</literal> (whose value is a path to the
          parent directory containing
          the <filename>svn.conf</filename> file you created).</para>

        <para>Because SASL provides so many different kinds of
          authentication mechanisms, it would be foolish (and far
          beyond the scope of this book) to try to describe every
          possible server-side configuration.  Instead, we recommend
          that you read the documentation supplied in the
          <filename>doc/</filename> subdirectory of the SASL source
          code.  It goes into great detail about every mechanism and
          how to configure the server appropriately for each.  For the
          purposes of this discussion, we'll just demonstrate a simple
          example of configuring the DIGEST-MD5 mechanism.  For
          example, if your <filename>subversion.conf</filename>
          (or <filename>svn.conf</filename>) file contains the
          following:</para>

        <informalexample>
          <programlisting>
pwcheck_method: auxprop
auxprop_plugin: sasldb
sasldb_path: /etc/my_sasldb
mech_list: DIGEST-MD5
</programlisting>
        </informalexample>

        <para>you've told SASL to advertise the DIGEST-MD5
          mechanism to clients and to check user passwords against a
          private password database located
          at <filename>/etc/my_sasldb</filename>.  A system
          administrator can then use
          the <command>saslpasswd2</command> program to add or modify
          usernames and passwords in the database:</para>

        <informalexample>
          <screen>
$ saslpasswd2 -c -f /etc/my_sasldb -u realm username
</screen>
        </informalexample>

        <para>A few words of warning: first, make sure the
          <quote>realm</quote> argument
          to <command>saslpasswd2</command> matches the same realm
          you've defined in your
          repository's <filename>svnserve.conf</filename> file; if
          they don't match, authentication will fail.  Also, due to a
          shortcoming in SASL, the common realm must be a string with
          no space characters.  Finally, if you decide to go with the
          standard SASL password database, make sure
          the <command>svnserve</command> program has read access to
          the file (and possibly write access as well, if you're using
          a mechanism such as OTP).</para>

        <para>This is just one simple way of configuring SASL.  Many
          other authentication mechanisms are available, and passwords
          can be stored in other places such as in LDAP or a SQL
          database.  Consult the full SASL documentation for
          details.</para>

        <para>Remember that if you configure your server to only allow
          certain SASL authentication mechanisms, this forces all
          connecting clients to have SASL support as well.  Any
          Subversion client built without SASL support (which includes
          all pre-1.5 clients) will be unable to authenticate.  On the
          one hand, this sort of restriction may be exactly what you
          want (<quote>My clients must all use Kerberos!</quote>).
          However, if you still want non-SASL clients to be able to
          authenticate, be sure to advertise the CRAM-MD5 mechanism as
          an option.  All clients are able to use CRAM-MD5, whether
          they have SASL capabilities or not.</para>

      </sect3>

      <sect3 id="svn.serverconfig.svnserve.sasl.encryption">
        <title>SASL encryption</title>

        <para>SASL is also able to perform data encryption if a
          particular mechanism supports it.  The built-in CRAM-MD5
          mechanism doesn't support encryption, but DIGEST-MD5 does,
          and mechanisms such as SRP actually require use of the
          OpenSSL library.  To enable or disable different levels of
          encryption, you can set two values in your repository's
          <filename>svnserve.conf</filename> file:</para>

        <informalexample>
          <programlisting>
[sasl]
use-sasl = true
min-encryption = 128
max-encryption = 256
</programlisting>
        </informalexample>

        <para>The <literal>min-encryption</literal> and
          <literal>max-encryption</literal> variables control the
          level of encryption demanded by the server.  To disable
          encryption completely, set both values to 0.  To enable
          simple checksumming of data (i.e., prevent tampering and
          guarantee data integrity without encryption), set both
          values to 1.  If you wish to allow but not
          require encryption, set the minimum value to 0, and
          the maximum value to some bit length.  To require encryption
          unconditionally, set both values to numbers greater than 1.
          In our previous example, we require clients to do at least
          128-bit encryption, but no more than 256-bit
          encryption.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshauth">
      <title>Tunneling over SSH</title>

      <para><command>svnserve</command>'s built-in authentication (and
        SASL support) can be very handy, because it avoids the need to
        create real system accounts.  On the other hand, some
        administrators already have well-established SSH
        authentication frameworks in place.  In these situations, all
        of the project's users already have system accounts and the
        ability to <quote>SSH into</quote> the server machine.</para>

      <para>It's easy to use SSH in conjunction with
        <command>svnserve</command>.  The client simply uses the
        <literal>svn+ssh://</literal> URL scheme to connect:</para>

      <informalexample>
        <screen>
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harryssh@host.example.com's password:  *****

foo
bar
baz
 
</screen>
      </informalexample>

      <para>In this example, the Subversion client is invoking a local
        <command>ssh</command> process, connecting to
        <literal>host.example.com</literal>, authenticating as the
        user <literal>harryssh</literal> (according to SSH user
        configuration), then spawning a private
        <command>svnserve</command> process on the remote machine
        running as the user <literal>harryssh</literal>.  The
        <command>svnserve</command> command is being invoked in tunnel
        mode (<option>-t</option>), and its network protocol is being
        <quote>tunneled</quote> over the encrypted connection by
        <command>ssh</command>, the tunnel agent.
        If the client performs a commit, the authenticated username
        <literal>harryssh</literal> will be used as the author
        of the new revision.</para>

      <para>The important thing to understand here is that the
        Subversion client is <emphasis>not</emphasis> connecting to a
        running <command>svnserve</command> daemon.  This method of
        access doesn't require a daemon, nor does it notice one if
        present.  It relies wholly on the ability of
        <command>ssh</command> to spawn a temporary
        <command>svnserve</command> process, which then terminates
        when the network connection is closed.</para>

      <para>When using <literal>svn+ssh://</literal> URLs to access a
        repository, remember that it's the <command>ssh</command>
        program prompting for authentication, and
        <emphasis>not</emphasis> the <command>svn</command> client
        program.  That means there's no automatic password-caching
        going on (see <xref linkend="svn.serverconfig.netmodel.credcache"/>).
        The Subversion client often makes multiple connections to the
        repository, though users don't normally notice this due to the
        password caching feature.  When using
        <literal>svn+ssh://</literal> URLs, however, users may be
        annoyed by <command>ssh</command> repeatedly asking for a
        password for every outbound connection.  The solution is to
        use a separate SSH password-caching tool such as
        <command>ssh-agent</command> on a Unix-like system, or
        <command>pageant</command> on Windows.</para>

      <para>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <literal>file://</literal> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks (be sure to read <xref
        linkend="svn.serverconfig.multimethod"/> later in this
        chapter).  But even in the case of tunneling, you can still use the
        <filename>svnserve.conf</filename> file to block access, by
        simply setting <literal>auth-access = read</literal>
        or <literal>auth-access = none</literal>.<footnote><para>Note
        that using any sort of <command>svnserve</command>-enforced
        access control at all only makes sense if the users cannot 
        bypass it and access the repository directory directly using
        other tools (such as <command>cd</command> and
        <command>vi</command>); implementing
        such restrictions is described in
        <xref linkend="svn.serverconfig.svnserve.sshtricks.fixedcmd"
        />.</para></footnote></para>

      <para>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your runtime <filename>config</filename>
        file (see <xref linkend="svn.advanced.confarea"/>).  For
        example, suppose you want to use RSH instead of
        SSH.<footnote><para>We don't actually recommend this, since
        RSH is notably less secure than SSH.</para></footnote>  In
        the <literal>[tunnels]</literal> section of your
        <filename>config</filename> file, simply define it like
        this:</para>

      <informalexample>
        <programlisting>
[tunnels]
rsh = rsh
</programlisting>
      </informalexample>

      <para>And now, you can use this new tunnel definition by using a
        URL scheme that matches the name of your new variable:
        <literal>svn+rsh://host/path</literal>.  When using the new
        URL scheme, the Subversion client will actually be running the
        command <userinput>rsh host svnserve -t</userinput> behind the
        scenes.  If you include a username in the URL (e.g.,
        <literal>svn+rsh://username@host/path</literal>), the client
        will also include that in its command (<userinput>rsh
        username@host svnserve -t</userinput>).  But you can define new
        tunneling schemes to be much more clever than that:</para>

      <informalexample>
        <programlisting>
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</programlisting>
      </informalexample>

      <para>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <filename>/opt/alternate/ssh</filename>) with specific
        options.  In this case, accessing an
        <literal>svn+joessh://</literal> URL would invoke the
        particular SSH binary with <option>-p 29934</option> as
        arguments useful if you want the tunnel program to
        connect to a nonstandard port.</para>

      <para>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <literal>SVN_SSH</literal> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options to SSH, you can use the
        mechanism demonstrated in this example.  Now if we were to set
        the <literal>JOESSH</literal> environment variable, its value
        would override the entire value of the tunnel
        variable <command>$JOESSH</command> would be executed
        instead of <userinput>/opt/alternate/ssh -p
        29934</userinput>.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.svnserve.sshtricks">
      <title>SSH Configuration Tricks</title>

      <para>It's possible to control not only the way in which the
        client invokes <command>ssh</command>, but also to control
        the behavior of <command>sshd</command> on your server
        machine.  In this section, we'll show how to control the
        exact <command>svnserve</command> command executed
        by <command>sshd</command>, as well as how to have multiple
        users share a single system account.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.setup">
        <title>Initial setup</title>

        <para>To begin, locate the home directory of the account
          you'll be using to launch <command>svnserve</command>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <filename>authorized_keys</filename> file.</para>

        <para>If it doesn't already exist, create the
          <filename>authorized_keys</filename> file (on Unix,
          typically <filename>~/.ssh/authorized_keys</filename>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</para>

        <informalexample>
          <programlisting>
  ssh-dsa AAAABtce9euch  user@example.com
</programlisting>
        </informalexample>

        <para>The first field describes the type of key, the second
          field is the base64-encoded key itself, and the third field
          is a comment.  However, it's a lesser known fact that the
          entire line can be preceded by a <literal>command</literal>
          field:</para>

        <informalexample>
          <programlisting>
  command="program" ssh-dsa AAAABtce9euch  user@example.com
</programlisting>
        </informalexample>

        <para>When the <literal>command</literal> field is set, the
          SSH daemon will run the named program instead of the
          typical tunnel-mode <command>svnserve</command> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</para>

        <informalexample>
          <programlisting>
  command="program" TYPE KEY COMMENT
</programlisting>
        </informalexample>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.svnserve.sshtricks.fixedcmd">
        <title>Controlling the invoked command</title>

        <para>Because we can specify the executed server-side command,
          it's easy to name a specific <command>svnserve</command>
          binary to run and to pass it extra arguments:</para>

        <informalexample>
          <programlisting>
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</programlisting>
        </informalexample>

        <para>In this example, <filename>/path/to/svnserve</filename>
          might be a custom wrapper script
          around <command>svnserve</command> which sets the umask (see
          <xref linkend="svn.serverconfig.multimethod"/>).  It also
          shows how to anchor <command>svnserve</command> in a virtual
          root directory, just as one often does when
          running <command>svnserve</command> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <literal>svn+ssh://</literal>
          URL.</para>

        <para>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private key pair for each
          person.  Then place each public key into
          the <filename>authorized_keys</filename> file, one per
          line, and use the <option>--tunnel-user</option>
          option:</para>

        <informalexample>
          <programlisting>
  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</programlisting>
        </informalexample>

        <para>This example allows both Harry and Sally to connect to
          the same account via public key authentication.  Each of
          them has a custom command that will be executed;
          the <option>--tunnel-user</option> option
          tells <command>svnserve</command> to assume that the named
          argument is the authenticated user.  Without
          <option>--tunnel-user</option>, it would appear as though
          all commits were coming from the one shared system
          account.</para>

        <para>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <literal>command</literal> value
          in <filename>authorized_keys</filename>.  For example, the
          user may still get shell access through SSH or be able to
          perform X11 or general port forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <literal>command</literal>:</para>

        <informalexample>
          <programlisting>
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,no-agent-forw
arding,no-X11-forwarding,no-pty TYPE1 KEY1 harry@example.com
</programlisting>
        </informalexample>

        <para>Note that this all must be on one line truly on
          one line since SSH <filename>authorized_keys</filename>
          files do not even allow the conventional backslash character
          (<literal>\</literal>) for line continuation.  The only
          reason we've shown it with a line break is to fit it on
          the physical page of a book.</para>

      </sect3>
    </sect2>
  </sect1>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.httpd">

    <title>httpd, the Apache HTTP Server</title>

    <para>The Apache HTTP Server is a <quote>heavy-duty</quote>
      network server that Subversion can leverage.  Via a custom
      module, <command>httpd</command> makes Subversion repositories
      available to clients via the WebDAV/DeltaV<footnote><para>See
      <ulink url="http://www.webdav.org/"/>.</para></footnote>
      protocol, which is an extension to HTTP 1.1.  This protocol
      takes the ubiquitous HTTP protocol that is the core of the World
      Wide Web, and adds writing specifically, versioned
      writing capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, supported by numerous operating systems and
      third-party products, and doesn't require network administrators
      to open up yet another custom port.<footnote><para>They really
      hate doing that.</para></footnote> While an Apache-Subversion
      server has more features than <command>svnserve</command>, it's
      also a bit more difficult to set up.  With flexibility often
      comes more complexity.</para>

    <para>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their web site at
      <ulink url="http://httpd.apache.org"/>.  For example, a general
      reference for the configuration directives is located at
      <ulink url="http://httpd.apache.org/docs/current/mod/directives.html"
      />.</para>

    <para>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <filename>httpd.conf</filename>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <literal>CustomLog</literal> and <literal>ErrorLog</literal>
      directives, respectively).
      Subversion's <command>mod_dav_svn</command> uses Apache's error
      logging interface as well.  You can always browse the contents
      of those files for information that might reveal the source of a
      problem that is not clearly noticeable otherwise.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.prereqs">
      <title>Prerequisites</title>

      <para>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <command>httpd</command> 2.0 or newer, the
        <command>mod_dav</command> DAV module that comes with it,
        Subversion, and the <command>mod_dav_svn</command>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</para>

      <itemizedlist>
        <listitem>
          <para>Getting httpd up and running with
            the <command>mod_dav</command> module</para>
        </listitem>
        <listitem>
          <para>Installing the <command>mod_dav_svn</command> backend
            to <command>mod_dav</command>, which uses Subversion's
            libraries to access the repository</para>
        </listitem>
        <listitem>
          <para>Configuring your <filename>httpd.conf</filename>
            file to export (or expose) the repository</para>
        </listitem>
      </itemizedlist>

      <para>You can accomplish the first two items either by
        compiling <command>httpd</command> and Subversion from
        source code or by installing prebuilt binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <filename>INSTALL</filename> file in
        the top level of the Subversion source code tree.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.basic">
      <title>Basic Apache Configuration</title>

      <para>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <filename>httpd.conf</filename> file.  Instruct Apache
        to load the <command>mod_dav_svn</command> module using the
        <literal>LoadModule</literal> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <command>mod_dav_svn</command> module should have been
        installed in the <filename>modules</filename> subdirectory of
        the Apache install location (often
        <filename>/usr/local/apache2</filename>).  The
        <literal>LoadModule</literal> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</para>

      <informalexample>
        <programlisting>
LoadModule dav_svn_module     modules/mod_dav_svn.so
</programlisting>
      </informalexample>

      <para>Apache interprets the <literal>LoadModule</literal>
        configuration item's library path as relative to its own
        server root.  If configured as previously shown, Apache will
        look for the Subversion DAV module shared library in its
        own <filename>modules/</filename> subdirectory.  Depending on
        how Subversion was installed on your system, you might need to
        specify a different path for this library altogether, perhaps
        even an absolute path such as in the following example:</para>

      <informalexample>
        <programlisting>
LoadModule dav_svn_module     C:/Subversion/lib/mod_dav_svn.so
</programlisting>
      </informalexample>

      <para>Note that if <command>mod_dav</command> was compiled as a
        shared object (instead of statically linked directly to the
        <command>httpd</command> binary), you'll need a similar
        <literal>LoadModule</literal> statement for it, too.  Be sure
        that it comes before the <command>mod_dav_svn</command> line:</para>

      <informalexample>
        <programlisting>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</programlisting>
      </informalexample>

      <para>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <literal>Location</literal> directive
        has an XML-like notation, starting with an opening tag and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <literal>Location</literal> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <filename>/repos/</filename> to a DAV provider whose
        repository is located at
        <filename>/var/svn/repository</filename> using the
        following <filename>httpd.conf</filename> syntax:</para>

      <informalexample>
        <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
&lt;/Location&gt;
</programlisting>
      </informalexample>

      <para>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative
        directive <literal>SVNParentPath</literal> to
        indicate that common parent directory.  For example, if you
        know you will be creating multiple Subversion repositories in
        a directory <filename>/var/svn</filename> that would be
        accessed via URLs such as
        <uri>http://my.server.com/svn/repos1</uri>,
        <uri>http://my.server.com/svn/repos2</uri>, and so on, you
        could use the <filename>httpd.conf</filename> configuration
        syntax in the following example:</para>

      <informalexample>
        <programlisting>
&lt;Location /svn&gt;
  DAV svn

  # Automatically map any "/svn/foo" URL to repository /var/svn/foo
  SVNParentPath /var/svn
&lt;/Location&gt;
</programlisting>
      </informalexample>

      <para>Using this syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <filename>/svn/</filename> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <literal>SVNParentPath</literal> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <literal>SVNPath</literal> directive, you don't have to
        restart Apache to add or remove hosted repositories.</para>

      <para>Be sure that when you define your new
        <literal>Location</literal>, it doesn't overlap with other
        exported locations.  For example, if your main
        <literal>DocumentRoot</literal> is exported to
        <filename>/www</filename>, do not export a Subversion
        repository in <literal>&lt;Location /www/repos&gt;</literal>.
        If a request comes in for the URI
        <filename>/www/repos/foo.c</filename>, Apache won't know
        whether to look for a file <filename>repos/foo.c</filename> in
        the <literal>DocumentRoot</literal>, or whether to delegate
        <command>mod_dav_svn</command> to return
        <filename>foo.c</filename> from the Subversion repository.
        The result is often an error from the server of the form
        <literal>301 Moved Permanently</literal>.</para>

      <sidebar>
        <title>Server Names and the COPY Request</title>

        <para>Subversion makes use of the <literal>COPY</literal>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to
          tell <command>mod_dav</command> the name you use as the
          hostname of your server.  Generally, you can use
          the <literal>ServerName</literal> directive in
          <filename>httpd.conf</filename> to accomplish this.</para>

        <informalexample>
          <programlisting>
ServerName svn.example.com
</programlisting>
        </informalexample>

        <para>If you are using Apache's virtual hosting support via
          the <literal>NameVirtualHost</literal> directive, you may
          need to use the <literal>ServerAlias</literal> directive to
          specify additional names by which your server is known.
          Again, refer to the Apache documentation for full
          details.</para>
      </sidebar>

      <para>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content web pages, scripts, and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</para>

      <para>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <literal>User</literal> and <literal>Group</literal>
        directives in <filename>httpd.conf</filename> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authn">
      <title>Authentication Options</title>

      <para>At this point, if you configured
        <filename>httpd.conf</filename> to contain something such as the
        following:</para>

      <informalexample>
        <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
&lt;/Location&gt;
</programlisting>
      </informalexample>

      <para>your repository is <quote>anonymously</quote>
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories that you make available via the
        <literal>Location</literal> directive will be generally
        accessible to everyone.  In other words:</para>

      <itemizedlist>
        <listitem>
          <para>Anyone can use a Subversion client to check out a
            working copy of a repository URL (or any of its
            subdirectories).</para>
        </listitem>
        <listitem>
          <para>Anyone can interactively browse the repository's
            latest revision simply by pointing a web browser to
            the repository URL.</para>
        </listitem>
        <listitem>
          <para>Anyone can commit to the repository.</para>
        </listitem>
      </itemizedlist>

      <para>Of course, you might have already set up
        a <filename>pre-commit</filename> hook script to prevent
        commits (see <xref linkend="svn.reposadmin.hooks" />).
        But as you read on, you'll see that it's also possible to use
        Apache's built-in methods to restrict access in specific
        ways.</para>

      <tip>
        <para>Requiring authentication defends against invalid users
          directly accessing the repository, but does not guard the
          privacy of valid users' network activity.  See
          <xref linkend="svn.serverconfig.httpd.ssl"/> for how to
          configure your server to support SSL encryption, which can
          provide that extra layer of protection.</para>
      </tip>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.basic">
        <title>Basic authentication</title>

        <para>The easiest way to authenticate a client is via the HTTP
          Basic authentication mechanism, which simply uses a username
          and password to verify a user's identity.  Apache provides
          the <command>htpasswd</command> utility<footnote><para>See
          <ulink url="http://httpd.apache.org/docs/current/programs/htpasswd.html"
          />.</para></footnote> for managing files containing
          usernames and passwords.</para>

        <warning>
          <para>Basic authentication is <emphasis>extremely</emphasis>
            insecure, because it sends passwords over the network
            in very nearly plain text.  See
            <xref linkend="svn.serverconfig.httpd.authn.digest"/> for
            details on using the much safer Digest mechanism.</para>
        </warning>

        <para>First, create a password file and grant access to
          users Harry and Sally:</para>

        <informalexample>
          <screen>
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -c -m /etc/svn-auth.htpasswd harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth.htpasswd sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</screen>
        </informalexample>
        
        <para>Next, ensure that Apache has access to the modules which
          provide the Basic authentication and related
          functionality:  <literal>mod_auth_basic</literal>,
          <literal>mod_authn_file</literal>, and
          <literal>mod_authz_user</literal>.  In many cases, these
          modules are compiled into <command>httpd</command> itself,
          but if not, you might need to explicitly load one or more of
          them using the <literal>LoadModule</literal> directive:</para>

        <informalexample>
          <programlisting>
LoadModule auth_basic_module   modules/mod_auth_basic.so
LoadModule authn_file_module   modules/mod_authn_file.so
LoadModule authz_user_module   moduels/mod_authz_user.so
</programlisting>
        </informalexample>

        <para>After ensuring the Apache has access to the required
          functionality, you'll need to add some more directives
          inside the <literal>&lt;Location&gt;</literal> block to tell
          Apache what type of authentication you wish to use, and just
          how to to so:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Basic
  AuthName "Subversion repository"
  AuthType Basic
  AuthBasicProvider file
  AuthUserFile /etc/svn-auth.htpasswd
&lt;/Location&gt;
</programlisting>
        </informalexample>

        <para>These directives work as follows:</para>

        <itemizedlist>
          <listitem>
            <para><literal>AuthName</literal> is an arbitrary name
              that you choose for the authentication domain.  Most
              browsers display this name in the dialog box when
              prompting for username and password.</para>
          </listitem>
          <listitem>
            <para><literal>AuthType</literal> specifies the type of
              authentication to use.</para>
          </listitem>
          <listitem>
            <para><literal>AuthBasicProvider</literal> specifies the
              Basic authentication provider to use for the location.
              In our example, we wish to consult a local password
              file.</para>
          </listitem>
          <listitem>
            <para><literal>AuthUserFile</literal> specifies the
              location of the password file to use.</para>
          </listitem>
        </itemizedlist>

        <para>However, this <literal>&lt;Location&gt;</literal> block
          doesn't yet do anything useful.  It merely tells Apache that
          <emphasis>if</emphasis> authorization were required, it
          should challenge the Subversion client for a username and
          password.  (When authorization is required, Apache requires
          authentication as well.)  What's missing here, however, are
          directives that tell Apache <emphasis>which sorts</emphasis>
          of client requests require authorization; currently, none do.
          The simplest thing is to specify that <emphasis>all</emphasis>
          requests require authorization by adding
          <literal>Require valid-user</literal> to the block:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Basic
  AuthName "Subversion repository"
  AuthType Basic
  AuthBasicProvider file
  AuthUserFile /etc/svn-auth.htpasswd

  # Authorization: Authenticated users only
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </informalexample>

        <para>Refer to <xref linkend="svn.serverconfig.httpd.authz"/>
          for more detail on the <literal>Require</literal> directive
          and other ways to set authorization policies.</para>

        <note>
          <para>The default value of the
            <literal>AuthBasicProvider</literal> option is
            <literal>file</literal>, so we won't bother including
            it in future examples.  Just know that if in a broader
            context you've set this value to something else, you'll
            need to explicitly reset it to <literal>file</literal>
            within your Subversion <literal>&lt;Location&gt;</literal>
            block in order to get that behavior.</para>
        </note>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authn.digest">
        <title>Digest authentication</title>

        <para>Digest authentication is an improvement on Basic
          authentication which allows the server to verify a client's
          identity without sending the password over the network
          unprotected.  Both client and server create a non-reversible
          MD5 hash of the username, password, requested URI, and a
          <firstterm>nonce</firstterm> (number used once) provided by
          the server and changed each time authentication is required.
          The client sends its hash to the server, and the server then
          verifies that the hashes match.</para>

        <para>Configuring Apache to use Digest authentication is
          straightforward.  You'll need to ensure that
          the <literal>mod_auth_digest</literal> module is available
          (instead of <literal>mod_auth_basic</literal>), and then
          make a few small variations on our prior example:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthDigestProvider file
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Authenticated users only
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </informalexample>

        <para>Notice that <literal>AuthType</literal> is now set to
          <literal>Digest</literal>, and we specify a different path
          for <literal>AuthUserFile</literal>.  Digest authentication
          uses a different file format than Basic authentication, 
          created and managed using Apache's <command>htdigest</command>
          utility<footnote><para>See
          <ulink url="http://httpd.apache.org/docs/current/programs/htdigest.html"
          />.</para></footnote> rather than <command>htpasswd</command>.
          Digest authentication also has the additional concept of a
          <quote>realm</quote>, which must match the value of the
          <literal>AuthName</literal> directive.</para>

        <note>
          <para>For digest authentication, the authentication provider
            is selected using the <literal>AuthDigestProvider</literal>
            as shown in the previous example.  As was the case with
            the <literal>AuthBasicProvider</literal> directive,
            <literal>file</literal> is the default value of the
            <literal>AuthDigestProvider</literal> option, so this
            line is not strictly required unless you need to override
            a different value thereof inherited from a broader
            configuration context.</para>
        </note>

        <para>The password file can be created as follows:</para>

        <informalexample>
          <screen>
$ ### First time: use -c to create the file
$ htdigest -c /etc/svn-auth.htdigest "Subversion repository" harry
Adding password for harry in realm Subversion repository.
New password: *****
Re-type new password: *****
$ htdigest /etc/svn-auth.htdigest "Subversion repository" sally
Adding user sally in realm Subversion repository
New password: *******
Re-type new password: *******
$
</screen>
        </informalexample>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.authz">
      <title>Authorization Options</title>

      <para>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.blanket">
        <title>Blanket access control</title>

        <para>The simplest form of access control is to authorize
          certain users for either read-only access to a repository or
          read/write access to a repository.</para>

        <para>You can restrict access on all repository operations by
          adding <literal>Require valid-user</literal> directly inside
          the <literal>&lt;Location&gt;</literal> block.  The example
          from <xref linkend="svn.serverconfig.httpd.authn.digest"/>
          allows only clients that successfully authenticate to do
          anything with the Subversion repository:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Authenticated users only
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </informalexample>

        <para>Sometimes you don't need to run such a tight ship.  For
          example, the server hosting Subversion's own source code at
          <ulink url="https://svn.apache.org/repos/asf/subversion/"/> allows
          anyone in the world to perform read-only repository tasks (such as
          checking out working copies and browsing the repository),
          but restricts write operations to authenticated users.  The
          <literal>Limit</literal> and <literal>LimitExcept</literal>
          directives allow for this type of selective restriction.
          Like the <literal>Location</literal> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <literal>&lt;Location&gt;</literal>
          block.</para>

        <para>The parameters present on the <literal>Limit</literal>
          and <literal>LimitExcept</literal> directives are HTTP
          request types that are affected by that block.  For example,
          to allow anonymous read-only operations, you would use the
          <literal>LimitExcept</literal> directive (passing the
          <literal>GET</literal>, <literal>PROPFIND</literal>,
          <literal>OPTIONS</literal>, and <literal>REPORT</literal>
          request type parameters) and place the previously mentioned
          <literal>Require valid-user</literal> directive inside the
          <literal>&lt;LimitExcept&gt;</literal> block instead of just
          inside the <literal>&lt;Location&gt;</literal> block.</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Authenticated users only for non-read-only
  #                (write) operations; allow anonymous reads
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</programlisting>
        </informalexample>

        <para>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <literal>Require</literal> directive, take a look at the
          <literal>Security</literal> section of the Apache
          documentation's tutorials collection at <ulink
          url="http://httpd.apache.org/docs-2.0/misc/tutorials.html"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.perdir">
        <title>Per-directory access control</title>

        <para>It's possible to set up finer-grained permissions using
          <command>mod_authz_svn</command>.  This Apache module grabs
          the various opaque URLs passing from client to server, asks
          <command>mod_dav_svn</command> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</para>

        <para>If you've built Subversion from source code,
          <command>mod_authz_svn</command> is automatically built
          and installed alongside <command>mod_dav_svn</command>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <command>mod_dav_svn</command>'s
          <literal>LoadModule</literal> directive in
          <filename>httpd.conf</filename>:</para>

        <informalexample>
          <programlisting>
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</programlisting>
        </informalexample>

        <para>To activate this module, you need to configure your
          <literal>&lt;Location&gt;</literal> block to use the
          <literal>AuthzSVNAccessFile</literal> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</para>

        <para>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          following examples are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</para>

        <para>The most open approach is to allow access to everyone.
          This means Apache never sends authentication challenges, and
          all users are treated as <quote>anonymous</quote>.  (See
          <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-1"
          />.)</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-1">
          <title>A sample configuration for anonymous access</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: None

  # Authorization: Path-based access control
  AuthzSVNAccessFile /path/to/access/file
&lt;/Location&gt;
</programlisting>
        </example>

        <para>On the opposite end of the paranoia scale, you can
          configure Apache to authenticate all clients.
          This block unconditionally requires authentication via the
          <literal>Require valid-user</literal> directive, and defines
          a means to authenticate valid users.  (See
          <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-2"/>.)</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-2">
          <title>A sample configuration for authenticated access</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Path-based access control; authenticated users only
  AuthzSVNAccessFile /path/to/access/file
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </example>

        <para>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but restrict access to more
          sensitive areas to authenticated users.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, use both the <literal>Satisfy Any</literal>
          and <literal>Require valid-user</literal> directives.  (See
          <xref linkend="svn.serverconfig.httpd.authz.perdir.ex-3"
          />.)</para>

        <example id="svn.serverconfig.httpd.authz.perdir.ex-3">
          <title>A sample configuration for mixed
            authenticated/anonymous access</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # Authentication: Digest
  AuthName "Subversion repository"
  AuthType Digest
  AuthUserFile /etc/svn-auth.htdigest

  # Authorization: Path-based access control; try anonymous access
  #                first, but authenticate if necessary
  AuthzSVNAccessFile /path/to/access/file
  Satisfy Any
  Require valid-user
&lt;/Location&gt;
</programlisting>
        </example>

        <para>The next step is to create the authorization file
          containing access rules for particular paths within the
          repository.  We describe how later in this chapter, in
          <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.authz.pathauthzoff">
        <title>Disabling path-based checks</title>

        <para>The <command>mod_dav_svn</command> module goes through a
          lot of work to make sure that data you've marked
          <quote>unreadable</quote> doesn't get accidentally leaked.
          This means it needs to closely monitor all of the paths
          and file-contents returned by commands such as <command>svn
          checkout</command> and <command>svn update</command>.
          If these commands encounter a path that isn't
          readable according to some authorization policy, the
          path is typically omitted altogether.  In the case of
          history or rename tracing for example, running a command such
          as <userinput>svn cat -r OLD foo.c</userinput> on a file that
          was renamed long ago the rename tracking will simply
          halt if one of the object's former names is determined to be
          read-restricted.</para>

        <para>All of this path checking can sometimes be quite
          expensive, especially in the case of <command>svn
          log</command>.  When retrieving a list of revisions, the
          server looks at every changed path in each revision and
          checks it for readability.  If an unreadable path is
          discovered, it's omitted from the list of the revision's
          changed paths (normally seen with
          the <option>--verbose</option> (<option>-v</option>) option),
          and the whole log message is suppressed.  Needless to say,
          this can be time-consuming on revisions that affect a large
          number of files.  This is the cost of security: even if you
          haven't configured a module such as
          <command>mod_authz_svn</command> at all, the
          <command>mod_dav_svn</command> module is still asking Apache
          <command>httpd</command> to run authorization checks on
          every path.  The <command>mod_dav_svn</command> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</para>

        <para>On the other hand, there's also an escape hatch of
          sorts, which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e., not using
          <command>mod_authz_svn</command> or similar module),
          you can disable all of this path checking.  In your
          <filename>httpd.conf</filename> file, use the
          <literal>SVNPathAuthz</literal> directive as shown in
          <xref linkend="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"/>.</para>

        <example id="svn.serverconfig.httpd.authz.pathauthzoff.ex-1">
          <title>Disabling path checks altogether</title>
          <programlisting>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  SVNPathAuthz off
&lt;/Location&gt;
</programlisting>
        </example>

        <para>The <literal>SVNPathAuthz</literal> directive
          is <quote>on</quote> by default.  When
          set to <quote>off,</quote> all path-based authorization
          checking is disabled;
          <command>mod_dav_svn</command> stops invoking authorization
          checks on every path it discovers.</para>

      </sect3>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.ssl">
      <title>Protecting network traffic with SSL</title>

      <para>Connecting to a repository via <literal>http://</literal>
        means that all Subversion activity is sent across the network
        in the clear.  This means that actions such as checkouts,
        commits, and updates could potentially be intercepted by an
        unauthorized party <quote>sniffing</quote> network traffic.
        Encrypting traffic using SSL is a good way to protect
        potentially sensitive information over the network.</para>

      <para>If a Subversion client is compiled to use OpenSSL,
        it gains the ability to speak to an Apache server via
        <literal>https://</literal> URLs, so all traffic is encrypted
        with a per-connection session key.  The WebDAV library used by
        the Subversion client is not only able to verify server
        certificates, but can also supply client certificates when
        challenged by the server.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ssl.server">
        <title>Subversion server SSL certificate configuration</title>

        <para>It's beyond the scope of this book to describe how to
          generate client and server SSL certificates and how to
          configure Apache to use them.  Many other references,
          including Apache's own documentation (<ulink 
          url="http://httpd.apache.org/docs/current/ssl/"/>),
          describe the process.</para>

        <tip>
          <para>SSL certificates from well-known entities generally
            cost money, but at a bare minimum, you can configure
            Apache to use a self-signed certificate generated with a
            tool such as OpenSSL (<ulink url="http://openssl.org"
            />).<footnote><para>While self-signed certificates are
            still vulnerable to a <quote>man-in-the-middle</quote>
            attack (before a client sees the certificate for the first
            time), such an attack is much more difficult for a casual
            observer to pull off, compared to sniffing unprotected
            passwords.</para></footnote></para>
        </tip>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ssl.client">
        <title>Subversion client SSL certificate management</title>

        <para>When connecting to Apache via <literal>https://</literal>,
          a Subversion client can receive two different types of
          responses:</para>

        <itemizedlist>
          <listitem>
            <para>A server certificate</para>
          </listitem>
          <listitem>
            <para>A challenge for a client certificate</para>
          </listitem>
        </itemizedlist>

        <sect4 id="svn.serverconfig.httpd.ssl.client.servercert">
          <title>Server certificate</title>

          <para>When the client receives a server certificate, it needs
            to verify that the server is who it claims to be. OpenSSL
            does this by examining the signer of the server certificate,
            or <firstterm>certificate authority</firstterm> (CA).  If
            OpenSSL is unable to automatically trust the CA, or if some
            other problem occurs (such as an expired certificate or
            hostname mismatch), the Subversion command-line client will
            ask you whether you want to trust the server certificate
            anyway:</para>

          <informalexample>
            <screen>
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority.  Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</screen>
          </informalexample>

          <para>This dialogue is essentially the same question you may
            have seen coming from your web browser (which is just
            another HTTP client like Subversion).  If you choose the
            <literal>(p)</literal>ermanent option, Subversion will
            cache the server certificate in your private runtime
            <filename>auth/</filename> area, just as your username and
            password are cached (see <xref
            linkend="svn.serverconfig.netmodel.credcache"/>), and will
            automatically trust the certificate in the future.</para>

          <para>Your runtime <filename>servers</filename> file also gives
            you the ability to make your Subversion client automatically
            trust specific CAs, either globally or on a per-host basis.
            Simply set the <literal>ssl-authority-files</literal>
            variable to a semicolon-separated list of PEM-encoded CA
            certificates:</para>

          <informalexample>
            <programlisting>
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</programlisting>
          </informalexample>

          <para>Many OpenSSL installations also have a predefined set
            of <quote>default</quote> CAs that are nearly universally
            trusted.  To make the Subversion client automatically trust
            these standard authorities, set the
            <literal>ssl-trust-default-ca</literal> variable to
            <literal>true</literal>.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.ssl.client.clientcert">
          <title>Client certificate challenge</title>

          <para>If the client receives a challenge for a certificate,
            the server is asking the client to prove its identity.
            The client must send back a certificate signed by a CA
            that the server trusts, along with a <firstterm>challenge
            response</firstterm> which proves that the client owns the
            private key associated with the certificate.  The private
            key and certificate are usually stored in an encrypted
            format on disk, protected by a passphrase.  When Subversion
            receives this challenge, it will ask you for the path to the
            encrypted file and the passphrase that protects it:</para>

          <informalexample>
            <screen>
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
</screen>
          </informalexample>

          <para>Notice that the client credentials are stored in a
            <literal>.p12</literal> file.  To use a client certificate
            with Subversion, it must be in PKCS#12 format, which is a
            portable standard.  Most web browsers are able to import
            and export certificates in that format.  Another option
            is to use the OpenSSL command-line tools to convert
            existing certificates into PKCS#12.</para>

          <para>The runtime <filename>servers</filename> file also
            allows you to automate this challenge on a per-host basis.
            If you set the <literal>ssl-client-cert-file</literal>
            and <literal>ssl-client-cert-password</literal> variables,
            Subversion can automatically respond to a client
            certificate challenge without prompting you:</para>

          <informalexample>
            <programlisting>
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</programlisting>
          </informalexample>

          <para>More security-conscious folk might want to exclude
            <literal>ssl-client-cert-password</literal> to avoid
            storing the passphrase in the clear on disk.</para>

        </sect4>
      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.perf">
      <title>Tuning for Performance</title>

      <para>The Apache HTTP Server is built for performance, but you
        can improve upon its default configuration to get even better
        results out of your Subversion service offering.  In this
        section, we'll recommend some specific configuration changes
        to consider.  Understand, however, that some of
        the <filename>httpd.conf</filename> configuration options
        we'll be discussing herein affect the general behavior of your
        server, not merely the Subversion service.  As such, you need
        to consider the full breadth of your HTTP service offering to
        discern how modifications to these settings for Subversion's
        sake may affect your other services.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.perf.keepalive">
        <title>KeepAlive</title>

        <para>By default, the Apache HTTP Server is configured to
          enable the re-use of a single server connection for multiple
          requests.  That's very beneficial for Subversion, because
          unlike many HTTP-based applications, Subversion can very
          quickly generate hundreds or thousands of requests against
          the server for a single operation, and the cost of opening a
          new connection to the server is non-trivial.  Subversion
          wants to squeeze as many requests as possible out of a
          single connection before that connection is terminated by
          the server.  The <literal>KeepAlive</literal> directive is the
          boolean flag which enables or disables this connection
          re-use facility, and as we indicated previously, by default
          its value is <literal>On</literal>.</para>

        <para>But there's another directive which limits the number of
          requests a client is allowed to submit on a single
          connection:  the <literal>MaxKeepAliveRequests</literal>
          directive.  The default value for that option
          is <literal>100</literal>.  This was probably sufficient for
          older versions of Subversion, but Subversion 1.8 employs a
          different HTTP communications library (called Serf) which
          prefers to pipeline several smaller requests for specific bits
          of information rather than asking the server to transmit
          huge chunks of data in a single response.  We recommend that
          you increase the value of the
          <literal>MaxKeepAliveRequests</literal> option
          to at least <literal>1000</literal>.</para>

        <informalexample>
          <programlisting>
#
# KeepAlive: Whether or not to allow persistent connections (more than
# one request per connection). Set to "Off" to deactivate.
#
KeepAlive On

#
# MaxKeepAliveRequests: The maximum number of requests to allow
# during a persistent connection. Set to 0 to allow an unlimited amount.
# We recommend you leave this number high, for maximum performance.
#
MaxKeepAliveRequests 1000
</programlisting>
        </informalexample>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.perf.bulk-updates">
        <title>Bulk updates</title>

        <para>The biggest difference between the way that Subversion
          1.8 clients and pre-1.8 clients behave is in how update-style
          operations (<command>svn checkout</command>, <command>svn
          update</command>, <command>svn switch</command>, etc.) are
          handled.  Older clients which used the Neon HTTP library for
          communications preferred to ask the server for the entire
          payload of information required from the server in a single
          request.  Admins will have noticed that in their server
          logs, there would be some initial handshaking operations,
          and then a <literal>REPORT</literal> request with a massive
          response.  That response was the entire checkout/update
          dataset!</para>

        <para>Subversion clients which use the Serf HTTP
          library which includes all clients built atop the
          Subversion 1.8 still send the <literal>REPORT</literal>
          request, but with slightly different flags set inside that
          request.  These flags ask the server not to send all the
          data for the operation, but to instead send only a checklist
          of other more specific things that the client needs to
          subsequently fetch from the server in order to complete that
          operation.  In the server's <filename>access_log</filename>,
          that <literal>REPORT</literal> is followed by many smaller
          requests (<literal>GET</literal>s and, in older versions of
          Subversion, <literal>PROPFIND</literal>s).</para>

        <para>There are pros and cons to each approach.  As we've
          mentioned, the so-called bulk updates generate considerably
          less information in the server logs, but a given Apache HTTP
          Server child process is completely consumed for the duration
          of what could be a lengthy operation.  Non-bulk updates
          offer opportunities for setting up content caches (which
          themselves can improve performance), but generate server log
          traffic which is whole orders of magnitude larger than the
          bulk update approach.  So, for one reason or another,
          administrators may desire to exert a little more control
          over which approach the clients use.  Subversion 1.6
          introduced the <literal>SVNAllowBulkUpdates</literal>
          <command>mod_dav_svn</command> directive a simple
          boolean flag to allow admins to specify whether the
          server was allowed to honor bulk update requests.  In
          Subversion 1.8, this directive has expanded to include
          a <literal>Prefer</literal> value in addition to the
          <literal>On</literal> and <literal>Off</literal> values it
          already supported. When <literal>SVNAllowBulkUpdates</literal>
          is set to <literal>Prefer</literal>, supporting clients (1.8
          or newer) will try to use the bulk update approach unless
          otherwise configured.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.extra">
      <title>Extra Goodies</title>

      <para>We've covered most of the authentication and authorization
        options for Apache and <command>mod_dav_svn</command>.  But
        there are a few other nice features that Apache
        provides.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.browsing">
        <title>Repository browsing</title>

        <para>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that your
          versioned files and directories are immediately available
          for viewing via a regular web browser.  Since Subversion
          uses URLs to identify versioned resources, those URLs used
          for HTTP-based repository access can be typed directly into
          a web browser.  Your browser will issue an
          HTTP <literal>GET</literal> request for that URL; based on
          whether that URL represents a versioned directory or
          file, <command>mod_dav_svn</command> will respond with a
          directory listing or with file contents.</para>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.syntax">
          <title>URL syntax</title>

          <para>If the URLs do not contain any information about which
            version of the resource you wish to
            see, <command>mod_dav_svn</command> will answer with the
            youngest version.  This functionality has the wonderful
            side effect that you can pass around Subversion URLs to
            your peers as references to documents, and those URLs will
            always point at the latest manifestation of that document.
            Of course, you can even use the URLs as hyperlinks from
            other web sites, too.</para>

          <para>As of Subversion 1.6, <command>mod_dav_svn</command>
            supports a public URI syntax for examining older revisions
            of both files and directories.  The syntax uses the query
            string portion of the URL to specify either or both of a
            peg revision and operative revision, which Subversion will
            then use to determine which version of the file or
            directory to display to your web browser.  Add the query
            string name/value pair
            <literal>p=<replaceable>PEGREV</replaceable></literal>,
            where <replaceable>PEGREV</replaceable> is a revision
            number, to specify the peg revision you wish to apply to the
            request.  Use
            <literal>r=<replaceable>REV</replaceable></literal>,
            where <replaceable>REV</replaceable> is a revision number, to
            specify an operative revision.</para>

          <para>For example, if you wish to see the latest version of a
            <filename>README.txt</filename> file located in your
            project's <filename>/trunk</filename>, point your web
            browser to that file's repository URL, which might look
            something like the following:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/README.txt
</programlisting>
          </informalexample>

          <para>If you now wish to see some older version of that
            file, add an operative revision to the URL's query
            string:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/README.txt?r=1234
</programlisting>
          </informalexample>

          <para>What if the thing you're trying to view no longer exists
            in the youngest revision of the repository?  That's where a
            peg revision is handy:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/deleted-thing.txt?p=321
</programlisting>
          </informalexample>

          <para>And of course, you can combine peg revision and
            operative revision specifiers to fine-tune the exact item
            you wish to view:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/renamed-thing.txt?p=123&amp;r=21
</programlisting>
          </informalexample>

          <para>The previous URL would display revision 21 of the
            object which, in revision 123, was located
            at <filename>/trunk/renamed-thing.txt</filename> in the
            repository.  See <xref linkend="svn.advanced.pegrevs" /> for a
            detailed explanation of these <quote>peg revision</quote>
            and <quote>operative revision</quote> concepts.  They can
            be a bit tricky to wrap your head around.</para>

          <para>Beginning with Subversion 1.8, <command>mod_dav_svn</command>
            has the ability to substitute keywords.  When mod_dav_svn
            finds the query argument <literal>kw=1</literal> added to
            the URL of a file, it will expand keywords when delivering
            the file's content.  Omitting the <literal>kw</literal>
            parameter or using any value besides <literal>1</literal>
            for that parameter will cause Subversion to use its
            default behavior, which is to deliver the file's content
            without any keywords expanded.</para>

          <para>For example, if you wish to see the latest version of a
            <filename>README.txt</filename> file located in your
            project's <filename>/trunk</filename> with keywords
            expanded, add the query argument <literal>kw=1</literal> to the
            URL:</para>

          <informalexample>
            <programlisting>
http://host.example.com/repos/project/trunk/README.txt?kw=1
</programlisting>
          </informalexample>

          <para>As with client-side keyword expansion, only those keywords
            which are explicitly designated for expansion via the
            <literal>svn:keywords</literal> property set on the file itself
            will be expanded.  See
            <xref linkend="svn.advanced.props.special.keywords" /> for a
            detailed description of the keyword substitution feature.</para>

          <para>As a reminder, <command>mod_dav_svn</command> offers only a
            limited repository browsing experience.  You can see directory
            listings and file contents, but no revision properties
            (such as commit log messages) or file/directory
            properties.  For folks who require more extensive browsing
            of repositories and their history, there are several
            third-party software packages which offer this.  Some
            examples include ViewVC (<ulink url="http://viewvc.org" />),
            Trac (<ulink url="http://trac.edgewall.org" />) and WebSVN
            (<ulink url="http://websvn.info" />).  These third-party
            tools don't affect <command>mod_dav_svn</command>'s
            built-in <quote>browseability</quote>, and generally offer
            a much wider set of features, including the display of the
            aforementioned property sets, display of content
            differences between file revisions, and so on.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.mimetype">
          <title>Proper MIME type</title>

          <para>When browsing a Subversion repository, the web browser
            gets a clue about how to render a file's contents by
            looking at the <literal>Content-Type:</literal> header
            returned in Apache's response to the
            HTTP <literal>GET</literal> request.  The value of this
            header is some sort of MIME type.  By default, Apache will
            tell the web browsers that all repository files are of
            the <quote>default</quote> MIME type,
            typically <literal>text/plain</literal>.  This can be
            frustrating, however, if a user wishes repository files to
            render as something more meaningful for example,
            it might be nice to have a <filename>foo.html</filename> file
            in the repository actually render as HTML when
            browsing.</para>

          <para>To make this happen, you need only to make sure that
            your files have the proper <literal>svn:mime-type</literal>
            set.  We discuss this in more detail in
            <xref linkend="svn.advanced.props.special.mime-type"/>,
            and you can even configure your client to automatically
            attach proper <literal>svn:mime-type</literal> properties
            to files entering the repository for the first time; see
            <xref linkend="svn.advanced.props.auto"/>.</para>

          <para>Continuing our example, if one were to set
            the <literal>svn:mime-type</literal> property
            to <literal>text/html</literal> on
            file <filename>foo.html</filename>, Apache would properly
            tell your web browser to render the file as HTML.  One
            could also attach proper <literal>image/*</literal>
            MIME-type properties to image files and ultimately get an
            entire web site to be viewable directly from a repository!
            There's generally no problem with this, as long as the web
            site doesn't contain any dynamically generated
            content.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.xslt">
          <title>Customizing the look</title>

          <para>You generally will get more use out of URLs to
            versioned files after all, that's where the
            interesting content tends to lie.  But you might have
            occasion to browse a Subversion directory listing, where
            you'll quickly note that the generated HTML used to
            display that listing is very basic, and certainly not
            intended to be aesthetically pleasing (or even
            interesting).  To enable customization of these directory
            displays, Subversion provides an XML index feature.  A
            single <literal>SVNIndexXSLT</literal> directive in your
            repository's <literal>Location</literal> block of
            <filename>httpd.conf</filename> will
            instruct <command>mod_dav_svn</command> to generate XML
            output when displaying a directory listing, and to
            reference the XSLT stylesheet of your choice:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNIndexXSLT "/svnindex.xsl"
   
&lt;/Location&gt;
</programlisting>
          </informalexample>

          <para>Using the <literal>SVNIndexXSLT</literal> directive
            and a creative XSLT stylesheet, you can make your
            directory listings match the color schemes and imagery
            used in other parts of your web site.  Or, if you'd
            prefer, you can use the sample stylesheets provided in the
            Subversion source distribution's
            <filename>tools/xslt/</filename> directory.
            Keep in mind that the path provided to the
            <literal>SVNIndexXSLT</literal> directory is actually a
            URL path browsers need to be able to read your
            stylesheets to make use of them!</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.browsing.reposlisting">
          <title>Listing repositories</title>

          <para>If you're serving a collection of repositories from a
            single URL via the <literal>SVNParentPath</literal>
            directive, then it's also possible to have Apache display
            all available repositories to a web browser.  Just
            activate the <literal>SVNListParentPath</literal>
            directive:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNListParentPath on
   
&lt;/Location&gt;
</programlisting>
          </informalexample>

          <para>If a user now points her web browser to the
            URL <literal>http://host.example.com/svn/</literal>,
            she'll see a list of all Subversion repositories sitting
            in <filename>/var/svn</filename>.  Obviously, this can be
            a security problem, so this feature is turned off by
            default.</para>

        </sect4>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.logging">
        <title>Apache logging</title>

        <para>Because Apache is an HTTP server at heart, it contains
          fantastically flexible logging features.  It's beyond the
          scope of this book to discuss all of the ways logging can be
          configured, but we should point out that even the most
          generic <filename>httpd.conf</filename> file will cause
          Apache to produce two logs:
          <filename>error_log</filename>
          and <filename>access_log</filename>.  These logs may appear
          in different places, but are typically created in the
          logging area of your Apache installation.  (On Unix, they
          often live
          in <filename>/usr/local/apache2/logs/</filename>.)</para>

        <para>The <filename>error_log</filename> describes any internal
          errors that Apache runs into as it works.
          The <filename>access_log</filename> file records every
          incoming HTTP request received by Apache.  This makes it
          easy to see, for example, which IP addresses Subversion
          clients are coming from, how often particular clients use
          the server, which users are authenticating properly, and
          which requests succeed or fail.</para>

        <para>Unfortunately, because HTTP is a stateless protocol,
          even the simplest Subversion client operation generates
          multiple network requests.  It's very difficult to look at
          the <filename>access_log</filename> and deduce what the
          client was doing most operations look like a series
          of cryptic <literal>PROPPATCH</literal>, <literal>GET</literal>,
          <literal>PUT</literal>, and <literal>REPORT</literal>
          requests.  To make things worse, many client operations send
          nearly identical series of requests, so it's even harder to
          tell them apart.</para>

        <para><command>mod_dav_svn</command>, however, can come to
          your aid.  By activating an <quote>operational
          logging</quote> feature, you can
          ask <command>mod_dav_svn</command> to create a separate log
          file describing what sort of high-level operations your
          clients are performing.</para>

        <para>To do this, you need to make use of
          Apache's <literal>CustomLog</literal> directive (which is
          explained in more detail in Apache's own documentation).
          Be sure to invoke this
          directive <emphasis>outside</emphasis> your
          Subversion <literal>Location</literal> block:</para>

        <informalexample>
          <programlisting>
&lt;Location /svn&gt;
  DAV svn
   
&lt;/Location&gt;

CustomLog logs/svn_logfile "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</programlisting>
        </informalexample>

        <para>In this example, we're asking Apache to create a special
          logfile, <filename>svn_logfile</filename>, in the standard
          Apache <filename>logs</filename> directory.
          The <literal>%t</literal> and <literal>%u</literal>
          variables are replaced by the time and username of the
          request, respectively.  The really important parts are the
          two instances of <literal>SVN-ACTION</literal>.
          When Apache sees that variable, it substitutes the value of
          the <literal>SVN-ACTION</literal> environment variable,
          which is automatically set by <command>mod_dav_svn</command>
          whenever it detects a high-level client action.</para>

        <para>So, instead of having to interpret a
          traditional <filename>access_log</filename> like
          this:</para>

        <informalexample>
          <programlisting>
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
 
</programlisting>
        </informalexample>

        <para>you can peruse a much more
          intelligible <filename>svn_logfile</filename> like
          this:</para>

        <informalexample>
          <programlisting>
[26/Jan/2007:22:24:20 -0600] - get-dir /tags r1729 props
[26/Jan/2007:22:24:27 -0600] - update /trunk r1729 depth=infinity
[26/Jan/2007:22:25:29 -0600] - status /trunk/foo r1729 depth=infinity
[26/Jan/2007:22:25:31 -0600] sally commit r1730
</programlisting>
        </informalexample>

        <para>In addition to the <literal>SVN-ACTION</literal>
          environment variable, <command>mod_dav_svn</command> also
          populates the <literal>SVN-REPOS</literal>
          and <literal>SVN-REPOS-NAME</literal> variables, which carry
          the filesystem path to the repository and the basename
          thereof, respectively.  You might wish to include references
          to one or both of these variables in
          your <literal>CustomLog</literal> format string, too,
          especially if you are combining usage information from
          multiple repositories into a single log file.  For an
          exhaustive list of all actions logged, see
          <xref linkend="svn.serverconfig.operational-logging"/>.</para>

        <para>Obviously, the more information that Apache logs about
          your Subversion activities, the more disk space on your
          server those logs consume.  It is non uncommon for
          high-traffic Subversion servers to generate many gigabytes
          of log information daily.  Obviously, logs are only valuable
          if they can be meaningfully processed, and huge log files
          can quickly become unwieldy.  There are various standard
          approaches to Apache HTTP Server log management which are
          outside the scope of this book.  Administrators are
          encouraged to use the log rotation and archival approach
          which works best for them.</para>

        <para>But what if Subversion is simply generating too much log
          information to be useful?  For example, in
          <xref linkend="svn.serverconfig.httpd.perf.bulk-updates" />,
          we mentioned that certain approaches that Subversion clients
          may take to checkouts and other update-style operations can
          cause rapid growth of your server logs as requests for
          individual pieces of the update data set are individually
          logged (whereas in previous version of Subversion, they
          might not have been).  In this case, you might consider
          using some Apache configuration magic to selectively silence
          some of that log activity.</para>

        <para>Apache HTTP Server's
          <literal>mod_setenvif</literal> module offers
          a <literal>SetEnvIf</literal> directive which is handy for
          conditionally setting environment variables.  And as it
          turns out, the <literal>CustomLog</literal> directive can be
          told to conditionally log requests based on the state of
          environment variables.  The following is a sample
          configuration which instructs the server
          to <emphasis>not</emphasis> log <literal>GET</literal>
          and <literal>PROPFIND</literal> requests aimed at private
          Subversion URLs.</para>

        <informalexample>
          <programlisting>
# Matches everything, just to initialize the "in_repos" variable.
SetEnvIf Request_URI "^" in_repos=0

# Set "in_repos" if this is a request for a private Subversion URL.
SetEnvIf Request_URI "/!svn/" in_repos=1

# Set "do_not_log" for non-public request types we don't care to log.
SetEnvIf Request_Method "GET" do_not_log
SetEnvIf Request_Method "PROPFIND" do_not_log

# Unset "do_not_log" for URLs that aren't private Subversion URLs.
SetEnvIf in_repos 0 !do_not_log

# Log requests, but only if "do_not_log" isn't set.
CustomLog logs/access_log env=!do_not_log
</programlisting>
        </informalexample>

        <para>Using this configuration, <command>httpd</command> would
          still log <literal>GET</literal> requests aimed at public
          Subversion URLs.  These are the sorts of requests generated
          by a web browser as someone navigates the repository
          directly.  But <literal>GET</literal>
          and <literal>PROPFIND</literal> requests aimed at so-called
          "private" Subversion URLs which are the very sorts of
          requests used to fetch each and every individual file during
          a checkout operation won't get logged.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.writethruproxy">
        <title>Write-through proxying</title>

        <para>
          <indexterm>
            <primary>WebDAV</primary>
            <secondary>proxies</secondary>
            <see>httpd, write-through proxies</see>
          </indexterm>
          <indexterm>
            <primary>httpd</primary>
            <secondary>write-through proxies</secondary>
            <tertiary>master</tertiary>
          </indexterm>
          <indexterm>
            <primary>httpd</primary>
            <secondary>write-through proxies</secondary>
            <tertiary>slave</tertiary>
          </indexterm>One of the nice advantages of using Apache as a
          Subversion server is that it can be set up for simple
          replication.  For example, suppose that your team is
          distributed across four offices around the globe.  The
          Subversion repository can exist only in one of those
          offices, which means the other three offices will not enjoy
          accessing it they're likely to experience
          significantly slower traffic and response times when
          updating and committing code.  A powerful solution is to set
          up a system consisting of one <firstterm>master</firstterm>
          Apache server and several <firstterm>slave</firstterm>
          Apache servers.  If you place a slave server in each office,
          users can check out a working copy from whichever slave
          is closest to them.  All read requests go to their local
          slave.  Write requests get automatically routed to the
          single master server.  When the commit completes, the master
          then automatically <quote>pushes</quote> the new revision to
          each slave server using the <command>svnsync</command>
          replication tool.</para>

        <para>This configuration creates a huge perceptual speed
          increase for your users, because Subversion client traffic
          is typically 80-90% read requests.  And if those
          requests are coming from a <emphasis>local</emphasis>
          server, it's a huge win.</para>

        <para>In this section, we'll walk you through a standard setup
          of this single-master/multiple-slave system.  However, keep
          in mind that your servers must be running at least Apache
          2.2.0 (with <command>mod_proxy</command> loaded) and
          Subversion 1.5 (<command>mod_dav_svn</command>).</para>

        <note>
          <para>Ours is just one example of how you might setup a
            Subversion write-through proxy configuration.  There are
            other approaches.  For example, rather than having the
            master server push changes out to every slave server, the
            slaves could periodically pull those changes from the
            master.  Or perhaps the master could push changes to a
            single slave, which then pushes the same change to the
            next slave, and so on down the line.  Administrators are
            encouraged to use this section for basic understanding
            of what happens in a Subversion WebDAV proxy deployment
            scenario, and then implement the specific approach that
            works best for their organization.</para>
        </note>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.configure">
          <title>Configure the servers</title>

          <para>First, configure your master server's
            <filename>httpd.conf</filename> file in the usual way.
            Make the repository available at a certain URI location,
            and configure authentication and authorization however
            you'd like.  After that's done, configure each of your
            <quote>slave</quote> servers in the exact same way, but
            add the special <literal>SVNMasterURI</literal> directive
            to the block:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn&gt;
  DAV svn
  SVNPath /var/svn/repos
  SVNMasterURI http://master.example.com/svn
   
&lt;/Location&gt;
</programlisting>
          </informalexample>

          <para>This new directive tells a slave server to redirect
            all write requests to the master.  (This is done
            automatically via Apache's <command>mod_proxy</command>
            module.)  Ordinary read requests, however, are still
            serviced by the slaves.  Be sure that your master and
            slave servers all have matching authentication and
            authorization configurations;  if they fall out of sync,
            it can lead to big headaches.</para>

          <para>Next, we need to deal with the problem of infinite
            recursion.  With the current configuration, imagine what
            will happen when a Subversion client performs a commit to
            the master server.  After the commit completes, the server
            uses <command>svnsync</command> to replicate the new
            revision to each slave.  But because
            <command>svnsync</command> appears to be just another
            Subversion client performing a commit, the slave will
            immediately attempt to proxy the incoming write request
            back to the master!  Hilarity ensues.</para>

          <para>The solution to this problem is to have the master
            push revisions to a different
            <literal>&lt;Location&gt;</literal> on the slaves.  This
            location is configured to <emphasis>not</emphasis> proxy
            write requests at all, but to accept normal commits from
            (and only from) the master's IP address:</para>

          <informalexample>
            <programlisting>
&lt;Location /svn-proxy-sync&gt;
  DAV svn
  SVNPath /var/svn/repos
  Order deny,allow
  Deny from all
  # Only let the server's IP address access this Location:
  Allow from 10.20.30.40
   
&lt;/Location&gt;
</programlisting>
          </informalexample>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.replicate">
          <title>Set up replication</title>

          <para>Now that you've configured
            your <literal>Location</literal> blocks on master and
            slaves, you need to configure the master to replicate to
            the slaves.  Our walkthough uses <command>svnsync</command>,
            which is covered in more detail in
            <xref linkend="svn.reposadmin.maint.replication.svnsync"
            />.</para>

          <para>First, make sure that each slave repository has a
            <filename>pre-revprop-change</filename> hook script which
            allows remote revision property changes.  (This is
            standard procedure for being on the receiving end of
            <command>svnsync</command>.) Then log into the master
            server and configure each of the slave repository URIs to
            receive data from the master repository on the local
            disk:</para>

          <informalexample>
            <screen>
$ svnsync init http://slave1.example.com/svn-proxy-sync \
               file:///var/svn/repos
Copied properties for revision 0.
$ svnsync init http://slave2.example.com/svn-proxy-sync \
               file:///var/svn/repos
Copied properties for revision 0.
$ svnsync init http://slave3.example.com/svn-proxy-sync \
               file:///var/svn/repos
Copied properties for revision 0.

# Perform the initial replication

$ svnsync sync http://slave1.example.com/svn-proxy-sync \
               file:///var/svn/repos
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
 

$ svnsync sync http://slave2.example.com/svn-proxy-sync \
               file:///var/svn/repos
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
 

$ svnsync sync http://slave3.example.com/svn-proxy-sync \
               file:///var/svn/repos
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
 
</screen>
          </informalexample>

          <para>After this is done, we configure the master server's
            <literal>post-commit</literal> hook script to invoke
            <command>svnsync</command> on each slave server:</para>

          <informalexample>
            <programlisting>
#!/bin/sh
# Post-commit script to replicate newly committed revision to slaves

svnsync sync http://slave1.example.com/svn-proxy-sync \
             file:///var/svn/repos &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync sync http://slave2.example.com/svn-proxy-sync \
             file:///var/svn/repos &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync sync http://slave3.example.com/svn-proxy-sync \
             file:///var/svn/repos &gt; /dev/null 2&gt;&amp;1 &amp;
</programlisting>
          </informalexample>

          <para>The extra bits on the end of each line aren't
            necessary, but they're a sneaky way to allow the sync
            commands to run in the background so that the Subversion
            client isn't left waiting forever for the commit to
            finish.  In addition to this
            <literal>post-commit</literal> hook, you'll need a
            <literal>post-revprop-change</literal> hook as well so
            that when a user, say, modifies a log message, the slave
            servers get that change also:</para>

          <informalexample>
            <programlisting>
#!/bin/sh
# Post-revprop-change script to replicate revprop-changes to slaves

REV=${2}
svnsync copy-revprops http://slave1.example.com/svn-proxy-sync \
                      file:///var/svn/repos \
                      -r ${REV} &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync copy-revprops http://slave2.example.com/svn-proxy-sync \
                      file:///var/svn/repos \
                      -r ${REV} &gt; /dev/null 2&gt;&amp;1 &amp;
svnsync copy-revprops http://slave3.example.com/svn-proxy-sync \
                      file:///var/svn/repos \
                      -r ${REV} &gt; /dev/null 2&gt;&amp;1 &amp;
</programlisting>
          </informalexample>

          <para>The only thing we've left out here is what to do about
            user-level locks (of the <command>svn lock</command>
            variety).  Locks are enforced by the master server during
            commit operations; but all the information about locks is
            distributed during read operations such as <command>svn
            update</command> and <command>svn status</command> by the
            slave server.  As such, a fully functioning proxy setup
            needs to perfectly replicate lock information from the
            master server to the slave servers.  Unfortunately, most
            of the mechanisms that one might employ to accomplish this
            replication fall short in one way or
            another<footnote><para><ulink
            url="http://subversion.tigris.org/issues/show_bug.cgi?id=3457"
            /> tracks these problems.</para></footnote>.  Many teams
            don't use Subversion's locking features at all, so this
            may be a nonissue for you.  Sadly, for those teams which
            do use locks, we have no recommendations on how to
            gracefully work around this shortcoming.</para>

        </sect4>

        <sect4 id="svn.serverconfig.httpd.extra.writethruproxy.caveats">
          <title>Caveats</title>

          <para>Your master/slave replication system should now be
            ready to use.  A couple of words of warning are in order,
            however.  Remember that this replication isn't entirely
            robust in the face of computer or network crashes.  For
            example, if one of the automated
            <command>svnsync</command> commands fails to complete for
            some reason, the slaves will begin to fall behind.  For
            example, your remote users will see that they've committed
            revision 100, but then when they run <command>svn
            update</command>, their local server will tell them that
            revision 100 doesn't yet exist!  Of course, the problem
            will be automatically fixed the next time another commit
            happens and the subsequent <command>svnsync</command> is
            successful the sync will replicate all waiting
            revisions.  But still, you may want to set up some sort of
            out-of-band monitoring to notice synchronization failures
            and force <command>svnsync</command> to run when things go
            wrong.</para>

          <para>Another limitation of the write-through proxy
            deployment model involves version mismatches of the
            version of Subversion which is installed, that
            is between the master and slave servers.  Each new
            release of Subversion may (and often does) add new
            features to the network protocol used between the clients
            and servers.  Since feature negotiation happens against
            the slave, it is the slave's protocol version and feature
            set which is used.  But write operations are passed
            through to the master server quite literally.  Therefore,
            there is always a risk that the slave server will answer a
            feature negotiation request from the client in way that is
            true for the slave, but untrue for the master if the
            master is running an older version of Subversion.  This
            could result in the client trying to use a new feature
            that the master doesn't understand, and failing.  There
            are a couple of known problems of this sort in Subversion
            1.7, which introduced a major revision of its HTTP
            protocol.  If you are deploying a Subversion 1.7 slave
            server in front of a pre-1.7 master, you'll want to
            configure your slave server's
            Subversion <literal>&lt;Location&gt;</literal> block with
            the <literal>SVNAdvertiseV2Protocol Off</literal>
            directive.</para>

          <tip>
            <para>For the best results possible, try to run the same
              version of Subversion on your master and slave
              servers.</para>
          </tip>

          <sidebar>
            <title>Can We Set Up Replication with svnserve?</title>

            <para>If you're using <command>svnserve</command> instead
              of Apache as your server, you can certainly configure
              your repository's hook scripts to invoke
              <command>svnsync</command> as we've shown here, thereby
              causing automatic replication from master to slaves.
              Unfortunately, at the time of this writing there is no way to
              make slave <command>svnserve</command> servers
              automatically proxy write requests back to the master
              server.  This means your users would only be able to
              check out read-only working copies from the slave
              servers.  You'd have to configure your slave servers to
              disallow write access completely.  This might be useful
              for creating read-only <quote>mirrors</quote> of popular
              open source projects, but it's not a transparent
              proxying system.</para>
          </sidebar>

        </sect4>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.extra.other">
        <title>Other Apache features</title>

        <para>Several of the features already provided by Apache in
          its role as a robust web server can be leveraged for
          increased functionality or security in Subversion as well.
          The Subversion client is able to use SSL (the Secure Sockets
          Layer, discussed earlier).  If your Subversion client is
          built to support SSL, it can access your Apache server
          using <literal>https://</literal> and enjoy a high-quality
          encrypted network session.</para>

        <para>Equally useful are other features of the Apache and
          Subversion relationship, such as the ability to specify a
          custom port (instead of the default HTTP port 80) or a
          virtual domain name by which the Subversion repository
          should be accessed, or the ability to access the repository
          through an HTTP proxy.</para>

        <para>Finally, because <command>mod_dav_svn</command> is
          speaking a subset of the WebDAV/DeltaV protocol, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network <quote>shared folder.</quote> This is a
          complicated topic, but also wondrous when implemented.  For
          details, read <xref linkend="svn.webdav"/>.</para>

        <para>Note that there are a number of other small tweaks one
          can make to <command>mod_dav_svn</command> that perhaps do
          not merit extensive coverage.  For those interested,
          however, we provide a complete list of
          all <filename>httpd.conf</filename> directives
          to which <command>mod_dav_svn</command> responds in
          <xref linkend="svn.serverconfig.httpd.ref.mod_dav_svn"
          />.</para>

      </sect3>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.httpd.ref">
      <title>Subversion Apache HTTP Server Configuration Reference</title>

      <para>In the previous sections, we've mentioned numerous
        directives that administrators can use in their
        <filename>httpd.conf</filename> files to enable and configure
        their Subversion server offering, introducing each directive
        as we also introduce the functionality it toggles.  In this
        section, we'll quickly summarize <emphasis>all</emphasis> the
        configuration directives supported by both of the Apache HTTP
        Server modules which are provided as part of the standard
        Subversion distribution.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ref.mod_dav_svn">
        <title>mod_dav_svn configuration directives</title>

        <para>The following configuration directives are recognized
          and supported by Subversion's Apache HTTP Server module,
          <command>mod_dav_svn</command>.</para>

        <variablelist>
    
          <varlistentry>
            <term><literal>DAV svn</literal></term>
            <listitem>

              <para>Must be included in any
                <literal>Directory</literal> or <literal>Location</literal>
                block for a Subversion repository.  It
                tells <command>httpd</command> to use the Subversion
                backend for <literal>mod_dav</literal> to handle all
                requests.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNActivitiesDB
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

              <para>Specifies the location in the filesystem where the
                activities database should be stored.  By default,
                <command>mod_dav_svn</command> creates and uses a
                directory in the repository
                called <filename>dav/activities.d</filename>.  The
                path specified with this option must be an absolute
                path.</para>

              <para>If specified for
                an <literal>SVNParentPath</literal>
                area, <command>mod_dav_svn</command> appends the
                basename of the repository to the path specified here.
                For example:</para>

              <informalexample>
          <screen>
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository in 
  # /net/svn.nfs/repositories/foo
  SVNParentPath         "/net/svn.nfs/repositories"

  # any "/svn/foo" URL will map to an activities db in
  #  /var/db/svn/activities/foo
  SVNActivitiesDB       "/var/db/svn/activities"
&lt;/Location&gt;
</screen>
        </informalexample>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNAdvertiseV2Protocol On|Off</literal></term>
            <listitem>

              <para>New to Subversion 1.7, this toggles
                whether <command>mod_dav_svn</command> advertises its
                support for the new version of its HTTP protocol also
                introduced in that version.  Most admins will not wish
                to use this directive (which is <literal>On</literal>
                by default), choosing instead to enjoy the performance
                benefits that the new protocol offers.  However, whena
                configuring a server as a write-through proxy to
                another server which does not support the new
                protocol, set this directive's value
                to <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNAllowBulkUpdates On|Off</literal></term>
            <listitem>

              <para>Toggles support for all-inclusive
                responses to update-style <literal>REPORT</literal>
                requests.  Subversion clients use
                <literal>REPORT</literal> requests to get information
                about directory tree checkouts and updates from
                <command>mod_dav_svn</command>.  They can ask the
                server to send that information in one of two ways:
                with the entirety of the tree's information in one
                massive response, or with a
                <firstterm>skelta</firstterm> (a skeletal
                representation of a tree delta) which contains just
                enough information for the client to know what
                <emphasis>additional</emphasis> data to request from
                the server.  When this directive is included with a
                value of <literal>Off</literal>,
                <command>mod_dav_svn</command> will only ever respond
                to these <literal>REPORT</literal> requests with
                skelta responses, regardless of the type of responses
                requested by the client.</para>

              <para>Most folks won't need to use this directive at
                all.  It primarily exists for administrators who
                wish for security or auditing reasons to
                force Subversion clients to fetch individually all the
                files and directories needed for updates and
                checkouts, thus leaving an audit trail of
                <literal>GET</literal> and <literal>PROPFIND</literal>
                requests in Apache's logs.  The default value of this
                directive is <literal>On</literal>.</para>

            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>SVNAutoversioning On|Off</literal></term>
            <listitem>

              <para>When its value is
                <literal>On</literal>, allows write requests from
                WebDAV clients to result in automatic commits.  A
                generic log message is auto-generated and attached to
                each revision.  If you enable autoversioning, you'll
                likely want to set <literal>ModMimeUsePathInfo
                On</literal> so that <literal>mod_mime</literal> can
                set <literal>svn:mime-type</literal> to the correct
                MIME type automatically (as best as
                <literal>mod_mime</literal> is able to, of course).
                For more information, see <xref
                linkend="svn.webdav"/>.  The default value of this
                directive is <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNCacheFullTexts On|Off</literal></term>
            <listitem>

              <para>When set to <literal>On</literal>, this tells
                Subversion to cache content fulltexts if sufficient
                in-memory cache is available, which could offer a
                significant performance benefit to the server.  (See
                also the <literal>SVNInMemoryCacheSize</literal>
                directive.)  The default value of this directive
                is <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>SVNCacheTextDeltas On|Off</literal></term>
            <listitem>

              <para>When set to <literal>On</literal>, this tells
                Subversion to cache content deltas if sufficient
                in-memory cache is available, which could offer a
                significant performance benefit to the server.  (See
                also the <literal>SVNInMemoryCacheSize</literal>
                directive.)  The default value of this directive
                is <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNCompressionLevel
              <replaceable>level</replaceable></literal></term>
            <listitem>

              <para>Specifies the compression level used when sending
                file content over the network.  A value
                of <literal>0</literal> disables compression
                altogether, and <literal>9</literal> is the maximum
                value.  <literal>5</literal> is the default
                value.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNIndexXSLT
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

              <para>Specifies the URI of an XSL transformation for
                directory indexes.  This directive is optional.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNInMemoryCacheSize
              <replaceable>size</replaceable></literal></term>
            <listitem>

              <para>Specifies the maximum size (in kbytes) per process
                of Subversion's in-memory object cache.  The default
                value is <literal>16384</literal>; use a value
                of <literal>0</literal> to deactivate this cache
                altogether.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNListParentPath On|Off</literal></term>
            <listitem>

              <para>When set to <literal>On</literal>, allows
                a <literal>GET</literal>
                of <literal>SVNParentPath</literal>, which results in
                a listing of all repositories under that path.  The
                default setting is
                <literal>Off</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNMasterURI
              <replaceable>url</replaceable></literal></term>
            <listitem>

              <para>Specifies a URI to the master Subversion
                repository (used for a write-through proxy).</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNParentPath
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

              <para>Specifies the location in the filesystem of a
                parent directory whose child directories are
                Subversion repositories.  In a configuration block for
                a Subversion repository, either this directive or
                <literal>SVNPath</literal> must be present, but not
                both.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNPath
              <replaceable>directory-path</replaceable></literal></term>
            <listitem>

              <para>Specifies the location in the
                filesystem for a Subversion repository's files.  In a
                configuration block for a Subversion repository,
                either this directive or
                <literal>SVNParentPath</literal> must be present, but
                not both.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNPathAuthz On|Off|short_circuit</literal></term>
            <listitem>

              <para>Controls path-based authorization by enabling
                subrequests (<literal>On</literal>), disabling
                subrequests (<literal>Off</literal>; see <xref
                linkend="svn.serverconfig.httpd.authz.pathauthzoff"/>),
                or querying <command>mod_authz_svn</command> directly
                (<literal>short_circuit</literal>).  The default
                value of this directive is <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNReposName
              <replaceable>name</replaceable></literal></term>
            <listitem>

              <para>Specifies the name of a Subversion repository for
                use in <literal>HTTP GET</literal> responses.  This
                value will be prepended to the title of all directory
                listings (which are served when you navigate to a
                Subversion repository with a web browser).  This
                directive is optional.</para>

               <note>
                 <para>Subversion will not use the repository name as
                   configured via this directive when trying to match
                   rules in access control files.  The repository names
                   used in that file's syntax are always derived from
                   the repository URL.  See
                   <xref linkend="svn.serverconfig.pathbasedauthz.getting-started"
                   /> for details.</para>
               </note>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNSpecialURI
              <replaceable>component</replaceable></literal></term>
            <listitem>

              <para>Specifies the URI component (namespace) for
                special Subversion resources.  The default is
                <literal>!svn</literal>, and most
                administrators will never use this directive.  Set
                this only if there is a pressing need to have a file
                named <filename>!svn</filename> in your repository.
                If you change this on a server already in use, it will
                break all of the outstanding working copies, and your
                users will hunt you down with pitchforks and flaming
                torches.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>SVNUseUTF8 On|Off</literal></term>
            <listitem>

              <para>When set to <literal>On</literal>,
                <command>mod_dav_svn</command> will communicate with
                hook scripts using repository root paths encoded in
                UTF-8, and will expect those scripts to likewise
                generate output (such as error messages) encoded in
                UTF-8.  The default value of this option
                is <literal>Off</literal>, which means
                that <command>mod_dav_svn</command> assumes a 7-bit
                ASCII encoding for its hook script interactions.  This
                option is available as of Subversion 1.8.</para>

              <note>
                <para>Administrators should ensure that the character
                  set and encoding expectations of hook scripts match
                  all the ways they might be invoked.  For example, if
                  one repository is served by both <command>httpd</command>
                  and <command>svnserve</command>, <command>svnserve</command>
                  should also be configured to use UTF-8 (by setting
                  an appropriate locale in its environment) if this
                  option is enabled for <command>mod_dav_svn</command>.
                  Also, local filesystem paths containing non-ASCII
                  characters which will be accessed by those scripts
                  (such as repository root paths) must be properly
                  encoded in the filesystem to match the scripts'
                  expectations.</para>
              </note>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.serverconfig.httpd.ref.mod_authz_svn">
        <title>mod_authz_svn configuration directives</title>

        <para>The following configuration directives are provided
          by <command>mod_authz_svn</command>, Subversion's path-based
          authorization Apache HTTP Server module.  For an in-depth
          description of using path-based authorization in Subversion,
          see <xref linkend="svn.serverconfig.pathbasedauthz"/>.</para>

        <variablelist>
   
          <varlistentry>
            <term><literal>AuthzForceUsernameCase Upper|Lower</literal></term>
            <listitem>

              <para>Set to <literal>Upper</literal>
                or <literal>Lower</literal> to perform case conversion
                of the specified sort on the authenticated username
                before checking it for authorization.  While usernames
                are compared in a case-sensitive fashion against those
                referenced in the authorization rules file, this
                directive can at least normalize variably-cased
                usernames into something consistent.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNAccessFile
              <replaceable>file-path</replaceable></literal></term>
            <listitem>

              <para>Consult <replaceable>file-path</replaceable> for
                access rules describing the permissions for paths in
                Subversion repository.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNAnonymous On|Off</literal></term>
            <listitem>

              <para>Set to <literal>Off</literal> to disable two
                special-case behaviours of this module: interaction
                with the <literal>Satisfy Any</literal> directive and
                enforcement of the authorization policy even when no
                <literal>Require</literal> directives are present.
                The default value of this directive is
                <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNAuthoritative On|Off</literal></term>
            <listitem>

              <para>Set to <literal>Off</literal> to allow access
                control to be passed along to lower modules.  The
                default value of this directive is
                <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>AuthzSVNNoAuthWhenAnonymousAllowed On|Off</literal></term>
            <listitem>

              <para>Set to <literal>On</literal> to suppress
                authentication and authorization for requests which
                anonymous users are allowed to perform.  The default
                value of this directive is
                <literal>On</literal>.</para>

            </listitem>
          </varlistentry>

        </variablelist>
      </sect3>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.pathbasedauthz">

    <title>Path-Based Authorization</title>

    <para>Both Apache and <command>svnserve</command> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).</para>

    <para>It's also possible, however, to define finer-grained access
      rules.  One set of users may have permission to write to a
      certain directory in the repository, but not others; another
      directory might not even be readable by all but a few special
      people.  It's even possible to restrict access on a per file
      basis.</para>

    <para>Both Subversion servers use a common file format to describe
      these path-based access rules.  In this section, we will
      explain that file format, as well how to configure your
      Subversion server to use it for managing path-based
      authorization.</para>

    <sidebar>
      <title>Do You Really Need Path-Based Access Control?</title>

      <para>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</para>

      <para>Note, though, that there are often invisible (and
        visible!) costs associated with this feature.  In the visible
        category, the server needs to do a lot more work to ensure
        that the user has the right to read or write each specific
        path; in certain situations, there's very noticeable
        performance loss.  In the invisible category, consider the
        culture you're creating.  Most of the time, while certain
        users <emphasis>shouldn't</emphasis> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to
        maintain.</para>

        <para>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something she
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, it's a
        social problem anyway, and that the problem needs to be dealt
        with outside Subversion.</para>

      <para>So, before you begin restricting users' access rights, ask
        yourself whether there's a real, honest need for this, or
        whether it's just something that <quote>sounds good</quote> to
        an administrator.  Decide whether it's worth sacrificing some
        server speed, and remember that there's very little risk
        involved; it's bad to become dependent on technology as a
        crutch for social problems.<footnote><para>A common theme in
        this book!</para></footnote></para>

      <para>As an example to ponder, consider that the Subversion
        project itself has always had a notion of who is allowed to
        commit where, but it's always been enforced socially.  This is
        a good model of community trust, especially for open source
        projects.  Of course, sometimes there <emphasis>are</emphasis>
        truly legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</para>

    </sidebar>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.getting-started">

      <title>Getting Started with Path-Based Access Control</title>

      <para>Subversion offers path-based access control in Apache via
        the <command>mod_authz_svn</command> module, which must be
        loaded using the <literal>LoadModule</literal> directive
        in <filename>httpd.conf</filename> in the same fashion
        that <command>mod_dav_svn</command> itself is loaded.  To
        enable the use of this module for your repositories, you'll
        add the <literal>AuthzSVNAccessFile</literal> directive (again
        within the <filename>httpd.conf</filename> file) pointing to
        your own access rules file.  (For a full explanation, see
        <xref linkend="svn.serverconfig.httpd.authz.perdir"/>.)</para>

      <para>To configure path-based authorization
        in <command>svnserve</command>, simply point
        the <literal>authz-db</literal> configuration variable (within
        your <filename>svnserve.conf</filename> file) to your access
        rules file.</para>

      <para>Once your server knows where to look for your access
        rules, it's time to define those rules.</para>

      <para>The syntax of the Subversion access file is the same
        familiar one used by <filename>svnserve.conf</filename> and
        the runtime configuration files.  Lines that start with a hash
        (<literal>#</literal>) are ignored.  In its simplest form,
        each section names a versioned path and, optionally, the
        repository in which that path is found.  In other words,
        except for a few reserved sections, section names are of one
        of two forms: either <literal>[repos-name:path]</literal>
        or <literal>[path]</literal>.  Authenticated usernames are the
        option names within each section, and an option's value
        describes that user's level of access to the repository path:
        either <literal>r</literal> (read-only) or <literal>rw</literal>
        (read/write).  If the user is not mentioned at all, no access is
        allowed.</para>

      <note>
        <para>Paths used in access file sections must be specified
          using Subversion's <quote>internal style</quote>, which
          mostly just means that they are encoded in UTF-8 and use
          forward slash (<literal>/</literal>) characters as directory
          separators (even on Windows systems).  Note also that these
          paths do not employ any character escaping mechanism (such
          as URI-encoding) spaces in path names should be
          represented exactly as such in access file section names
          (<literal>[repos-name:path with spaces]</literal>,
          e.g.)</para>
      </note>

      <para>Here's a simple example demonstrating a piece of the
        access configuration which grants read access Sally, and
        read/write access to Harry, for the
        path <filename>/branches/calc/bug-142</filename> (and all its
        children) in the repository <literal>calc</literal>:</para>

      <informalexample>
        <programlisting>
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</programlisting>
      </informalexample>

      <warning>
        <para>Prior to version 1.7, Subversion treated repository names
          and paths in a case-insensitive fashion for the purposes of
          access control, converting them to lower case internally
          before comparing them against the contents of your access
          file.  It now does these comparisons case-sensitively.  If you
          upgraded to Subversion 1.7 from an older version, you should
          review your access files for case correctness.</para>
      </warning>

      <para>The name of a repository as evaluated by the authorization
        subsystem is derived directly from the repository's path.
        Exactly how this happens differs between to two server
        options. <command>mod_dav_svn</command> uses only the basename
        of the repository's root URL<footnote><para>Any human-readable
        name for a repository configured via
        the <literal>SVNReposName</literal> <filename>httpd.conf</filename>
        directive will be ignored by the authorization subsystem.
        Your access control file sections must refer to repositories
        by their server-sensitive paths as previously
        described.</para></footnote>,
        while <command>svnserve</command> uses the entire relative
        path from the serving root (as determined by
        its <option>--root</option> (<option>-r</option>) command-line
        option) to the repository.</para>

      <warning>
        <para>The differences in the ways that a repository's name is
          determined by each of <command>mod_dav_svn</command>
          and <command>svnserve</command> can cause problems when
          trying to serve a repository via both servers
          simultaneously.  Naturally, an administrator would prefer to
          point both servers' configurations toward a common access
          file.  However, for this to work, you must ensure that the
          repository name portion of the file's section names are
          compatible with each server's idea of what the repository
          name should be for example, by
          configuring <command>svnserve</command>'s root to be the
          same as <command>mod_dav_svn</command>'s configured
          <literal>SVNParentPath</literal>, or by using a different
          access file per repository so that section names needn't
          reference the repository at all.</para>
      </warning>

      <para>If you're using the <literal>SVNParentPath</literal>
        directive, it's important to specify the repository names in
        your sections.  If you omit them, a section such as
        <literal>[/some/dir]</literal> will match the path
        <filename>/some/dir</filename> in <emphasis>every</emphasis>
        repository.  If you're using the <literal>SVNPath</literal>
        directive, however, it's fine to provide only paths in your
        sections after all, there's only one repository.</para>

      <para>Permissions are inherited from a path's parent directory.
        That means we can specify a subdirectory with a different
        access policy for Sally.  Let's continue our previous
        example, and grant Sally write access to a child of the branch
        that she's otherwise permitted only to read:</para>

      <informalexample>
        <programlisting>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</programlisting>
      </informalexample>

      <para>Now Sally can write to the <filename>testing</filename>
        subdirectory of the branch, but can still only read other parts.
        Harry, meanwhile, continues to have complete read/write access
        to the whole branch.</para>

      <para>It's also possible to explicitly deny permission to someone
        via inheritance rules, by setting the username variable to
        nothing:</para>

      <informalexample>
        <programlisting>
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</programlisting>
      </informalexample>

      <para>In this example, Harry has read/write access to the
        entire <filename>bug-142</filename> tree, but has absolutely no
        access at all to the <filename>secret</filename> subdirectory
        within it.</para>

      <tip>
        <para>The thing to remember is that the most specific path
          always matches first.  The server tries to match the path
          itself, and then the parent of the path, then the parent of
          that, and so on.  The net effect is that mentioning a specific
          path in the access file will always override any permissions
          inherited from parent directories.</para>

        <para>Similarly, sections that specify a repository name have
          precedence over those that don't: if both
          <literal>[calc:/some/path]</literal> and
          <literal>[/some/path]</literal> are present, the former will be used
          and the latter ignored for <literal>calc</literal>.</para>
      </tip>

      <para>By default, nobody has any access to any repository at all.
        That means that if you're starting with an empty file, you'll
        probably want to give at least read permission to all users at
        the roots of the repositories.  You can do this by using the
        asterisk variable (<literal>*</literal>), which means <quote>all
        users</quote>:</para>

      <informalexample>
        <programlisting>
[/]
* = r
</programlisting>
      </informalexample>

      <para>This is a common setup; notice that no repository
        name is mentioned in the section name.  This makes all repositories
        world-readable to all users.  Once all users have read access to
        the repositories, you can give explicit
        <literal>rw</literal> permission to certain users on specific
        subdirectories within specific repositories.</para>

      <para>Note that while all of the previous examples use
        directories, that's only because defining access rules on
        directories is the most common case.  You may similarly
        restrict access on file paths, too.</para>

      <informalexample>
        <programlisting>
[calendar:/projects/calendar/manager.ics]
harry = rw
sally = r
</programlisting>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.groups">

      <title>Access Control Groups</title>

      <para>The access file also allows you to define whole groups of
        users, much like the Unix <filename>/etc/group</filename>
        file.  To do this, create a <literal>groups</literal> section
        in your access file, and then describe your groups within that
        section: each variable's name defines the name of the group,
        and its value is a comma-delimited list of usernames which
        are part of that group.</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, jane
</programlisting>
      </informalexample>

      <para>Groups can be granted access control just like users.
        Distinguish them with an <quote>at sign</quote>
        (<literal>@</literal>) prefix:</para>

      <informalexample>
        <programlisting>
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
jane = r
@paint-developers = rw
</programlisting>
      </informalexample>

      <para>Another important fact is that group permissions are not
        overridden by individual user permissions. Rather, the
        <emphasis>combination</emphasis> of all matching permissions is
        granted.  In the prior example, Jane is a member of the
        <literal>paint-developers</literal> group, which has read/write
        access.  Combined with the <literal>jane = r</literal> rule,
        this still gives Jane read/write access.  Permissions for group
        members can only be extended beyond the permissions the group
        already has. Restricting users who are part of a group to less
        than their group's permissions is impossible.</para>

      <para>Groups can also be defined to contain other groups:</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</programlisting>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.aliases">

      <title>Username Aliases</title>

      <para>Some authentication systems expect and carry relatively
        short usernames of the sorts we've been describing
        here <literal>harry</literal>,
        <literal>sally</literal>, <literal>joe</literal>, and so on.  But
        other authentication systems such as those which use LDAP
        stores or SSL client certificates may carry much more
        complex usernames.  For example, Harry's username in an
        LDAP-protected system might be <literal>CN=Harold
        Hacker,OU=Engineers,DC=red-bean,DC=com</literal>.  With
        usernames like that, the access file can become quite bloated
        with long or obscure usernames that are easy to
        mistype.</para>

      <para>Fortunately, Subversion 1.5 introduced username aliases to
        the access file syntax.  Username aliases allow you to have to
        type the correct complex username only once, in a statement
        which assigns to it a more easily digestable alias.</para>

      <para>Username aliases are defined in the
        special <literal>aliases</literal> section of the access file,
        with each variable name in that section defining an alias, and
        the value of those variables carrying the real Subversion
        username which is being aliased.</para>

      <informalexample>
        <programlisting>
[aliases]
harry = CN=Harold Hacker,OU=Engineers,DC=red-bean,DC=com
sally = CN=Sally Swatterbug,OU=Engineers,DC=red-bean,DC=com
joe = CN=Gerald I. Joseph,OU=Engineers,DC=red-bean,DC=com
 
</programlisting>
      </informalexample>

      <para>Once you've defined a set of aliases, you can refer to the
        users elsewhere in the access file via their aliases in all the
        same places you could have instead used their actual usernames.
        Simply prepend an ampersand to the alias to distinguish it from
        a regular username:</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = &amp;harry, &amp;sally, &amp;joe
paint-developers = &amp;frank, &amp;sally, &amp;jane
everyone = @calc-developers, @paint-developers
</programlisting>
      </informalexample>

      <para>You might also choose to use aliases if your users'
        usernames change frequently.  Doing so allows you to need to
        update only the aliases table when these username changes occur,
        instead of doing global search-and-replace operations on the
        whole access file.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.authclass-tokens">

      <title>Advanced Access Control Features</title>

      <para>Beginning with Subversion 1.5, the access file syntax also
        supports some <quote>magic</quote> tokens for helping you to
        make rule assignments based on the user's authentication
        class.  One such token is
        the <literal>$authenticated</literal> token.  Use this token
        where you would otherwise specify a username, alias, or group
        name in your authorization rules to declare the permissions
        granted to any user who has authenticated with any username at
        all.  Similarly employed is the <literal>$anonymous</literal>
        token, except that it matches everyone who has
        <emphasis>not</emphasis> authenticated with a username.</para>

      <informalexample>
        <programlisting>
[calendar:/projects/calendar]
$anonymous = r
$authenticated = rw
</programlisting>
      </informalexample>

      <para>Another handy bit of access file syntax magic is the use
        of the tilde (<literal>~</literal>) character as an exclusion
        marker.  In your authorization rules, prefixing a username,
        alias, group name, or authentication class token with a tilde
        character will cause Subversion to apply the rule to users who
        do <emphasis>not</emphasis> match the rule.  Though somewhat
        unnecessarily obfuscated, the following block is equivalent to
        the one in the previous example:</para>

      <informalexample>
        <programlisting>
[calendar:/projects/calendar]
~$authenticated = r
~$anonymous = rw
</programlisting>
      </informalexample>

      <para>A less obvious example might be as follows:</para>

      <informalexample>
        <programlisting>
[groups]
calc-developers = &amp;harry, &amp;sally, &amp;joe
calc-owners = &amp;hewlett, &amp;packard
calc = @calc-developers, @calc-owners

# Any calc participant has read-write access...
[calc:/projects/calc]
@calc = rw

# ...but only allow the owners to make and modify release tags.
[calc:/projects/calc/tags]
~@calc-owners = r
</programlisting>
      </informalexample>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.pathbasedauthz.gotchas">

      <title>Some Gotchas with Access Control</title>

      <para>If you're using Apache as your Subversion server and have
        made certain subdirectories of your repository unreadable to
        certain users, you need to be aware of a possible nonoptimal
        behavior with <command>svn checkout</command>.</para>

      <para>Depending on which HTTP communication library the
        Subversion client is using, it may request that the entire
        payload of a checkout or update be delivered in a single
        (often large) response to the primary checkout/update request.
        When this happens, this single request is the
        <emphasis>only</emphasis> opportunity Apache has to demand
        user authentication.  This has some odd side effects.  For
        example, if a certain subdirectory of the repository is
        readable only by user Sally, and user Harry checks out a
        parent directory, his client will respond to the initial
        authentication challenge as Harry.  As the server generates
        the large response, there's no way it can resend an
        authentication challenge when it reaches the special
        subdirectory; thus the subdirectory is skipped altogether,
        rather than asking the user to reauthenticate as Sally at the
        right moment.</para>

      <para>In a similar way, if the root of the repository is
        anonymously world-readable, the entire checkout will be done
        without authentication again, skipping the unreadable
        directory, rather than asking for authentication partway
        through.<footnote><para>For more on this, see the blog
        post <emphasis>Authz and Anon Authn Agony</emphasis> at
        <ulink url="http://blogs.collab.net/subversion/2007/03/authz_and_anon_/"
        />.</para></footnote></para>
      <!-- TODO: Merge content from the blog post into the book. --> 

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.operational-logging">
    <title>High-level Logging</title>

    <para>Both the Apache <command>httpd</command>
      and <command>svnserve</command> Subversion servers provide
      support for high-level logging of Subversion operations.
      Configuring each of the server options to provide this level of
      logging is done differently, of course, but the output from each
      is designed to conform to a uniform syntax.</para>

    <para>To enable high-level logging in <command>svnserve</command>,
      you need only use the <option>--log-file</option> command-line
      option when starting the server, passing as the value to the
      option the file to which <command>svnserve</command> should
      write its log output.</para>

    <informalexample>
      <screen>
$ svnserve -d -r /path/to/repositories --log-file /var/log/svn.log
</screen>
    </informalexample>

    <para>Enabling the same in Apache is a bit more involved, but is
      essentially an extension of Apache's stock log output
      configuration mechanisms see
      <xref linkend="svn.serverconfig.httpd.extra.logging"/> for
      details.</para>

    <para>The following is a list of Subversion action log messages
      produced by its high-level logging mechanism, followed by one or
      more examples of the log message as it appears in the log
      output.</para>

    <variablelist>
      <varlistentry>
        <term>Checkout or export</term>
        <listitem>
          <programlisting>
checkout-or-export /path r62 depth=infinity
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Commit</term>
        <listitem>
          <programlisting>
commit harry r100
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Diffs</term>
        <listitem>
          <programlisting>
diff /path r15:20 depth=infinity ignore-ancestry
diff /path1@15 /path2@20 depth=infinity ignore-ancestry
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Fetch a directory</term>
        <listitem>
          <programlisting>
get-dir /trunk r17 text
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Fetch a file</term>
        <listitem>
          <programlisting>
get-file /path r20 props
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Fetch a file revision</term>
        <listitem>
          <programlisting>
get-file-revs /path r12:15 include-merged-revisions
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Fetch merge information</term>
        <listitem>
          <programlisting>
get-mergeinfo (/path1 /path2)
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Lock</term>
        <listitem>
          <programlisting>
lock /path steal
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Log</term>
        <listitem>
          <programlisting>
log (/path1,/path2,/path3) r20:90 discover-changed-paths revprops=()
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Replay revisions (svnsync)</term>
        <listitem>
          <programlisting>
replay /path r19
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Revision property change</term>
        <listitem>
          <programlisting>
change-rev-prop r50 propertyname
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Revision property list</term>
        <listitem>
          <programlisting>
rev-proplist r34
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Status</term>
        <listitem>
          <programlisting>
status /path r62 depth=infinity
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Switch</term>
        <listitem>
          <programlisting>
switch /pathA /pathB@50 depth=infinity
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Unlock</term>
        <listitem>
          <programlisting>
unlock /path break
</programlisting>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Update</term>
        <listitem>
          <programlisting>
update /path r17 send-copyfrom-args
</programlisting>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>As a convenience to administrators who wish to post-process
      their Subversion high-level logging output (perhaps for
      reporting or analysis purposes), Subversion source code
      distributions provide a Python module (located at
      <filename>tools/server-side/svn_server_log_parse.py</filename>)
      which can be used to parse Subversion's log output.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.optimization">
    <title>Server Optimization</title>

    <para>Part of the due diligence when offering a service such as a
      Subversion server involves capacity planning and performance
      tuning.  Subversion doesn't tend to be particularly greedy in
      terms of server resources such as CPU cycles and memory, but any
      service can benefit from optimizations, especially when usage of
      the service skyrockets<footnote><para>In Subversion's case, the
      skyrocketing affect is, of course, due to its cool name.  Well,
      that and its popularity, reliability, ease of
      use .</para></footnote>.  In this section, we'll discuss
      some ways you can tweak your Subversion server configuration
      to offer even better performance and scalability.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.optimization.caching">
      <title>Data Caching</title>

      <para>Generally speaking, the most expensive part of a
        Subversion server's job is fetching data from the repository.
        Subversion 1.6 attempted to offset this cost by introducing
        some in-memory caching of certain classes of data read from
        the repository.  But Subversion 1.7 takes this a step further,
        not only caching the results of some of the more costly
        operations, but also by providing in each of the available
        servers the means by which fine-tune the size and some
        behaviors of the cache.</para>

      <para>For <command>svnserve</command>, you can specify the size
        of the cache using the <option>--memory-cache-size</option>
        (<option>-M</option>) command-line option.  You can also
        dictate whether <command>svnserve</command> should attempt to
        cache content fulltexts and deltas via the
        boolean <option>--cache-fulltexts</option>
        and <option>--cache-txdeltas</option> options,
        respectively.</para>

      <informalexample>
        <screen>
$ svnserve -d -r /path/to/repositories \
           --memory-cache-size 1024 \
           --cache-txdeltas yes \
           --cache-fulltexts yes
 
$
</screen>
      </informalexample>

      <para><command>mod_dav_svn</command> provides the same degree of
        cache configurability via <filename>httpd.conf</filename>
        directives.
        The <literal>SVNInMemoryCacheSize</literal>,
        <literal>SVNCacheFullTexts</literal>,
        and <literal>SVNCacheTextDeltas</literal> directives may be
        used at the server configuration level to control Subversion's
        data cache characteristics:</para>

      <informalexample>
        <programlisting>
&lt;IfModule dav_svn_module&gt;
  # Enable a 1 Gb Subversion data cache for both fulltext and deltas.
  SVNInMemoryCacheSize 1048576
  SVNCacheTextDeltas On
  SVNCacheFullTexts On
&lt;/IfModule&gt;
</programlisting>
      </informalexample>

      <para>So what settings should you use?  Certainly you need to
        consider what resources are available on your server.  To get
        any benefit out of the cache at all, you'll probably want to
        let the cache be at least large enough to hold all the files
        which are most commonly accessed in your repository (for
        example, your project's <filename>trunk</filename> directory
        tree).</para>

      <tip>
        <para>Setting the memory cache size to <literal>0</literal>
          will disable this enhanced caching mechanism and cause
          Subversion to fall back to using the older cache mechanisms
          introduced in Subversion 1.6.</para>
      </tip>

      <note>
        <para>Currently, only repositories which make use of the FSFS
          backend data store make use of this data caching
          functionality.</para>
      </note>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.serverconfig.optimization.compression">
      <title>Network Compression of Data</title>

      <para>Compressing the data transmitted across the wire can
        greatly reduce the size of those network transmissions, but
        comes at the cost of server (and client) CPU cycles.
        Depending on your server's CPU capacity, the typical access
        patterns of the clients who use your servers, and the
        bandwidth of the networks between them, you might wish to fine
        tune just how hard your server will work to compress the data
        it sends across the wire.  To assist with this fine tuning
        process, Subversion 1.7 offers
        the <option>--compression</option> (<option>-c</option>)
        option to <command>svnserve</command> and
        the <literal>SVNCompressionLevel</literal> directive
        for <command>mod_dav_svn</command>.  Both accept a value which
        is an integer between 0 and 9 (inclusive), where 9 offers the
        best compression of wire data, and 0 disables compression
        altogether.</para>

      <para>For example, on a local area network (LAN) with 1-Gigabit
        connections, it might not make sense to have the server
        compress its network transmissions (which also forces the
        clients to decompress them), as the network itself is so fast
        that users won't really benefit from the smaller overall
        network payload.  On the other hand, servers which are
        accessed primarily by clients with low-bandwidth connections
        would be doing those clients a favor by minimizing the overall
        size of its network communications.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.serverconfig.multimethod">

    <title>Supporting Multiple Repository Access Methods</title>

    <para>You've seen how a repository can be accessed in many
      different ways.  But is it possible or safe for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</para>

    <para>At any given time, these processes may require read and
      write access to your repository:</para>

    <itemizedlist>
      <listitem>
        <para>Regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <literal>file://</literal> URLs</para>
      </listitem>
      <listitem>
        <para>Regular system users connecting to SSH-spawned private
          <command>svnserve</command> processes (running as
          themselves), which access the repository</para>
      </listitem>
      <listitem>
        <para>An <command>svnserve</command> process either a
          daemon or one launched by
          <command>inetd</command> running as a particular fixed
          user</para>
      </listitem>
      <listitem>
        <para>An Apache <command>httpd</command> process, running as a
          particular fixed user</para>
      </listitem>
    </itemizedlist>

    <para>The most common problem administrators run into is
      repository ownership and permissions.  Does every process (or
      user) in the preceding list have the rights to read and write the
      repository's underlying data files?  Assuming you have a
      Unix-like operating system, a straightforward approach might be
      to place every potential repository user into a
      new <literal>svn</literal> group, and make the repository wholly
      owned by that group.  But even that's not enough, because a
      process may write to the database files using an unfriendly
      umask one that prevents access by other users.</para>

    <para>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <command>svn</command> program into a
      wrapper script that first runs <userinput>umask 002</userinput> and
      then runs the real <command>svn</command> client program.  You
      can write a similar wrapper script for the
      <command>svnserve</command> program, and add a <userinput>umask
      002</userinput> command to Apache's own startup script,
      <filename>apachectl</filename>.  For example:</para>

    <informalexample>
      <screen>
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"
</screen>
    </informalexample>

    <para>Another common problem is often encountered on Unix-like
      systems.  If your repository is backed by Berkeley DB, for
      example, it occasionally creates new log files to journal its
      actions.  Even if the Berkeley DB repository is wholly owned by
      the <command>svn</command> group, these newly created log files
      won't necessarily be owned by that same group, which then
      creates more permissions problems for your users.  A good
      workaround is to set the group SUID bit on the
      repository's <filename>db</filename> directory.  This causes all
      newly created log files to have the same group owner as the
      parent directory.</para>

    <para>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write access to common files are classic
      ones that are not often elegantly solved.</para>

    <para>Fortunately, most repository administrators will never
      <emphasis>need</emphasis> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <literal>file://</literal>
      access URLs they can typically contact the Apache HTTP
      server or <command>svnserve</command> using
      <literal>localhost</literal> for the server name in their
      <literal>http://</literal> or <literal>svn://</literal> URL.
      And maintaining multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend that you choose a single server that best meets your
      needs and stick with it!</para>

    <sidebar>
      <title>The svn+ssh:// Server Checklist</title>

      <para>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of the
        topics discussed in this section:</para>

      <itemizedlist>
        <listitem>
          <para>All of your SSH users need to be able to read and
            write to the repository, so put all the SSH users into a
            single group.</para>
        </listitem>
        <listitem>
          <para>Make the repository wholly owned by that group.</para>
        </listitem>
        <listitem>
          <para>Set the group permissions to read/write.</para>
        </listitem>
        <listitem>
          <para>Your users need to use a sane umask when accessing the
            repository, so make sure <command>svnserve</command>
            (<filename>/usr/bin/svnserve</filename>, or wherever it
            lives in <literal>$PATH</literal>) is actually a wrapper
            script that runs <userinput>umask 002</userinput> and
            executes the real <command>svnserve</command>
            binary.</para>
        </listitem>
        <listitem>
          <para>Take similar measures when using
            <command>svnlook</command> and
            <command>svnadmin</command>.  Either run them with a sane
            umask or wrap them as just described.</para>
        </listitem>
      </itemizedlist>

    </sidebar>

  </sect1>
</chapter>

<!--
local variables:
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.customization">
  <title>Customizing Your Subversion Experience</title>

  <para>Version control can be a complex subject, as much art as
    science, that offers myriad ways of getting stuff done.
    Throughout this book, you've read of the various Subversion
    command-line client subcommands and the options that modify their
    behavior.  In this chapter, we'll look into still more ways to
    customize the way Subversion works for you setting up the
    Subversion runtime configuration, using external helper
    applications, Subversion's interaction with the operating system's
    configured locale, and so on.</para>

  <!-- TODO(cmpilato): Gut the runtime config stuff like I did the
       property stuff, making larger topical sections to which the
       runtime config stuff generally refers.  Like already exists for
       external diff/diff3, add, for example, a section on external
       editors. -->

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.confarea">
    <title>Runtime Configuration Area</title>
    
    <para>Subversion provides many optional behaviors that the user can
      control.  Many of these options are of the kind
      that a user would wish to apply to all Subversion operations.
      So, rather than forcing users to remember command-line arguments
      for specifying these options and to use them for every
      operation they perform, Subversion uses configuration files,
      segregated into a Subversion configuration area.</para>

    <para>
      <indexterm>
        <primary>runtime configuration</primary>
      </indexterm>The Subversion <firstterm>runtime configuration
      area</firstterm> is a two-tiered hierarchy of option names and
      their values.  Usually, this boils down to a special directory
      that contains configuration files (the first tier), which are
      just text files in standard INI format
      where <quote>sections</quote> provide the second tier.  You can
      easily edit these files using your favorite text editor (such as
      Emacs or vi), and they contain directives read by the client to
      determine which of several optional behaviors the user
      prefers.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.confarea.layout">
      <title>Configuration Area Layout</title>

      <para>
        <indexterm>
          <primary>runtime configuration</primary>
          <secondary>per-user</secondary>
        </indexterm>The first time the <command>svn</command> command-line
        client is executed, it creates a per-user configuration area.
        On Unix-like systems, this area appears as a directory
        named <filename>.subversion</filename> in the user's home
        directory.  On Win32 systems, Subversion creates a folder
        named <filename>Subversion</filename>, typically inside
        the <filename>Application Data</filename> area of the user's
        profile directory (which, by the way, is usually a hidden
        directory).  However, on this platform, the exact location
        differs from system to system and is dictated by the Windows
        Registry.<footnote><para>The <literal>APPDATA</literal>
        environment variable points to the <filename>Application
        Data</filename> area, so you can always refer to this folder
        as <filename>%APPDATA%\Subversion</filename>.</para></footnote>
        We will refer to the per-user configuration area using its
        Unix name, <filename>.subversion</filename>.</para>

      <para>
        <indexterm>
          <primary>runtime configuration</primary>
          <secondary>system-wide</secondary>
        </indexterm>In addition to the per-user configuration area, Subversion
        also recognizes the existence of a system-wide configuration
        area.  This gives system administrators the ability to
        establish defaults for all users on a given machine.  Note
        that the system-wide configuration area alone does not dictate
        mandatory policy the settings in the per-user
        configuration area override those in the system-wide one, and
        command-line arguments supplied to the <command>svn</command>
        program have the final word on behavior.  On Unix-like
        platforms, the system-wide configuration area is
        expected to be the <filename>/etc/subversion</filename>
        directory; on Windows machines, it looks for a
        <filename>Subversion</filename> directory inside the common
        <filename>Application Data</filename> location (again, as
        specified by the Windows Registry).  Unlike the per-user
        case, the <command>svn</command> program does not attempt
        to create the system-wide configuration area.</para>

      <para>The per-user configuration area currently contains three
        files two configuration files (<filename>config</filename> and
        <filename>servers</filename>), and a <filename>README.txt</filename> 
        file, which describes the INI format.  At the time of their
        creation, the files contain default values for each of the
        supported Subversion options, mostly commented out and grouped
        with textual descriptions about how the values for the key
        affect Subversion's behavior.  To change a certain behavior,
        you need only to load the appropriate configuration file into
        a text editor, and to modify the desired option's value.  If at
        any time you wish to have the default configuration settings
        restored, you can simply remove (or rename) your configuration
        directory and then run some innocuous <command>svn</command>
        command, such as <userinput>svn --version</userinput>.  A new
        configuration directory with the default contents will be
        created.</para>

      <para>
        <indexterm>
          <primary>runtime configuration</primary>
          <secondary>command-line override</secondary>
        </indexterm>Subversion also allows you to override individual
        configuration option values at the command line via
        the <option>--config-option</option> option, which is
        especially useful if you need to make a (very) temporary
        change in behavior.  For more about this option's proper
        usage, see <xref linkend="svn.ref.svn.sw"/>.</para>

      <para>The per-user configuration area also contains a cache of
        authentication data.  The <filename>auth</filename> directory
        holds a set of subdirectories that contain pieces of cached
        information used by Subversion's various supported
        authentication methods.  This directory is created in such a
        way that only the user herself has permission to read its
        contents.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.confarea.windows-registry">
      <title>Configuration and the Windows Registry</title>

      <para>
        <indexterm>
          <primary>runtime configuration</primary>
          <secondary>Windows Registry</secondary>
        </indexterm>In addition to the usual INI-based configuration
        area, Subversion clients running on Windows platforms may also
        use the Windows Registry to hold the configuration data.  The
        option names and their values are the same as in the INI
        files.  The <quote>file/section</quote> hierarchy is preserved
        as well, though addressed in a slightly different
        fashion in this schema, files and sections are just
        levels in the Registry key tree.</para>

      <para>Subversion looks for system-wide configuration values
        under the
        <literal>HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion</literal>
        key.  For example, the <literal>global-ignores</literal> option,
        which is in the <literal>miscellany</literal> section of the
        <filename>config</filename> file, would be found at
        <literal>HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Config\Miscellany\global-ignores</literal>.
        Per-user configuration values should be stored under
        <literal>HKEY_CURRENT_USER\Software\Tigris.org\Subversion</literal>.</para>

      <para>Registry-based configuration options are parsed
        <emphasis>before</emphasis> their file-based counterparts, so
        they are overridden by values found in the configuration files.  In
        other words, Subversion looks for configuration information in
        the following locations on a Windows system; lower-numbered
        locations take precedence over higher-numbered locations:</para>
      
      <orderedlist>
        <listitem>
          <para>Command-line options</para>
        </listitem>
        <listitem>
          <para>The per-user INI files</para>
        </listitem>
        <listitem>
          <para>The per-user Registry values</para>
        </listitem>
        <listitem>
          <para>The system-wide INI files</para>
        </listitem>
        <listitem>
          <para>The system-wide Registry values</para>
        </listitem>
      </orderedlist>

      <para>Also, the Windows Registry doesn't really support the
        notion of something being <quote>commented out.</quote>
        However, Subversion will ignore any option key whose name
        begins with a hash (<literal>#</literal>) character.  This
        allows you to effectively comment out a Subversion option
        without deleting the entire key from the Registry, obviously
        simplifying the process of restoring that option.</para>

      <para>The <command>svn</command> command-line client never
        attempts to write to the Windows Registry and will not attempt
        to create a default configuration area there.  You can create
        the keys you need using the <command>REGEDIT</command>
        program.  Alternatively, you can create a
        <filename>.reg</filename> file (such as the one in <xref
        linkend="svn.advanced.confarea.windows-registry.ex-1" />), and
        then double-click on that file's icon in the Explorer shell,
        which will cause the data to be merged into your
        Registry.</para>

      <example id="svn.advanced.confarea.windows-registry.ex-1">
        <title>Sample registration entries (.reg) file</title>

        <programlisting>
REGEDIT4

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\groups]

[HKEY_LOCAL_MACHINE\Software\Tigris.org\Subversion\Servers\global]
"#http-auth-types"="basic;digest;negotiate"
"#http-compression"="yes"
"#http-library"=""
"#http-proxy-exceptions"=""
"#http-proxy-host"=""
"#http-proxy-password"=""
"#http-proxy-port"=""
"#http-proxy-username"=""
"#http-timeout"="0"
"#neon-debug-mask"=""
"#ssl-authority-files"=""
"#ssl-client-cert-file"=""
"#ssl-client-cert-password"=""
"#ssl-pkcs11-provider"=""
"#ssl-trust-default-ca"=""
"#store-auth-creds"="yes"
"#store-passwords"="yes"
"#store-plaintext-passwords"="ask"
"#store-ssl-client-cert-pp"="yes"
"#store-ssl-client-cert-pp-plaintext"="ask"
"#username"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auth]
"#password-stores"="windows-cryptoapi"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\helpers]
"#diff-cmd"=""
"#diff-extensions"="-u"
"#diff3-cmd"=""
"#diff3-has-program-arg"=""
"#editor-cmd"="notepad"
"#merge-tool-cmd"=""

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\tunnels]

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\miscellany]
"#enable-auto-props"="no"
"#global-ignores"="*.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo *.rej *~ #*# .#* .*.swp .DS_Store"
"#interactive-conflicts"="yes"
"#log-encoding"=""
"#mime-types-file"=""
"#no-unlock"="no"
"#preserved-conflict-file-exts"="doc ppt xls od?"
"#use-commit-times"="no"

[HKEY_CURRENT_USER\Software\Tigris.org\Subversion\Config\auto-props]
</programlisting>
      </example>

      <para><xref linkend="svn.advanced.confarea.windows-registry.ex-1"/>
        shows the contents of a <filename>.reg</filename> file, which
        contains some of the most commonly used configuration options
        and their default values.  Note the presence of both
        system-wide (for network proxy-related options) and per-user
        settings (editor programs and password storage, among others).
        Also note that all the options are effectively commented out.
        You need only to remove the hash (<literal>#</literal>)
        character from the beginning of the option names and set the
        values as you desire.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.confarea.opts">
      <title>Runtime Configuration Options</title>

      <para>
        <indexterm>
          <primary>runtime configuration</primary>
          <secondary>options</secondary>
        </indexterm>In this section, we will discuss the specific
        runtime configuration options that Subversion currently 
        supports.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.confarea.opts.config">
        <title>General configuration</title>

        <para>The <filename>config</filename> file contains the rest
          of the currently available Subversion runtime
          options those not related to networking.  There are
          only a few options in use as of this writing, but they are
          again grouped into sections in expectation of future
          additions.</para>

        <para>The <literal>[auth]</literal> section contains settings
          related to Subversion's authentication and authorization
          against the repository.  It contains the following:</para>

        <variablelist>
          <varlistentry>
	    <term><literal>password-stores</literal></term>
            <listitem>
              <para>This comma-delimited list specifies which (if any)
                system-provided password stores Subversion should
                attempt to use when saving and retrieving cached
                authentication credentials, and in what order
                Subversion should prefer them.  The default value is
                <literal>gnome-keyring, kwallet, keychain,
                windows-crypto-api</literal>, representing the GNOME
                Keyring, KDE Wallet, Mac OS X Keychain, and Microsoft
                Windows cryptography API, respectively.  Listed stores
                which are not available on the system are
                ignored.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-passwords</literal></term>
            <listitem>
              <para>This option has been deprecated from
                the <filename>config</filename> file.  It now lives as
                a per-server configuration item in
                the <filename>servers</filename> configuration area.
                See <xref linkend="svn.advanced.confarea.opts.servers"/>
                for details.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-auth-creds</literal></term>
            <listitem>
              <para>This option has been deprecated from
                the <filename>config</filename> file.  It now lives as
                a per-server configuration item in
                the <filename>servers</filename> configuration area.
                See <xref linkend="svn.advanced.confarea.opts.servers"/>
                for details.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The <literal>[helpers]</literal> section controls which
          external applications Subversion uses to accomplish its
          tasks.  Valid options in this section are:</para>

        <variablelist>
          <varlistentry>
            <term><literal>diff-cmd</literal></term>
            <listitem>
              <para>This specifies the absolute path of a differencing
                program, used when Subversion generates
                <quote>diff</quote> output (such as when using the
                <command>svn diff</command> command).  By default,
                Subversion uses an internal differencing
                library setting this option will cause it to
                perform this task using an external program.  See
                <xref linkend="svn.advanced.externaldifftools"/> for
                more details on using such programs.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>diff-extensions</literal></term>
            <listitem>
              <para>Like the <option>--extensions</option>
                (<option>-x</option>) command-line option, this
                specifies additional options passed to the file
                content differencing engine.  The set of meaningful
                extension options differs depending on whether the
                client is using Subversion's internal differencing
                engine or an external mechanism.  See the output
                of <userinput>svn help diff</userinput> for details.
                The default value for this option
                is <literal>-u</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>diff3-cmd</literal></term>
            <listitem>
              <para>This specifies the absolute path of a three-way
                differencing program.  Subversion uses this program to
                merge changes made by the user with those received
                from the repository.  By default, Subversion uses an
                internal differencing library setting this
                option will cause it to perform this task using an
                external program.  See <xref
                linkend="svn.advanced.externaldifftools"/> for more
                details on using such programs.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>diff3-has-program-arg</literal></term>
            <listitem>
              <para>This flag should be set to <literal>true</literal>
                if the program specified by the
                <literal>diff3-cmd</literal> option accepts a
                <option>--diff-program</option> command-line
                parameter.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>editor-cmd</literal></term>
            <listitem>
              <para>This specifies the program Subversion will use to
                query the user for certain types of textual metadata
                or when interactively resolving conflicts.  See
                <xref linkend="svn.advanced.externaleditors"/> for
                more details on using external text editors with
                Subversion.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>merge-tool-cmd</literal></term>
            <listitem>
              <para>This specifies the program that Subversion will
                use to perform three-way merge operations on your
                versioned files.  See <xref
                linkend="svn.advanced.externaldifftools"/> for more
                details on using such programs.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The <literal>[tunnels]</literal> section allows you to
          define new tunnel schemes for use with
          <command>svnserve</command> and <literal>svn://</literal>
          client connections.  For more details, see <xref
          linkend="svn.serverconfig.svnserve.sshauth"/>.</para>

        <para>The <literal>miscellany</literal> section is where
          everything that doesn't belong elsewhere winds
          up.<footnote><para>Anyone for potluck
          dinner?</para></footnote>  In this section, you can
          find:</para>

        <variablelist>
          <varlistentry>
            <term><literal>enable-auto-props</literal></term>
            <listitem>
              <para>This instructs Subversion to automatically set
                properties on newly added or imported files.  The
                default value is <literal>no</literal>, so set this to
                <literal>yes</literal> to enable this feature.
                The <literal>[auto-props]</literal> section of this file
                specifies which properties are to be set on which files.</para>
            </listitem>            
          </varlistentry>
          <varlistentry>
            <term><literal>global-ignores</literal></term>
            <listitem>
              <para>When running the <command>svn status</command>
                command, Subversion lists unversioned files and
                directories along with the versioned ones, annotating
                them with a <literal>?</literal> character (see <xref
                linkend="svn.tour.cycle.examine.status" />).  Sometimes it can
                be annoying to see uninteresting, unversioned
                items for example, object files that result from
                a program's compilation in this display.  The
                <literal>global-ignores</literal> option is a list of
                whitespace-delimited globs that describe the names of
                files and directories that Subversion should not
                display unless they are versioned.  The default value
                is <literal>*.o *.lo *.la *.al .libs *.so *.so.[0-9]*
                *.a *.pyc *.pyo *.rej *~ #*# .#* .*.swp
                .DS_Store</literal>.</para>

              <para>As well as <command>svn status</command>, the
                <command>svn add</command> and <command>svn import</command>
                commands also ignore files that match the list
                when they are scanning a directory.  You can override this
                behavior for a single instance of any of these commands
                by explicitly specifying the filename, or by using
                the <option>--no-ignore</option> command-line flag.</para>

              <para>For information on finer-grained control of
                ignored items, see 
                <xref linkend="svn.advanced.props.special.ignore" />.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>interactive-conflicts</literal></term>
            <listitem>
              <para>This is a Boolean option that specifies whether
                Subversion should try to resolve conflicts
                interactively.  If its value is <literal>yes</literal>
                (which is the default value), Subversion will prompt
                the user for how to handle conflicts in the manner
                demonstrated in <xref linkend="svn.tour.cycle.resolve"
                />.  Otherwise, it will simply flag the conflict and
                continue its operation, postponing resolution to a later
                time.</para>
            </listitem>         
          </varlistentry>
          <varlistentry>
            <term><literal>log-encoding</literal></term>
            <listitem>         
              <para>This variable sets the default character set
                encoding for commit log messages.  It's a permanent
                form of the <option>--encoding</option> option (see
                <xref linkend="svn.ref.svn.sw"/>).  The Subversion
                repository stores log messages in UTF-8 and assumes
                that your log message is written using your operating
                system's native locale.  You should specify a
                different encoding if your commit messages are written
                in any other encoding.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>mime-types-file</literal></term>
            <listitem>
              <para>This option, new to Subversion 1.5, specifies the
                path of a MIME types mapping file, such as the
                <filename>mime.types</filename> file provided by the
                Apache HTTP Server.  Subversion uses this file to
                assign MIME types to newly added or imported files.
                See <xref linkend="svn.advanced.props.auto" /> and
                <xref linkend="svn.advanced.props.special.mime-type"
                /> for more about Subversion's detection and use of
                file content types.</para>
            </listitem>         
          </varlistentry>
          <varlistentry>
            <term><literal>no-unlock</literal></term>
            <listitem>
              <para>This Boolean option corresponds to <command>svn
                commit</command>'s <option>--no-unlock</option>
                option, which tells Subversion not to release locks on
                files you've just committed.  If this runtime option
                is set to <literal>yes</literal>, Subversion will
                never release locks automatically, leaving you to run
                <command>svn unlock</command> explicitly.  It defaults
                to <literal>no</literal>.</para>
            </listitem>         
          </varlistentry>
          <varlistentry>
            <term><literal>preserved-conflict-file-exts</literal></term>
            <listitem>
              <para>The value of this option is a space-delimited list
                of file extensions that Subversion should preserve
                when generating conflict filenames.  By default, the
                list is empty.  This option is new to Subversion
                1.5.</para>

              <para>When Subversion detects conflicting file content
                changes, it defers resolution of those conflicts to the
                user.  To assist in the resolution, Subversion keeps
                pristine copies of the various competing versions of
                the file in the working copy.  By default, those
                conflict files have names constructed by appending to
                the original filename a custom extension such as
                <filename>.mine</filename> or
                <filename>.<replaceable>REV</replaceable></filename>
                (where <replaceable>REV</replaceable> is a revision
                number).  A mild annoyance with this naming scheme is
                that on operating systems where a file's extension
                determines the default application used to open and
                edit that file, appending a custom extension prevents
                the file from being easily opened by its native
                application.  For example, if the file
                <filename>ReleaseNotes.pdf</filename> was conflicted,
                the conflict files might be named
                <filename>ReleaseNotes.pdf.mine</filename> or
                <filename>ReleaseNotes.pdf.r4231</filename>.  While
                your system might be configured to use Adobe's Acrobat
                Reader to open files whose extensions are
                <filename>.pdf</filename>, there probably isn't an
                application configured on your system to open all
                files whose extensions are
                <filename>.r4231</filename>.</para>

              <para>You can fix this annoyance by using this
                configuration option, though.  For files with one of
                the specified extensions, Subversion will append to
                the conflict file names the custom extension just as
                before, but then also reappend the file's original
                extension.  Using the previous example, and assuming
                that <literal>pdf</literal> is one of the extensions
                configured in this list thereof, the conflict files
                generated for <filename>ReleaseNotes.pdf</filename>
                would instead be named
                <filename>ReleaseNotes.pdf.mine.pdf</filename> and
                <filename>ReleaseNotes.pdf.r4231.pdf</filename>.
                Because each file ends in
                <filename>.pdf</filename>, the correct default
                application will be used to view them.</para>
            </listitem>         
          </varlistentry>
          <varlistentry>
            <term><literal>use-commit-times</literal></term>
            <listitem>         
              <para>Normally your working copy files have timestamps
                that reflect the last time they were touched by any
                process, whether your own editor or some
                <command>svn</command> subcommand.  This is generally
                convenient for people developing software, because
                build systems often look at timestamps as a way of
                deciding which files need to be recompiled.</para>

              <para>In other situations, however, it's sometimes nice
                for the working copy files to have timestamps that
                reflect the last time they were changed in the
                repository.  The <command>svn export</command> command
                always places these <quote>last-commit
                timestamps</quote> on trees that it produces.  By
                setting this config variable to
                <literal>yes</literal>, the <command>svn
                checkout</command>, <command>svn update</command>,
                <command>svn switch</command>, and <command>svn
                revert</command> commands will also set last-commit
                timestamps on files that they touch.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>The <literal>[auto-props]</literal> section controls the
          Subversion client's ability to automatically set properties
          on files when they are added or imported.  It contains any
          number of key-value pairs in the
          format <literal><replaceable>PATTERN</replaceable>
          = <replaceable>PROPNAME</replaceable>=<replaceable>VALUE</replaceable>[;<replaceable>PROPNAME</replaceable>=<replaceable>VALUE</replaceable>
          ...]</literal>, where <replaceable>PATTERN</replaceable> is
          a file pattern that matches one or more filenames and the
          rest of the line is a semicolon-delimited set of property
          assignments.  (If you need to use a semicolon in your
          property's name or value, you can escape it by doubling
          it.)</para>

        <informalexample>
          <screen>
$ cat ~/.subversion/config
 
[auto-props]
*.c = svn:eol-style=native
*.html = svn:eol-style=native;svn:mime-type=text/html;; charset=UTF8
*.sh = svn:eol-style=native;svn:executable
 
$ cd projects/myproject
$ svn status
?       www/index.html
$ svn add www/index.html
A         www/index.html
$ svn diff www/index.html
 

Property changes on: www/index.html
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+text/html; charset=UTF8
Added: svn:eol-style
## -0,0 +1 ##
+native
$
</screen>

        </informalexample>

        <para>Multiple matches on a file will result in
          multiple propsets for that file; however, there is no
          guarantee that auto-props will be applied in the order in
          which they are listed in the config file, so you can't have
          one rule <quote>override</quote> another.  You can find
          several examples of auto-props usage in the
          <filename>config</filename> file.  Lastly, don't
          forget to set <literal>enable-auto-props</literal> to
          <literal>yes</literal> in the <literal>miscellany</literal>
          section if you want to enable auto-props.</para>

      </sect3>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->
      <sect3 id="svn.advanced.confarea.opts.servers">
        <title>Per-server configuration</title>

        <para>The <filename>servers</filename> file contains
          Subversion configuration options related to the network
          layers.  There are two special sections in this
          file <literal>[groups]</literal> and
          <literal>[global]</literal>.  The <literal>[groups]</literal>
          section is essentially a cross-reference table.  The keys in
          this section are the names of other sections in the file;
          their values are <firstterm>globs</firstterm> textual
          tokens that possibly contain wildcard
          characters that are compared against the hostnames of
          the machine to which Subversion requests are sent.</para>

        <informalexample>
          <programlisting>
[groups]
beanie-babies = *.red-bean.com
collabnet = svn.collab.net

[beanie-babies]
 

[collabnet]
 
</programlisting>
        </informalexample>

        <para>When Subversion is used over a network, it attempts to
          match the name of the server it is trying to reach with a
          group name under the <literal>[groups]</literal> section.  If
          a match is made, Subversion then looks for a section in the
          <filename>servers</filename> file whose name is the matched
          group's name.  From that section, it reads the actual network
          configuration settings.</para>

        <para>The <literal>[global]</literal> section contains the
          settings that are meant for all of the servers not matched
          by one of the globs under the <literal>[groups]</literal>
          section.  The options available in this section are
          exactly the same as those that are valid for the other server
          sections in the file (except, of course, the special
          <literal>[groups]</literal> section), and are as
          follows:</para>

        <variablelist>
          <varlistentry>
            <term><literal>http-auth-types</literal></term>
            <listitem>
              <para>This is a semicolon-delimited list of HTTP
                authentication types which the client will deem
                acceptable.  Valid types
                are <literal>basic</literal>, <literal>digest</literal>,
                and <literal>negotiate</literal>, with the default
                behavior being acceptance of any these authentication
                types.  A client which insists on not transmitting
                authentication credentials in cleartext might, for
                example, be configured such that the value of this
                option is
                <literal>digest;negotiate</literal> omitting
                <literal>basic</literal> from the list.  (Note that
                this setting is only honored by Subversion's
                Neon-based HTTP provider module.)</para>
              <!-- ### TODO: Subversion 1.7 exposed this to Serf, too,
                   and with an additional 'ntlm' auth type. -->
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-compression</literal></term>
            <listitem>
              <para>This specifies whether Subversion should
                attempt to compress network requests made to DAV-ready
                servers.  The default value is <literal>yes</literal>
                (though compression will occur only if that capability
                is compiled into the network layer).  Set this to
                <literal>no</literal> to disable compression, such as
                when debugging network transmissions.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-library</literal></term>
            <listitem>
              <para>The <literal>http-library</literal> runtime
                configuration option allows users to specify
                (generally, or in a per-server-group fashion) which of
                the available WebDAV access modules they'd prefer to
                use.  Prior to version 1.8, Subversion offered a pair
                of such modules: its original implementiation
                <literal>libsvn_ra_neon</literal> (selected by
                using the value <literal>neon</literal> for this
                option) and the newer <literal>libsvn_ra_serf</literal>
                (selected using the value <literal>serf</literal>).
                As of Subversion 1.8, only <literal>libsvn_ra_serf</literal>
                is supported.  This configuration option remains,
                though, because the runtime configuration area is
                version-agnostic.  Users with multiple versions of
                Subversion installed may still wish to enable the use
                of <literal>libsvn_ra_neon</literal> for sites which
                they access with an older version of Subversion.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-exceptions</literal></term>
            <listitem>
              <para>This specifies a comma-separated list of patterns
                for repository hostnames that should be accessed
                directly, without using the proxy machine.  The
                pattern syntax is the same as is used in the Unix
                shell for filenames.  A repository hostname matching
                any of these patterns will not be proxied.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-host</literal></term>
            <listitem>
              <para>This specifies the hostname of the proxy computer
                through which your HTTP-based Subversion requests must
                pass.  It defaults to an empty value, which means that
                Subversion will not attempt to route HTTP requests
                through a proxy computer, and will instead attempt to
                contact the destination machine directly.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-password</literal></term>
            <listitem>
              <para>This specifies the password to supply to the proxy
                machine.  It defaults to an empty value.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-port</literal></term>
            <listitem>
              <para>This specifies the port number on the proxy host
                to use.  It defaults to an empty value.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-proxy-username</literal></term>
            <listitem>
              <para>This specifies the username to supply to the proxy
                machine.  It defaults to an empty value.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>http-timeout</literal></term>
            <listitem>
              <para>This specifies the amount of time, in seconds, to
                wait for a server response.  If you experience
                problems with a slow network connection causing
                Subversion operations to time out, you should increase
                the value of this option.  The default value is
                <literal>0</literal>, which instructs the underlying
                HTTP library, Neon, to use its default timeout
                setting.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>neon-debug-mask</literal></term>
            <listitem>
              <para>This is an integer mask that the Neon HTTP library
                uses for choosing what type of debugging output to
                yield.  The default value is <literal>0</literal>,
                which will silence all debugging output.  Prior to
                version 1.8, most Subversion clients used Neon (via
                the <literal>libsvn_ra_neon</literal> repository
                access module) for WebDAV/HTTP communications between
                the Subversion client and server.  Support
                for <literal>libsvn_ra_neon</literal> was dropped in
                Subversion 1.8, though, making this option obsolete
                for newer Subversion installations.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-authority-files</literal></term>
            <listitem>
              <para>This is a semicolon-delimited list of paths to files
                containing certificates of the certificate authorities
                (or CAs) that
                are accepted by the Subversion client when accessing the
                repository over HTTPS.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-client-cert-file</literal></term>
            <listitem>
              <para>If a host (or set of hosts) requires an SSL client
                certificate, you'll normally be prompted for a path to
                your certificate.  By setting this variable to that
                same path, Subversion will be able to find your client
                certificate automatically without prompting you.
                There's no standard place to store your certificate on
                disk; Subversion will grab it from any path you
                specify.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-client-cert-password</literal></term>
            <listitem>
              <para>If your SSL client certificate file is encrypted
                by a passphrase, Subversion will prompt you for the
                passphrase whenever the certificate is used.  If you
                find this annoying (and don't mind storing the
                password in the <filename>servers</filename> file),
                you can set this variable to the certificate's
                passphrase.  You won't be prompted anymore.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-pkcs11-provider</literal></term>
            <listitem>
              <para>The value of this option is the name of the
                PKCS#11 provider from which an SSL client certificate
                will be drawn (if the server asks for one).  This
                setting is only honored by Subversion's Neon-based
                HTTP provider module.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>ssl-trust-default-ca</literal></term>
            <listitem>
              <para>Set this variable to <literal>yes</literal> if you
                want Subversion to automatically trust the set of
                default CAs that ship with OpenSSL.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-auth-creds</literal></term>
            <listitem>
              <para>This setting is the same as
                <literal>store-passwords</literal>, except that it
                enables or disables on-disk caching of
                <emphasis>all</emphasis> authentication information:
                usernames, passwords, server certificates, and any
                other types of cacheable credentials.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-passwords</literal></term>
            <listitem>
              <para>This instructs Subversion to cache, or not to
                cache, passwords that are supplied by the user in
                response to server authentication challenges.  The
                default value is <literal>yes</literal>.  Set this to
                <literal>no</literal> to disable this on-disk password
                caching.  You can override this option for a single
                instance of the <command>svn</command> command using
                the <option>--no-auth-cache</option> command-line
                parameter (for those subcommands that support it).
                For more information regarding that, see
                <xref linkend="svn.serverconfig.netmodel.credcache"/>.
                Note that regardless of how this option is configured,
                Subversion will not store passwords in plaintext
                unless the <literal>store-plaintext-passwords</literal>
                option is also set to <literal>yes</literal>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-plaintext-passwords</literal></term>
            <listitem>
              <para>This variable is only important on UNIX-like systems.
                It controls what the Subversion client does in case
                the password for the current authentication realm can
                only be cached on disk in unencrypted form, in the
                <filename>~/.subversion/auth/</filename> caching area.
                You can set it to <literal>yes</literal> or
                <literal>no</literal> to enable or disable caching of
                passwords in unencrypted form, respectively.
                The default setting is <literal>ask</literal>, which causes
                the Subversion client to ask you each time a
                <emphasis>new</emphasis> password is about to be added to
                the <filename>~/.subversion/auth/</filename> caching area.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-ssl-client-cert-pp</literal></term>
            <listitem>
              <para>This option controls whether Subversion will cache
                SSL client certificate passphrases provided by the
                user.  Its value defaults to <literal>yes</literal>.
                Set this to <literal>no</literal> to disable this
                passphrase caching.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><literal>store-ssl-client-cert-pp-plaintext</literal></term>
            <listitem>
              <para>This option controls whether Subversion, when
                attempting to cache an SSL client certificate
                passphrase, will be allowed to do so using its on-disk
                plaintext storage mechanism.  The default value of
                this option is <literal>ask</literal>, which causes
                the Subversion client to ask you each time a
                <emphasis>new</emphasis> client certificate passphrase
                is about to be added to
                the <filename>~/.subversion/auth/</filename> caching
                area.  Set this option's value
                to <literal>yes</literal> or <literal>no</literal> to
                indicate your preference and avoid related
                prompts.</para>
            </listitem>
          </varlistentry>
        </variablelist>

      </sect3>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.l10n">
    <title>Localization</title>

    <para>
      <indexterm>
        <primary>localization</primary>
      </indexterm><firstterm>Localization</firstterm> is the act of making
      programs behave in a region-specific way.  When a program
      formats numbers or dates in a way specific to your part of the
      world or prints messages (or accepts input) in your native
      language, the program is said to
      be <firstterm>localized</firstterm>.  This section describes
      steps Subversion has made toward localization.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.l10n.understanding">
      <title>Understanding Locales</title>
      
      <para>Most modern operating systems have a notion of the
        <quote>current locale</quote> that is, the region or
        country whose localization conventions are honored.  These
        conventions typically chosen by some runtime
        configuration mechanism on the computer affect the way
        in which programs present data to the user, as well as the way
        in which they accept user input.</para>

      <para>On most Unix-like systems, you can check the values of the
        locale-related runtime configuration options by running the
        <command>locale</command> command:</para>

      <informalexample>
        <screen>
$ locale
LANG=
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ALL="C"
$
</screen>
      </informalexample>

      <para>The output is a list of locale-related environment
        variables and their current values.  In this example, the
        variables are all set to the default <literal>C</literal>
        locale, but users can set these variables to specific
        country/language code combinations.  For example, if one were
        to set the <literal>LC_TIME</literal> variable to
        <literal>fr_CA</literal>, programs would know to present
        time and date information formatted according to a
        French-speaking Canadian's expectations.  And if one were to
        set the <literal>LC_MESSAGES</literal> variable to
        <literal>zh_TW</literal>, programs would know to present
        human-readable messages in Traditional Chinese.  Setting the
        <literal>LC_ALL</literal> variable has the effect of changing
        every locale variable to the same value.  The value of
        <literal>LANG</literal> is used as a default value for any
        locale variable that is unset.  To see the list of available
        locales on a Unix system, run the command <userinput>locale
        -a</userinput>.</para>

      <para>On Windows, locale configuration is done via the
        <quote>Regional and Language Options</quote> control panel
        item.  There you can view and select the values of individual
        settings from the available locales, and even customize (at a
        sickening level of detail) several of the display formatting
        conventions.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.l10n.svnuse">
      <title>Subversion's Use of Locales</title>

      <para>The Subversion client, <command>svn</command>, honors the
        current locale configuration in two ways.  First, it notices
        the value of the <literal>LC_MESSAGES</literal> variable and
        attempts to print all messages in the specified language.  For
        example:</para>

      <informalexample>
        <screen>
$ export LC_MESSAGES=de_DE
$ svn help cat
cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.
Aufruf: cat ZIEL[@REV]...
 
</screen>
      </informalexample>

      <para>This behavior works identically on both Unix and Windows
        systems.  Note, though, that while your operating system might
        have support for a certain locale, the Subversion client still
        may not be able to speak the particular language.  In order to
        produce localized messages, human volunteers must provide
        translations for each language.  The translations are written
        using the GNU gettext package, which results in translation
        modules that end with the <filename>.mo</filename> filename
        extension.  For example, the German translation file is named
        <filename>de.mo</filename>.  These translation files are
        installed somewhere on your system.  On Unix, they typically
        live in <filename>/usr/share/locale/</filename>, while
        on Windows they're often found in the
        <filename>share\locale\</filename> folder in Subversion's
        installation area.  Once installed, a module is named after
        the program for which it provides translations.  For example, the
        <filename>de.mo</filename> file may ultimately end up
        installed as
        <filename>/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>.
        By browsing the installed <filename>.mo</filename> files, you
        can see which languages the Subversion client is able to
        speak.</para>

      <para>
        <indexterm>
          <primary>internationalization</primary>
        </indexterm>
        <indexterm>
          <primary>UTF-8</primary>
        </indexterm>The second way in which the locale is honored involves how
        <command>svn</command> interprets your input.  The repository
        stores all paths, filenames, and log messages in Unicode,
        encoded as UTF-8.  In that sense, the repository is
        <firstterm>internationalized</firstterm> that is, the
        repository is ready to accept input in any human language.
        This means, however, that the Subversion client is responsible
        for sending only UTF-8 filenames and log messages into the
        repository.  To do this, it must convert the data
        from the native locale into UTF-8.</para>

      <para>For example, suppose you create a file named
        <filename>caffè.txt</filename>, and then when committing the
        file, you write the log message as <quote>Adesso il caffè è
        più forte.</quote>  Both the filename and the log message contain
        non-ASCII characters, but because your locale is set to
        <literal>it_IT</literal>, the Subversion client knows to
        interpret them as Italian.  It uses an Italian character set
        to convert the data to UTF-8 before sending it off to the
        repository.</para>

      <para>Note that while the repository demands UTF-8 filenames and
        log messages, it <emphasis>does not</emphasis> pay attention
        to file contents.  Subversion treats file contents as opaque
        strings of bytes, and neither client nor server makes an
        attempt to understand the character set or encoding of the
        contents.</para>

      <sidebar>
        <title>Character Set Conversion Errors</title>

        <para>While using Subversion, you might get hit with an error
          related to character set conversions:</para>

        <informalexample>
          <screen>
svn: E000022: Can't convert string from native encoding to 'UTF-8':
 
svn: E000022: Can't convert string from 'UTF-8' to native encoding:
 
</screen>
        </informalexample>
    
        <para>Errors such as this typically occur when the Subversion
          client has received a UTF-8 string from the repository, but
          not all of the characters in that string can be represented
          using the encoding of the current locale.  For example, if
          your locale is <literal>en_US</literal> but a collaborator
          has committed a Japanese filename, you're likely to see this
          error when you receive the file during an <command>svn
          update</command>.</para>

        <para>The solution is either to set your locale to something
          that <emphasis>can</emphasis> represent the incoming UTF-8
          data, or to change the filename or log message in the
          repository.  (And don't forget to slap your collaborator's
          hand projects should decide on common languages ahead of
          time so that all participants are using the same
          locale.)</para>
      </sidebar>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externaleditors">
    <title>Using External Editors</title>

    <para>The most obvious way to get data into Subversion is through
      the addition of files to version control, committing changes to
      those files, and so on.  But other pieces of
      information besides merely versioned file data live in your
      Subversion repository.  Some of these bits of
      information commit log messages, lock comments, and some
      property values tend to be textual in nature and are
      provided explicitly by users.  Most of this information can be
      provided to the Subversion command-line client using the
      <option>--message</option> (<option>-m</option>) and
      <option>--file</option> (<option>-F</option>) options with the
      appropriate subcommands.</para>

    <para>Each of these options has its pros and cons.  For example,
      when performing a commit, <option>--file</option>
      (<option>-F</option>) works well if you've already prepared a
      text file that holds your commit log message.  If you didn't,
      though, you can use <option>--message</option>
      (<option>-m</option>) to provide a log message on the command
      line.  Unfortunately, it can be tricky to compose anything more
      than a simple one-line message on the command line.  Users want
      more flexibility multiline, free-form log message editing
      on demand.</para>
      
    <para>Subversion supports this by allowing you to specify an
      external text editor that it will launch as necessary
      to give you a more powerful input mechanism for this textual
      metadata.  There are several ways to tell Subversion which
      editor you'd like use.  Subversion checks the following things,
      in the order specified, when it wants to launch such an
      editor:</para>

    <orderedlist>
      <listitem>
        <para><literal>--editor-cmd</literal> command-line option</para>
      </listitem>
      <listitem>
        <para><literal>SVN_EDITOR</literal> environment variable</para>
      </listitem>
      <listitem>
        <para><literal>editor-cmd</literal> runtime configuration option</para>
      </listitem>
      <listitem>
        <para><literal>VISUAL</literal> environment variable</para>
      </listitem>
      <listitem>
        <para><literal>EDITOR</literal> environment variable</para>
      </listitem>
      <listitem>
        <para>Possibly, a fallback value built into the Subversion
          libraries (not present in the official builds)</para>
      </listitem>
    </orderedlist>

    <para>The value of any of these options or variables is the
      beginning of a command line to be executed by the shell.
      Subversion appends to that command line a space and the pathname
      of a temporary file to be edited.  So, to be used with
      Subversion, the configured or specified editor needs to support
      an invocation in which its last command-line parameter is a file
      to be edited, and it should be able to save the file in place
      and return a zero exit code to indicate success.</para>

    <para>As noted, external editors can be used to provide commit log
      messages to any of the committing subcommands (such as
      <command>svn commit</command> or <command>import</command>,
      <command>svn mkdir</command> or <command>delete</command> when
      provided a URL target, etc.), and Subversion will try to
      launch the editor automatically if you don't specify either of
      the <option>--message</option> (<option>-m</option>) or
      <option>--file</option> (<option>-F</option>) options.  The
      <command>svn propedit</command> command is built almost entirely
      around the use of an external editor.  And beginning in version
      1.5, Subversion will also use the configured external text
      editor when the user asks it to launch an editor during
      interactive conflict resolution.  Oddly, there doesn't appear to
      be a way to use external editors to interactively provide lock
      comments.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.advanced.externaldifftools">
    <title>Using External Differencing and Merge Tools</title>

    <para>The interface between Subversion and external two- and three-way
      differencing tools harkens back to a time when Subversion's only
      contextual differencing capabilities were built around
      invocations of the GNU diffutils toolchain, specifically the
      <command>diff</command> and <command>diff3</command> utilities.
      To get the kind of behavior Subversion needed, it called these
      utilities with more than a handful of options and parameters,
      most of which were quite specific to the utilities.  Some time
      later, Subversion grew its own internal differencing library,
      and as a failover mechanism, the <option>--diff-cmd</option> and
      <option>--diff3-cmd</option> options were added to the
      Subversion command-line client so that users could more easily
      indicate that they preferred to use the GNU diff and diff3
      utilities instead of the newfangled internal diff library.  If
      those options were used, Subversion would simply ignore the
      internal diff library, and fall back to running those external
      programs, lengthy argument lists and all.  And that's where
      things remain today.</para>

    <para>It didn't take long for folks to realize that having such
      easy configuration mechanisms for specifying that Subversion
      should use the external GNU diff and diff3 utilities located at
      a particular place on the system could be applied toward the use
      of other differencing tools, too.  After all, Subversion didn't
      actually verify that the things it was being told to run were
      members of the GNU diffutils toolchain.  But the only
      configurable aspect of using those external tools is their
      location on the system not the option set, parameter
      order, and so on.  Subversion continues to throw all those GNU utility
      options at your external diff tool regardless of whether
      that program can understand those options.  And that's where
      things get unintuitive for most users.</para>

    <note>
      <para>The decision on when to fire off a contextual two- or three-way
        diff as part of a larger Subversion operation is made entirely
        by Subversion and is affected by, among other things, whether
        the files being operated on are human-readable as
        determined by their <literal>svn:mime-type</literal> property.
        This means, for example, that even if you had the niftiest
        Microsoft Word-aware differencing or merging tool in the
        universe, it would never be invoked by Subversion as long as
        your versioned Word documents had a configured MIME type that
        denoted that they were not human-readable (such as
        <literal>application/msword</literal>).  For more about MIME
        type settings, see <xref
        linkend="svn.advanced.props.special.mime-type"/></para>
    </note>

    <para>Much later, Subversion 1.5 introduced interactive resolution
      of conflicts (described in
      <xref linkend="svn.tour.cycle.resolve" />).  One of the options
      that this feature provides to users is the ability to
      interactively launch a third-party merge tool.  If this action
      is taken, Subversion will check to see if the user has specified
      such a tool for use in this way.  Subversion will first check
      the <literal>SVN_MERGE</literal> environment variable for the
      name of an external merge tool.  If that variable is not set, it
      will look for the same information in the value of
      the <literal>merge-tool-cmd</literal> runtime configuration
      option.  Upon finding a configured external merge tool, it will
      invoke that tool.</para>

    <note>
      <para>While the general purposes of the three-way differencing
        and merge tools are roughly the same (finding a way to make
        separate-but-overlapping file changes live in harmony),
        Subversion exercises each of these options at different times
        and for different reasons.  The internal three-way
        differencing engine and its optional external replacement are
        used when interaction with the user
        is <emphasis>not</emphasis> expected.  In fact, significant
        delay introduced by such a tool can actually result in the
        failure of some time-sensitive Subversion operations.  It's
        the external merge tool that is intended to be invoked
        interactively.</para>
    </note>

    <para>Now, while the interface between Subversion and an external
      merge tool is significantly less convoluted than that between
      Subversion and the diff and diff3 tools, the likelihood of
      finding such a tool whose calling conventions exactly match what
      Subversion expects is still quite low.  The key to using
      external differencing and merge tools with Subversion is to use
      wrapper scripts, which convert the input from Subversion into
      something that your specific differencing tool can understand,
      and then convert the output of your tool back into a format that
      Subversion expects.  The following sections cover the specifics
      of those expectations.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.externaldifftools.diff">
      <title>External diff</title>

      <para>Subversion calls external diff programs with parameters
        suitable for the GNU diff utility, and expects only that the
        external program will return with a successful error code per
        the GNU diff definition thereof.  For most alternative diff
        programs, only the sixth and seventh arguments the paths
        of the files that represent the left and right sides of the
        diff, respectively are of interest.  Note that
        Subversion runs the diff program once per modified file
        covered by the Subversion operation, so if your program runs
        in an asynchronous fashion (or is <quote>backgrounded</quote>),
        you might have several instances of it all running
        simultaneously.  Finally, Subversion expects that your program
        return an error code of 1 if your program detected
        differences, or 0 if it did not any other error code is
        considered a fatal error.<footnote><para>The GNU diff manual
        page puts it this way: <quote>An exit status of 0 means no
        differences were found, 1 means some differences were found,
        and 2 means trouble.</quote></para></footnote></para>

      <para><xref linkend="svn.advanced.externaldifftools.diff.ex-1"/>
        and <xref linkend="svn.advanced.externaldifftools.diff.ex-2"/>
        are templates for external diff tool wrappers in the Python
        and Windows batch scripting languages, respectively.</para>

      <example id="svn.advanced.externaldifftools.diff.ex-1">
        <title>diffwrap.py</title>
        <programlisting>
#!/usr/bin/env python
import sys
import os

# Configure your favorite diff program here.
DIFF = "/usr/local/bin/my-diff-tool"

# Subversion provides the paths we need as the last two parameters.
LEFT  = sys.argv[-2]
RIGHT = sys.argv[-1]

# Call the diff command (change the following line to make sense for
# your diff program).
cmd = [DIFF, '--left', LEFT, '--right', RIGHT]
os.execv(cmd[0], cmd)

# Return an errorcode of 0 if no differences were detected, 1 if some were.
# Any other errorcode will be treated as fatal.
</programlisting>
      </example>

      <example id="svn.advanced.externaldifftools.diff.ex-2">
        <title>diffwrap.bat</title>
        <programlisting>
@ECHO OFF

REM Configure your favorite diff program here.
SET DIFF="C:\Program Files\Funky Stuff\My Diff Tool.exe"

REM Subversion provides the paths we need as the last two parameters.
REM These are parameters 6 and 7 (unless you use svn diff -x, in
REM which case, all bets are off).
SET LEFT=%6
SET RIGHT=%7

REM Call the diff command (change the following line to make sense for
REM your diff program).
%DIFF% --left %LEFT% --right %RIGHT%

REM Return an errorcode of 0 if no differences were detected, 1 if some were.
REM Any other errorcode will be treated as fatal.
</programlisting>
      </example>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.externaldifftools.diff3">
      <title>External diff3</title>

      <para>Subversion invokes three-way differencing programs to
        perform non-interactive merges.  When configured to use an
        external three-way differencing program, it executes that
        program with parameters suitable for the GNU diff3 utility,
        expecting that the external program will return with a
        successful error code and that the full file contents that
        result from the completed merge operation are printed on the
        standard output stream (so that Subversion can redirect them
        into the appropriate version-controlled file).  For most
        alternative merge programs, only the ninth, tenth, and
        eleventh arguments, the paths of the files which represent
        the <quote>mine</quote>, <quote>older</quote>,
        and <quote>yours</quote> inputs, respectively, are of
        interest.  Note that because Subversion depends on the output
        of your merge program, your wrapper script must not exit
        before that output has been delivered to Subversion.  When it
        finally does exit, it should return an error code of 0 if the
        merge was successful, or 1 if unresolved conflicts remain in
        the output any other error code is considered a fatal
        error.</para>

      <para><xref linkend="svn.advanced.externaldifftools.diff3.ex-1"/> 
        and <xref linkend="svn.advanced.externaldifftools.diff3.ex-2"/> are
        templates for external three-way differencing tool wrappers in
        the Python and Windows batch scripting languages,
        respectively.</para>

      <example id="svn.advanced.externaldifftools.diff3.ex-1">
        <title>diff3wrap.py</title>
        <programlisting>
#!/usr/bin/env python
import sys
import os

# Configure your favorite three-way diff program here.
DIFF3 = "/usr/local/bin/my-diff3-tool"

# Subversion provides the paths we need as the last three parameters.
MINE  = sys.argv[-3]
OLDER = sys.argv[-2]
YOURS = sys.argv[-1]

# Call the three-way diff command (change the following line to make
# sense for your three-way diff program).
cmd = [DIFF3, '--older', OLDER, '--mine', MINE, '--yours', YOURS]
os.execv(cmd[0], cmd)

# After performing the merge, this script needs to print the contents
# of the merged file to stdout.  Do that in whatever way you see fit.
# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
# remain in the result.  Any other errorcode will be treated as fatal.
</programlisting>
      </example>

      <example id="svn.advanced.externaldifftools.diff3.ex-2">
        <title>diff3wrap.bat</title>
        <programlisting>
@ECHO OFF

REM Configure your favorite three-way diff program here.
SET DIFF3="C:\Program Files\Funky Stuff\My Diff3 Tool.exe"

REM Subversion provides the paths we need as the last three parameters.
REM These are parameters 9, 10, and 11.  But we have access to only
REM nine parameters at a time, so we shift our nine-parameter window
REM twice to let us get to what we need.
SHIFT
SHIFT
SET MINE=%7
SET OLDER=%8
SET YOURS=%9

REM Call the three-way diff command (change the following line to make
REM sense for your three-way diff program).
%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%

REM After performing the merge, this script needs to print the contents
REM of the merged file to stdout.  Do that in whatever way you see fit.
REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
REM remain in the result.  Any other errorcode will be treated as fatal.
</programlisting>
      </example>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.advanced.externaldifftools.merge">
      <title>External merge</title>

      <para>Subversion optionally invokes an external merge tool as
        part of its support for interactive conflict resolution.  It
        provides as arguments to the merge tool the following: the
        path of the unmodified base file, the path of
        the <quote>theirs</quote> file (which contains upstream
        changes), the path of the <quote>mine</quote> file (which
        contains local modifications), the path of the file into which
        the final resolved contents should be stored by the merge
        tool, and the working copy path of the conflicted file
        (relative to the original target of the merge operation).  The
        merge tool is expected to return an error code of 0 to
        indicate success, or 1 to indicate failure.</para>

      <para><xref linkend="svn.advanced.externaldifftools.merge.ex-1"/> 
        and <xref linkend="svn.advanced.externaldifftools.merge.ex-2"/> are
        templates for external merge tool wrappers in the Python
        and Windows batch scripting languages, respectively.</para>

      <example id="svn.advanced.externaldifftools.merge.ex-1">
        <title>mergewrap.py</title>
        <programlisting>
#!/usr/bin/env python
import sys
import os

# Configure your favorite merge program here.
MERGE = "/usr/local/bin/my-merge-tool"

# Get the paths provided by Subversion.
BASE   = sys.argv[1]
THEIRS = sys.argv[2]
MINE   = sys.argv[3]
MERGED = sys.argv[4]
WCPATH = sys.argv[5]

# Call the merge command (change the following line to make sense for
# your merge program).
cmd = [DIFF3, '--base', BASE, '--mine', MINE, '--theirs', THEIRS,
              '--outfile', MERGED]
os.execv(cmd[0], cmd)

# Return an errorcode of 0 if the conflict was resolved; 1 otherwise.
# Any other errorcode will be treated as fatal.
</programlisting>
      </example>

      <example id="svn.advanced.externaldifftools.merge.ex-2">
        <title>mergewrap.bat</title>
        <programlisting>
@ECHO OFF

REM Configure your favorite merge program here.
SET DIFF3="C:\Program Files\Funky Stuff\My Merge Tool.exe"

REM Get the paths provided by Subversion.
SET BASE=%1
SET THEIRS=%2
SET MINE=%3
SET MERGED=%4
SET WCPATH=%5

REM Call the merge command (change the following line to make sense for
REM your merge program).
%DIFF3% --base %BASE% --mine %MINE% --theirs %THEIRS% --outfile %MERGED%

REM Return an errorcode of 0 if the conflict was resolved; 1 otherwise.
REM Any other errorcode will be treated as fatal.
</programlisting>
      </example>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.customization.summary">
    <title>Summary</title>

    <para>Sometimes there's a single right way to do things; sometimes
      there are many.  Subversion's developers understand that while
      the majority of its exact behaviors are acceptable to most of
      its users, there are some corners of its functionality where
      such a universally pleasing approach doesn't exist.  In those
      places, Subversion offers users the opportunity to tell it how
      <emphasis>they</emphasis> want it to behave.</para>

    <para>In this chapter, we explored Subversion's runtime
      configuration system and other mechanisms by which users can
      control those configurable behaviors.  If you are a developer,
      though, the next chapter will take you one step further.  It
      describes how you can further customize your Subversion
      experience by writing your own software against Subversion's
      libraries.</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<chapter id="svn.developer">
  <title>Embedding Subversion</title>
  
  <para>
    <indexterm>
      <primary>API</primary>
    </indexterm>
    <indexterm>
      <primary>application programming interface</primary>
      <see>API</see>
    </indexterm>Subversion has a modular design: it's implemented as a
    collection of libraries written in C.  Each library has a
    well-defined purpose and application programming interface (API),
    and that interface is available not only for Subversion itself to
    use, but for any software that wishes to embed or otherwise
    programmatically control Subversion.  Additionally, Subversion's
    API is available not only to other C programs, but also to
    programs written in higher-level languages such as Python, Perl,
    Java, and Ruby.</para>

  <para>This chapter is for those who wish to interact with Subversion
    through its public API or its various language bindings.  If you
    wish to write robust wrapper scripts around Subversion
    functionality to simplify your own life, are trying to develop
    more complex integrations between Subversion and other pieces of
    software, or just have an interest in Subversion's various library
    modules and what they offer, this chapter is for you.  If,
    however, you don't foresee yourself participating with Subversion
    at such a level, feel free to skip this chapter with the
    confidence that your experience as a Subversion user will not be
    affected.</para>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.layerlib">
    <title>Layered Library Design</title>

    <para>
      <indexterm>
        <primary>API</primary>
        <secondary>layers</secondary>
      </indexterm>Each of Subversion's core libraries can be said to
      exist in one of three main layers the Repository layer,
      the Repository Access (RA) layer, or the Client layer (see
      <xref linkend="svn.intro.architecture.dia-1" /> in the Preface).
      We will examine these layers shortly, but first, let's briefly
      summarize Subversion's various libraries.  For the sake of
      consistency, we will refer to the libraries by their
      extensionless Unix library names
      (<filename>libsvn_fs</filename>, <filename>libsvn_wc</filename>,
      <filename>mod_dav_svn</filename>, etc.).</para>

    <variablelist>
      <varlistentry>
        <term>libsvn_client</term> 
        <listitem><para>Primary interface for client
          programs</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_delta</term>
        <listitem><para>Tree and byte-stream differencing
          routines</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_diff</term>
        <listitem><para>Contextual differencing and merging
          routines</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs</term>
        <listitem><para>Filesystem commons and module
          loader</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_base</term>
        <listitem><para>The Berkeley DB filesystem
          backend</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_fs_fs</term>
        <listitem><para>The native filesystem (FSFS)
          backend</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra</term>
        <listitem><para>Repository Access commons and module
          loader</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_local</term>
        <listitem><para>The local Repository Access
          module</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_serf</term>
        <listitem><para>Another (experimental) WebDAV Repository
          Access module</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_ra_svn</term>
        <listitem><para>The custom protocol Repository Access
          module</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_repos</term>
        <listitem><para>Repository interface</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_subr</term>
        <listitem><para>Miscellaneous helpful
          subroutines</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>libsvn_wc</term>
        <listitem><para>The working copy management
          library</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_authz_svn</term>
        <listitem><para>Apache authorization module for Subversion
          repositories access via WebDAV</para></listitem>
      </varlistentry>
      <varlistentry>
        <term>mod_dav_svn</term>
        <listitem><para>Apache module for mapping WebDAV operations to
          Subversion ones</para></listitem>
      </varlistentry>
    </variablelist>

    <para>The fact that the word <quote>miscellaneous</quote>
      appears only once in the previous list is a good sign.  The
      Subversion development team is serious about making sure that
      functionality lives in the right layer and libraries.  Perhaps
      the greatest advantage of the modular design is its lack of
      complexity from a developer's point of view.  As a developer,
      you can quickly formulate that kind of <quote>big
      picture</quote> that allows you to pinpoint the location of
      certain pieces of functionality with relative ease.</para>

    <para>Another benefit of modularity is the ability to replace a
      given module with a whole new library that implements the same
      API without affecting the rest of the code base.  In some sense,
      this happens within Subversion already.  The
      <filename>libsvn_ra_local</filename>,
      <filename>libsvn_ra_serf</filename>, and
      <filename>libsvn_ra_svn</filename> libraries each implement the
      same interface, all working as plug-ins to
      <filename>libsvn_ra</filename>.  And all three communicate with
      the Repository layer <filename>libsvn_ra_local</filename>
      connects to the repository directly; the others do so over a
      network.  The <filename>libsvn_fs_base</filename> and
      <filename>libsvn_fs_fs</filename> libraries are another pair of
      libraries that implement the same functionality in different
      ways both are plug-ins to the common
      <filename>libsvn_fs</filename> library.</para>

    <para>The client itself also highlights the benefits of modularity
      in the Subversion design.  Subversion's
      <filename>libsvn_client</filename> library is a one-stop shop
      for most of the functionality necessary for designing a working
      Subversion client (see <xref
      linkend="svn.developer.layerlib.client"/>).  So while the
      Subversion distribution provides only the <command>svn</command>
      command-line client program, several third-party
      programs provide various forms of graphical client UIs.
      These GUIs use the same APIs that the stock command-line client
      does.  This type of modularity has played a large role in the
      proliferation of available Subversion clients and IDE
      integrations and, by extension, to the tremendous adoption rate
      of Subversion itself.</para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.repos">
      <title>Repository Layer</title>

      <para>
        <indexterm>
          <primary>API</primary>
          <secondary>layers</secondary>
          <tertiary>Repository Layer</tertiary>
        </indexterm>When referring to Subversion's Repository layer, we're
        generally talking about two basic concepts the versioned
        filesystem implementation (accessed via
        <filename>libsvn_fs</filename>, and supported by its
        <filename>libsvn_fs_base</filename> and
        <filename>libsvn_fs_fs</filename> plug-ins), and the repository
        logic that wraps it (as implemented in
        <filename>libsvn_repos</filename>).  These libraries provide
        the storage and reporting mechanisms for the various revisions
        of your version-controlled data.  This layer is connected to
        the Client layer via the Repository Access layer, and is, from
        the perspective of the Subversion user, the stuff at the
        <quote>other end of the line.</quote></para>

      <para>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem</secondary>
        </indexterm>The Subversion filesystem is not a kernel-level filesystem
        that one would install in an operating system (such as the
        Linux ext2 or NTFS), but instead is a virtual filesystem.
        Rather than storing <quote>files</quote> and
        <quote>directories</quote> as real files and directories (the
        kind you can navigate through using your favorite shell
        program), it uses one of two available abstract storage
        backends either a Berkeley DB database environment or a
        flat-file representation.  (To learn more about the two
        repository backends, see <xref
        linkend="svn.reposadmin.basics.backends"/>.)  There has even
        been considerable interest by the development community in
        giving future releases of Subversion the ability to use other
        backend database systems, perhaps through a mechanism such as
        Open Database Connectivity (ODBC).  In fact, Google did
        something similar to this before launching the Google Code
        Project Hosting service:  they announced in mid-2006 that
        members of its open source team had written a new proprietary
        Subversion filesystem plug-in that used Google's ultra-scalable
        Bigtable database for its storage.</para>

      <para>
        <indexterm>
          <primary>repositories</primary>
          <secondary>filesystem tree</secondary>
        </indexterm>The filesystem API exported by
        <filename>libsvn_fs</filename> contains the kinds of
        functionality you would expect from any other filesystem
        API you can create and remove files and directories,
        copy and move them around, modify file contents, and so on.
        It also has features that are not quite as common, such as the
        ability to add, modify, and remove metadata
        (<quote>properties</quote>) on each file or directory.
        Furthermore, the Subversion filesystem is a versioning
        filesystem, which means that as you make changes to your
        directory tree, Subversion remembers what your tree looked
        like before those changes.  And before the previous changes.
        And the previous ones.  And so on, all the way back through
        versioning time to (and just beyond) the moment you first
        started adding things to the filesystem.</para>

      <para>All the modifications you make to your tree are done
        within the context of a Subversion commit transaction.  The
        following is a simplified general routine for modifying your
        filesystem:</para>

      <orderedlist>
        <listitem>
          <para>Begin a Subversion commit transaction.</para>
        </listitem>
        <listitem>
          <para>Make your changes (adds, deletes, property
            modifications, etc.).</para>
        </listitem>
        <listitem>
          <para>Commit your transaction.</para>
        </listitem>
      </orderedlist>

      <para>Once you have committed your transaction, your filesystem
        modifications are permanently stored as historical artifacts.
        Each of these cycles generates a single new revision of your
        tree, and each revision is forever accessible as an immutable
        snapshot of <quote>the way things were.</quote></para>

      <sidebar>
        <title>The Transaction Distraction</title>

        <para>The notion of a Subversion transaction can become easily
          confused with the transaction support provided by the
          underlying database itself, especially given the former's
          close proximity to the Berkeley DB database code in
          <filename>libsvn_fs_base</filename>.  Both types of
          transaction exist to provide atomicity and isolation.  In
          other words, transactions give you the ability to perform a
          set of actions in an all-or-nothing fashion either all
          the actions in the set complete with success, or they all
          get treated as though <emphasis>none</emphasis> of them ever
          happened and in a way that does not interfere with
          other processes acting on the data.</para>

        <para>Database transactions generally encompass small
          operations related specifically to the modification of data
          in the database itself (such as changing the contents of a
          table row).  Subversion transactions are larger in scope,
          encompassing higher-level operations such as making
          modifications to a set of files and directories that are
          intended to be stored as the next revision of the filesystem
          tree.  If that isn't confusing enough, consider the fact
          that Subversion uses a database transaction during the
          creation of a Subversion transaction (so that if the
          creation of a Subversion transaction fails, the database will
          look as though we had never attempted that creation in the first
          place)!</para>

        <para>Fortunately for users of the filesystem API, the
          transaction support provided by the database system itself
          is hidden almost entirely from view (as should be expected
          from a properly modularized library scheme).  It is only
          when you start digging into the implementation of the
          filesystem itself that such things become visible (or
          interesting).</para>

      </sidebar>

      <para>Most of the functionality the filesystem
        interface provides deals with actions that occur on individual
        filesystem paths.  That is, from outside the filesystem, the
        primary mechanism for describing and accessing the individual
        revisions of files and directories comes through the use of
        path strings such as <filename>/foo/bar</filename>, just as though
        you were addressing files and directories through your
        favorite shell program.  You add new files and directories by
        passing their paths-to-be to the right API functions.  You
        query for information about them by the same mechanism.</para>

      <para>Unlike most filesystems, though, a path alone is not
        enough information to identify a file or directory in
        Subversion.  Think of a directory tree as a two-dimensional
        system, where a node's siblings represent a sort of
        left-and-right motion, and navigating into the node's
        subdirectories represents a downward motion.  <xref
        linkend="svn.developer.layerlib.repos.dia-1"/> shows a typical
        representation of a tree as exactly that.</para>

      <figure id="svn.developer.layerlib.repos.dia-1">
        <title>Files and directories in two dimensions</title>
        <graphic fileref="images/ch08dia1.png"/>
      </figure>

      <para>The difference here is that the Subversion filesystem has
        a nifty third dimension that most filesystems do not
        have Time!<footnote><para>We understand that this may
        come as a shock to sci-fi fans who have long been under the
        impression that Time was actually
        the <emphasis>fourth</emphasis> dimension, and we apologize
        for any emotional trauma induced by our assertion of a
        different theory.</para></footnote>  In the filesystem
        interface, nearly every function that has a
        <parameter>path</parameter> argument also expects a
        <parameter>root</parameter> argument.  This
        <literal>svn_fs_root_t</literal> argument describes
        either a revision or a Subversion transaction (which is simply
        a revision in the making) and provides that third dimension
        of context needed to understand the difference between
        <filename>/foo/bar</filename> in revision 32, and the same
        path as it exists in revision 98.  <xref
        linkend="svn.developer.layerlib.repos.dia-2"/> shows revision
        history as an added dimension to the Subversion filesystem
        universe.</para>

      <figure id="svn.developer.layerlib.repos.dia-2">
        <title>Versioning time the third dimension!</title>
        <graphic fileref="images/ch08dia2.png"/>
      </figure>

      <para>As we mentioned earlier, the
        <filename>libsvn_fs</filename> API looks and feels like any
        other filesystem, except that it has this wonderful versioning
        capability.  It was designed to be usable by any program
        interested in a versioning filesystem.  Not coincidentally,
        Subversion itself is interested in that functionality.  But
        while the filesystem API should be sufficient for basic file
        and directory versioning support, Subversion wants
        more and that is where <filename>libsvn_repos</filename>
        comes in.</para>

      <para>The Subversion repository library
        (<filename>libsvn_repos</filename>) sits (logically speaking)
        atop the <filename>libsvn_fs</filename> API, providing
        additional functionality beyond that of the underlying
        versioned filesystem logic.  It does not completely wrap each
        and every filesystem function only certain major steps
        in the general cycle of filesystem activity are wrapped by the
        repository interface.  Some of these include the creation and
        commit of Subversion transactions and the modification of
        revision properties.  These particular events are wrapped by
        the repository layer because they have hooks associated with
        them.  A repository hook system is not strictly related to
        implementing a versioning filesystem, so it lives in the
        repository wrapper library.</para>
      
      <para>The hooks mechanism is but one of the reasons for the
        abstraction of a separate repository library from the rest of
        the filesystem code.  The <filename>libsvn_repos</filename>
        API provides several other important utilities to Subversion.
        These include the abilities to:</para>

      <itemizedlist>
        <listitem>
          <para>Create, open, destroy, and perform recovery steps on a
            Subversion repository and the filesystem included in that
            repository.</para>
        </listitem>
        <listitem>
          <para>Describe the differences between two filesystem
            trees.</para>
        </listitem>
        <listitem>
          <para>Query for the commit log messages associated with all
            (or some) of the revisions in which a set of files was
            modified in the filesystem.</para>
        </listitem>
        <listitem>
          <para>Generate a human-readable <quote>dump</quote> of the
            filesystem a complete representation of the revisions in
            the filesystem.</para>
        </listitem>
        <listitem>
          <para>Parse that dump format, loading the dumped revisions
            into a different Subversion repository.</para>
        </listitem>
      </itemizedlist>

      <para>As Subversion continues to evolve, the repository library
        will grow with the filesystem library to offer increased
        functionality and configurable option support.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.ra">
      <title>Repository Access Layer</title>

      <para>
        <indexterm>
          <primary>API</primary>
          <secondary>layers</secondary>
          <tertiary>Repository Access (RA) Layer</tertiary>
        </indexterm>If the Subversion Repository layer is at <quote>the other
        end of the line,</quote> the Repository Access (RA) layer is
        the line itself.  Charged with marshaling data between the
        client libraries and the repository, this layer includes the
        <filename>libsvn_ra</filename> module loader library, the RA
        modules themselves (which currently includes
        <filename>libsvn_ra_local</filename>,
        <filename>libsvn_ra_serf</filename>, and
        <filename>libsvn_ra_svn</filename>), and any additional
        libraries needed by one or more of those RA modules (such as
        the <filename>mod_dav_svn</filename> Apache module or
        <filename>libsvn_ra_svn</filename>'s server,
        <command>svnserve</command>).</para>

      <para>
        <indexterm>
          <primary>repository URL</primary>
        </indexterm>Since Subversion uses URLs to identify its repository
        resources, the protocol portion of the URL scheme (usually
        <literal>file://</literal>, <literal>http://</literal>,
        <literal>https://</literal>, <literal>svn://</literal>, or
        <literal>svn+ssh://</literal>) is used to determine which RA
        module will handle the communications.  Each module registers
        a list of the protocols it knows how to <quote>speak</quote>
        so that the RA loader can, at runtime, determine which module
        to use for the task at hand.  You can determine which RA
        modules are available to the Subversion command-line client,
        and what protocols they claim to support, by running
        <userinput>svn --version</userinput>:</para>

      <informalexample>
        <screen>
$ svn --version
svn, version 1.8.0-dev (under development)
   compiled Jan  8 2013, 11:45:25 on i686-pc-linux-gnu

Copyright (C) 2013 The Apache Software Foundation.
This software consists of contributions made by many people;
see the NOTICE file for more information.
Subversion is open source software, see http://subversion.apache.org/

The following repository access (RA) modules are available:

* ra_svn : Module for accessing a repository using the svn network protocol.
  - with Cyrus SASL authentication
  - handles 'svn' scheme
* ra_local : Module for accessing a repository on local disk.
  - handles 'file' scheme
* ra_serf : Module for accessing a repository via WebDAV protocol using serf.
  - handles 'http' scheme
  - handles 'https' scheme

$
</screen>
      </informalexample>

      <para>The public API exported by the RA layer contains
        functionality necessary for sending and receiving versioned
        data to and from the repository.  And each of the available RA
        plug-ins is able to perform that task using a specific
        protocol <filename>libsvn_ra_serf</filename> speaks HTTP/WebDAV
        (optionally using SSL encryption) with an Apache HTTP Server
        that is running the <filename>mod_dav_svn</filename>
        Subversion server module; <filename>libsvn_ra_svn</filename>
        speaks a custom network protocol with the
        <command>svnserve</command> program; and so on.</para>

      <para>For those who wish to access a Subversion repository
        using still another protocol, that is precisely why the
        Repository Access layer is modularized!  Developers can simply
        write a new library that implements the RA interface on one
        side and communicates with the repository on the other.  Your
        new library can use existing network protocols or you can
        invent your own.  You could use interprocess communication
        (IPC) calls, or let's get crazy, shall we? you
        could even implement an email-based protocol.  Subversion
        supplies the APIs; you supply the creativity.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.layerlib.client">
      <title>Client Layer</title>
      
      <para>
        <indexterm>
          <primary>API</primary>
          <secondary>layers</secondary>
          <tertiary>Client Layer</tertiary>
        </indexterm>On the client side, the Subversion working copy is where
        all the action takes place.  The bulk of functionality
        implemented by the client-side libraries exists for the sole
        purpose of managing working copies directories full of
        files and other subdirectories that serve as a sort of local,
        editable <quote>reflection</quote> of one or more repository
        locations and propagating changes to and from the
        Repository Access layer.</para>

      <para>
        <indexterm>
          <primary>administrative directory</primary>
        </indexterm>Subversion's working copy library,
        <filename>libsvn_wc</filename>, is directly responsible for
        managing the data in the working copies.  To accomplish this,
        the library stores administrative information about the
        working copy within a special subdirectory.  This
        subdirectory, named <filename>.svn</filename>, is present in
        each working copy and contains various other files
        and directories that record state and provide a private
        workspace for administrative action.  For those familiar with
        CVS, this <filename>.svn</filename> subdirectory is similar in
        purpose to the <filename>CVS</filename> administrative
        directories found in CVS working copies.</para>

      <para>The Subversion client library,
        <filename>libsvn_client</filename>, has the broadest
        responsibility; its job is to mingle the functionality of the
        working copy library with that of the Repository Access layer,
        and then to provide the highest-level API to any application
        that wishes to perform general revision control actions.  For
        example, the function
        <function>svn_client_checkout()</function> takes a URL as an
        argument.  It passes this URL to the RA layer and opens an
        authenticated session with a particular repository.  It then
        asks the repository for a certain tree, and sends this tree
        into the working copy library, which then writes a full
        working copy to disk (<filename>.svn</filename> directories
        and all).</para>

      <para>The client library is designed to be used by any
        application.  While the Subversion source code includes a
        standard command-line client, it should be very easy to write
        any number of GUI clients on top of the client library.  New
        GUIs (or any new client, really) for Subversion need not be
        clunky wrappers around the included command-line
        client they have full access via the
        <filename>libsvn_client</filename> API to the same functionality,
        data, and callback mechanisms that the command-line client
        uses.  In fact, the Subversion source code tree contains a
        small C program (which you can find at
        <filename>tools/examples/minimal_client.c</filename>) that
        exemplifies how to wield the Subversion API to create a simple
        client program.</para>

      <sidebar>
        <title>Binding Directly A Word About Correctness</title>

        <para>Why should your GUI program bind directly with a
          <filename>libsvn_client</filename> instead of acting as a
          wrapper around a command-line program?  Besides simply being
          more efficient, it can be more correct as well.  A
          command-line program (such as the one supplied with
          Subversion) that binds to the client library needs to
          effectively translate feedback and requested data bits from
          C types to some form of human-readable output.  This type of
          translation can be lossy.  That is, the program may not
          display all of the information harvested from the API or may
          combine bits of information for compact
          representation.</para>

        <para>If you wrap such a command-line program with yet another
          program, the second program has access only to
          already interpreted (and as we mentioned, likely incomplete)
          information, which it must <emphasis>again</emphasis>
          translate into <emphasis>its</emphasis> representation
          format.  With each layer of wrapping, the integrity of the
          original data is potentially tainted more and more, much
          like the result of making a copy of a copy (of a copy )
          of a favorite audio or video cassette.</para>
 
        <para>But the most compelling argument for binding directly to
          the APIs instead of wrapping other programs is that the
          Subversion project makes compatibility promises regarding
          its APIs.  Across minor versions of those APIs (such as
          between 1.3 and 1.4), no function's prototype will change.
          In other words, you aren't forced to update your program's
          source code simply because you've upgraded to a new version
          of Subversion.  Certain functions might be deprecated, but
          they still work, and this gives you a buffer of time to
          eventually embrace the newer APIs.  These kinds of
          compatibility promises do not exist for Subversion
          command-line program output, which is subject to change from
          release to release.</para>

      </sidebar>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.usingapi">
    <title>Using the APIs</title>

    <para>Developing applications against the Subversion library APIs
      is fairly straightforward.  Subversion is primarily a set of C
      libraries, with header (<filename>.h</filename>) files that live
      in the <filename>subversion/include</filename> directory of the
      source tree.  These headers are copied into your system
      locations (e.g., <filename>/usr/local/include</filename>)
      when you build and install Subversion itself from source.  These
      headers represent the entirety of the functions and types meant
      to be accessible by users of the Subversion libraries.  The
      Subversion developer community is meticulous about ensuring that
      the public API is well documented refer directly to the
      header files for that documentation.</para>

    <para>When examining the public header files, the first thing you
      might notice is that Subversion's datatypes and functions are
      namespace-protected.  That is, every public Subversion symbol
      name begins with <literal>svn_</literal>, followed by a short
      code for the library in which the symbol is defined (such as
      <literal>wc</literal>, <literal>client</literal>,
      <literal>fs</literal>, etc.), followed by a single underscore
      (<literal>_</literal>), and then the rest of the symbol name.
      Semipublic functions (used among source files of a given
      library but not by code outside that library, and found inside
      the library directories themselves) differ from this naming
      scheme in that instead of a single underscore after the library
      code, they use a double underscore
      (<literal></literal>).  Functions that are private to
      a given source file have no special prefixing and are declared
      <literal>static</literal>.  Of course, a compiler isn't
      interested in these naming conventions, but they help to clarify
      the scope of a given function or datatype.</para>

    <para>Another good source of information about programming against
      the Subversion APIs is the project's own hacking guidelines,
      which you can find at
      <ulink url="http://subversion.apache.org/docs/community-guide/"
      />.  This document contains useful information, which, while
      aimed at developers and would-be developers of Subversion
      itself, is equally applicable to folks developing against
      Subversion as a set of third-party
      libraries.<footnote><para>After all, Subversion uses
      Subversion's APIs, too.</para></footnote></para>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.apr">
      <title>The Apache Portable Runtime Library</title>

      <para>Along with Subversion's own datatypes, you will see many
        references to datatypes that begin with
        <literal>apr_</literal> symbols from the Apache Portable
        Runtime (APR) library.  APR is Apache's portability library,
        originally carved out of its server code as an attempt to
        separate the OS-specific bits from the OS-independent portions
        of the code.  The result was a library that provides a generic
        API for performing operations that differ mildly or
        wildly from OS to OS.  While the Apache HTTP Server was
        obviously the first user of the APR library, the Subversion
        developers immediately recognized the value of using APR as
        well.  This means that there is practically no OS-specific
        code in Subversion itself.  Also, it means that the Subversion
        client compiles and runs anywhere that the Apache HTTP Server
        does.  Currently, this list includes all flavors of Unix,
        Win32, BeOS, OS/2, and Mac OS X.</para>

      <para>In addition to providing consistent implementations of
        system calls that differ across operating
        systems,<footnote><para>Subversion uses ANSI system calls and
        datatypes as much as possible.</para></footnote> APR gives
        Subversion immediate access to many custom datatypes, such as
        dynamic arrays and hash tables.  Subversion uses these types
        extensively.  But perhaps the most pervasive APR datatype,
        found in nearly every Subversion API prototype, is the
        <literal>apr_pool_t</literal> the APR memory pool.
        Subversion uses pools internally for all its memory allocation
        needs (unless an external library requires a different memory
        management mechanism for data passed through its
        API),<footnote><para>Neon and Berkeley DB are examples of such
        libraries.</para></footnote> and while a person coding against
        the Subversion APIs is not required to do the same,
        she <emphasis>is</emphasis> required to provide pools to the
        API functions that need them.  This means that users of the
        Subversion API must also link against APR, must
        call <function>apr_initialize()</function> to initialize the
        APR subsystem, and then must create and manage pools for use
        with Subversion API calls, typically by
        using <function>svn_pool_create()</function>,
        <function>svn_pool_clear()</function>, and
        <function>svn_pool_destroy()</function>.</para>

      <sidebar>
        <title>Programming with Memory Pools</title>

        <para>
          <indexterm>
            <primary>API</primary>
            <secondary>memory pools</secondary>
          </indexterm>Almost every developer who has used the C programming
          language has at some point sighed at the daunting task of
          managing memory usage.  Allocating enough memory to use,
          keeping track of those allocations, freeing the memory when
          you no longer need it these tasks can be quite
          complex.  And of course, failure to do those things properly
          can result in a program that crashes itself, or worse,
          crashes the computer.</para>

        <para>Higher-level languages, on the other hand, either take
          the job of memory management away from you completely or
          make it something you toy with only when doing extremely
          tight program optimization.  Languages such as Java and
          Python use <firstterm>garbage collection</firstterm>,
          allocating memory for objects when needed, and automatically
          freeing that memory when the object is no longer in
          use.</para>

        <para>APR provides a middle-ground approach called
          <firstterm>pool-based memory management</firstterm>.  It
          allows the developer to control memory usage at a lower
          resolution per chunk (or <quote>pool</quote>) of
          memory, instead of per allocated object.  Rather than using
          <function>malloc()</function> and friends to allocate enough
          memory for a given object, you ask APR to allocate the
          memory from a memory pool.  When you're finished using the
          objects you've created in the pool, you destroy the entire
          pool, effectively de-allocating the memory consumed by
          <emphasis>all</emphasis> the objects you allocated from it.
          Thus, rather than keeping track of individual objects that
          need to be de-allocated, your program simply considers the
          general lifetimes of those objects and allocates the objects
          in a pool whose lifetime (the time between the pool's
          creation and its deletion) matches the object's
          needs.</para>

      </sidebar>
    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.funcsbatons">
      <title>Functions and Batons</title> 

      <para>
        <indexterm>
          <primary>API</primary>
          <secondary>batons</secondary>
        </indexterm>To facilitate <quote>streamy</quote> (asynchronous) behavior
        and provide consumers of the Subversion C API with hooks for
        handling information in customizable ways, many functions in
        the API accept pairs of parameters: a pointer to a callback
        function, and a pointer to a blob of memory called
        a <firstterm>baton</firstterm> that carries context
        information for that callback function.  Batons are typically
        C structures with additional information that the callback
        function needs but which is not given directly to the callback
        function by the driving API function.</para>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.urlpath">
      <title>URL and Path Requirements</title>

      <para>With remote version control operation as the whole point
        of Subversion's existence, it makes sense that some attention
        has been paid to internationalization (i18n) support.  After
        all, while <quote>remote</quote> might mean <quote>across the
        office,</quote> it could just as well mean <quote>across the
        globe.</quote> To facilitate this, all of Subversion's public
        interfaces that accept path arguments expect those paths to be
        canonicalized which is most easily accomplished by
        passing them through <function>svn_dirent_canonicalize()</function>
        or <function>svn_uri_canonicalize()</function> (depending on
        whether you are canonicalizing a local system path or a URL,
        respectively) and encoded in UTF-8.  This means, for
        example, that any new client binary that drives the
        <filename>libsvn_client</filename> interface needs to first
        convert paths from the locale-specific encoding to UTF-8
        before passing those paths to the Subversion libraries, and
        then reconvert any resultant output paths from Subversion
        back into the locale's encoding before using those paths for
        non-Subversion purposes.  Fortunately, Subversion provides a
        suite of functions (see
        <filename>subversion/include/svn_utf.h</filename>) that 
        any program can use to do these conversions.</para>

      <para>Also, Subversion APIs require all URL parameters to be
        properly URI-encoded.  So, instead of passing
        <uri>file:///home/username/My File.txt</uri> as the URL of a
        file named <filename>My File.txt</filename>, you need to pass
        <uri>file:///home/username/My%20File.txt</uri>.  Again,
        Subversion supplies helper functions that your application can
        use <function>svn_path_uri_encode()</function> and
        <function>svn_path_uri_decode()</function>, for URI encoding
        and decoding, respectively.</para> </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.otherlangs">
      <title>Using Languages Other Than C and C++</title> 

      <para>If you are interested in using the Subversion libraries in
        conjunction with something other than a C program say, a
        Python or Perl script Subversion has some support for this
        via the Simplified Wrapper and Interface Generator (SWIG).  The
        SWIG bindings for Subversion are located in
        <filename>subversion/bindings/swig</filename>.  They are still
        maturing, but they are usable.  These bindings allow you
        to call Subversion API functions indirectly, using wrappers that
        translate the datatypes native to your scripting language into
        the datatypes needed by Subversion's C libraries.</para>

      <para>Significant efforts have been made toward creating
        functional SWIG-generated bindings for Python, Perl, and Ruby.
        To some extent, the work done preparing the SWIG interface
        files for these languages is reusable in efforts to generate
        bindings for other languages supported by SWIG (which include
        versions of C#, Guile, Java, MzScheme, OCaml, PHP, and Tcl,
        among others).  However, some extra programming is required to
        compensate for complex APIs that SWIG needs some help
        translating between languages.  For more information on SWIG
        itself, see the project's web site at <ulink
        url="http://www.swig.org/"/>.</para>

      <para>Subversion also has language bindings for Java.  The
        javahl bindings (located in
        <filename>subversion/bindings/java</filename> in the
        Subversion source tree) aren't SWIG-based, but are instead a
        mixture of Java and hand-coded JNI.  Javahl covers most
        Subversion client-side APIs and is specifically targeted at
        implementors of Java-based Subversion clients and IDE
        integrations.</para>

      <para>Subversion's language bindings tend to lack the level of
        developer attention given to the core Subversion modules, but
        can generally be trusted as production-ready.  A number of
        scripts and applications, alternative Subversion GUI clients,
        and other third-party tools are successfully using
        Subversion's language bindings today to accomplish their
        Subversion integrations.</para>

      <para>It's worth noting here that there are other options for
        interfacing with Subversion using other languages:  alternative
        bindings for Subversion that aren't provided by the
        Subversion development community at all.  There
        are a couple of popular ones we feel are especially
        noteworthy.  First, Barry Scott's PySVN bindings (<ulink
        url="http://pysvn.tigris.org/" />) are a popular option for
        binding with Python.  PySVN boasts of a more Pythonic
        interface than the more C-like APIs provided by Subversion's
        own Python bindings.  And if you're looking for a pure Java
        implementation of Subversion, check out SVNKit (<ulink
        url="http://svnkit.com/" />), which is Subversion rewritten
        from the ground up in Java.</para>

      <sidebar>
        <title>SVNKit Versus javahl</title>

        <para>In 2005, a small company called TMate announced the
          1.0.0 release of JavaSVN a pure Java implementation of
          Subversion.  Since then, the project has been renamed to
          SVNKit (available at <ulink url="http://svnkit.com/" />)
          and has seen great success as a provider of Subversion
          functionality to various Subversion clients, IDE
          integrations, and other third-party tools.</para>

        <para>The SVNKit library is interesting in that, unlike the
          javahl library, it is not merely a wrapper around the
          official Subversion core libraries.  In fact, it shares no
          code with Subversion at all.  But while it is easy to
          confuse SVNKit with javahl, and easier still to not even
          realize which of these libraries you are using, folks should
          be aware that SVNKit differs from javahl in some significant
          ways.  First, while SVNKit is developed as open source
          software just like Subversion, SVNKit's license is more
          restrictive than that of
          Subversion.<footnote><para>Redistributions in any form must
          be accompanied by information on how to obtain complete
          source code for the software that uses SVNKit and any
          accompanying software that uses the software that uses
          SVNKit. See <ulink url="http://svnkit.com/license.html" />
          for details.</para></footnote>  Finally, by aiming to be a
          pure Java Subversion library, SVNKit is limited in which
          portions of Subversion can be reasonably cloned while still
          keeping up with Subversion's releases.  This has already
          happened once SVNKit cannot access BDB-backed
          Subversion repositories via the <literal>file://</literal>
          protocol because there's no pure Java implementation of
          Berkeley DB that is file-format-compatible with the native
          implementation of that library.</para>

        <para>That said, SVNKit has a well-established track record of
          reliability.  And a pure Java solution is much more robust
          in the face of programming errors a bug in SVNKit
          might raise a catchable Java Exception, but a bug in the
          Subversion core libraries as accessed via javahl can bring
          down your entire Java Runtime Environment.  So, weigh the
          costs when choosing a Java-based Subversion
          implementation.</para>

      </sidebar>

    </sect2>

    <!-- =============================================================== -->
    <sect2 id="svn.developer.usingapi.codesamples">
      <title>Code Samples</title> 

      <para><xref linkend="svn.developer.layerlib.repos.ex-1" />
        contains a code segment (written in C) that illustrates some
        of the concepts we've been discussing.  It uses both the
        repository and filesystem interfaces (as can be determined by
        the prefixes <literal>svn_repos_</literal> and
        <literal>svn_fs_</literal> of the function names,
        respectively) to create a new revision in which a directory is
        added.  You can see the use of an APR pool, which is passed
        around for memory allocation purposes.  Also, the code reveals
        a somewhat obscure fact about Subversion error
        handling all Subversion errors must be explicitly
        handled to avoid memory leakage (and in some cases,
        application failure).</para>

      <example id="svn.developer.layerlib.repos.ex-1">
        <title>Using the repository layer</title>

        <programlisting>
/* Convert a Subversion error into a simple boolean error code.
 *
 * NOTE:  Subversion errors must be cleared (using svn_error_clear())
 *        because they are allocated from the global pool, else memory
 *        leaking occurs.
 */
#define INT_ERR(expr)                           \
  do {                                          \
    svn_error_t *__temperr = (expr);            \
    if (__temperr)                              \
      {                                         \
        svn_error_clear(__temperr);             \
        return 1;                               \
      }                                         \
    return 0;                                   \
  } while (0)

/* Create a new directory at the path NEW_DIRECTORY in the Subversion
 * repository located at REPOS_PATH.  Perform all memory allocation in
 * POOL.  This function will create a new revision for the addition of
 * NEW_DIRECTORY.  Return zero if the operation completes
 * successfully, nonzero otherwise.
 */
static int
make_new_directory(const char *repos_path,
                   const char *new_directory,
                   apr_pool_t *pool)
{
  svn_error_t *err;
  svn_repos_t *repos;
  svn_fs_t *fs;
  svn_revnum_t youngest_rev;
  svn_fs_txn_t *txn;
  svn_fs_root_t *txn_root;
  const char *conflict_str;

  /* Open the repository located at REPOS_PATH. 
   */
  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));

  /* Get a pointer to the filesystem object that is stored in REPOS. 
   */
  fs = svn_repos_fs(repos);

  /* Ask the filesystem to tell us the youngest revision that
   * currently exists. 
   */
  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));

  /* Begin a new transaction that is based on YOUNGEST_REV.  We are
   * less likely to have our later commit rejected as conflicting if we
   * always try to make our changes against a copy of the latest snapshot
   * of the filesystem tree. 
   */
  INT_ERR(svn_repos_fs_begin_txn_for_commit2(&amp;txn, repos, youngest_rev,
                                             apr_hash_make(pool), pool));

  /* Now that we have started a new Subversion transaction, get a root
   * object that represents that transaction. 
   */
  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));
  
  /* Create our new directory under the transaction root, at the path
   * NEW_DIRECTORY. 
   */
  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));

  /* Commit the transaction, creating a new revision of the filesystem
   * which includes our added directory path.
   */
  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, 
                                &amp;youngest_rev, txn, pool);
  if (! err)
    {
      /* No error?  Excellent!  Print a brief report of our success.
       */
      printf("Directory '%s' was successfully added as new revision "
             "'%ld'.\n", new_directory, youngest_rev);
    }
  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)
    {
      /* Uh-oh.  Our commit failed as the result of a conflict
       * (someone else seems to have made changes to the same area 
       * of the filesystem that we tried to modify).  Print an error
       * message.
       */
      printf("A conflict occurred at path '%s' while attempting "
             "to add directory '%s' to the repository at '%s'.\n", 
             conflict_str, new_directory, repos_path);
    }
  else
    {
      /* Some other error has occurred.  Print an error message.
       */
      printf("An error occurred while attempting to add directory '%s' "
             "to the repository at '%s'.\n", 
             new_directory, repos_path);
    }

  INT_ERR(err);
} 
</programlisting>
      </example>

      <para>Note that in <xref
        linkend="svn.developer.layerlib.repos.ex-1" />, the code could
        just as easily have committed the transaction using
        <function>svn_fs_commit_txn()</function>.  But the filesystem
        API knows nothing about the repository library's hook
        mechanism.  If you want your Subversion repository to
        automatically perform some set of non-Subversion tasks every
        time you commit a transaction (e.g., sending an
        email that describes all the changes made in that transaction
        to your developer mailing list), you need to use the
        <filename>libsvn_repos</filename>-wrapped version of that
        function, which adds the hook triggering
        functionality in this case,
        <function>svn_repos_fs_commit_txn()</function>.  (For more
        information regarding Subversion's repository hooks, see <xref
        linkend="svn.reposadmin.hooks" />.)</para>

      <para>Now let's switch languages.  <xref
        linkend="svn.developer.usingapi.otherlangs.ex-1" /> is a
        sample program that uses Subversion's SWIG Python bindings to
        recursively crawl the youngest repository revision, and to
        print the various paths reached during the crawl.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-1">
        <title>Using the repository layer with Python</title>

        <programlisting>
#!/usr/bin/python

"""Crawl a repository, printing versioned object path names."""

import sys
import os.path
import svn.fs, svn.core, svn.repos

def crawl_filesystem_dir(root, directory):
    """Recursively crawl DIRECTORY under ROOT in the filesystem, and return
    a list of all the paths at or below DIRECTORY."""

    # Print the name of this path.
    print directory + "/"
    
    # Get the directory entries for DIRECTORY.
    entries = svn.fs.svn_fs_dir_entries(root, directory)

    # Loop over the entries.
    names = entries.keys()
    for name in names:
        # Calculate the entry's full path.
        full_path = directory + '/' + name

        # If the entry is a directory, recurse.  The recursion will return
        # a list with the entry and all its children, which we will add to
        # our running list of paths.
        if svn.fs.svn_fs_is_dir(root, full_path):
            crawl_filesystem_dir(root, full_path)
        else:
            # Else it's a file, so print its path here.
            print full_path

def crawl_youngest(repos_path):
    """Open the repository at REPOS_PATH, and recursively crawl its
    youngest revision."""
    
    # Open the repository at REPOS_PATH, and get a reference to its
    # versioning filesystem.
    repos_obj = svn.repos.svn_repos_open(repos_path)
    fs_obj = svn.repos.svn_repos_fs(repos_obj)

    # Query the current youngest revision.
    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)
    
    # Open a root object representing the youngest (HEAD) revision.
    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)

    # Do the recursive crawl.
    crawl_filesystem_dir(root_obj, "")
    
if __name__ == "__main__":
    # Check for sane usage.
    if len(sys.argv) != 2:
        sys.stderr.write("Usage: %s REPOS_PATH\n"
                         % (os.path.basename(sys.argv[0])))
        sys.exit(1)

    # Canonicalize the repository path.
    repos_path = svn.core.svn_dirent_canonicalize(sys.argv[1])

    # Do the real work.
    crawl_youngest(repos_path)
</programlisting>
      </example>

      <para>This same program in C would need to deal with APR's
        memory pool system.  But Python handles memory usage
        automatically, and Subversion's Python bindings adhere to that
        convention.  In C, you'd be working with custom datatypes
        (such as those provided by the APR library) for representing
        the hash of entries and the list of paths, but Python has
        hashes (called <quote>dictionaries</quote>) and lists as
        built-in datatypes, and it provides a rich collection of
        functions for operating on those types.  So SWIG (with the
        help of some customizations in Subversion's language bindings
        layer) takes care of mapping those custom datatypes into the
        native datatypes of the target language.  This provides a more
        intuitive interface for users of that language.</para>

      <para>The Subversion Python bindings can be used for working
        copy operations, too.  In the previous section of this
        chapter, we mentioned the <filename>libsvn_client</filename>
        interface and how it exists for the sole purpose of
        simplifying the process of writing a Subversion client.  <xref
        linkend="svn.developer.usingapi.otherlangs.ex-2" /> is a brief
        example of how that library can be accessed via the SWIG
        Python bindings to re-create a scaled-down version of the
        <command>svn status</command> command.</para>

      <example id="svn.developer.usingapi.otherlangs.ex-2">
        <title>A Python status crawler</title>

        <programlisting>
#!/usr/bin/env python

"""Crawl a working copy directory, printing status information."""

import sys
import os.path
import getopt
import svn.core, svn.client, svn.wc

def generate_status_code(status):
    """Translate a status value into a single-character status code,
    using the same logic as the Subversion command-line client."""
    code_map = { svn.wc.svn_wc_status_none        : ' ',
                 svn.wc.svn_wc_status_normal      : ' ',
                 svn.wc.svn_wc_status_added       : 'A',
                 svn.wc.svn_wc_status_missing     : '!',
                 svn.wc.svn_wc_status_incomplete  : '!',
                 svn.wc.svn_wc_status_deleted     : 'D',
                 svn.wc.svn_wc_status_replaced    : 'R',
                 svn.wc.svn_wc_status_modified    : 'M',
                 svn.wc.svn_wc_status_conflicted  : 'C',
                 svn.wc.svn_wc_status_obstructed  : '~',
                 svn.wc.svn_wc_status_ignored     : 'I',
                 svn.wc.svn_wc_status_external    : 'X',
                 svn.wc.svn_wc_status_unversioned : '?',
               }
    return code_map.get(status, '?')

def do_status(wc_path, verbose, prefix):
    # Build a client context baton.
    ctx = svn.client.svn_client_create_context()

    def _status_callback(path, status):
        """A callback function for svn_client_status."""

        # Print the path, minus the bit that overlaps with the root of
        # the status crawl
        text_status = generate_status_code(status.text_status)
        prop_status = generate_status_code(status.prop_status)
        prefix_text = ''
        if prefix is not None:
            prefix_text = prefix + " "
        print '%s%s%s  %s' % (prefix_text, text_status, prop_status, path)
        
    # Do the status crawl, using _status_callback() as our callback function.
    revision = svn.core.svn_opt_revision_t()
    revision.type = svn.core.svn_opt_revision_head
    svn.client.svn_client_status2(wc_path, revision, _status_callback,
                                  svn.core.svn_depth_infinity, verbose,
                                  0, 0, 1, ctx)

def usage_and_exit(errorcode):
    """Print usage message, and exit with ERRORCODE."""
    stream = errorcode and sys.stderr or sys.stdout
    stream.write("""Usage: %s OPTIONS WC-PATH

  Print working copy status, optionally with a bit of prefix text.

Options:
  --help, -h    : Show this usage message
  --prefix ARG  : Print ARG, followed by a space, before each line of output
  --verbose, -v : Show all statuses, even uninteresting ones
""" % (os.path.basename(sys.argv[0])))
    sys.exit(errorcode)
    
if __name__ == '__main__':
    # Parse command-line options.
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hv",
                                   ["help", "prefix=", "verbose"])
    except getopt.GetoptError:
        usage_and_exit(1)
    verbose = 0
    prefix = None
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage_and_exit(0)
        if opt in ("--prefix"):
            prefix = arg
        if opt in ("-v", "--verbose"):
            verbose = 1
    if len(args) != 1:
        usage_and_exit(2)
            
    # Canonicalize the working copy path.
    wc_path = svn.core.svn_dirent_canonicalize(args[0])

    # Do the real work.
    try:
        do_status(wc_path, verbose, prefix)
    except svn.core.SubversionException, e:
        sys.stderr.write("Error (%d): %s\n" % (e.apr_err, e.message))
        sys.exit(1)
</programlisting>
      </example>

      <para>As was the case in
        <xref linkend="svn.developer.usingapi.otherlangs.ex-1" />,
        this program is pool-free and uses, for the most part, normal
        Python datatypes.</para>

      <warning>
        <para>Run user-provided paths
          through the appropriate canonicalization function
          (<function>svn_dirent_canonicalize()</function> or
          <function>svn_uri_canonicalize()</function>) before passing
          them to other API functions.  Failure to do so can trigger
          assertions in the underlying Subversion C library which
          translate into rather immediate and unceremonious program
          abortion.</para>
      </warning>

      <para>Of particular interest to users of the Python flavor of
        Subversion's API is the implementation of callback functions.
        As previously mentioned, Subversion's C API makes liberal use
        of the callback function/baton paradigm.  API functions which
        in C accept a function and baton pair only accept a callback
        function parameter in Python.  How, then, does the caller pass
        arbitrary context information to the callback function?  In
        Python, this is done by taking advantage of Python's scoping
        rules and default argument values.  You can see this in action
        in <xref linkend="svn.developer.usingapi.otherlangs.ex-2" />.
        The <function>svn_client_status2()</function> function is
        given a callback function
        (<function>_status_callback()</function>) but no
        baton <function>_status_callback()</function> gets
        access to the user-provided prefix string because that
        variable falls into the scope of the function
        automatically.</para>

    </sect2>
  </sect1>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <sect1 id="svn.developer.summary">
    <title>Summary</title>

    <para>One of Subversion's greatest features isn't something you
      get from running its command-line client or other tools.  It's
      the fact that Subversion was designed modularly and provides a
      stable, public API so that others like yourself,
      perhaps can write custom software that drives Subversion's
      core logic.</para>

    <para>In this chapter, we took a closer look at Subversion's
      architecture, examining its logical layers and describing that
      public API, the very same API that Subversion's own layers use
      to communicate with each other.  Many developers have found
      interesting uses for the Subversion API, from simple repository
      hook scripts, to integrations between Subversion and some other
      application, to completely different version control systems.
      What unique itch will <emphasis>you</emphasis> scratch with
      it?</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->
<!-- -*- sgml -*- -->

<appendix id="svn.copyright">
  <title>Copyright</title>

  <para>Copyright (c) 2002-2013 Ben Collins-Sussman, Brian
    W. Fitzpatrick, C. Michael Pilato.</para>

  <para>This work is licensed under the Creative Commons Attribution
    License.  To view a copy of this license, visit
    <ulink url="http://creativecommons.org/licenses/by/2.0/" /> or
    send a letter to Creative Commons, 559 Nathan Abbott Way,
    Stanford, California 94305, USA.</para>

  <para>A summary of the license is given below, followed by the full
    legal text.</para>

  <programlisting>
You are free:

    * to copy, distribute, display, and perform the work
    * to make derivative works
    * to make commercial use of the work

Under the following conditions:
	
Attribution. You must give the original author credit.

    * For any reuse or distribution, you must make clear to others the
      license terms of this work.

    * Any of these conditions can be waived if you get permission from
      the author.

Your fair use and other rights are in no way affected by the above.

The above is a summary of the full license below.

====================================================================

Creative Commons Legal Code
Attribution 2.0

CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS
CREATIVE COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS
PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE
WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS
PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND
AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS
YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF
SUCH TERMS AND CONDITIONS.

1. Definitions

   a. "Collective Work" means a work, such as a periodical issue,
      anthology or encyclopedia, in which the Work in its entirety in
      unmodified form, along with a number of other contributions,
      constituting separate and independent works in themselves, are
      assembled into a collective whole. A work that constitutes a
      Collective Work will not be considered a Derivative Work (as
      defined below) for the purposes of this License.

   b. "Derivative Work" means a work based upon the Work or upon the
      Work and other pre-existing works, such as a translation,
      musical arrangement, dramatization, fictionalization, motion
      picture version, sound recording, art reproduction, abridgment,
      condensation, or any other form in which the Work may be recast,
      transformed, or adapted, except that a work that constitutes a
      Collective Work will not be considered a Derivative Work for the
      purpose of this License. For the avoidance of doubt, where the
      Work is a musical composition or sound recording, the
      synchronization of the Work in timed-relation with a moving
      image ("synching") will be considered a Derivative Work for the
      purpose of this License.

   c. "Licensor" means the individual or entity that offers the Work
      under the terms of this License.

   d. "Original Author" means the individual or entity who created the Work.

   e. "Work" means the copyrightable work of authorship offered under
      the terms of this License.

   f. "You" means an individual or entity exercising rights under this
      License who has not previously violated the terms of this
      License with respect to the Work, or who has received express
      permission from the Licensor to exercise rights under this
      License despite a previous violation.

2. Fair Use Rights. Nothing in this license is intended to reduce,
   limit, or restrict any rights arising from fair use, first sale or
   other limitations on the exclusive rights of the copyright owner
   under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
   Licensor hereby grants You a worldwide, royalty-free,
   non-exclusive, perpetual (for the duration of the applicable
   copyright) license to exercise the rights in the Work as stated
   below:

   a. to reproduce the Work, to incorporate the Work into one or more
      Collective Works, and to reproduce the Work as incorporated in
      the Collective Works;

   b. to create and reproduce Derivative Works;

   c. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission the Work including as incorporated in
      Collective Works;

   d. to distribute copies or phonorecords of, display publicly,
      perform publicly, and perform publicly by means of a digital
      audio transmission Derivative Works.

   e.

      For the avoidance of doubt, where the work is a musical composition:

         i. Performance Royalties Under Blanket Licenses. Licensor
            waives the exclusive right to collect, whether
            individually or via a performance rights society
            (e.g. ASCAP, BMI, SESAC), royalties for the public
            performance or public digital performance (e.g. webcast)
            of the Work.

        ii. Mechanical Rights and Statutory Royalties. Licensor waives
            the exclusive right to collect, whether individually or
            via a music rights agency or designated agent (e.g. Harry
            Fox Agency), royalties for any phonorecord You create from
            the Work ("cover version") and distribute, subject to the
            compulsory license created by 17 USC Section 115 of the US
            Copyright Act (or the equivalent in other jurisdictions).

   f. Webcasting Rights and Statutory Royalties. For the avoidance of
      doubt, where the Work is a sound recording, Licensor waives the
      exclusive right to collect, whether individually or via a
      performance-rights society (e.g. SoundExchange), royalties for
      the public digital performance (e.g. webcast) of the Work,
      subject to the compulsory license created by 17 USC Section 114
      of the US Copyright Act (or the equivalent in other
      jurisdictions).

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights
in other media and formats. All rights not expressly granted by
Licensor are hereby reserved.

4. Restrictions.The license granted in Section 3 above is expressly
   made subject to and limited by the following restrictions:

   a. You may distribute, publicly display, publicly perform, or
      publicly digitally perform the Work only under the terms of this
      License, and You must include a copy of, or the Uniform Resource
      Identifier for, this License with every copy or phonorecord of
      the Work You distribute, publicly display, publicly perform, or
      publicly digitally perform. You may not offer or impose any
      terms on the Work that alter or restrict the terms of this
      License or the recipients' exercise of the rights granted
      hereunder. You may not sublicense the Work. You must keep intact
      all notices that refer to this License and to the disclaimer of
      warranties. You may not distribute, publicly display, publicly
      perform, or publicly digitally perform the Work with any
      technological measures that control access or use of the Work in
      a manner inconsistent with the terms of this License
      Agreement. The above applies to the Work as incorporated in a
      Collective Work, but this does not require the Collective Work
      apart from the Work itself to be made subject to the terms of
      this License. If You create a Collective Work, upon notice from
      any Licensor You must, to the extent practicable, remove from
      the Collective Work any reference to such Licensor or the
      Original Author, as requested. If You create a Derivative Work,
      upon notice from any Licensor You must, to the extent
      practicable, remove from the Derivative Work any reference to
      such Licensor or the Original Author, as requested.

   b. If you distribute, publicly display, publicly perform, or
      publicly digitally perform the Work or any Derivative Works or
      Collective Works, You must keep intact all copyright notices for
      the Work and give the Original Author credit reasonable to the
      medium or means You are utilizing by conveying the name (or
      pseudonym if applicable) of the Original Author if supplied; the
      title of the Work if supplied; to the extent reasonably
      practicable, the Uniform Resource Identifier, if any, that
      Licensor specifies to be associated with the Work, unless such
      URI does not refer to the copyright notice or licensing
      information for the Work; and in the case of a Derivative Work,
      a credit identifying the use of the Work in the Derivative Work
      (e.g., "French translation of the Work by Original Author," or
      "Screenplay based on original Work by Original Author"). Such
      credit may be implemented in any reasonable manner; provided,
      however, that in the case of a Derivative Work or Collective
      Work, at a minimum such credit will appear where any other
      comparable authorship credit appears and in a manner at least as
      prominent as such other comparable authorship credit.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING,
LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR
WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED,
STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF
TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE,
NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,
OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT
DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED
WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY
   APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY
   LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE
   OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE
   WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGES.

7. Termination

   a. This License and the rights granted hereunder will terminate
      automatically upon any breach by You of the terms of this
      License. Individuals or entities who have received Derivative
      Works or Collective Works from You under this License, however,
      will not have their licenses terminated provided such
      individuals or entities remain in full compliance with those
      licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any
      termination of this License.

   b. Subject to the above terms and conditions, the license granted
      here is perpetual (for the duration of the applicable copyright
      in the Work). Notwithstanding the above, Licensor reserves the
      right to release the Work under different license terms or to
      stop distributing the Work at any time; provided, however that
      any such election will not serve to withdraw this License (or
      any other license that has been, or is required to be, granted
      under the terms of this License), and this License will continue
      in full force and effect unless terminated as stated above.

8. Miscellaneous

   a. Each time You distribute or publicly digitally perform the Work
      or a Collective Work, the Licensor offers to the recipient a
      license to the Work on the same terms and conditions as the
      license granted to You under this License.

   b. Each time You distribute or publicly digitally perform a
      Derivative Work, Licensor offers to the recipient a license to
      the original Work on the same terms and conditions as the
      license granted to You under this License.

   c. If any provision of this License is invalid or unenforceable
      under applicable law, it shall not affect the validity or
      enforceability of the remainder of the terms of this License,
      and without further action by the parties to this agreement,
      such provision shall be reformed to the minimum extent necessary
      to make such provision valid and enforceable.

   d. No term or provision of this License shall be deemed waived and
      no breach consented to unless such waiver or consent shall be in
      writing and signed by the party to be charged with such waiver
      or consent.

   e. This License constitutes the entire agreement between the
      parties with respect to the Work licensed here. There are no
      understandings, agreements or representations with respect to
      the Work not specified here. Licensor shall not be bound by any
      additional provisions that may appear in any communication from
      You. This License may not be modified without the mutual written
      agreement of the Licensor and You.

Creative Commons is not a party to this License, and makes no warranty
whatsoever in connection with the Work. Creative Commons will not be
liable to You or any party on any legal theory for any damages
whatsoever, including without limitation any general, special,
incidental or consequential damages arising in connection to this
license. Notwithstanding the foregoing two (2) sentences, if Creative
Commons has expressly identified itself as the Licensor hereunder, it
shall have all rights and obligations of Licensor.

Except for the limited purpose of indicating to the public that the
Work is licensed under the CCPL, neither party will use the trademark
"Creative Commons" or any related trademark or logo of Creative
Commons without the prior written consent of Creative Commons. Any
permitted use will be in compliance with Creative Commons'
then-current trademark usage guidelines, as may be published on its
website or otherwise made available upon request from time to time.

Creative Commons may be contacted at http://creativecommons.org/.

====================================================================
</programlisting>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "")
end:
-->
<!-- -*- sgml -*- -->

<preface id="svn.foreword">

  <prefaceinfo>
    <author>
      <firstname>Karl</firstname>
      <surname>Fogel</surname>
    </author>
    <pubdate>Chicago, March 14, 2004.</pubdate>
  </prefaceinfo>

  <title>Foreword</title>

  <para>A bad Frequently Asked Questions (FAQ) sheet is one that is
    composed not of the questions people actually ask, but of the
    questions the FAQ's author <emphasis>wishes</emphasis> people
    would ask.  Perhaps you've seen the type before:</para>

  <blockquote>
    <para>Q: How can I use Glorbosoft XYZ to maximize team
      productivity?</para>
  </blockquote>

  <blockquote>
    <para>A: Many of our customers want to know how they can
      maximize productivity through our patented office groupware
      innovations.  The answer is simple.  First, click on the
      <literal>File</literal> menu, scroll down to
      <literal>Increase Productivity</literal>,
      then </para>
  </blockquote>

  <para>The problem with such FAQs is that they are not, in a
    literal sense, FAQs at all.  No one ever called the tech support
    line and asked, <quote>How can we maximize
    productivity?</quote>  Rather, people asked highly specific
    questions, such as <quote>How can we change the calendaring system
    to send reminders two days in advance instead of one?</quote>
    and so on.  But it's a lot easier to make up imaginary
    Frequently Asked Questions than it is to discover the real ones.
    Compiling a true FAQ sheet requires a sustained, organized
    effort: over the lifetime of the software, incoming questions
    must be tracked, responses monitored, and all gathered into a
    coherent, searchable whole that reflects the collective
    experience of users in the wild.  It calls for the patient,
    observant attitude of a field naturalist.  No grand
    hypothesizing, no visionary pronouncements here open eyes
    and accurate note-taking are what's needed most.</para>

  <para>What I love about this book is that it grew out of just such
    a process, and shows it on every page.  It is the direct result
    of the authors' encounters with users.  It began with Ben
    Collins-Sussman's observation that people were asking the same
    basic questions over and over on the Subversion mailing lists:
    what are the standard workflows to use with Subversion?  Do
    branches and tags work the same way as in other version control
    systems?  How can I find out who made a particular change?</para>

  <para>Frustrated at seeing the same questions day after day, Ben
    worked intensely over a month in the summer of 2002 to write
    <citetitle>The Subversion Handbook</citetitle>, a 60-page
    manual that covered all the basics of using Subversion.  The
    manual made no pretense of being complete, but it was
    distributed with Subversion and got users over that initial hump
    in the learning curve.  When O'Reilly decided to
    publish a full-length Subversion book, the path of least
    resistance was obvious: just expand the Subversion
    handbook.</para>

  <para>The three coauthors of the new book were thus presented
    with an unusual opportunity.  Officially, their task was to
    write a book top-down, starting from a table of contents and an
    initial draft.  But they also had access to a steady
    stream indeed, an uncontrollable geyser of bottom-up
    source material.  Subversion was already in the hands of
    thousands of early adopters, and those users were giving tons of
    feedback, not only about Subversion, but also about its existing
    documentation.</para>

  <para>During the entire time they wrote this book, Ben, Mike, and
    Brian haunted the Subversion mailing lists and chat rooms
    incessantly, carefully noting the problems users were having in
    real-life situations.  Monitoring such feedback was part of their
    job descriptions at CollabNet anyway, and it gave them a huge
    advantage when they set out to document Subversion.  The book
    they produced is grounded firmly in the bedrock of experience,
    not in the shifting sands of wishful thinking; it combines the
    best aspects of user manual and FAQ sheet.  This duality might
    not be noticeable on a first reading.  Taken in order, front to
    back, the book is simply a straightforward description of a
    piece of software.  There's the overview, the obligatory guided
    tour, the chapter on administrative configuration, some advanced
    topics, and of course, a command reference and troubleshooting
    guide.  Only when you come back to it later, seeking the
    solution to some specific problem, does its authenticity shine
    out: the telling details that can only result from encounters
    with the unexpected, the examples honed from genuine use cases,
    and most of all the sensitivity to the user's needs and the
    user's point of view.</para>

  <para>Of course, no one can promise that this book will answer
    every question you have about Subversion.  Sometimes the
    precision with which it anticipates your questions will seem
    eerily telepathic; yet occasionally, you will stumble into a
    hole in the community's knowledge and come away empty-handed.
    When this happens, the best thing you can do is email
    <email>users@subversion.apache.org</email> and present your
    problem.  The authors are still there and still watching, and the
    authors include not just the three listed on the cover, but many others
    who contributed corrections and original material.  From the
    community's point of view, solving your problem is merely a
    pleasant side effect of a much larger project namely,
    slowly adjusting this book, and ultimately Subversion itself, to
    more closely match the way people actually use it.  They are
    eager to hear from you, not only because they can help you, but
    because you can help them.  With Subversion, as with all active
    free software projects, <emphasis>you are not
    alone</emphasis>.</para>

  <para>Let this book be your first companion.</para>

</preface>

<!--
local variables: 
sgml-parent-document: ("book.xml" "foreword")
end:
-->
<!-- -*- sgml -*- -->

<index id="svn.index"/><!-- -*- sgml -*- -->

<reference id="svn.ref.reposhooks">
  <title>Subversion Repository Hook Reference</title>

  <partintro>

    <para>Subversion repositories provide a number of event hooks
      which are essentially opportunities for administrators to extend
      Subversion's functionality at key moments of key operations.
      Repository hooks are implemented as programs executed by
      Subversion itself at those key moments before and after a
      commit, before and after a user locks a file, and so on.</para>
    
    <para>For each hook it provides, Subversion will attempt to
      execute the program of that hook's name which is found in
      the <filename>hooks/</filename> subdirectory of the repository's
      on-disk directory structure.  For example, on a Unix system, the
      start-commit hook script would be installed at
      <filename><replaceable>REPOS_PATH</replaceable>/hooks/start-commit</filename>,
      where it could be a binary executable program, a shell script, a
      Python program, etc.  On a Windows system, the program would be
      installed in the same location, but would be
      named <filename>START-COMMIT.EXE</filename>
      or <filename>START-COMMIT.BAT</filename> instead of
      simply <filename>start-commit</filename>.</para>

    <para>This reference guide describes the various hooks which
      Subversion offers to administrators, detailing when the hook is
      invoked, its input parameters, and how its behavior affects the
      Subversion workflow.</para>

  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.start-commit">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>start-commit</secondary>
    </indexterm>

    <refnamediv>
      <refname>start-commit</refname>
      <refpurpose>Notification of the beginning of a commit.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>start-commit
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>USER</replaceable>
        <replaceable>CAPABILITIES</replaceable>
        <replaceable>TXN-NAME</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>The start-commit hook is run immediately after the
        commit transaction is created and its initial properties
        set.  It is typically used as an early termination
        mechanism, avoiding what could be a lengthy commit process
        which would eventually fail at a later phase anyway due to a
        user's lack of commit privileges or some other commit
        metadata validation failure.</para>

      <para>If the start-commit hook program returns a nonzero exit
        value, the commit process is stopped, the commit transaction
        is destroyed, and anything printed to
        <filename>stderr</filename> is marshalled back to the
        client.</para>

      <para>The start-commit hook is not a suitable place to
        evaluate the substance of a particular commit, as it is
        invoked before any file or directory change information has
        been transmitted.  Use the pre-commit hook script (which is
        described in <xref linkend="svn.ref.reposhooks.pre-commit"
        /> elsewhere in this reference) for that purpose.</para>

      <note>
        <para>Prior to Subversion 1.8, the Subversion invoked the
          start-commit hook <emphasis>before</emphasis> creating the
          commit transaction.  Failure of the script resulted in that
          transaction not being created at all.  This was changed in
          Subversion 1.8, though, to allow implementations of the
          start-commit hook access to the transaction's properties,
          which can include (among other things) the revision log
          associated with the commit.</para>
      </note>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input Parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Authenticated username attempting the commit</para>
        </listitem>
        <listitem>
          <para>Colon-separated list of
            capabilities that a client passes to the server,
            including <literal>depth</literal>,
            <literal>mergeinfo</literal>, and
            <literal>log-revprops</literal> (new in Subversion 1.5)</para>
        </listitem>
        <listitem>
          <para>Commit transaction name (new in Subversion 1.8)</para>
        </listitem>
      </orderedlist>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>

      <para>Access control (e.g., temporarily lock out commits for
        some reason).</para>

      <para>A means to allow access only from clients that have
        certain capabilities.</para>
    </refsect1>

  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.pre-commit">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>pre-commit</secondary>
    </indexterm>

    <refnamediv>
      <refname>pre-commit</refname>
      <refpurpose>Notification just prior to commit completion.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>pre-commit
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>TXN-NAME</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>pre-commit</literal> hook is run just
        before a commit transaction is promoted to a new revision.
        Typically, this hook is used to protect against commits that
        are disallowed due to content or location (e.g., your
        site might require that all commits to a certain branch
        include a ticket number from the bug tracker, or that the
        incoming log message is nonempty).</para>

      <para>If the <literal>pre-commit</literal> hook program
        returns a nonzero exit value, the commit is aborted, the
        commit transaction is removed, and anything printed to
        <filename>stderr</filename> is marshalled back to the client.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>

      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Commit transaction name</para>
        </listitem>
      </orderedlist>

      <para>Additionally, Subversion passes any lock tokens provided
        by the committing client to the hook script via standard
        input.  When present, these are formatted as a single line
        containing the string <literal>LOCK-TOKENS:</literal>,
        followed by additional lines one per lock
        token which contain the lock token information.  Each
        lock token information line consists of the URI-escaped
        repository filesystem path associated with the lock,
        followed by the pipe (<literal>|</literal>) separator
        character, and finally the lock token string.</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Change validation and control</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.post-commit">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>post-commit</secondary>
    </indexterm>

    <refnamediv>
      <refname>post-commit</refname>
      <refpurpose>Notification of a successful commit.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>post-commit
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>REVISION</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>post-commit</literal> hook is run after the
        transaction is committed and a new revision is created.  Most
        people use this hook to send out descriptive emails about
        the commit or to notify some other tool (such as an issue
        tracker) that a commit has happened.  Some configurations
        also use this hook to trigger backup processes.</para>

      <para>If the <literal>post-commit</literal> hook returns a
        nonzero exit status, the commit <emphasis>will
        not</emphasis> be aborted since it has already
        completed.  However, anything that the hook printed
        to <filename>stderr</filename> will be marshalled back to the
        client, making it easier to diagnose hook failures.</para>
            
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Revision number created by the commit</para>
        </listitem>
      </orderedlist>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Commit notification; tool integration</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.pre-revprop-change">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>pre-revprop-change</secondary>
    </indexterm>

    <refnamediv>
      <refname>pre-revprop-change</refname>
      <refpurpose>Notification of a revision property change
        attempt.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>pre-revprop-change
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>REVISION</replaceable>
        <replaceable>USER</replaceable>
        <replaceable>PROPNAME</replaceable>
        <replaceable>ACTION</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>pre-revprop-change</literal> hook is run
        immediately prior to the modification of a revision property
        when performed outside the scope of a normal commit.  Unlike
        the other hooks, the default state of this one is to deny
        the proposed action.  The hook must actually exist and
        return a zero exit value before a revision property
        modification can happen.</para>

      <para>If the <literal>pre-revprop-change</literal> hook doesn't
        exist, isn't executable, or returns a nonzero exit value, no
        change to the property will be made, and anything printed
        to <filename>stderr</filename> is marshalled back to the
        client.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>

      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Revision whose property is about to be modified</para>
        </listitem>
        <listitem>
          <para>Authenticated username attempting the property change</para>
        </listitem>
        <listitem>
          <para>Name of the property changed</para>
        </listitem>
        <listitem>
          <para>Change description: <literal>A</literal> (added),
            <literal>D</literal> (deleted), or <literal>M</literal>
            (modified)</para>
        </listitem>
      </orderedlist>

      <para>Additionally, Subversion passes the intended new value
         of the property to the hook program via standard
         input.</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Access control; change validation and control</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.post-revprop-change">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>post-revprop-change</secondary>
    </indexterm>

    <refnamediv>
      <refname>post-revprop-change</refname>
      <refpurpose>Notification of a successful revision property 
        change.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>post-revprop-change
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>REVISION</replaceable>
        <replaceable>USER</replaceable>
        <replaceable>PROPNAME</replaceable>
        <replaceable>ACTION</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>post-revprop-change</literal> hook is run
        immediately after the modification of a revision property
        when performed outside the scope of a normal commit.  As you can
        derive from the description of its counterpart, the
        <literal>pre-revprop-change</literal> hook, this hook will
        not run at all unless
        the <literal>pre-revprop-change</literal> hook is
        implemented.  It is typically used to send email
        notification of the property change.</para>

      <para>If the <literal>post-revprop-change</literal> hook returns a
        nonzero exit status, the change <emphasis>will
        not</emphasis> be aborted since it has already
        completed.  However, anything that the hook printed
        to <filename>stderr</filename> will be marshalled back to the
        client, making it easier to diagnose hook failures.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Revision whose property was modified</para>
        </listitem>
        <listitem>
          <para>Authenticated username of the person making the change</para>
        </listitem>
        <listitem>
          <para>Name of the property changed</para>
        </listitem>
        <listitem>
          <para>Change description: <literal>A</literal> (added),
            <literal>D</literal> (deleted), or <literal>M</literal>
            (modified)</para>
        </listitem>
      </orderedlist>

      <para>Additionally, Subversion passes to the hook program, via
        standard input, the previous value of the property.</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Property change notification</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.pre-lock">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>pre-lock</secondary>
    </indexterm>

    <refnamediv>
      <refname>pre-lock</refname>
      <refpurpose>Notification of a path lock attempt.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>pre-lock
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>PATH</replaceable>
        <replaceable>USER</replaceable>
        <replaceable>COMMENT</replaceable>
        <replaceable>STEAL</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>pre-lock</literal> hook runs whenever
        someone attempts to lock a path.  It can be used to prevent
        locks altogether or to create a more complex policy
        specifying exactly which users are allowed to lock
        particular paths.  If the hook notices a preexisting lock,
        it can also decide whether a user is allowed
        to <quote>steal</quote> the existing lock.</para>

      <para>If the <literal>pre-lock</literal> hook program returns
        a nonzero exit value, the lock action is aborted and
        anything printed to <filename>stderr</filename> is
        marshalled back to the client.</para>

      <para>The hook program may optionally dictate the lock token
        which will be assigned to the lock by printing the desired
        lock token to standard output.  Because of this,
        implementations of this hook should carefully avoid
        unexpected output sent to standard output.</para>

      <warning>
        <para>If the <literal>pre-lock</literal> script takes
          advantage of lock token dictation feature, the
          responsibility of generating a <emphasis>unique</emphasis>
          lock token falls to the script itself.  Failure to
          generate unique lock tokens may result in
          undefined and very likely,
          undesired behavior.</para>
      </warning>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Versioned path that is to be locked</para>
        </listitem>
        <listitem>
          <para>Authenticated username of the person attempting the 
            lock</para>
        </listitem>
        <listitem>
          <para>Comment provided when the lock was created</para>
        </listitem>
        <listitem>
          <para><literal>1</literal> if the user is attempting to
            steal an existing lock; <literal>0</literal>
            otherwise</para>
        </listitem>
      </orderedlist>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Access control</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.post-lock">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>post-lock</secondary>
    </indexterm>

    <refnamediv>
      <refname>post-lock</refname>
      <refpurpose>Notification of a successful path lock.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>post-lock
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>USER</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>post-lock</literal> hook runs after one or
        more paths have been locked.  It is typically used to send
        email notification of the lock event.</para>

      <para>If the <literal>post-lock</literal> hook returns a
        nonzero exit status, the lock <emphasis>will
        not</emphasis> be aborted since it has already
        completed.  However, anything that the hook printed
        to <filename>stderr</filename> will be marshalled back to the
        client, making it easier to diagnose hook failures.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Authenticated username of the person who locked the 
            paths</para>
        </listitem>
      </orderedlist>

      <para>Additionally, the list of paths locked is passed to the
        hook program via standard input, one path per line.</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Lock notification</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.pre-unlock">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>pre-unlock</secondary>
    </indexterm>

    <refnamediv>
      <refname>pre-unlock</refname>
      <refpurpose>Notification of a path unlock attempt.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>pre-unlock
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>PATH</replaceable>
        <replaceable>USER</replaceable>
        <replaceable>TOKEN</replaceable>
        <replaceable>BREAK-UNLOCK</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>pre-unlock</literal> hook runs whenever
        someone attempts to remove a lock on a file.  It can be used
        to create policies that specify which users are allowed to
        unlock particular paths.  It's particularly important for
        determining policies about lock breakage.  If user A locks a
        file, is user B allowed to break the lock?  What if the lock
        is more than a week old?  These sorts of things can be
        decided and enforced by the hook.</para>

      <para>If the <literal>pre-unlock</literal> hook program
        returns a nonzero exit value, the unlock action is aborted
        and anything printed to <filename>stderr</filename> is marshalled back to the
        client.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Versioned path which is to be unlocked</para>
        </listitem>
        <listitem>
          <para>Authenticated username of the person attempting the 
            unlock</para>
        </listitem>
        <listitem>
          <para>Lock token associated with the lock which is to be
            removed</para>
        </listitem>
        <listitem>
          <para><literal>1</literal> if the user is attempting to
            break the lock; <literal>0</literal> otherwise</para>
        </listitem>
      </orderedlist>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Access control</para>
    </refsect1>
  
  </refentry>
      
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.reposhooks.post-unlock">
  
    <indexterm>
      <primary>hook scripts</primary>
      <secondary>post-unlock</secondary>
    </indexterm>

    <refnamediv>
      <refname>post-unlock</refname>
      <refpurpose>Notification of a successful path unlock.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>post-unlock
        <replaceable>REPOS-PATH</replaceable>
        <replaceable>USER</replaceable></literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <literal>post-unlock</literal> hook runs after one
        or more paths have been unlocked.  It is typically used to
        send email notification of the unlock event.</para>

      <para>If the <literal>post-unlock</literal> hook returns a
        nonzero exit status, the unlock <emphasis>will
        not</emphasis> be aborted since it has already
        completed.  However, anything that the hook printed
        to <filename>stderr</filename> will be marshalled back to the
        client, making it easier to diagnose hook failures.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Input parameter(s)</title>

      <para>The command-line arguments passed to the hook program,
        in order, are:</para>
      
      <orderedlist>
        <listitem>
          <para>Repository path</para>
        </listitem>
        <listitem>
          <para>Authenticated username of the person who unlocked the 
            paths</para>
        </listitem>
      </orderedlist>

      <para>Additionally, the list of paths unlocked is passed to the
        hook program via standard input, one path per line.</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Common uses</title>
      <para>Unlock notification</para>
    </refsect1>
  
  </refentry>
</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svn">
  <title>svn Reference Subversion Command-Line Client</title>
    
  <partintro>
    <para><command>svn</command> is the official command-line client
      of Subversion.  Its functionality is offered via a collection of
      task-specific subcommands, most of which accept a number of
      options for fine-grained control of the program's
      behavior.</para>

    <para>When using the <command>svn</command> program, subcommands
      and other non-option arguments must appear in a specified order
      on the command line.  Options, on the other hand, may appear
      anywhere on the command line (after the program name, of
      course), and in general, their order is irrelevant.  For
      example, all of the following are valid ways to use <command>svn
      status</command>, and are interpreted in exactly the same
      way:</para>

    <informalexample>
      <screen>
$ svn -vq status myfile
$ svn status -v -q myfile
$ svn -q status -v myfile
$ svn status -vq myfile
$ svn status myfile -qv
</screen>
    </informalexample>

    <para>The following sections describe each of the various
      subcommands and options provided by the <command>svn</command>
      command-line client program, including some examples of each
      subcommand's typical uses.</para>

    <para>While Subversion has different options for its
      subcommands, all options exist in a single
      namespace that is, each option is guaranteed to mean the
      roughly same thing regardless of the subcommand you use it
      with.  For example, <option>--verbose</option>
      (<option>-v</option>) always means <quote>verbose
      output,</quote> regardless of the subcommand you use it
      with.</para>

    <para>The <command>svn</command> command-line client usually
      exits quickly with an error if you pass it an option which
      does not apply to the specified subcommand.  But as of
      Subversion 1.5, several of the options which apply to
      all or nearly all of the subcommands have been
      deemed acceptable by all subcommands, even if they have no
      effect on some of them.  (This change was made primarily to
      improve the client's ability to called from custom wrapping
      scripts.)  These options appear grouped together in the
      command-line client's usage messages as global options, as can
      be seen in the following bit of output:</para>

    <informalexample>
      <screen>
$ svn help upgrade
upgrade: Upgrade the metadata storage format for a working copy.
usage: upgrade [WCPATH...]

  Local modifications are preserved.

Valid options:
  -q [--quiet]             : print nothing, or only summary information

Global options:
  --username ARG           : specify a username ARG
  --password ARG           : specify a password ARG
  --no-auth-cache          : do not cache authentication tokens
  --non-interactive        : do no interactive prompting
  --trust-server-cert      : accept SSL server certificates from unknown
                             certificate authorities without prompting (but only
                             with '--non-interactive')
  --config-dir ARG         : read user configuration files from directory ARG
  --config-option ARG      : set user configuration option in the format:
                                 FILE:SECTION:OPTION=[VALUE]
                             For example:
                                 servers:global:http-library=serf
$
</screen>
    </informalexample>

    <para><command>svn</command> subcommands recognize the following
      options:</para>
      
    <variablelist id="svn.ref.svn.sw">
      <title>svn Options</title>
      
      <varlistentry id="svn.ref.svn.sw.accept">
        <term><option>--accept</option> <replaceable>ACTION</replaceable></term>
        <listitem>
          <para>Specifies an action for automatic conflict
            resolution, disabling the interactive prompts which ask
            the user how to handle each conflict as it is noticed.
            Though which of the specific actions are applicable
            differs depending on which subcommand is in use,
            Subversion supports the following long (and short)
            values for <replaceable>ACTION</replaceable>:</para>
          <variablelist>
            <varlistentry>
              <term><literal>postpone</literal>
                (<literal>p</literal>)</term>
              <listitem>
                <para>Take no resolution action at all and instead
                  allow the conflicts to be recorded for future
                  resolution.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>edit</literal>
                (<literal>e</literal>)</term>
              <listitem>
                <para>Open each conflicted file in a text editor for
                  manual resolution of line-based conflicts.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>launch</literal>
                (<literal>l</literal>)</term>
              <listitem>
                <para>Launch an interactive merge conflict
                  resolution tool for each conflicted file.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>base</literal></term>
              <listitem>
                <para>Choose the file that was the (unmodified)
                  <literal>BASE</literal> revision before you tried
                  to integrate changes from the server into
                  your working copy.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>working</literal></term>
              <listitem>
                <para>Assuming that you've manually handled the
                  conflict resolution, choose the version of the file
                  as it currently stands in your working copy.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>mine-full</literal>
                (<literal>mf</literal>)</term>
              <listitem>
                <para>Resolve conflicted files by preserving all
                  local modifications and discarding all changes
                  fetched from the server during the operation which
                  caused the conflict.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>theirs-full</literal>
                (<literal>tf</literal>)</term>
              <listitem>
                <para>Resolve conflicted files by discarding all
                  local modifications and integrating all changes
                  fetched from the server during the operation which
                  caused the conflict.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>mine-conflict</literal>
                (<literal>mc</literal>)</term>
              <listitem>
                <para>Resolve conflicted files by preferring local
                  modifications over the changes fetched from the
                  server in conflicting regions of each file's
                  content.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><literal>theirs-conflict</literal>
                (<literal>tc</literal>)</term>
              <listitem>
                <para>Resolve conflicted files by preferring the
                  changes fetched from the server over local
                  modifications in conflicting regions of each file's
                  content.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>Consult the output of <command>svn help
            <replaceable>SUBCOMMAND</replaceable></command> to see
            exactly which actions are supported by the specific
            subcommand of interest.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.allow_mixed_revisions">
        <term><option>--allow-mixed-revisions</option></term>
        <listitem>
          <para>Disables the verification performed by default
            by <command>svn merge</command> as of Subversion
            1.7 that the target of a merge operation and all
            of its children are at a uniform revision.  While
            merging into a single-revision working copy target is
            the recommended best practice, this option may be used
            to permit merges into mixed-revision working copies as
            necessary.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.auto_props">
        <term><option>--auto-props</option></term>
        <listitem>
          <para>Enables automatic property assignment (per runtime
            configuration rules), overriding the
            <literal>enable-auto-props</literal> runtime
            configuration directive.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.change">
        <term><option>--change</option> (<option>-c</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Perform the requested operation using a specific
            <quote>change</quote>.  Generally speaking, this option
            is syntactic sugar for <userinput>-r
            <replaceable>ARG-1</replaceable>:<replaceable>ARG</replaceable></userinput>.
            Some subcommands permit a comma-separated list of
            revision number arguments (e.g., <userinput>-c
            <replaceable>ARG1</replaceable>,<replaceable>ARG2</replaceable>,<replaceable>ARG3</replaceable></userinput>).
            Alternatively, you can provide two arguments separated
            by a dash (as
            in <userinput>-c <replaceable>ARG1</replaceable>-<replaceable>ARG2</replaceable></userinput>)
            to identify the range of revisions
            between <replaceable>ARG1</replaceable>
            and <replaceable>ARG2</replaceable>, inclusive.
            Finally, if the revision argument is negated, the
            implied revision range is reversed: <userinput>-c
            -45</userinput> is equivalent to <userinput>-r
            45:44</userinput>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.changelist">
        <term><option>--changelist</option> (<option>--cl</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Instructs Subversion to operate only on members of the changelist named
            <replaceable>ARG</replaceable>.  You can use this option
            multiple times to specify sets of changelists.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.config_dir">
        <term><option>--config-dir</option> <replaceable>DIR</replaceable></term>
        <listitem>
          <para>Instructs Subversion to read configuration
            information from the specified directory instead of the
            default location (<filename>.subversion</filename> in
            the user's home directory).</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.config_option">
        <term><option>--config-option</option> <replaceable>CONFSPEC</replaceable></term>
        <listitem>
          <para>Sets, for the duration of the command, the value of
            a runtime configuration
            option.  <replaceable>CONFSPEC</replaceable> is a string
            which specifies the configuration option namespace, name
            and value that you'd like to assign, formatted as
            <replaceable>FILE</replaceable>:<replaceable>SECTION</replaceable>:<replaceable>OPTION</replaceable>=[<replaceable>VALUE</replaceable>].
            In this syntax, <replaceable>FILE</replaceable>
            and <replaceable>SECTION</replaceable> are the runtime
            configuration file (either <literal>config</literal>
            or <literal>servers</literal>) and the section thereof,
            respectively, which contain the option whose value you
            wish to change.  <replaceable>OPTION</replaceable> is,
            of course, the option itself,
            and <replaceable>VALUE</replaceable> the value (if any)
            you wish to assign to the option.  For example, to
            temporarily disable the use of the automatic property
            setting feature,
            use <option>--config-option=config:miscellany:enable-auto-props=no</option>.
            You can use this option multiple times to change
            multiple option values simultaneously.</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.depth">
        <term><option>--depth</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Instructs Subversion to limit the scope of an
            operation to a particular tree
            depth.  <replaceable>ARG</replaceable> is one of
            <literal>empty</literal> (only the target
            itself), <literal>files</literal> (the target and any
            immediate file children thereof),
            <literal>immediates</literal> (the target and any
            immediate children thereof), or
            <literal>infinity</literal> (the target and all of its
            descendants full recursion).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.diff">
        <term><option>--diff</option></term>
        <listitem>
          <para>Enables a special output mode for <command>svn
            log</command> which includes a difference report (a
            la <command>svn diff</command>) as part of each
            revision's information.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.diff_cmd">
        <term><option>--diff-cmd</option> <replaceable>CMD</replaceable></term>
        <listitem>
          <para>Specifies an external program to use to show
            differences between files.  When <command>svn
            diff</command> is invoked without this option, it uses
            Subversion's internal differencing engine, which provides
            unified diffs by default.  If you want to use an
            external differencing program, use <option>--diff-cmd</option>.
            You can then pass options to the specified program using the
            <option>--extensions</option> (<option>-x</option>)
            option.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.diff3_cmd">
        <term><option>--diff3-cmd</option> <replaceable>CMD</replaceable></term>
        <listitem>
          <para>Specifies an external 3-way differencing program
            (used to merge line-based changes into files).</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.dry_run">
        <term><option>--dry-run</option></term>
        <listitem>
          <para>Goes through all the motions of running a command,
            but makes no actual changes either on disk or in
            the repository.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.editor_cmd">
        <term><option>--editor-cmd</option> <replaceable>CMD</replaceable></term>
        <listitem>
          <para>Specifies an external program to use to edit a log message
            or a property value.  See the <literal>editor-cmd</literal>
            section in <xref linkend="svn.advanced.confarea.opts.config"/>
            for ways to specify a default editor.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.encoding">
        <term><option>--encoding</option> <replaceable>ENC</replaceable></term>
        <listitem>
          <para>Tells Subversion that your commit message is
            composed using the character encoding provided.  The
            default character encoding is derived from your
            operating system's native locale; use this option if
            your commit message is composed using any other
            encoding.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.extensions">
        <term><option>--extensions</option> (<option>-x</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Specifies customizations which Subversion should
            make when performing difference calculations.  Valid
            extensions include:</para>
          <variablelist>
            <varlistentry>
              <term><option>--ignore-space-change</option> (<option>-b</option>)</term>
              <listitem>
                <para>Ignore changes in the amount of white space.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--ignore-all-space</option> (<option>-w</option>)</term>
              <listitem>
                <para>Ignore all white space.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--ignore-eol-style</option></term>
              <listitem>
                <para>Ignore changes in EOL (end-of-line) style.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--show-c-function</option> (<option>-p</option>)</term>
              <listitem>
                <para>Show C function names in the diff output.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--unified</option> (<option>-u</option>)</term>
              <listitem>
                <para>Show three lines of unified diff context.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>The default value of <replaceable>ARG</replaceable>
            is <literal>-u</literal>.  If you wish to pass multiple
            arguments, you must enclose all of them in quotes.</para>
          <para>Note that when Subversion is configured to invoke an
            external diff command, the value of
            the <option>--extension</option> (<option>-x</option>)
            option isn't restricted to the previously mentioned
            options, but may be <emphasis>any</emphasis> additional
            arguments which Subversion should pass to that command.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.file">
        <term><option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable></term>
        <listitem>
          <para>Uses the contents of the named file for the
            specified subcommand.  Different subcommands do
            different things with this content.  For example,
            <command>svn commit</command> uses the content as a
            commit log message, whereas <command>svn
            propset</command> uses it as a property value.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.force">
        <term><option>--force</option></term>
        <listitem>
          <para>Forces a particular command or operation to run.
            Subversion will prevent you from performing some
            operations in normal usage, but you can pass this option
            to tell Subversion <quote>I know what I'm doing as well
            as the possible repercussions of doing it, so let me at
            'em.</quote> This option is the programmatic equivalent
            of doing your own electrical work with the power
            on if you don't know what you're doing, you're
            likely to get a nasty shock.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.force_log">
        <term><option>--force-log</option></term>
        <listitem>
          <para>Forces a suspicious parameter passed to the
            <option>--message</option> (<option>-m</option>) or
            <option>--file</option> (<option>-F</option>) option to
            be accepted as valid.  By default, Subversion will
            produce an error if parameters to these options look
            like they might instead be targets of the subcommand.
            For example, if you pass a versioned file's path to the
            <option>--file</option> (<option>-F</option>) option,
            Subversion will assume you've made a mistake, that the
            path was instead intended as the target of the
            operation, and that you simply failed to provide some
            other unversioned file as the source of your
            log message.  To assert your intent and override these
            types of errors, pass the <option>--force-log</option>
            option to subcommands that accept log messages.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.git">
        <term><option>--git</option></term>
        <listitem>
          <para>Enables a special output mode for <command>svn
            diff</command> designed for cross-compatibility with the
            popular Git distributed version control system.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.help">
        <term><option>--help</option> (<option>-h</option>, <option>-?</option>)</term>
        <listitem>
          <para>If used with one or more subcommands, shows the
            built-in help text for each.  If used alone, it displays
            the general client help text.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.ignore_ancestry">
        <term><option>--ignore-ancestry</option></term>
        <listitem>
          <para>Tells Subversion to ignore ancestry when calculating
            differences (rely on path contents alone).  Also disables
            <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
            when used with the <command>svn merge</command> subcommand.
        </para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.ignore_externals">
        <term><option>--ignore-externals</option></term>
        <listitem>
          <para>Tells Subversion to ignore externals definitions and
            the external working copies managed by them.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.ignore_keywords">
        <term><option>--ignore-keywords</option></term>
        <listitem>
          <para>Disables keyword expansion.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.ignore_whitespace">
        <term><option>--ignore-whitespace</option></term>
        <listitem>
          <para>Instructs <command>svn patch</command> to ignore
            whitespace when attempting to identify patch
            context.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.incremental">
        <term><option>--incremental</option></term>
        <listitem>
          <para>Prints output in a format suitable for
            concatenation to prior similar output.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.internal_diff">
        <term><option>--internal-diff</option></term>
        <listitem>
          <para>Instructs Subversion to use its built-in
            differencing engine despite any external differencing
            mechanism that may be specified for use in the user's
            runtime configuration.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.keep_changelists">
        <term><option>--keep-changelists</option></term>
        <listitem>
          <para>Tells Subversion not to remove the changelist assigments
            from working copy items after committing.</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.keep_local">
        <term><option>--keep-local</option></term>
        <listitem>
          <para>Keeps the local copy of a file or directory (used
            with the <command>svn delete</command> command).</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.limit">
        <term><option>--limit</option> (<option>-l</option>) <replaceable>NUM</replaceable></term>
        <listitem>
          <para>Shows only the first <replaceable>NUM</replaceable>
            log messages.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.message">
        <term><option>--message</option> (<option>-m</option>) <replaceable>MESSAGE</replaceable></term>
        <listitem>
          <para>Indicates that you will specify either a log message
            or a lock comment on the command line, following this
            option.  For example:</para>

          <informalexample>
            <screen>
$ svn commit -m "They don't make Sunday."
</screen>
          </informalexample>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.native_eol">
        <term><option>--native-eol</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Causes <command>svn export</command> to use a
            specific end-of-line sequence as if it was the native
            sequence for the client platform.
            <replaceable>ARG</replaceable> may be one
            of <literal>CR</literal>, <literal>LF</literal>,
            or <literal>CRLF</literal>.</para>
        </listitem>
      </varlistentry>
            
      <varlistentry id="svn.ref.svn.sw.new">
        <term><option>--new</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Uses <replaceable>ARG</replaceable> as the newer
            target (for use with <command>svn diff</command>).</para>
        </listitem>
      </varlistentry>
    
      <varlistentry id="svn.ref.svn.sw.no_auth_cache">
        <term><option>--no-auth-cache</option></term>
        <listitem>
          <para>Prevents caching of authentication information
            (e.g., username and password) in the Subversion runtime
            configuration directories.</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_auto_props">
        <term><option>--no-auto-props</option></term>
        <listitem>
          <para>Disables automatic property setting, overriding the
            <literal>enable-auto-props</literal> runtime
            configuration directive.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_diff_deleted">
        <term><option>--no-diff-deleted</option></term>
      <listitem>
          <para>Prevents Subversion from printing differences for
            deleted files.  The default behavior when you remove a
            file is for <command>svn diff</command> to print the
            same differences that you would see if you had kept
            the file but removed all of its content.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.no_ignore">
        <term><option>--no-ignore</option></term>
        <listitem>
          <para>Shows files in the status listing or adds/imports files
            that would normally be omitted since they match a pattern
            in the <literal>global-ignores</literal> configuration
            option or the <literal>svn:ignore</literal> or
            <literal>svn:global-ignores</literal>properties.  See <xref
            linkend="svn.advanced.confarea.opts.config"/> and <xref
            linkend="svn.advanced.props.special.ignore"/> for more
            information.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.no_unlock">
        <term><option>--no-unlock</option></term>
        <listitem>
          <para>Tells Subversion not to automatically unlock files.
            (The default commit behavior is to unlock all files
            listed as part of the commit.)  See
            <xref linkend="svn.advanced.locking"/> for more
            information.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.non_interactive">
        <term><option>--non-interactive</option></term>
        <listitem>
          <para>Disables all interactive prompting.  Some examples
            of interactive prompting include requests for
            authentication credentials and conflict resolution
            decisions.  This is useful if you're running Subversion
            inside an automated script and it's more appropriate to
            have Subversion fail than to prompt for more
            information.</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.non_recursive">
        <term><option>--non-recursive</option> (<option>-N</option>)</term>
        <listitem>
          <para><emphasis>Deprecated</emphasis>.  Stops a subcommand
            from recursing into subdirectories.  Most subcommands
            recurse by default, but some do not.  Users should avoid
            this option and use the more precise <option>--depth</option>
            option instead.  For most subcommands, specifying
            <option>--non-recursive</option> produces behavior which
            is the same as if you'd specified
            <option>--depth=files</option>, but there are exceptions:
            non-recursive <command>svn status</command> operates at the
            <literal>immediates</literal> depth, and the  non-recursive
            forms of <command>svn revert</command>,
            <command>svn add</command>, and <command>svn commit</command>
            operate at an <literal>empty</literal> depth.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.notice_ancestry">
        <term><option>--notice-ancestry</option></term>
        <listitem>
          <para>Pays attention to ancestry when calculating 
            differences.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.old">
        <term><option>--old</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Uses <replaceable>ARG</replaceable> as the older
            target (for use with <command>svn diff</command>).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.parents">
        <term><option>--parents</option></term>
        <listitem>
          <para>Creates and adds nonexistent or nonversioned parent
            subdirectories to the working copy or repository as part
            of an operation.  This is useful for automatically
            creating multiple subdirectories where none currently
            exist.  If performed on a URL, all the directories will
            be created in a single commit.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.password">
        <term><option>--password</option> <replaceable>PASSWD</replaceable></term>
        <listitem>
          <para>Specifies the password to use when authenticating
            against a Subversion server.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.quiet">
        <term><option>--quiet</option> (<option>-q</option>)</term>
        <listitem>
          <para>Requests that the client print only essential
            information while performing an operation.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.record_only">
        <term><option>--record-only</option></term>
        <listitem>
          <para>Enables a special mode of <command>svn
          merge</command> in which the specified merge operation is
          recorded in the local merge tracking information, but is
          not actually performed.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.recursive">
        <term><option>--recursive</option> (<option>-R</option>)</term>
        <listitem>
          <para>Makes a subcommand recurse into subdirectories.
            (Most subcommands recurse by default.)</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.reintegrate">
        <term><option>--reintegrate</option></term>
        <listitem>
          <para>Deprecated.  Used with the <command>svn merge</command>
            subcommand to merge changes from a feature branch back into
            the feature branch's ancestor branch.  Since Subversion 1.8
            the <command>svn merge</command> subcommand automatically
            detects this scenario and performs the appropriate merge.
            See
            <xref linkend="svn.branchmerge.basicmerging.reintegrate"/>
            for details.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.relocate">
        <term><option>--relocate</option></term>
        <listitem>
          <para>Deprecated.  When used with the <command>svn
            switch</command> subcommand, changes the location of the
            repository that your working copy references.  The
            preferred approach as of Subversion 1.7, however, is to
            use the <command>svn relocate</command> subcommand.  See
            <xref linkend="svn.ref.svn.c.relocate" /> for more
            details and an example.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.remove">
        <term><option>--remove</option></term>
        <listitem>
          <para>Used with <command>svn changelist</command> to
            disassociate rather than associate (which is the
            default operation) the target(s) from a
            changelist.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.reverse_diff">
        <term><option>--reverse-diff</option></term>
        <listitem>
          <para>Causes <command>svn patch</command> to interpret the
            input patch instructions in reverse treating added
            lines as removed ones and vice-versa.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.revision">
        <term><option>--revision</option> (<option>-r</option>) <replaceable>REV</replaceable></term>
        <listitem>
          <para>Specifies a revision (or range of revisions) on with
            which to operate.  You can provide revision numbers,
            keywords, or dates (in curly braces) as arguments to the
            revision option.  If you wish to offer a range of
            revisions, you can provide two revisions separated by a
            colon.  For example:</para>

          <informalexample>
            <screen>
$ svn log -r 1729
$ svn log -r 1729:HEAD
$ svn log -r 1729:1744
$ svn log -r {2001-12-04}:{2002-02-17}
$ svn log -r 1729:{2002-02-17}
</screen>
          </informalexample>

          <para>See <xref linkend="svn.tour.revs.keywords"/> for more
            information.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.revprop">
        <term><option>--revprop</option></term>
        <listitem>
          <para>Operates on a revision property instead of a
            property specific to a file or directory.  This option
            requires that you also pass a revision with the
            <option>--revision</option> (<option>-r</option>)
            option.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.search">
        <term><option>--search</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Filters log messages to show only those that match
            the search pattern <replaceable>ARG</replaceable>.  Log
            messages are displayed only if the provided search
            pattern matches any of the author, date, log message
            text (unless <option>--quiet</option> is used), or, if
            the <option>--verbose</option> option is also provided,
            a changed path.  If multiple <option>--search</option>
            options are provided, a log message is shown if it
            matches any of the provided search patterns.  If
            <option>--limit</option> is used, it restricts the
            number of log messages searched, rather than
            restricting the output to a particular number of
            matching log messages.</para>

          <para>The search pattern may include "glob syntax"
            wildcards:</para>

          <variablelist>
            <varlistentry>
              <term>
                <literal>?</literal>
              </term>
              <listitem>
                <para>Matches any single character.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>*</literal>
              </term>
              <listitem>
                <para>Matches a sequence of arbitrary characters.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>[ABC]</literal>
              </term>
              <listitem>
                <para>Matches any of the characters listed inside the
                  brackets.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.search_and">
        <term><option>--search-and</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>The option's argument is combined with the pattern from
            the previous <option>--search</option>
            or <option>--search-and</option> option on the command
            line.  Log message is shown only if it matches the
            combined search pattern.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.set_depth">
        <term><option>--set-depth</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Sets the sticky depth on a directory in a working copy
            to one of <literal>exclude</literal>, <literal>empty</literal>,
            <literal>files</literal>, <literal>immediates</literal>,
            or <literal>infinity</literal>.  For detailed coverage
            of what these mean and how to use this option, see
            <xref linkend="svn.advanced.sparsedirs" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.show_copies_as_adds">
        <term><option>--show-copies-as-adds</option></term>
        <listitem>
          <para>Enables a special output mode for <command>svn
            diff</command> in which the content difference for a
            file created via a copy operation appears as it would
            for a brand new file (with each line therein appearing
            as an addition to an empty file) rather than as a delta
            against the original file from which the copy was
            created.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.show_inherited_props">
        <term><option>--show-inherited-props</option></term>
        <listitem>
          <para>Causes <command>svn propget</command> and <command>
            svn proplist</command> to display the versioned properties
            inherited by the target file or directory.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.show_revs">
        <term><option>--show-revs</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Used to make <command>svn mergeinfo</command>
            display certain classes of merge tracking
            information.  <replaceable>ARG</replaceable> may be
            either <literal>merged</literal>
            or <literal>eligible</literal>, indicating a desire to
            see revisions either already merged or eligible for future
            merge from the specified source URL, respectively.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.show_updates">
        <term><option>--show-updates</option> (<option>-u</option>)</term>
        <listitem>
          <para>Causes the client to display information about
            which files in your working copy are out of date.
            This doesn't actually update any of your
            files it just shows you which files will be
            updated if you then use <command>svn update</command>.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.stop_on_copy">
        <term><option>--stop-on-copy</option></term>
        <listitem>
          <para>Causes a Subversion subcommand that traverses
            the history of a versioned resource to stop harvesting
            that historical information when a copy that is, a
            location in history where that resource was copied from
            another location in the repository is
            encountered.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.strict">
        <term><option>--strict</option></term>
        <listitem>
          <para>Causes Subversion to use strict semantics, a notion
            that is rather vague unless talking about specific
            subcommands (namely, <command>svn propget</command>).</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.strip">
        <term><option>--strip</option> <replaceable>NUM</replaceable></term>
        <listitem>
          <para>Used by <command>svn patch</command> to
            ignore <replaceable>NUM</replaceable> leading path
            components found on paths specified in the patch input
            file.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.summarize">
        <term><option>--summarize</option></term>
        <listitem>
          <para>Display only high-level summary notifications about
            the operation instead of its detailed output.</para>
        </listitem>
      </varlistentry>
       
      <varlistentry id="svn.ref.svn.sw.targets">
        <term><option>--targets</option> <replaceable>FILENAME</replaceable></term>
        <listitem>
          <para>Tells Subversion to read additional target paths for
            the operation from <replaceable>FILENAME</replaceable>.
            <replaceable>FILENAME</replaceable> should contain one
            path per line, with each path expected to use the same
            encoding and formatting that it would if you had
            specified it directly as an argument on the command
            line.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.trust_server_cert">
        <term><option>--trust-server-cert</option></term>
        <listitem>
          <para>When used with <option>--non-interactive</option>,
            instructs Subversion to accept SSL server certificates
            issued by unknown certificate authorities without first
            prompting the user.  For security's sake, you should use
            this option only when the integrity of the remote server
            and the network path between it and your client is known
            to be trustworthy.</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.use_merge_history">
        <term><option>--use-merge-history</option> (<option>-g</option>)</term>
        <listitem>
          <para>Uses or displays additional information from merge
            history.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.username">
        <term><option>--username</option> <replaceable>NAME</replaceable></term>
        <listitem>
          <para>Specifies the username to use when authenticating
            against a Subversion server.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>

          <note>
            <para>This option is accepted by
              all <command>svn</command> subcommands.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.verbose">
        <term><option>--verbose</option> (<option>-v</option>)</term>
        <listitem>
          <para>Requests that the client print out as much
            information as it can while running any subcommand.
            This may result in Subversion printing out additional
            fields, detailed information about every file, or
            additional information regarding its actions.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.version">
        <term><option>--version</option></term>
        <listitem>
          <para>Prints the client version info.  This information
            includes not only the version number of the client, but
            also a listing of all repository access modules that the
            client can use to access a Subversion repository.
            With <option>--quiet</option> (<option>-q</option>) it
            prints only the version number in a compact form.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svn.sw.with_all_revprops">
        <term><option>--with-all-revprops</option></term>
        <listitem>
          <para>Used with the <option>--xml</option> option
          to <command>svn log</command>, instructs Subversion to
          retrieve and display all revision properties the
          standard ones used internally by Subversion as well as any
          user-defined ones in the log output.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.with_no_revprops">
        <term><option>--with-no-revprops</option></term>
        <listitem>
          <para>Used with the <option>--xml</option> option
          to <command>svn log</command>, instructs Subversion to
          omit all revision properties including the standard
          log message, author, and revision datestamp from the
          log output.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.with_revprop">
        <term><option>--with-revprop</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>When used with any command that writes to the
            repository, sets the revision property, using the
            <replaceable>NAME=VALUE</replaceable> format,
            <replaceable>NAME</replaceable> to
            <replaceable>VALUE</replaceable>.  When used with
            <command>svn log</command> in <option>--xml</option> mode, this displays the value of
            <replaceable>ARG</replaceable> in the log output.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svn.sw.xml">
        <term><option>--xml</option></term>
        <listitem>
          <para>Prints output in XML format.  XML schemas for the
            output (in RELAX NG format) are maintained in
            the <filename>subversion/svn/schema/</filename>
            directory of the Subversion source tree.</para>
        </listitem>
      </varlistentry>
      
    </variablelist>
      
  </partintro>
    
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.add">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>add</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn add</refname>
      <refpurpose>Add files, directories, or symbolic links.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn add PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Schedule files, directories, or symbolic links in your
        working copy for addition to the repository.  They will be
        uploaded and added to the repository on your next commit.
        If you add something and change your mind before
        committing, you can unschedule the addition using
        <command>svn revert</command>.</para>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.auto_props" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.no_auto_props" />
<xref linkend="svn.ref.svn.sw.no_ignore" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>To add a file to your working copy:</para>

      <informalexample>
        <screen>
$ svn add foo.c 
A         foo.c
</screen>
      </informalexample>

      <para>When adding a directory, the default behavior of
        <command>svn add</command> is to recurse:</para>

      <informalexample>
        <screen>
$ svn add testdir
A         testdir
A         testdir/a
A         testdir/b
A         testdir/c
A         testdir/d
</screen>
      </informalexample>

      <para>You can add a directory without adding its
        contents:</para>

      <informalexample>
        <screen>
$ svn add --depth=empty otherdir
A         otherdir
</screen>
      </informalexample>

      <para>Attempts to schedule the addition of an item which is
        already versioned will fail by default.  This behavior
        foils the most common scenario under which users attempt
        this: when trying to get to Subversion to recursively
        examine a versioned directory and add any unversioned
        items inside of it.  To override the default behavior and
        force Subversion to recurse into already-versioned
        directories, pass the <option>--force</option>
        option:</para>

      <informalexample>
        <screen>
$ svn add versioned-dir
svn: warning: W150002: '/home/cmpilato/projects/subversion/site' is already un\
der version control
$ svn add versioned-dir --force
A         versioned-dir/foo.c
A         versioned-dir/somedir/bar.c
A  (bin)  versioned-dir/otherdir/docs/baz.doc
 
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.blame">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>blame</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn blame (praise, annotate, ann)</refname>
      <refpurpose>Show author and revision information inline
        for the specified files or URLs.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn blame TARGET[@REV]...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Show author and revision information inline for the
        specified files or URLs.  Each line of text is annotated
        at the beginning with the author (username) and the
        revision number for the last change to that line.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.use_merge_history" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>If you want to see blame-annotated source for
        <filename>readme.txt</filename> in your test
        repository:</para>

      <informalexample>
        <screen>
$ svn blame http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     5      harry Don't bother reading it.  The boss is a knucklehead.
     3      sally 
 
</screen>
      </informalexample>

      <para>Now, just because <command>svn blame</command> says
        that Harry last modified <filename>readme.txt</filename>
        in revision 5, understand that this subcommand is by
        default very picky about what constitutes a change.
        Before clubbing Harry over the head for what appears to be
        insubordination, first consider that perhaps the change he
        made to the file might have been only to its specific
        character content, not to its overall semantic meaning.
        Perhaps his changes were the result of blindly running a
        whitespace cleanup script on this file.  You might need
        to examine the specific differences and related log
        message to understand exactly what Harry did to this file
        in revision 5.</para>

      <informalexample>
        <screen>
$ svn log -c 5 http://svn.red-bean.com/repos/test/readme.txt
------------------------------------------------------------------------
r5 | harry | 2008-05-29 07:26:12 -0600 (Thu, 29 May 2008) | 1 line

Commit the results of 'double-space-after-period.sh'.

------------------------------------------------------------------------
$ svn diff -c 5 http://svn.red-bean.com/repos/test/readme.txt
Index: http://svn.red-bean.com/repos/test/readme.txt
===================================================================
--- http://svn.red-bean.com/repos/test/readme.txt	(revision 4)
+++ http://svn.red-bean.com/repos/test/readme.txt	(revision 5)
@@ -1,5 +1,5 @@
 This is a README file.
-Don't bother reading it. The boss is a knucklehead.
+Don't bother reading it.  The boss is a knucklehead.
  
 INSTRUCTIONS
 ============
$
</screen>
      </informalexample>

      <para>Sure enough, Harry only changed the whitespace in that
        line.  Fortunately, the <option>--extensions</option>
        (<option>-x</option>) option can help you better determine
        the last time that a <emphasis>meaningful</emphasis>
        change was made to a given line of text.  For example,
        here's how you can see the annotation information while
        disregarding mere whitespace changes:</para>

      <informalexample>
        <screen>
$ svn blame -x -b http://svn.red-bean.com/repos/test/readme.txt
     3      sally This is a README file.
     4       jess Don't bother reading it.  The boss is a knucklehead.
     3      sally 
 
</screen>
      </informalexample>

      <para>If you use the <option>--xml</option> option, you can
        get XML output describing the blame annotations, but not
        the contents of the lines themselves:</para>

      <informalexample>
        <screen>
$ svn blame --xml http://svn.red-bean.com/repos/test/readme.txt
&lt;?xml version="1.0"?&gt;
&lt;blame&gt;
&lt;target
   path="readme.txt"&gt;
&lt;entry
   line-number="1"&gt;
&lt;commit
   revision="3"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2008-05-25T19:12:31.428953Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;entry
   line-number="2"&gt;
&lt;commit
   revision="5"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-05-29T13:26:12.293121Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;entry
   line-number="3"&gt;
 
&lt;/entry&gt;
&lt;/target&gt;
&lt;/blame&gt;
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.cat">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>cat</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn cat</refname>
      <refpurpose>Output the contents of the specified files or
        URLs.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn cat TARGET[@REV]...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Output the contents of the specified files or URLs.
        For listing the contents of directories, see <command>svn
        list</command> later in this chapter.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.revision" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>If you want to view <filename>readme.txt</filename> in
        your repository without checking it out:</para>

      <informalexample>
        <screen>
$ svn cat http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
Don't bother reading it.  The boss is a knucklehead.
 
INSTRUCTIONS
============

Step 1:  Do this.

Step 2:  Do that.
$
</screen>
      </informalexample>

      <para>You can view specific versions of files, too.</para>

      <informalexample>
        <screen>
$ svn cat -r 3 http://svn.red-bean.com/repos/test/readme.txt
This is a README file.
 
INSTRUCTIONS
============

Step 1:  Do this.

Step 2:  Do that.
$
</screen>
      </informalexample>

      <note>
        <para>You might develop a reflex action of
          using <command>svn cat</command> to view your working
          file contents.  But keep in mind that the default peg
          revision for <command>svn cat</command> when used on a
          working copy file target is <literal>BASE</literal>, the
          unmodified base revision of that file.  Don't be
          surprised when a simple <userinput>svn cat
          /path/to/file</userinput> invocation fails to display
          your local modifications to that file!</para>
      </note>

      <tip>
        <para>If your working copy is out of date (or you have
          local modifications) and you want to see the
          <literal>HEAD</literal> revision of a file in your
          working copy, use the <option>--revision</option>
          (<option>-r</option>) option:  <userinput>svn cat -r
          HEAD <replaceable>FILENAME</replaceable></userinput></para>
      </tip>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.changelist">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>changelist</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn changelist (cl)</refname>
      <refpurpose>Associate (or deassociate) local paths with a
        changelist.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>changelist CLNAME TARGET...</literal></para>
      <para><literal>changelist --remove TARGET...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Used for dividing files in a working copy into a
        changelist (logical named grouping) in order to allow
        users to easily work on multiple file collections within a
        single working copy.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.remove" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Example</title>

      <para>Edit three files, add them to a changelist, then
        commit only files in that changelist:</para>

      <informalexample>
        <screen>
$ svn changelist issue1729 foo.c bar.c baz.c
A [issue1729] foo.c
A [issue1729] bar.c
A [issue1729] baz.c
$ svn status
A       someotherfile.c
A       test/sometest.c

--- Changelist 'issue1729':
A       foo.c
A       bar.c
A       baz.c
$ svn commit --changelist issue1729 -m "Fixing Issue 1729."
Adding         bar.c
Adding         baz.c
Adding         foo.c
Transmitting file data ...
Committed revision 2.
$ svn status
A       someotherfile.c
A       test/sometest.c
$
</screen>
      </informalexample>

      <para>Note that in the previous example, only the files in
        changelist <literal>issue1729</literal> were
        committed.</para>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.checkout">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>checkout</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn checkout (co)</refname>
      <refpurpose>Check out a working copy from a repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn checkout URL[@REV]... [PATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Check out a working copy from a repository.  If
        <replaceable>PATH</replaceable> is omitted, the
        basename of the URL will be used as the destination.
        If multiple URLs are given, each will be checked out into a
        subdirectory of <replaceable>PATH</replaceable>, with the
        name of the subdirectory being the basename of the
        URL.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Check out a working copy into a directory called
        <filename>mine</filename>:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test mine
A    mine/a
A    mine/b
A    mine/c
A    mine/d
Checked out revision 20.
$ ls
mine
$
</screen>
      </informalexample>

      <para>Check out two different directories into two separate
        working copies:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test \
               file:///var/svn/repos/quiz
A    test/a
A    test/b
A    test/c
A    test/d
Checked out revision 20.
A    quiz/l
A    quiz/m
Checked out revision 13.
$ ls
quiz  test
$
</screen>
      </informalexample>

      <para>Check out two different directories into two separate
        working copies, but place both into a directory called
        <filename>working-copies</filename>:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test \
               file:///var/svn/repos/quiz \
               working-copies
A    working-copies/test/a
A    working-copies/test/b
A    working-copies/test/c
A    working-copies/test/d
Checked out revision 20.
A    working-copies/quiz/l
A    working-copies/quiz/m
Checked out revision 13.
$ ls
working-copies
</screen>
      </informalexample>

      <para>If you interrupt a checkout (or something else
        interrupts your checkout, such as loss of connectivity,
        etc.), you can restart it either by issuing the identical
        checkout command again or by updating the incomplete
        working copy:</para>

      <informalexample>
        <screen>
$ svn checkout file:///var/svn/repos/test mine
A    mine/a
A    mine/b
^C
svn: E200015: Caught signal
$ svn checkout file:///var/svn/repos/test mine
A    mine/c
^C
svn: E200015: Caught signal
$ svn update mine
Updating 'mine':
A    mine/d
Updated to revision 20.
$
</screen>
      </informalexample>

      <para>If you wish to check out some revision other than the
        most recent one, you can do so by providing the
        <option>--revision</option> (<option>-r</option>) option
        to the <command>svn checkout</command> command:</para>

      <informalexample>
        <screen>
$ svn checkout -r 2 file:///var/svn/repos/test mine
A    mine/a
Checked out revision 2.
$
</screen>
      </informalexample>

      <para>Prior to version 1.7, Subversion would complain by
        default if you try to check out a directory atop an
        existing directory which contains files or subdirectories
        that the checkout itself would have created.  Subversion
        1.7 handles this situation differently, allowing the
        checkout to proceed but marking any obstructing objects as
        tree conflicts.  Use the <option>--force</option> option
        to override this safeguard.  When you check out with
        the <option>--force</option> option, any unversioned file
        in the checkout target tree which ordinarily would
        obstruct the checkout will still become versioned, but
        Subversion will preserve its contents as-is.  If those
        contents differ from the repository file at that path
        (which was downloaded as part of the checkout), the file
        will appear to have local modifications the changes
        required to transform the versioned file you checked out
        into the unversioned file you had before checking
        out when the checkout completes.</para>

      <informalexample>
        <screen>
$ mkdir project
$ mkdir project/lib
$ touch project/lib/file.c
$ svn checkout file:///var/svn/repos/project/trunk project --force
E    project/lib
A    project/lib/subdir
E    project/lib/file.c
A    project/lib/anotherfile.c
A    project/include/header.h
Checked out revision 21.
$ svn status wc
M       project/lib/file.c
$ svn diff wc
Index: project/lib/file.c
===================================================================
--- project/lib/file.c	(revision 1)
+++ project/lib/file.c	(working copy)
@@ -3 +0,0 @@
-/* file.c: Code for acting file-ishly. */
-#include &lt;stdio.h&gt;
-/* Not feeling particularly creative today. */

$
</screen>
      </informalexample>

      <para>As in another other working copy, you have the choices
        typically available:  reverting some or all of those
        local <quote>modifications</quote>, committing them, or
        continuing to modify your working copy.</para>

      <para>This feature is especially useful for performing
        in-place imports of unversioned directory trees.  By first
        importing the tree into the repository, and then checking
        out new repository location atop the unversioned tree with
        the <option>--force</option> option, you effectively
        transform the unversioned tree into a working
        copy.</para>

      <informalexample>
        <screen>
$ svn mkdir -m "Create newproject project root." \
      file://var/svn/repos/newproject
$ svn import -m "Import initial newproject codebase." newproject \
      file://var/svn/repos/newproject/trunk
Adding         newproject/include
Adding         newproject/include/newproject.h
Adding         newproject/lib
Adding         newproject/lib/helpers.c
Adding         newproject/lib/base.c
Adding         newproject/notes
Adding         newproject/notes/README

Committed revision 22.
$ svn checkout file://`pwd`/repos-1.6/newproject/trunk newproject --force
E    newproject/include
E    newproject/include/newproject.h
E    newproject/lib
E    newproject/lib/helpers.c
E    newproject/lib/base.c
E    newproject/notes
E    newproject/notes/README
Checked out revision 2.
$ svn status newproject
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.cleanup">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>cleanup</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn cleanup</refname>
      <refpurpose>Recursively clean up the working copy</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn cleanup [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Recursively clean up the working copy, removing
        working copy locks and resuming unfinished operations.  If
        you ever get a <literal>working copy locked</literal>
        error, run this command to remove stale locks and get your
        working copy into a usable state again.</para>

      <para>If, for some reason, an <command>svn update</command>
        fails due to a problem running an external diff program
        (e.g., user input or network failure), pass the
        <option>--diff3-cmd</option> to allow the cleanup process
        to complete any required merging using your external diff
        program.  You can also specify any configuration directory
        with the <option>--config-dir</option> option, but you
        should need these options extremely infrequently.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
</screen>
      </informalexample>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Well, there's not much to the examples here, as
        <command>svn cleanup</command> generates no output.  If
        you pass no <replaceable>PATH</replaceable>, then
        <quote><filename>.</filename></quote> is used:</para>

      <informalexample>
        <screen>
$ svn cleanup
$ svn cleanup /var/svn/working-copy
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.commit">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>commit</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn commit (ci)</refname>
      <refpurpose>Send changes from your working copy to the repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn commit [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Send changes from your working copy to the repository.
        If you do not supply a log message with your commit by
        using either the <option>--file</option>
        (<option>-F</option>) or <option>--message</option>
        (<option>-m</option>) option,
        <command>svn</command> will launch your editor for you
        to compose a commit message.  See the
        <literal>editor-cmd</literal> list entry in <xref
        linkend="svn.advanced.confarea.opts.config"/>.</para>

      <para><command>svn commit</command> will send any lock
        tokens that it finds and will release locks on all
        <replaceable>PATH</replaceable>s committed (recursively)
        unless <option>--no-unlock</option> is passed.</para>

      <tip>
        <para>If you begin a commit and Subversion launches your
          editor to compose the commit message, you can still
          abort without committing your changes.  If you want to
          cancel your commit, just quit your editor without saving
          your commit message and Subversion will prompt you to
          either abort the commit, continue with no message, or
          edit the message again.</para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.keep_changelists" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.no_unlock" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Commit a simple modification to a file with the
        commit message on the command line and an implicit
        target of your current directory
        (<quote><filename>.</filename></quote>):</para>

      <informalexample>
        <screen>
$ svn commit -m "added howto section."
Sending        a
Transmitting file data .
Committed revision 3.
</screen>
      </informalexample>

      <para>Commit a modification to the file
        <filename>foo.c</filename> (explicitly specified on the
        command line) with the commit message in a file named
        <filename>msg</filename>:</para>

      <informalexample>
        <screen>
$ svn commit -F msg foo.c
Sending        foo.c
Transmitting file data .
Committed revision 5.
</screen>
      </informalexample>

      <para>If you want to use a file that's under version control
        for your commit message with <option>--file</option>
        (<option>-F</option>), you need to pass the
        <option>--force-log</option> option:</para>

      <informalexample>
        <screen>
$ svn commit -F file_under_vc.txt foo.c
svn: E205004: Log message file is a versioned file; use '--force-log' to override

$ svn commit --force-log -F file_under_vc.txt foo.c
Sending        foo.c
Transmitting file data .
Committed revision 6.
</screen>
      </informalexample>

      <para>To commit a file scheduled for deletion:</para>

      <informalexample>
        <screen>
$ svn commit -m "removed file 'c'."
Deleting       c

Committed revision 7.
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.copy">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>copy</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn copy (cp)</refname>
      <refpurpose>Copy a file or directory in a working copy or
        in the repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn copy SRC[@REV]... DST</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Copy one or more files in a working copy or in the
        repository. <replaceable>SRC</replaceable> and
        <replaceable>DST</replaceable> can each be either a
        working copy (WC) path or URL.  When copying multiple
        sources, add the copies as immediate children
        of <replaceable>DST</replaceable> (which, of course, must
        be a directory).</para>
        
        <variablelist>

          <varlistentry>
            <term>WC   WC</term>
            <listitem>
              <para>Copy and schedule an item for
                addition (with history).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>WC   URL</term>
            <listitem>
              <para>Immediately commit a copy of WC to URL.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>URL   WC</term>
            <listitem>
              <para>Check out URL into WC and schedule it for
                addition.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>URL   URL</term>
            <listitem>
              <para>Complete server-side copy.  This is
                usually used to branch and tag.</para>
            </listitem>
          </varlistentry>

        </variablelist>

      <para>If no peg revision (i.e.,
        <replaceable>@REV</replaceable>) is supplied, by default
        the <literal>BASE</literal> revision will be used for
        files copied from the working copy, while the
        <literal>HEAD</literal> revision will be used for files
        copied from a URL.</para>

      <note>
        <para>You can only copy files within a single repository.
          Subversion does not support cross-repository copying.</para>
      </note>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Copy an item within your working copy (this
        schedules the copy nothing goes into the repository
        until you commit):</para>

      <informalexample>
        <screen>
$ svn copy foo.txt bar.txt
A         bar.txt
$ svn status
A  +    bar.txt
</screen>
      </informalexample>

      <para>Copy several files in a working copy into a
        subdirectory:</para>

      <informalexample>
        <screen>
$ svn copy bat.c baz.c qux.c src
A         src/bat.c
A         src/baz.c
A         src/qux.c
</screen>
      </informalexample>

      <para>Copy revision 8 of <filename>bat.c</filename> into your
        working copy under a different name:</para>

      <informalexample>
        <screen>
$ svn copy -r 8 bat.c ya-old-bat.c
A         ya-old-bat.c
</screen>
      </informalexample>

      <para>Copy an item in your working copy to a URL in the
        repository (this is an immediate commit, so you must supply a
        commit message):</para>

      <informalexample>
        <screen>
$ svn copy near.txt file:///var/svn/repos/test/far-away.txt -m "Remote copy."

Committed revision 8.
</screen>
      </informalexample>

      <para>Copy an item from the repository to your working
        copy (this just schedules the copy nothing goes into the
        repository until you commit):</para>

      <informalexample>
        <screen>
$ svn copy file:///var/svn/repos/test/far-away -r 6 near-here
A         near-here
</screen>
      </informalexample>

      <tip>
        <para>This is the recommended way to resurrect a dead
          file in your repository!</para>
      </tip>

      <para>And finally, copy between two URLs:</para>

      <informalexample>
        <screen>
$ svn copy file:///var/svn/repos/test/far-away \
           file:///var/svn/repos/test/over-there -m "remote copy."

Committed revision 9.
</screen>
      </informalexample>

      <informalexample>
        <screen>
$ svn copy file:///var/svn/repos/test/trunk \
           file:///var/svn/repos/test/tags/0.6.32-prerelease -m "tag tree"

Committed revision 12.
</screen>
      </informalexample>

      <tip>
        <para>This is the easiest way to <quote>tag</quote> a
          revision in your repository just <command>svn
          copy</command> that revision (usually
          <literal>HEAD</literal>) into your <filename>tags</filename> directory.</para>
      </tip>

      <para>And don't worry if you forgot to tag you can
        always specify an older revision and tag anytime:</para>

      <informalexample>
        <screen>
$ svn copy -r 11 file:///var/svn/repos/test/trunk \
           file:///var/svn/repos/test/tags/0.6.32-prerelease \
           -m "Forgot to tag at rev 11"

Committed revision 13.
</screen>
      </informalexample>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.delete">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>delete</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn delete (del, remove, rm)</refname>
      <refpurpose>Delete an item from a working copy
        or the repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn delete PATH...</literal></para>
      <para><literal>svn delete URL...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Items specified by <replaceable>PATH</replaceable> are
        scheduled for deletion upon the next commit.  Files (and
        directories that have not been committed) are immediately
        removed from the working copy unless the
        <option>--keep-local</option> option is given.  The
        command will not remove any unversioned or modified items;
        use the <option>--force</option> option to override this
        behavior.</para>

      <para>Items specified by URL are deleted from
        the repository via an immediate commit.  Multiple URLs are
        committed atomically.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.keep_local" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Using <command>svn</command> to delete a file from
        your working copy deletes your local copy of the file, but
        it merely schedules the file to be deleted from the
        repository.  When you commit, the file is deleted in the
        repository.</para>

      <informalexample>
        <screen>
$ svn delete myfile
D         myfile

$ svn commit -m "Deleted file 'myfile'."
Deleting       myfile
Transmitting file data .
Committed revision 14.
</screen>
      </informalexample>

      <para>Deleting a URL, however, is immediate, so you have
        to supply a log message:</para>

      <informalexample>
        <screen>
$ svn delete -m "Deleting file 'yourfile'" \
             file:///var/svn/repos/test/yourfile

Committed revision 15.
</screen>
      </informalexample>

      <para>Here's an example of how to force deletion of a file
        that has local mods:</para>

      <informalexample>
        <screen>
$ svn delete over-there 
svn: E195006: Use --force to override this restriction (local modifications m\
ay be lost)
svn: E195006: '/home/sally/project/over-there' has local modifications -- com\
mit or revert them first
$ svn delete --force over-there 
D         over-there
$
</screen>
      </informalexample>

      <para>Use the <option>--keep-local</option> option to
        override the default <command>svn delete</command>
        behavior of also removing the target file that was
        scheduled for versioned deletion.  This is helpful when
        you realize that you've accidentally committed the
        addition of a file that you need to keep around in your
        working copy, but which shouldn't have been added to
        version control.</para>

      <informalexample>
        <screen>
$ svn delete --keep-local conf/program.conf
D         conf/program.conf

$ svn commit -m "Remove accidentally-added configuration file."
Deleting       conf/program.conf
Transmitting file data .
Committed revision 21.
$ svn status
?       conf/program.conf
$
</screen>
      </informalexample>

      <note>
        <para>The behavior of the <option>--keep-local</option>
          option does not propagate to other working copies which
          contain the items you've scheduled for deletion.  If you
          commit the deletion of those items they will remain in
          your working copy, but they will be deleted from other
          working copies which contain them when those working
          copies are then updated.</para>
      </note>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.diff">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>diff</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn diff (di)</refname>
      <refpurpose>This displays the differences between two revisions or paths.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>diff [-c M | -r N[:M]] [TARGET[@REV]...]</literal></para>
      <para><literal>diff [-r N[:M]] --old=OLD-TGT[@OLDREV] [--new=NEW-TGT[@NEWREV]] [PATH...]</literal></para>
      <para><literal>diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]</literal></para>

    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Display the differences between two paths.  You can
        use <command>svn diff</command> in the following ways:</para>

      <itemizedlist>

        <listitem>
          <para>Use just <command>svn diff</command> to display local
            modifications in a working copy.</para>
        </listitem>

        <listitem>
          <para>Display the changes made to
            <replaceable>TARGET</replaceable>s as they are seen in
            <replaceable>REV</replaceable> between two revisions.
            <replaceable>TARGET</replaceable>s may be all working copy
            paths or all <replaceable>URL</replaceable>s.  If
            <replaceable>TARGET</replaceable>s are working copy paths,
            <replaceable>N</replaceable> defaults to
            <literal>BASE</literal> and <replaceable>M</replaceable>
            to the working copy; if <replaceable>TARGET</replaceable>s
            are <replaceable>URL</replaceable>s,
            <replaceable>N</replaceable> must be specified and
            <replaceable>M</replaceable> defaults to
            <literal>HEAD</literal>.  The <literal>-c M</literal> option
            is equivalent to <literal>-r N:M</literal> where <literal>N =
            M-1</literal>.  Using <literal>-c -M</literal> does the
            reverse: <literal>-r M:N</literal> where <literal>N =
            M-1</literal>.</para>
        </listitem>

        <listitem>
          <para>Display the differences between
            <replaceable>OLD-TGT</replaceable> as it was seen in
            <replaceable>OLDREV</replaceable> and
            <replaceable>NEW-TGT</replaceable> as it was seen in
            <replaceable>NEWREV</replaceable>.
            <replaceable>PATH</replaceable>s, if given, are relative
            to <replaceable>OLD-TGT</replaceable> and
            <replaceable>NEW-TGT</replaceable> and restrict the output
            to differences for those paths.
            <replaceable>OLD-TGT</replaceable> and
            <replaceable>NEW-TGT</replaceable> may be working copy
            paths or <replaceable>URL[@REV]</replaceable>.
            <replaceable>NEW-TGT</replaceable> defaults to
            <replaceable>OLD-TGT</replaceable> if not specified.
            <literal>-r N</literal>
            makes <replaceable>OLDREV</replaceable> default to
            <literal>N</literal>; <literal>-r N:M</literal>
            makes <replaceable>OLDREV</replaceable> default to
            <replaceable>N</replaceable> and
            <replaceable>NEWREV</replaceable> default to
            <replaceable>M</replaceable>.</para>
        </listitem>

      </itemizedlist>

      <para><userinput>svn diff OLD-URL[@OLDREV]
        NEW-URL[@NEWREV]</userinput> is shorthand for <userinput>svn
        diff --old=OLD-URL[@OLDREV]
        --new=NEW-URL[@NEWREV].</userinput></para>

      <para><userinput>svn diff -r N:M URL</userinput> is shorthand
        for <userinput>svn diff -r N:M --old=URL
        --new=URL</userinput>.</para>

      <para><userinput>svn diff [-r N[:M]] URL1[@N]
        URL2[@M]</userinput> is shorthand for <userinput>svn diff [-r
        N[:M]] --old=URL1 --new=URL2</userinput>.</para>

      <para>If <replaceable>TARGET</replaceable> is a URL, then
        revs <literal>N</literal> and <literal>M</literal> can be
        given either via the
        <option>--revision</option> (<option>-r</option>) option
        or by using the
        <quote>@</quote> notation as described earlier.</para>

      <para>If <replaceable>TARGET</replaceable> is a working copy
        path, the default behavior (when no
        <option>--revision</option> (<option>-r</option>) option
        is provided) is to display the differences between the
        base and working copies
        of <replaceable>TARGET</replaceable>.  If a
        <option>--revision</option> (<option>-r</option>) option
        is specified in this scenario, though, it means:</para>

      <variablelist>

        <varlistentry>
          <term><option>--revision N:M</option></term>
          <listitem>
            <para>The server compares <replaceable>TARGET@N</replaceable>
              and <replaceable>TARGET@M</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--revision N</option></term>
          <listitem>
            <para>The client compares
              <replaceable>TARGET@N</replaceable>
              against the working copy.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>If the alternate syntax is used, the server compares
        <replaceable>URL1</replaceable> and
        <replaceable>URL2</replaceable> at revisions
        <replaceable>N</replaceable> and
        <replaceable>M</replaceable>, respectively.  If either
        <replaceable>N</replaceable> or
        <replaceable>M</replaceable> is omitted, a value of
        <literal>HEAD</literal> is assumed.</para>

      <para>By default, <command>svn diff</command> ignores the
        ancestry of files and merely compares the contents of the
        two files being compared.  If you use
        <option>--notice-ancestry</option>, the ancestry of the
        paths in question will be taken into consideration when
        comparing revisions (i.e., if you run <command>svn
        diff</command> on two files with identical contents but
        different ancestry, you will see the entire contents of
        the file as having been removed and added again).</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.change" />
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff_cmd" />
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.git" />
<xref linkend="svn.ref.svn.sw.internal_diff" />
<xref linkend="svn.ref.svn.sw.new" />
<xref linkend="svn.ref.svn.sw.no_diff_deleted" />
<xref linkend="svn.ref.svn.sw.notice_ancestry" />
<xref linkend="svn.ref.svn.sw.old" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.show_copies_as_adds" />
<xref linkend="svn.ref.svn.sw.summarize" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Compare <literal>BASE</literal> and your working copy
        (one of the most popular uses of <command>svn
        diff</command>):</para>

      <informalexample>
        <screen>
$ svn diff COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 4404)
+++ COMMITTERS	(working copy)
 
</screen>
      </informalexample>

      <para>See what changed in the file
        <filename>COMMITTERS</filename> revision 9115:</para>

      <informalexample>
        <screen>
$ svn diff -c 9115 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
 
</screen>
      </informalexample>


      <para>See how your working copy's modifications compare
        against an older revision:</para>

      <informalexample>
        <screen>
$ svn diff -r 3900 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3900)
+++ COMMITTERS	(working copy)
 
</screen>
      </informalexample>

      <para>Compare revision 3000 to revision 3500 using <quote>@</quote>
        syntax:</para>

      <informalexample>
        <screen>
$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 \
           http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
 
</screen>
      </informalexample>

      <para>Compare revision 3000 to revision 3500 using range
        notation (pass only the one URL in this
        case):</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
 
</screen>
      </informalexample>


      <para>Compare revision 3000 to revision 3500 of all the files in
        <filename>trunk</filename> using range notation:</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk
</screen>
      </informalexample>


      <para>Compare revision 3000 to revision 3500 of only three
        files in <filename>trunk</filename> using range
        notation:</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk \
       COMMITTERS README HACKING
</screen>
      </informalexample>

      <para>If you have a working copy, you can obtain the
        differences without typing in the long URLs:</para>

      <informalexample>
        <screen>
$ svn diff -r 3000:3500 COMMITTERS 
Index: COMMITTERS
===================================================================
--- COMMITTERS	(revision 3000)
+++ COMMITTERS	(revision 3500)
 
</screen>
      </informalexample>

      <para>Use <option>--diff-cmd</option>
        <replaceable>CMD</replaceable> <option>--extensions</option>
        (<option>-x</option>) to pass arguments directly to the
        external diff program:</para>

      <informalexample>
        <screen>
$ svn diff --diff-cmd /usr/bin/diff -x "-i -b" COMMITTERS 
Index: COMMITTERS
===================================================================
0a1,2
&gt; This is a test
&gt; 
$
</screen>
      </informalexample>

      <para>Lastly, you can use the <option>--xml</option> option
        along with the <option>--summarize</option> option to view
        XML describing the changes that occurred between
        revisions, but not the contents of the diff itself:</para>

      <informalexample>
        <screen>
$ svn diff --summarize --xml http://svn.red-bean.com/repos/test@r2 \
           http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;diff&gt;
&lt;paths&gt;
&lt;path
   props="none"
   kind="file"
   item="modified"&gt;http://svn.red-bean.com/repos/test/sandwich.txt&lt;/path&gt;
&lt;path
   props="none"
   kind="file"
   item="deleted"&gt;http://svn.red-bean.com/repos/test/burrito.txt&lt;/path&gt;
&lt;path
   props="none"
   kind="dir"
   item="added"&gt;http://svn.red-bean.com/repos/test/snacks&lt;/path&gt;
&lt;/paths&gt;
&lt;/diff&gt;
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.export">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>export</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn export</refname>
      <refpurpose>Export a clean directory tree.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn export [-r REV] URL[@PEGREV] [PATH]</literal></para>
      <para><literal>svn export [-r REV] PATH1[@PEGREV] [PATH2]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The first form exports a clean directory tree from the
        repository specified by <replaceable>URL</replaceable> at revision
        <replaceable>REV</replaceable> if it is given; otherwise,
        at <literal>HEAD</literal>, into
        <replaceable>PATH</replaceable>.  If
        <replaceable>PATH</replaceable> is omitted, the last
        component of the <replaceable>URL</replaceable> is used
        for the local directory name.</para>

      <para>The second form exports a clean directory tree from
        the working copy specified by
        <replaceable>PATH1</replaceable> into
        <replaceable>PATH2</replaceable>.  All local changes will
        be preserved, but files not under version control will not
        be copied.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.ignore_keywords" />
<xref linkend="svn.ref.svn.sw.native_eol" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Export from your working copy (doesn't print every
        file and directory):</para>

      <informalexample>
        <screen>
$ svn export a-wc my-export
Export complete.
</screen>
      </informalexample>

      <para>Export directly from the repository (prints every
        file and directory):</para>

      <informalexample>
        <screen>
$ svn export file:///var/svn/repos my-export
A    my-export/test
A    my-export/quiz
 
Exported revision 15.
</screen>
      </informalexample>

      <para>When rolling operating-system-specific release
        packages, it can be useful to export a tree that uses a
        specific EOL character for line endings.  The
        <option>--native-eol</option> option will do this, but it
        affects only files that have <literal>svn:eol-style =
        native</literal> properties attached to them.  For
        example, to export a tree with all CRLF line endings
        (possibly for a Windows <filename>.zip</filename> file
        distribution):</para>

      <informalexample>
        <screen>
$ svn export file:///var/svn/repos my-export --native-eol CRLF
A    my-export/test
A    my-export/quiz
 
Exported revision 15.
</screen>
      </informalexample>

      <para>You can specify <literal>LR</literal>,
        <literal>CR</literal>, or <literal>CRLF</literal> as a
        line-ending type with the <option>--native-eol</option>
        option.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.help">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn help (h, ?)</refname>
      <refpurpose>Help!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn help [SUBCOMMAND...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This is your best friend when you're using
        Subversion and this book isn't within reach!</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.import">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>import</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn import</refname>
      <refpurpose>Commit an unversioned file or tree into the 
        repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn import [PATH] URL</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Recursively commit a copy of
        <replaceable>PATH</replaceable> to
        <replaceable>URL</replaceable>.  If
        <replaceable>PATH</replaceable> is omitted,
        <quote><filename>.</filename></quote> is assumed.  Parent
        directories are created in the repository as necessary.
        Unversionable items such as device files and pipes are
        ignored even if <option>--force</option> is
        specified.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.auto_props" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.no_auto_props" />
<xref linkend="svn.ref.svn.sw.no_ignore" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This imports the local directory
        <filename>myproj</filename> into
        <filename>trunk/misc</filename> in your repository.  The
        directory <filename>trunk/misc</filename> need not exist
        before you import into it <command>svn
        import</command> will recursively create directories for
        you.</para>

      <informalexample>
        <screen>
$ svn import -m "New import" myproj \
             http://svn.red-bean.com/repos/trunk/misc
Adding         myproj/sample.txt
 
Transmitting file data .........
Committed revision 16.
</screen>
      </informalexample>

      <para>Be aware that this will <emphasis>not</emphasis>
        create a directory named <filename>myproj</filename> in
        the repository.  If that's what you want, simply add
        <filename>myproj</filename> to the end of the URL:</para>

      <informalexample>
        <screen>
$ svn import -m "New import" myproj \
            http://svn.red-bean.com/repos/trunk/misc/myproj
Adding         myproj/sample.txt
 
Transmitting file data .........
Committed revision 16.
</screen>
      </informalexample>

      <para>After importing data, note that the original tree is
        <emphasis>not</emphasis> under version control.  To start
        working, you still need to <command>svn checkout</command>
        a fresh working copy of the tree.</para>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.info">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>info</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn info</refname>
      <refpurpose>Display information about a local or remote 
        item.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn info [TARGET[@REV]...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print information about the working copy paths or URLs
        specified.  The information displayed for each path may
        include (as pertinent to the object at that path):</para>

      <itemizedlist>
        <listitem><para>information about the repository in which
          the object is versioned</para></listitem>
        <listitem><para>the most recent commit made to the
          specified version of the object</para></listitem>
        <listitem><para>any user-level locks held on the
          object</para></listitem>
        <listitem><para>local scheduling information (added,
          deleted, copied, etc.)</para></listitem>
        <listitem><para>local conflict information</para></listitem>
      </itemizedlist>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para><command>svn info</command> will show you all the
        useful information that it has for items in your working
        copy.  It will show information for files:</para>

      <informalexample>
        <screen>
$ svn info foo.c
Path: foo.c
Name: foo.c
Working Copy Root Path: /home/sally/projects/test
URL: http://svn.red-bean.com/repos/test/foo.c
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 4417
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 20
Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)
Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)
Checksum: d6aeb60b0662ccceb6bce4bac344cb66
</screen>
      </informalexample>

      <para>It will also show information for directories:</para>

      <informalexample>
        <screen>
$ svn info vendors
Path: vendors
Working Copy Root Path: /home/sally/projects/test
URL: http://svn.red-bean.com/repos/test/vendors
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 19
Node Kind: directory
Schedule: normal
Last Changed Author: harry
Last Changed Rev: 19
Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)
Properties Last Updated: 2003-01-16 23:39:02 -0600 (Thu, 16 Jan 2003)
</screen>
      </informalexample>

       <para><command>svn info</command> also acts on URLs (also
         note that the file <filename>readme.doc</filename> in
         this example is locked, so lock information is also
         provided):</para>

       <informalexample>
         <screen>
$ svn info http://svn.red-bean.com/repos/test/readme.doc
Path: readme.doc
Name: readme.doc
URL: http://svn.red-bean.com/repos/test/readme.doc
Repository Root: http://svn.red-bean.com/repos/test
Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25
Revision: 1
Node Kind: file
Schedule: normal
Last Changed Author: sally
Last Changed Rev: 42
Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)
Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2
Lock Owner: harry
Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)
Lock Comment (1 line):
My test lock comment
</screen>
       </informalexample>

       <para>Lastly, <command>svn info</command> output is
         available in XML format by passing
         the <option>--xml</option> option:</para>

       <informalexample>
         <screen>
$ svn info --xml http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;info&gt;
&lt;entry
   kind="dir"
   path="."
   revision="1"&gt;
&lt;url&gt;http://svn.red-bean.com/repos/test&lt;/url&gt;
&lt;repository&gt;
&lt;root&gt;http://svn.red-bean.com/repos/test&lt;/root&gt;
&lt;uuid&gt;5e7d134a-54fb-0310-bd04-b611643e5c25&lt;/uuid&gt;
&lt;/repository&gt;
&lt;wc-info&gt;
&lt;schedule&gt;normal&lt;/schedule&gt;
&lt;depth&gt;infinity&lt;/depth&gt;
&lt;/wc-info&gt;
&lt;commit
   revision="1"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2003-01-15T23:35:12.847647Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
&lt;/info&gt;
</screen>
       </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.list">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>list</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn list (ls)</refname>
      <refpurpose>List directory entries in the repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn list [TARGET[@REV]...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>List each <replaceable>TARGET</replaceable> file and
        the contents of each <replaceable>TARGET</replaceable>
        directory as they exist in the repository.  If
        <replaceable>TARGET</replaceable> is a working copy path,
        the corresponding repository URL will be used.</para>

      <para>The default <replaceable>TARGET</replaceable> is
        <quote><filename>.</filename></quote>, meaning the
        repository URL of the current working copy
        directory.</para>

      <para>With <option>--verbose</option>
        (<option>-v</option>), <command>svn list</command> shows
        the following fields for each item:</para>

      <itemizedlist>
        <listitem><para>Revision number of the last
          commit</para></listitem>

        <listitem><para>Author of the last commit</para></listitem>

        <listitem><para>If locked, the letter <quote>O</quote> (see the preceding section on <xref
          linkend="svn.ref.svn.c.info"/> for details).</para></listitem>

        <listitem><para>Size (in bytes)</para></listitem>

        <listitem><para>Date and time of the last
          commit</para></listitem>
      </itemizedlist>

      <para>With <option>--xml</option>, output is in XML format
        (with a header and an enclosing document element unless
        <option>--incremental</option> is also specified).  All of
        the information is present; the <option>--verbose</option>
        (<option>-v</option>) option is not accepted.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para><command>svn list</command> is most useful if you
        want to see what files a repository has without
        downloading a working copy:</para>

      <informalexample>
        <screen>
$ svn list http://svn.red-bean.com/repos/test/support
README.txt
INSTALL
examples/
 
</screen>
      </informalexample>

      <para>You can pass the <option>--verbose</option>
        (<option>-v</option>) option for additional information,
        rather like the Unix command
        <command>ls -l</command>:</para>

      <informalexample>
        <screen>
$ svn list -v file:///var/svn/repos
     16 sally         28361 Jan 16 23:18 README.txt
     27 sally             0 Jan 18 15:27 INSTALL
     24 harry               Jan 18 11:27 examples/
</screen>
      </informalexample>

      <para>You can also get <command>svn list</command> output in
        XML format with the <option>--xml</option> option:</para>

      <informalexample>
        <screen>
$ svn list --xml http://svn.red-bean.com/repos/test
&lt;?xml version="1.0"?&gt;
&lt;lists&gt;
&lt;list
   path="http://svn.red-bean.com/repos/test"&gt;
&lt;entry
   kind="dir"&gt;
&lt;name&gt;examples&lt;/name&gt;
&lt;size&gt;0&lt;/size&gt;
&lt;commit
   revision="24"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-01-18T06:35:53.048870Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/entry&gt;
...
&lt;/list&gt;
&lt;/lists&gt;
</screen>
      </informalexample>

      <para>For further details, see the earlier section <xref
        linkend="svn.tour.history.browsing.list"/>.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.lock">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>lock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn lock</refname> 
        <refpurpose>Lock working copy paths or URLs in the
          repository so that no other user can commit changes to
          them.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn lock TARGET...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Lock each <replaceable>TARGET</replaceable>.  If any
        <replaceable>TARGET</replaceable> is already locked by
        another user, print a warning and continue locking the
        rest of the <replaceable>TARGET</replaceable>s.  Use
        <option>--force</option> to steal a lock from another user
        or working copy.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Lock two files in your working copy:</para>

      <informalexample>
        <screen>
$ svn lock tree.jpg house.jpg
'tree.jpg' locked by user 'harry'.
'house.jpg' locked by user 'harry'.
</screen>
      </informalexample>

      <para>Lock a file in your working copy that is currently
        locked by another user:</para>

      <informalexample>
        <screen>
$ svn lock tree.jpg
svn: warning: W160035: Path '/tree.jpg is already locked by user 'sally' in fi
lesystem '/var/svn/repos/db'
$ svn lock --force tree.jpg
'tree.jpg' locked by user 'harry'.
</screen>
      </informalexample>

      <para>Lock a file without a working copy:</para>

      <informalexample>
        <screen>
$ svn lock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg' locked by user 'harry'.
</screen>
      </informalexample>

      <para>For further details, see <xref
        linkend="svn.advanced.locking"/>.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.log">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>log</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn log</refname>
      <refpurpose>Display commit log messages.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn log [PATH]</literal></para>
      <para><literal>svn log URL[@REV] [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Shows log messages from the repository.
        If no arguments are supplied, <command>svn
        log</command> shows the log messages for all files and
        directories inside (and including) the current working
        directory of your working copy.  You can refine the
        results by specifying a path, one or more revisions, or
        any combination of the two.  The default revision range
        for a local path is <literal>BASE:1</literal>.</para>

      <para>If you specify a URL alone, it prints log
        messages for everything the URL contains.  If you
        add paths past the URL, only messages for those paths
        under that URL will be printed.  The default revision range
        for a URL is <literal>HEAD:1</literal>.</para>

      <para>With <option>--verbose</option>
        (<option>-v</option>), <command>svn log</command> will
        also print all affected paths with each log message.
        With <option>--quiet</option>
        (<option>-q</option>), <command>svn log</command> will not
        print the log message body itself, this is compatible
        with <option>--verbose</option>
        (<option>-v</option>).</para>

      <para>Each log message is printed just once, even if more
        than one of the affected paths for that revision were
        explicitly requested.  Logs follow copy history by
        default.  Use <option>--stop-on-copy</option> to disable
        this behavior, which can be useful for determining branch
        points.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.change" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff" />
<xref linkend="svn.ref.svn.sw.diff_cmd" />
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.internal_diff" />
<xref linkend="svn.ref.svn.sw.limit" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.search" />
<xref linkend="svn.ref.svn.sw.search_and" />
<xref linkend="svn.ref.svn.sw.stop_on_copy" />
<xref linkend="svn.ref.svn.sw.targets" />
<xref linkend="svn.ref.svn.sw.use_merge_history" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.with_all_revprops" />
<xref linkend="svn.ref.svn.sw.with_no_revprops" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>You can see the log messages for all the paths that
        changed in your working copy by running <userinput>svn
        log</userinput> from the top:</para>

      <informalexample>
        <screen>
$ svn log
------------------------------------------------------------------------
r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Tweak.
------------------------------------------------------------------------
r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines
 
</screen>
      </informalexample>

      <para>Examine all log messages for a particular file in
        your working copy:</para>

      <informalexample>
        <screen>
$ svn log foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
 
</screen>
      </informalexample>

      <para>If you don't have a working copy handy, you can log
        a URL:</para>

      <informalexample>
        <screen>
$ svn log http://svn.red-bean.com/repos/test/foo.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
 
</screen>
      </informalexample>

      <para>If you want several distinct paths underneath the
        same URL, you can use the <literal>URL [PATH...]</literal>
        syntax:</para>

      <informalexample>
        <screen>
$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
 
</screen>
      </informalexample>

      <para>The <option>--verbose</option> (<option>-v</option>)
        option causes <command>svn log</command> to include
        information about the paths that were changed in each
        displayed revision.  These paths appear, one path per line
        of output, with action codes that indicate what type of
        change was made to the path.</para>

      <informalexample>
        <screen>
$ svn log -v http://svn.red-bean.com/repos/test/ foo.c bar.c
------------------------------------------------------------------------
r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line
Changed paths:
   M /foo.c

Added defines.
------------------------------------------------------------------------
r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line
Changed paths:
   A /bar.c

Added new file bar.c
------------------------------------------------------------------------
r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines
 
</screen>
      </informalexample>

      <para><command>svn log</command> uses just a handful of action codes,
        and they are similar to the
        ones the <command>svn update</command>
        command uses:</para>

      <variablelist>
        <varlistentry>
          <term><literal>A</literal></term>
          <listitem><para>The item was added.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>D</literal></term>
          <listitem><para>The item was deleted.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>M</literal></term>
          <listitem><para>Properties or textual contents on the
            item were changed.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>R</literal></term>
          <listitem><para>The item was replaced by a different one
            at the same location.</para></listitem>
        </varlistentry>
      </variablelist>

      <para>In addition to the action codes which precede the
        changed paths, <command>svn log</command> with
        the <option>--verbose</option> (<option>-v</option>)
        option will note whether a path was added or replaced as
        the result of a copy operation.  It does so by
        printing <literal>(from
        <replaceable>COPY-FROM-PATH</replaceable>:<replaceable>COPY-FROM-REV</replaceable>)</literal>
        after such paths.</para>

      <para>When you're concatenating the results of multiple
        calls to the log command, you may want to use the
        <option>--incremental</option> option. <command>svn
        log</command> normally prints out a dashed line at the
        beginning of a log message, after each subsequent log
        message, and following the final log message.  If you
        ran <command>svn log</command> on a range of two
        revisions, you would get this:</para>

      <informalexample>
        <screen>
$ svn log -r 14:15
------------------------------------------------------------------------
r14 |  

------------------------------------------------------------------------
r15 |  

------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>However, if you wanted to gather two nonsequential log
        messages into a file, you might do something like
        this:</para>

      <informalexample>
        <screen>
$ svn log -r 14 &gt; mylog
$ svn log -r 19 &gt;&gt; mylog
$ svn log -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 |  

------------------------------------------------------------------------
------------------------------------------------------------------------
r19 |  

------------------------------------------------------------------------
------------------------------------------------------------------------
r27 |  

------------------------------------------------------------------------
</screen>
      </informalexample>

      <para>You can avoid the clutter of the double dashed lines
        in your output by using the <option>--incremental</option>
        option:</para>

      <informalexample>
        <screen>
$ svn log --incremental -r 14 &gt; mylog
$ svn log --incremental -r 19 &gt;&gt; mylog
$ svn log --incremental -r 27 &gt;&gt; mylog
$ cat mylog
------------------------------------------------------------------------
r14 |  

------------------------------------------------------------------------
r19 |  

------------------------------------------------------------------------
r27 |  
</screen>
      </informalexample>

      <para>The <option>--incremental</option> option provides
        similar output control when using the
        <option>--xml</option> option:</para>

      <informalexample>
        <screen>
$ svn log --xml --incremental -r 1 sandwich.txt
&lt;logentry
   revision="1"&gt;
&lt;author&gt;harry&lt;/author&gt;
&lt;date&gt;2008-06-03T06:35:53.048870Z&lt;/date&gt;
&lt;msg&gt;Initial Import.&lt;/msg&gt;
&lt;/logentry&gt;
</screen>
      </informalexample>

      <tip>
        <para>Sometimes when you run <command>svn log</command> on
          a specific path and a specific revision, you see no log
          information output at all, as in the following:</para>

        <informalexample>
          <screen>
$ svn log -r 20 http://svn.red-bean.com/untouched.txt
------------------------------------------------------------------------
</screen>
        </informalexample>

        <para>That just means the path wasn't modified in that
          revision.  To get log information for that revision,
          either run the log operation against the repository's
          root URL, or specify a path that you happen to know was
          changed in that revision:</para>

        <informalexample>
          <screen>
$ svn log -r 20 touched.txt 
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.
------------------------------------------------------------------------
</screen>
        </informalexample>
      </tip>

      <para>Beginning with Subversion 1.7, users can take
        advantage of a special output mode which combines the
        information from <command>svn log</command> with what you
        would see when running <command>svn diff</command> on the
        same targets for each revision of the log.  Simply
        invoke <command>svn log</command> with
        the <option>--diff</option> option to trigger this output
        mode.</para>

      <informalexample>
        <screen>
$ svn log -r 20 touched.txt --diff
------------------------------------------------------------------------
r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line

Made a change.

Index: touched.txt
===================================================================
--- touched.txt	(revision 19)
+++ touched.txt	(revision 20)
@@ -1 +1,2 @@
 This is the file 'touched.txt'.
+We add such exciting text to files around here!
------------------------------------------------------------------------
$
</screen>
      </informalexample>

      <para>As with <command>svn diff</command>, you may also make
        use of many of the various options which control the way
        the difference is generated,
        including <option>--depth</option>, <option>--diff-cmd</option>,
        and <option>--extensions</option>
        (<option>-x</option>).</para>

      <para>
        Beginning with Subversion 1.8, users can filter <command>svn log</command>
        output using <option>--search</option> and <option>--search-and</option>
        options.  When using these options, a log message is shown only if a
        revision's author, date, log message text, or list of changed paths,
        matches a search pattern. Searching by changed patch requies
        <option>--verbose</option> option, otherwise <command>svn log</command>
        does not show changed paths therefore they can't be filtered.
      </para>
      <para>
        The search pattern may include "glob syntax"
        wildcards:
      </para>
      <variablelist>
        <varlistentry>
          <term>
            <literal>?</literal>
          </term>
          <listitem>
            <para>
              Matches any single character.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>*</literal>
          </term>
          <listitem>
            <para>
              Matches a sequence of arbitrary
              characters.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>[ABC]</literal>
          </term>
          <listitem>
            <para>
              Matches any of the characters listed inside the brackets.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        Using multiple <option>--search</option> parameters will show log messages
        that match the pattern specified at least in one of the options.  For example:
      </para>
      <informalexample>
<screen>
$ svn log --search sally --search harry https://svn.red-bean.com/repos/test
------------------------------------------------------------------------
r1701 | sally | 2011-10-12 22:35:30 -0600 (Wed, 12 Oct 2011) | 1 line

Add a reminder.
------------------------------------------------------------------------
r1564 | harry | 2011-10-09 22:35:30 -0600 (Sun, 09 Oct 2011) | 1 line

Merge r1560 to the 1.0.x branch.
------------------------------------------------------------------------
$
        </screen>
      </informalexample>
      <para>
        Using <option>--search</option> with <option>--search-and</option> options will show log messages
        that match the combined pattern from both options. For example:
      </para>
      <informalexample>
<screen>
$ svn log --verbose --search sally --search-and /foo/bar https://svn.red-bean.com/repos/test
------------------------------------------------------------------------
r1555 | sally | 2011-07-15 22:33:14 -0600 (Fri, 15 Jul 2011) | 1 line
Changed paths:
M /foo/bar/src.c

Typofix.
------------------------------------------------------------------------
r1530 | sally | 2011-07-13 07:24:11 -0600 (Wed, 13 Jul 2011) | 1 line
Changed paths:
M /foo/bar
M /foo/build

Fix up some svn:ignore properties.
------------------------------------------------------------------------
$
</screen>
      </informalexample>
      <tip>
        <para>
          <option>--search</option> and <option>--search-and</option>
          options does not actually perform a search.  They just filter
          the <command>svn log</command> output to display only log
          messages that match the specified pattern.  Therefore, if
          <option>--limit</option> is used, it restricts the number
          of log messages searched, rather than restricting the
          output to a particular number of matching log messages.
        </para>
      </tip>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.merge">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>merge</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn merge</refname>
      <refpurpose>Apply the differences between two sources to a
      working copy path.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn merge SOURCE[@REV] [TARGET_WCPATH]</literal></para>
      <para><literal>svn merge [-c M[,N...] | -r N:M ...] SOURCE[@REV] [TARGET_WCPATH]</literal></para>
      <para><literal>svn merge SOURCE1[@N] SOURCE2[@M] [TARGET_WCPATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>In all three forms
        <replaceable>TARGET_WCPATH</replaceable> is
        the working copy path that will receive the differences. If
        <replaceable>TARGET_WCPATH</replaceable> is omitted, the
        changes are applied to the current working directory,
        unless the sources have identical basenames that match a
        file within the current working directory.  In
        that case, the differences will be applied to that
        file.</para>

      <para>In the first two forms, <replaceable>SOURCE</replaceable>
        can be either a URL or a working copy path (in which case its
        corresponding URL is used). If the peg revision
        <replaceable>REV</replaceable> is not specified, then
        <literal>HEAD</literal> is assumed.  In the third form the
        same rules apply for
        <replaceable>SOURCE1</replaceable>,
        <replaceable>SOURCE2</replaceable>,
        <replaceable>M</replaceable>, and <replaceable>N</replaceable>
        with the only difference being that if either source is a
        working copy path, then the peg revisions
        <emphasis>must</emphasis> be explicitly stated.</para>

      <itemizedlist>
        <listitem>
          <para>Automatic Merges</para>
          <para>The first form is called an <quote>automatic
            merge</quote> and is used to perform <quote>sync</quote>
            and <quote>reintegrate</quote> merges.
            <quote>Sync</quote> merges merge eligible changes to a
            branch (<replaceable>TARGET_WCPATH</replaceable>) from
            the branch's ancestor branch
            (<replaceable>SOURCE</replaceable>).
            <quote>Eligible</quote> changes are defined as those that
            were not previously merged from
            (<replaceable>SOURCE</replaceable>) to
            (<replaceable>TARGET_WCPATH</replaceable>).  See
            <xref linkend="svn.branchmerge.basicmerging.stayinsync"/>.
            <quote>Reintegrate</quote> merges merge changes from a
            feature branch (<replaceable>SOURCE</replaceable>)
            back into the feature branch's ancestor branch
            (<replaceable>TARGET_WCPATH</replaceable>), see
            <xref linkend="svn.branchmerge.basicmerging.reintegrate"/>
            and
            <xref linkend="svn.branchmerge.commonpatterns.feature"/>.
            </para>
        </listitem>
        <listitem>
          <para>Cherrypick Merges</para>
          <para>The second form is called a <quote>cherry-pick</quote>
            merge and is used to merge an explicitly defined set of
            changes from one branch to another.
            <replaceable>SOURCE</replaceable> in revision
            <replaceable>REV</replaceable> is compared as it existed
            between revisions <replaceable>N</replaceable> and
            <replaceable>M</replaceable> for each revision range
            provided.  See
            <xref linkend="svn.branchmerge.cherrypicking"/> for more
            information.</para>
          <tip>
            <para>Multiple <literal>-c</literal> and/or
              <literal>-r</literal> instances may be specified, and
              mixing of forward and reverse ranges is allowed 
              the ranges are internally compacted to their minimum
              representation before merging begins (which may result
              in a no-op merge or conflicts that cause the merge to
              stop before merging all of the requested revisions).</para>
          </tip>
        </listitem>
        <listitem>
          <para>2-URL Merges</para>
          <para>In the third form, called a <quote>2-URL Merge</quote>,
            the difference between <replaceable>SOURCE1</replaceable>
            at revision <replaceable>N</replaceable> and
            <replaceable>SOURCE2</replaceable> at revision
            <replaceable>M</replaceable> is generated and applied to
            <replaceable>TARGET_WCPATH</replaceable>.  The revisions
            default to <literal>HEAD</literal> if omitted.</para>
        </listitem>
      </itemizedlist>

      <para>If
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
        is active, then Subversion will internally track metadata
        (i.e. the <literal>svn:mergeinfo</literal> property) about
        merge operations when the two merge sources are ancestrally
        related if the first source is an ancestor of the
        second or vice versa this is guaranteed to be the case
        when performing automatic merges.  Subversion will also take
        preexisting merge metadata on the working copy target into
        account when determining what revisions to merge and in an
        effort to avoid repeat merges and needless conflicts it may
        only merge a subset of the requested ranges.</para>

      <para>Unlike <command>svn diff</command>, the merge command
        takes the ancestry of a file into consideration when
        performing a merge operation. This is very important when
        you're merging changes from one branch into another and you've
        renamed a file on one branch but not the other.</para>

      <tip>
        <para>The <option>--ignore-ancestry</option> option will cause
        <xref linkend="svn.branchmerge.basicmerging.mergetracking"/>
        to be disabled and makes merge act like
        <command>svn diff</command>, ignoring the ancestry of files
        when merging.</para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.allow_mixed_revisions" />
<xref linkend="svn.ref.svn.sw.change" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
<xref linkend="svn.ref.svn.sw.dry_run" />
<xref linkend="svn.ref.svn.sw.extensions" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_ancestry" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.record_only" />
<xref linkend="svn.ref.svn.sw.reintegrate" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.verbose" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Reintegrate a branch back into the trunk assuming
        that you have an up-to-date working copy of the trunk (the
        <option>--verbose</option> option prints additional
        information regarding what the merge is doing prior to
        actually applying any diff; useful in very large which
        might take a significant amount of time to complete):</para>

      <informalexample>
        <screen>
$ svn merge ^/branches/feature-branch-calc-enhancements trunk --verbose
checking branch relationship...
calculating automatic merge...
merging...
--- Merging r12 through r37 into 'trunk':
U    trunk/calc/brush.c
--- Recording mergeinfo for merge of r12 through r37 into 'trunk':
 U   trunk

$ # build, test, verify, ...

$ svn commit trunk -m "Reintegrate the calc enhancements back to trunk!"
Sending        trunk
Sending        trunk/calc/brush.c
Transmitting file data .
Committed revision 38.
</screen>
      </informalexample>
      
    <para>Cherry-pick merge a single change to a file:</para>

    <informalexample>
      <screen>
$ svn merge ^/trunk/calc/brush.c branches/1.x/calc/brush.c -c38
--- Merging r38 into 'branches/1.x/calc/brush.c':
U    branches/1.x/calc/brush.c
--- Recording mergeinfo for merge of r38 into 'branches/1.x/calc/brush.c':
 G   branches/1.x/calc/brush.c
</screen>
    </informalexample>

    <para>Merge the differences between two unrelated branches
      into a third branch:</para>

    <informalexample>
      <screen>
$ svn merge ^/vendor-drop/vendor-1.0 ^/vendor-drop/vendor-1.1 \
            trunk --ignore-ancestry
--- Merging differences between repository URLs into 'trunk':
U    trunk/draw/draw.py
</screen>
    </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.mergeinfo">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>mergeinfo</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn mergeinfo</refname>
      <refpurpose>Query merge-related information.  See <xref
        linkend="svn.branchmerge.basicmerging.mergeinfo"/> for
        details.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn mergeinfo SOURCE_URL[@REV] [TARGET[@REV]]</literal></para>

    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      <para>Query information related to merges (or potential
        merges) between <replaceable>SOURCE-URL</replaceable> and
        <replaceable>TARGET</replaceable>.  If
        the <option>--show-revs</option> option is not provided,
        display a graphical representation of revisions which have
        been fully merged from <replaceable>SOURCE-URL</replaceable>
        to <replaceable>TARGET</replaceable>.  Otherwise, list
        either the <literal>merged</literal>
        or <literal>eligible</literal> revisions as specified by
        the <option>--show-revs</option> option.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.show_revs" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Graphical summary of the merges from one branch to
        another:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/trunk feature-branch
    youngest  last               repos.
    common    full     tip of    path of
    ancestor  merge    branch    branch

    11        16       33
    |         |        |
  -------| |------------         trunk
     \         \
      \         \
       --| |------------         feature-branch
                       |
                       33
</screen>
      </informalexample>

      <para>List the operative revisions merged from one branch to
        another:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/trunk feature-branch --show-revs merged
r15
r16
</screen>
      </informalexample>

      <para>List the operative revisions eligible to be merged from
        one branch to another:</para>

      <informalexample>
        <screen>
$ svn mergeinfo ^/trunk feature-branch --show-revs eligible
r28
r30
</screen>
      </informalexample>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.mkdir">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>mkdir</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn mkdir</refname>
      <refpurpose>Create a new directory under version control.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn mkdir PATH...</literal></para>
      <para><literal>svn mkdir URL...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Create a directory with a name given by the final
        component of the <replaceable>PATH</replaceable> or <replaceable>URL</replaceable>.
        A directory specified by a working copy
        <replaceable>PATH</replaceable> is scheduled for addition
        in the working copy.  A directory specified by a URL is
        created in the repository via an immediate commit.
        Multiple directory URLs are committed atomically.  In both
        cases, all the intermediate directories must already exist
        unless the <option>--parents</option> option is
        used.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Create a directory in your working copy:</para>

      <informalexample>
        <screen>
$ svn mkdir newdir
A         newdir
</screen>
      </informalexample>

      <para>Create one in the repository (this is an instant commit, so a
        log message is required):</para>

      <informalexample>
        <screen>
$ svn mkdir -m "Making a new dir." http://svn.red-bean.com/repos/newdir

Committed revision 26.
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.move">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>move</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn move (mv)</refname>
      <refpurpose>Move a file or directory.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn move SRC... DST</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This command moves files or directories in your
        working copy or in the repository.</para>

      <tip>
        <para>This command is equivalent to an <command>svn
          copy</command> followed by <command>svn
          delete</command>.</para>
      </tip>

      <para>When moving multiple sources, they will be added as
        children of <replaceable>DST</replaceable>, which must be
        a directory.</para>

      <note>
        <para>Subversion does not support moving between working
          copies and URLs.  In addition, you can only move files
          within a single repository Subversion does not
          support cross-repository moving.  Subversion supports
          the following types of moves within a single repository:</para>
      </note>

      <variablelist>

        <varlistentry>
          <term>WC   WC</term>
          <listitem>
            <para>Move and schedule a file or directory for
              addition (with history).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>URL   URL</term>
          <listitem>
            <para>Complete server-side rename.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>When moving large trees you should be aware that the
        URL   URL moves are lighter than WC   WC moves. Moving
        nodes inside a working copy does more than just change directory
        listings (it will copy files, manage temporary files, and expand
        keywords) and may be significantly slower.</para>

      <para>Also bear in mind that a WC   WC move in a
        mixed-revision working copy may yield unexpected results
        (see <xref linkend="svn.basic.in-action.mixedrevs" />).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Move a file in your working copy:</para>

      <informalexample>
        <screen>
$ svn move foo.c bar.c
A         bar.c
D         foo.c
</screen>
      </informalexample>

      <para>Move several files in your working copy into a
        subdirectory:</para>

      <informalexample>
        <screen>
$ svn move baz.c bat.c qux.c src
A         src/baz.c
D         baz.c
A         src/bat.c
D         bat.c
A         src/qux.c
D         qux.c
</screen>
      </informalexample>

      <para>Move a file in the repository (this is an immediate commit,
        so it requires a commit message):</para>

      <informalexample>
        <screen>
$ svn move -m "Move a file" http://svn.red-bean.com/repos/foo.c \
                            http://svn.red-bean.com/repos/bar.c

Committed revision 27.
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.patch">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>patch</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn patch</refname>
      <refpurpose>Apply changes represented in a unidiff patch to
        the working copy.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn patch PATCHFILE [WCPATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This subcommand will apply changes described a
        unidiff-formatted patch
        file <replaceable>PATCHFILE</replaceable> to the working
        copy <replaceable>WCPATH</replaceable>.  As with most
        other working copy subcommands,
        if <replaceable>WCPATH</replaceable> is omitted, the
        changes are applied to the current working directory.  A
        unidiff patch suitable for application to a working copy
        can be produced with the <command>svn diff</command>
        command or third-party differencing tools.  Any
        non-unidiff content found in the patch file is
        ignored.</para>

      <para>Changes listed in the patch file will either be
        applied or rejected.  If a change does not match at its
        exact line offset, it may be applied earlier or later in
        the file if a match is found elsewhere for the surrounding
        lines of context provided by the patch.  A change may also
        be applied with <firstterm>fuzz</firstterm> meaning,
        one or more lines of context are ignored when attempting
        to match the change location.  If no matching context can
        be found for a change, the change conflicts and will be
        written to a reject file which bears the extension
        <filename>.svnpatch.rej</filename>.</para>

      <para><command>svn patch</command> reports a status line for
        patched file or directory using letter codes, very similar
        to the way that <command>svn update</command> provides
        notification.  The letter codes have the following
        meanings:</para>

      <variablelist>

        <varlistentry>
          <term><literal>A</literal></term>
          <listitem>
            <para>Added</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>D</literal></term>
          <listitem>
            <para>Deleted</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>C</literal></term>
          <listitem>
            <para>Conflicted</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>G</literal></term>
          <listitem>
            <para>Merged</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>U</literal></term>
          <listitem>
            <para>Updated</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>Changes applied with an offset or fuzz are reported on
        lines starting with the '<literal>&gt;</literal>'
        symbol. You should review such changes carefully.</para>

      <para>If the patch removes all content from a file, that
        file is automatically scheduled for deletion.  Likewise,
        if the patch creates a new file, that file is
        automatically scheduled for addition.  Use <command>svn
        revert</command> to undo undesired deletions and
        additions.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.dry_run" />
<xref linkend="svn.ref.svn.sw.ignore_whitespace" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.reverse_diff" />
<xref linkend="svn.ref.svn.sw.strip" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Apply a simple patch file generated by
        the <command>svn diff</command> command.  Our patch file
        will create a new file, delete another file, and modify a
        third's contents and properties.  Here's the patch file
        itself (which we'll assume is creatively named
        <filename>PATCH</filename>):</para>

      <informalexample>
        <programlisting>
Index: deleted-file
===================================================================
--- deleted-file	(revision 3)
+++ deleted-file	(working copy)
@@ -1 +0,0 @@
-This file will be deleted.
Index: changed-file
===================================================================
--- changed-file	(revision 4)
+++ changed-file	(working copy)
@@ -1,6 +1,6 @@
 The letters in a line of text
 Could make your day much better.
 But expanded into paragraphs,
-I'd tell of kangaroos and calves
+I'd tell of monkeys and giraffes
 Until you were all smiles and laughs
 From my letter made of letters.

Property changes on: changed-file
___________________________________________________________________
Added: propname
## -0,0 +1 ##
+propvalue
Index: added-file
===================================================================
--- added-file	(revision 0)
+++ added-file	(working copy)
@@ -0,0 +1 @@
+This is an added file.
</programlisting>
      </informalexample>
      
      <para>We can apply the previous patch file to another
        working copy from our repository using <command>svn
        patch</command>, and verify that it did the right thing by
        using <command>svn diff</command>:</para>

      <informalexample>
        <screen>
$ cd /some/other/workingcopy
$ svn patch /path/to/PATCH
D         deleted-file
UU        changed-file
A         added-file
$ svn diff
Index: deleted-file
===================================================================
--- deleted-file	(revision 3)
+++ deleted-file	(working copy)
@@ -1 +0,0 @@
-This file will be deleted.
Index: changed-file
===================================================================
--- changed-file	(revision 4)
+++ changed-file	(working copy)
@@ -1,6 +1,6 @@
 The letters in a line of text
 Could make your day much better.
 But expanded into paragraphs,
-I'd tell of kangaroos and calves
+I'd tell of monkeys and giraffes
 Until you were all smiles and laughs
 From my letter made of letters.

Property changes on: changed-file
___________________________________________________________________
Added: propname
## -0,0 +1 ##
+propvalue
Index: added-file
===================================================================
--- added-file	(revision 0)
+++ added-file	(working copy)
@@ -0,0 +1 @@
+This is an added file.
$
</screen>             
      </informalexample>
    
      <para>Sometimes you might need Subversion to interpret a
        patch <quote>in reverse</quote> where added things
        get treated as removed things, and vice-versa.  Use
        the <option>--reverse-diff</option> option for this
        purpose.  In the following example, we'll squirrel away
        a patch file which describes the changes in our working
        copy, and then use a reverse patch operation to undo those
        changes.</para>

      <informalexample>
        <screen>
$ svn status
M       foo.c
$ svn diff > PATCH
$ cat PATCH
Index: foo.c
===================================================================
--- foo.c	(revision 128)
+++ foo.c	(working copy)
@@ -1003,7 +1003,7 @@
     return ERROR_ON_THE_G_STRING;
 
   /* Do something in a loop. */
-  for (i = 0; i &lt; txns->nelts; i++)
+  for (i = 0; i &lt; txns->nelts; i--)
     {
       status = do_something(i);
       if (status)
$ svn patch --reverse-diff PATCH
U         foo.c
$ svn status
$
</screen>             
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propdel">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propdel</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propdel (pdel, pd)</refname>
      <refpurpose>Remove a property from an item.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propdel PROPNAME [PATH...]</literal></para>
      <para><literal>svn propdel PROPNAME --revprop -r REV [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This removes properties from files, directories, or
        revisions.  The first form removes versioned properties in
        your working copy, and the second removes unversioned
        remote properties on a repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Delete a property from a file in your working
        copy:</para>

      <informalexample>
        <screen>
$ svn propdel svn:mime-type some-script
property 'svn:mime-type' deleted from 'some-script'.
</screen>
      </informalexample>

      <para>Delete a revision property:</para>

      <informalexample>
        <screen>
$ svn propdel --revprop -r 26 release-date 
property 'release-date' deleted from repository revision '26'
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propedit">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propedit</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propedit (pedit, pe)</refname>
      <refpurpose>Edit the property of one or more items under
        version control.  See <xref
        linkend="svn.ref.svn.c.propset"/> later in this chapter.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propedit PROPNAME TARGET...</literal></para>
      <para><literal>svn propedit PROPNAME --revprop -r REV [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Edit one or more properties using your favorite
        editor.  The first form edits versioned properties in
        your working copy, and the second edits unversioned
        remote properties on a repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.force_log" />
<xref linkend="svn.ref.svn.sw.message" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.with_revprop" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para><command>svn propedit</command> makes it easy to
        modify properties that have multiple values:</para>

      <informalexample>
        <screen>
$ svn propedit svn:keywords foo.c 

    # svn will open in your favorite text editor a temporary file
    # containing the current contents of the svn:keywords property.  You
    # can add multiple values to a property easily here by entering one
    # value per line.  When you save the temporary file and exit,
    # Subversion will re-read the temporary file and use its updated
    # contents as the new value of the property.

Set new value for property 'svn:keywords' on 'foo.c'
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propget">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propget</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propget (pget, pg)</refname>
      <refpurpose>Print the value of a property.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propget PROPNAME [TARGET[@REV]...]</literal></para>
      <para><literal>svn propget PROPNAME --revprop -r REV [URL]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the value of a property on files,
        directories, or revisions.  The first form prints the
        versioned property of an item or items in your working
        copy, and the second prints unversioned remote
        properties on a repository revision.  See <xref
        linkend="svn.advanced.props"/> for more information on
        properties.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.show_inherited_props" />
<xref linkend="svn.ref.svn.sw.strict" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Examine a property of a file in your working
        copy:</para>

      <informalexample>
        <screen>
$ svn propget svn:keywords foo.c
Author
Date
Rev
</screen>
      </informalexample>

      <para>The same goes for a revision property:</para>

      <informalexample>
        <screen>
$ svn propget svn:log --revprop -r 20 
Began journal.
</screen>
      </informalexample>

      <para>For a more structured display of properties, use
        the <option>--verbose</option> (<option>-v</option>)
        option:</para>

      <informalexample>
        <screen>
$ svn propget svn:keywords foo.c --verbose
Properties on 'foo.c':
  svn:keywords
    Author
    Date
    Rev
</screen>
      </informalexample>

      <para>Examine the versioned properties inherited by a URL in
        your repository using the <option>--show-inherited-props
        </option> option:</para>

      <informalexample>
        <screen>
$ svn pg svn:global-ignores --verbose --show-inherited-props ^/branches/1.x
Inherited properties on 'http://svn.example.com/repos/branches/1.x',
from 'http://svn.example.com/repos':
  svn:global-ignores
    *.diff
    *.patch
</screen>
      </informalexample>

      <para>By default, <command>svn propget</command> will append
        a trailing end-of-line sequence to the property value it
        prints.  Most of the time, this is a desirable feature
        that has a positive effect on the printed output.  But
        there are times when you might wish to capture the precise
        property value, perhaps because that value is not textual
        in nature, but of some binary format (such as a JPEG
        thumbnail stored as a property value, for example).  To
        disable pretty-printing of property values, use
        the <option>--strict</option> option.</para>

      <para>Lastly, you can get <command>svn propget</command>
        output in XML format with the <option>--xml</option>
        option:</para>

      <informalexample>
        <screen>
$ svn propget --xml svn:ignore .
&lt;?xml version="1.0"?&gt;
&lt;properties&gt;
&lt;target
   path=""&gt;
&lt;property
   name="svn:ignore"&gt;*.o
&lt;/property&gt;
&lt;/target&gt;
&lt;/properties&gt;
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.proplist">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>proplist</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn proplist (plist, pl)</refname>
      <refpurpose>List all properties.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn proplist [TARGET[@REV]...]</literal></para>
      <para><literal>svn proplist --revprop -r REV [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>List all properties on files, directories, or
        revisions.  The first form lists versioned properties in
        your working copy, and the second lists unversioned remote
        properties on a repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.show_inherited_props" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>You can use <command>proplist</command> to see the properties on an
        item in your working copy:</para>

      <informalexample>
        <screen>
$ svn proplist foo.c
Properties on 'foo.c':
  svn:mime-type
  svn:keywords
  owner
</screen>
      </informalexample>

      <para>But with the <option>--verbose</option>
        (<option>-v</option>) flag, <command>svn
        proplist</command> is extremely handy as it also shows you
        the values for the properties:</para>

      <informalexample>
        <screen>
$ svn proplist -v foo.c
Properties on 'foo.c':
  svn:mime-type
    text/plain
  svn:keywords
    Author Date Rev
  owner
    sally
</screen>
      </informalexample>

      <para>List all the versioned properties inherited by a file in
        your working copy using the <option>--show-inherited-props
        </option> option:</para>

      <informalexample>
        <screen>
$ svn proplist --show-inherited-props foo.c
Inherited properties on 'foo.c',
from 'http://svn.example.com/repos':
  svn:auto-props
  svn:global-ignores
Inherited properties on 'foo.c',
from '/home/theob/svn/working-copies/baz-wc':
  svn:auto-props
</screen>
      </informalexample>

      <para>Lastly, you can get <command>svn proplist</command>
        output in XML format with the <option>--xml</option>
        option:</para>

      <informalexample>
        <screen>
$ svn proplist --xml 
&lt;?xml version="1.0"?&gt;
&lt;properties&gt;
&lt;target
   path="."&gt;
&lt;property
   name="svn:ignore"/&gt;
&lt;/target&gt;
&lt;/properties&gt;
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.propset">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>propset</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn propset (pset, ps)</refname>
      <refpurpose>Set <replaceable>PROPNAME</replaceable>
        to <replaceable>PROPVAL</replaceable> on files, directories,
        or revisions.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn propset PROPNAME [PROPVAL | -F VALFILE] PATH...</literal></para>
      <para><literal>svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [TARGET]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Set <replaceable>PROPNAME</replaceable> to
        <replaceable>PROPVAL</replaceable> on files, directories,
        or revisions.  The first example creates a versioned, local
        property change in the working copy, and the second
        creates an unversioned, remote property change on a
        repository revision
        (<replaceable>TARGET</replaceable> determines only which
        repository to access).</para>

      <tip>
        <para>Subversion has a number of <quote>special</quote>
          properties that affect its behavior.  See <xref
          linkend="svn.advanced.props.ref"/> for details.</para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.encoding" />
<xref linkend="svn.ref.svn.sw.file" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.revprop" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Set the MIME type for a file:</para>

      <informalexample>
        <screen>
$ svn propset svn:mime-type image/jpeg foo.jpg 
property 'svn:mime-type' set on 'foo.jpg'
</screen>
      </informalexample>

      <para>On a Unix system, if you want a file to have the
        executable permission set:</para>

      <informalexample>
        <screen>
$ svn propset svn:executable ON somescript
property 'svn:executable' set on 'somescript'
</screen>
      </informalexample>

      <para>Perhaps you have an internal policy to set certain
        properties for the benefit of your coworkers:</para>

      <informalexample>
        <screen>
$ svn propset owner sally foo.c
property 'owner' set on 'foo.c'
</screen>
      </informalexample>

      <para>If you made a mistake in a log message for a
        particular revision and want to change it, use
        <option>--revprop</option> and set <literal>svn:log</literal>
        to the new log message:</para>

      <informalexample>
        <screen>
$ svn propset --revprop -r 25 svn:log "Journaled about trip to New York."
property 'svn:log' set on repository revision '25'
</screen>
      </informalexample>

      <para>Or, if you don't have a working copy, you can
        provide a URL:</para>

      <informalexample>
        <screen>
$ svn propset --revprop -r 26 svn:log "Document nap." \
              http://svn.red-bean.com/repos
property 'svn:log' set on repository revision '25'
</screen>
      </informalexample>

      <para>Lastly, you can tell <command>propset</command> to take its input from
        a file.  You could even use this to set the contents of a
        property to something binary:</para>

      <informalexample>
        <screen>
$ svn propset owner-pic -F sally.jpg moo.c 
property 'owner-pic' set on 'moo.c'
</screen>
      </informalexample>

      <note>
        <para>By default, you cannot modify revision properties
          in a Subversion repository.  Your repository
          administrator must explicitly enable revision property
          modifications by creating a hook named
          <literal>pre-revprop-change</literal>.  See
          <xref linkend="svn.reposadmin.hooks" /> for more
          information on hook scripts.</para>
      </note>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.relocate">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>relocate</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn relocate</refname>
      <refpurpose>Relocate the working copy to point to a
        different repository root URL.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn relocate FROM-PREFIX TO-PREFIX [PATH...]</literal></para>
      <para><literal>svn relocate TO-URL [PATH]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Sometimes an administrator might change the location
        (or apparent location, from the client's perspective) of a
        repository.  The content of the repository doesn't change,
        but the repository's root URL does.  The hostname may
        change because the repository is now being served from a
        different computer.  Or, perhaps the URL scheme changes
        because the repository is now being served via SSL
        (using <literal>https://</literal>) instead of over plain
        HTTP.  There are many different reasons for these types of
        repository relocations.  But ideally, a <quote>change of
        address</quote> for a repository shouldn't suddently cause
        all the working copies which point to that repository to
        become forever unusable.  And fortunately, that's not the
        case.  Rather than force users to check out a new working
        copy when a repository is relocated, Subversion provides
        the <command>svn relocate</command> command, which 
        <quote>rewrites</quote> the working copy's administrative
        metadata to refer to the new repository location.</para>

      <para>The first <command>svn relocate</command> syntax
        allows you to update one or more working copies by what
        essentially amounts to a find-and-replace within the
        repository root URLs recorded in those working copies.
        Subversion will replace the initial substring
        <replaceable>FROM-PREFIX</replaceable> with the
        string <replaceable>TO-PREFIX</replaceable> in those URLs.
        These initial URL substrings can be as long or as short as
        is necessary to differentiate between them.  Obviously, to
        use this syntax form, you need to know both the current
        root URL of the repository to which the working copy is
        pointing, and the new URL of that repository.
        (You can use <command>svn info</command> to determine
        the former.)</para>

      <para>The second syntax does not require that you know the
        current repository root URL with which the working copy is
        associated at all only the new repository URL
        (<replaceable>TO-URL</replaceable>) to which it should be
        pointing.  In this syntax form, only one working copy may
        be relocated at a time.</para>

      <warning>
        <para>Users often get confused about the difference
          between <command>svn switch</command> and <command>svn
          relocate</command>.  Here's the rule of thumb:</para>
        
        <itemizedlist>
          <listitem>
            <para>If the working copy needs to reflect a new
              directory <emphasis>within</emphasis> the
              repository, use <command>svn
              switch</command>.</para>
          </listitem>
          <listitem>
            <para>If the working copy still reflects the
              same repository directory, but the location of the
              repository itself has changed, use <command>svn
              relocate</command>.</para>
          </listitem>
        </itemizedlist>
      </warning>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.ignore_externals" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Let's start with a working copy that reflects a local
        repository URL:</para>

      <informalexample>
        <screen>
$ svn info | grep URL:
URL: file:///var/svn/repos/trunk
$
</screen>
      </informalexample>

      <para>One day the administrator decides to rename the
        on-disk repository directory.  We missed the memo, so we
        see an error the next time we try to update our working
        copy.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
svn: E180001: Unable to connect to a repository at URL 'file:///var/svn/repos/trunk'
</screen>
      </informalexample>

      <para>After cornering the administrator over by the vending
        machines, we learn about the repository being moved and
        are told the new URL.  Rather than checkout a new working
        copy, though, we simply ask Subversion to rewrite the
        working copy metadata to point to the new repository
        location.</para>

      <informalexample>
        <screen>
$ svn relocate file:///var/svn/new-repos/trunk
$
</screen>
      </informalexample>

      <para>Subversion doesn't tell us much about what it did, but
        hey error-free operation is really all we need,
        right?  Our working copy is functional for online
        operations again.</para>

      <informalexample>
        <screen>
$ svn up
Updating '.':
A    lib/new.c
M    src/code.h
M    src/headers.h
 
</screen>
      </informalexample>

      <note>
        <para>Once again, this type of relocation
          affects <emphasis>working copy metadata only</emphasis>.
          It will not change your versioned or unversioned file
          contents, perform any version control operations (such
          as commits or updates), and so on.</para>
      </note>

      <para>A few months later, we're told that the company is
        moving development to separate machines and that we'll be
        using HTTP to access the repository.  So we relocate our
        working copy again.</para>

      <informalexample>
        <screen>
$ svn relocate http://svn.company.com/repos/trunk
$
</screen>
      </informalexample>

      <para>Now, each time we perform a relocation of this sort,
        Subversion contacts the repository at its new URL,
        of course to verify a few things.</para>

      <para>First, it wants to compare the UUID of the repository
        against what is stored in the working copy.  If these UUIDs
        don't match, the working copy relocation is disallowed.
        Maybe this isn't the same repository (just in a new
        location) after all?</para>

      <para>Secondly, Subversion wants to ensure that the updated
        working copy metadata jives with respect to the directory
        location <emphasis>inside</emphasis> the repository.
        Subversion won't let you accidentally relocate a working
        copy of a branch in your repository to the URL of a
        different branch in the same repository.  (That's
        what <command>svn switch</command>, described in
        <xref linkend="svn.ref.svn.c.switch" />, is for.)</para>

      <para>Also, Subversion will not allow you to relocate a
        subtree of the working copy.  If you're going to relocate
        the working copy at all, you must relocate the whole
        thing.  This is to protect the integrity of the working
        copy metadata and behavior as a whole.  (And really, you'd
        be hard pressed to come up with a compelling reason to
        relocate only a piece of your working copy anyway.)</para>

      <para>Let's look at one final relocation opportunity.  After
        using HTTP access for some time, the company moves to
        SSL-only access.  Now, the only change to the repository
        URL is that the scheme goes from
        being <literal>http://</literal> to
        being <literal>https://</literal>.  There are two
        different ways that we could make our working copy reflect
        ths change.  The first is to do exactly as we've done
        before and relocate to the new repository URL.</para>

      <informalexample>
        <screen>
$ svn relocate http://svn.company.com/repos/trunk
$
</screen>
      </informalexample>

      <para>But we have another option here, too.  We could simply
        ask Subversion to swap out the changed prefixes of the
        URL.</para>

      <informalexample>
        <screen>
$ svn relocate http https
$
</screen>
      </informalexample>

      <para>Either approach leaves us a working copy whose
        metadata has been updated to point to the right repository
        location.</para>

      <para>By default, <command>svn relocate</command> will
        traverse any external working copies nested within your
        working copy and attempt relocation of those working
        copies, too.  Use the <option>--ignore-externals</option>
        option to disable this behavior.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.resolve">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>resolve</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn resolve</refname>
      <refpurpose>Resolve conflicts on working copy files or
        directories.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn resolve [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Resolve <quote>conflicted</quote> state on working
        copy files or directories.  This routine does not
        semantically resolve conflict markers; however, it
        replaces the conflicted item with the version specified
        (interactively or via the <option>--accept</option>
        argument) and then removes conflict-related artifact
        files.  This allows <replaceable>PATH</replaceable> to be
        committed again that is, it tells Subversion that
        the conflicts have been <quote>resolved.</quote></para>

      <para>See <xref linkend="svn.tour.cycle.resolve" /> for an
        in-depth look at resolving conflicts.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>Here's an example where, after a postponed conflict
        resolution during update, <command>svn resolve</command>
        replaces the all conflicts in
        file <filename>foo.c</filename> with your edits:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
Conflict discovered in 'foo.c'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options: p
C    foo.c
Updated to revision 5.
Summary of conflicts:
  Text conflicts: 1
$ svn resolve --accept mine-full foo.c
Resolved conflicted state of 'foo.c'
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.resolved">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>resolved</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn resolved</refname>
      <refpurpose><emphasis>Deprecated</emphasis>.
        Remove <quote>conflicted</quote> state on working copy
        files or directories.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn resolved PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This command has been deprecated in favor of
        running <userinput>svn resolve --accept
        working <replaceable>PATH</replaceable></userinput>.  See
        <xref linkend="svn.ref.svn.c.resolve"/> in the preceding
        section for details.</para>

      <para>Remove <quote>conflicted</quote> state on working copy
        files or directories.  This routine does not semantically
        resolve conflict markers; it merely removes
        conflict-related artifact files and allows
        <replaceable>PATH</replaceable> to be committed again;
        that is, it tells Subversion that the conflicts have been
        <quote>resolved.</quote>  See <xref
        linkend="svn.tour.cycle.resolve"/> for an in-depth look at
        resolving conflicts.</para> </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>If you get a conflict on an update, your working
        copy will sprout three new files:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
C    foo.c
Updated to revision 31.
Summary of conflicts:
  Text conflicts: 1
$ ls foo.c*
foo.c
foo.c.mine
foo.c.r30
foo.c.r31
$
</screen>
      </informalexample>

      <para>Once you've resolved the conflict and
        <filename>foo.c</filename> is ready to be committed, run
        <command>svn resolved</command> to let your working copy
        know you've taken care of everything.</para>

      <warning>
        <para>You <emphasis>can</emphasis> just remove the
          conflict files and commit, but <command>svn
          resolved</command> fixes up some bookkeeping data
          in the working copy administrative area in addition
          to removing the conflict files, so we recommend that
          you use this command.</para>
      </warning>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.revert">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>revert</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn revert</refname>
      <refpurpose>Undo all local edits.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn revert PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Reverts any local changes to a file or directory and
        resolves any conflicted states.  <command>svn
        revert</command> will revert not only the contents of an
        item in your working copy, but also any property
        changes.  Finally, you can use it to undo any scheduling
        operations that you may have performed (e.g., files scheduled
        for addition or deletion can be
        <quote>unscheduled</quote>).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.recursive" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Discard changes to a file:</para>

      <informalexample>
        <screen>
$ svn revert foo.c
Reverted foo.c
</screen>
      </informalexample>

      <para>If you want to revert a whole directory of files,
        use the <option>--depth=infinity</option> option:</para>

      <informalexample>
        <screen>
$ svn revert --depth=infinity .
Reverted newdir/afile
Reverted foo.c
Reverted bar.txt
</screen>
      </informalexample>

      <para>Lastly, you can undo any scheduling
        operations:</para>

      <informalexample>
        <screen>
$ svn add mistake.txt whoops
A         mistake.txt
A         whoops
A         whoops/oopsie.c

$ svn revert mistake.txt whoops
Reverted mistake.txt
Reverted whoops

$ svn status
?       mistake.txt
?       whoops
</screen>
      </informalexample>

      <warning>
        <para><command>svn revert</command> is inherently
          dangerous, since its entire purpose is to throw away
          data namely, your uncommitted changes.  Once
          you've reverted, Subversion provides <emphasis>no
          way</emphasis> to get back those uncommitted
          changes.</para>

        <para>If you provide no targets to <command>svn
          revert</command>, it will do nothing.  To protect you
          from accidentally losing changes in your working
          copy, <command>svn revert</command> requires you to
          explicitly provide at least one target.</para>
      </warning>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.status">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>status</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn status (stat, st)</refname>
      <refpurpose>Print the status of working copy files and directories.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn status [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the status of working copy files and
        directories.  With no arguments, it prints only locally
        modified items (no repository access).  With
        <option>--show-updates</option> (<option>-u</option>), it
        adds working revision and server out-of-date information.
        With <option>--verbose</option> (<option>-v</option>), it
        prints full revision information on every item.
        With <option>--quiet</option> (<option>-q</option>), it
        prints only summary information about locally modified
        items.</para>

      <para>The first seven columns in the output are each one
        character wide, and each column gives you information
        about a different aspect of each working copy item.</para>
      
      <para>The first column indicates that an item
        was added, deleted, or otherwise changed:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>No modifications.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'A'</literal></term>
          <listitem>
            <para>Item is scheduled for addition.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'D'</literal></term>
          <listitem>
            <para>Item is scheduled for deletion.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'M'</literal></term>
          <listitem>
            <para>Item has been modified.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'R'</literal></term>
          <listitem>
            <para>Item has been replaced in your working copy.
            This means the file was scheduled for deletion, and
            then a new file with the same name was scheduled for
            addition in its place.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'C'</literal></term>
          <listitem>
            <para>The contents (as opposed to the properties) of
              the item conflict with updates received from the
              repository.</para>  
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'X'</literal></term>
          <listitem>
            <para>Item is present because of an externals definition.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'I'</literal></term>
          <listitem>
            <para>Item is being ignored (e.g., with the 
              <literal>svn:ignore</literal> property).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'?'</literal></term>
          <listitem>
            <para>Item is not under version control.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'!'</literal></term>
          <listitem>
            <para>Item is missing (e.g., you moved or deleted it
              without using <command>svn</command>).  This also
              indicates that a directory is incomplete (a checkout
              or update was interrupted).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'~'</literal></term>
          <listitem>
            <para>Item is versioned as one kind of object (file,
              directory, link), but has been replaced by a different
              kind of object.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The second column tells the status of a file's or
        directory's properties:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>No modifications.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'M'</literal></term>
          <listitem>
            <para>Properties for this item have been
              modified.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'C'</literal></term>
          <listitem>
            <para>Properties for this item are in conflict with
              property updates received from the
              repository.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The third column is populated only if the
        working copy directory is locked (see
        <xref linkend="svn.tour.cleanup"/>):</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>Item is not locked.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'L'</literal></term>
          <listitem>
            <para>Item is locked.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The fourth column is populated only if the item is
        scheduled for addition-with-history:</para>
      
      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>No history scheduled with commit.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'+'</literal></term>
          <listitem>
            <para>History scheduled with commit.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The fifth column is populated only if the item is
        switched relative to its parent (see <xref
        linkend="svn.branchmerge.switchwc"/>):</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>Item is a child of its parent directory.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'S'</literal></term>
          <listitem>
            <para>Item is switched.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The sixth column is populated with lock information:</para>
      
      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>When <option>--show-updates</option>
              (<option>-u</option>) is used, this means the file is not
              locked.  If <option>--show-updates</option>
              (<option>-u</option>) is <emphasis>not</emphasis>
              used, this merely means that the file is not locked
              in this working copy.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'K'</literal></term>
          <listitem>
            <para>File is locked in this working copy.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'O'</literal></term>
          <listitem>
            <para>File is locked either by another user or in
            another working copy.  This appears only when
            <option>--show-updates</option>
            (<option>-u</option>) is used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'T'</literal></term>
          <listitem>
            <para>File was locked in this working copy, but the
            lock has been <quote>stolen</quote> and is invalid.
            The file is currently locked in the repository.  This
            appears only when <option>--show-updates</option>
            (<option>-u</option>) is used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'B'</literal></term>
          <listitem>
            <para>File was locked in this working copy, but the
              lock has been <quote>broken</quote> and is invalid.
              The file is no longer locked.  This appears only
              when <option>--show-updates</option>
              (<option>-u</option>) is used.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The seventh column is populated only if the item is
        the victim of a tree conflict:</para>

      <variablelist>

        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>Item is not the victim of a tree conflict.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'C'</literal></term>
          <listitem>
            <para>Item is the victim of a tree conflict.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The eighth column is always blank.</para>

      <para>The out-of-date information appears in the ninth
        column (only if you pass the
        <option>--show-updates</option> (<option>-u</option>)
        option):</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>' '</literal></term>
          <listitem>
            <para>The item in your working copy is up to date.</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><literal>'*'</literal></term>
          <listitem>
            <para>A newer revision of the item exists on the
              server.</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>The remaining fields are variable width and delimited
        by spaces.  The working revision is the next field if
        the <option>--show-updates</option> (<option>-u</option>)
        or <option>--verbose</option> (<option>-v</option>) option
        is passed.</para>
      
      <para>If the <option>--verbose</option>
        (<option>-v</option>) option is passed, the last committed
        revision and last committed author are displayed
        next.</para>
      
      <para>The working copy path is always the final field, so
        it can include spaces.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.incremental" />
<xref linkend="svn.ref.svn.sw.no_ignore" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.show_updates" />
<xref linkend="svn.ref.svn.sw.verbose" />
<xref linkend="svn.ref.svn.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This is the easiest way to find out what changes you
        have made to your working copy:</para>

      <informalexample>
        <screen>
$ svn status wc
 M      wc/bar.c
A  +    wc/qax.c
</screen>
      </informalexample>

      <para>If you want to find out what files in your working
        copy are out of date, pass
        the <option>--show-updates</option> (<option>-u</option>)
        option (this will <emphasis>not</emphasis> make any
        changes to your working copy).  Here you can see that
        <filename>wc/foo.c</filename> has changed in the
        repository since we last updated our working
        copy:</para>

      <informalexample>
        <screen>
$ svn status -u wc
 M            965    wc/bar.c
        *     965    wc/foo.c
A  +          965    wc/qax.c
Status against revision:    981
</screen>
      </informalexample>

      <note>
        <para><option>--show-updates</option>
          (<option>-u</option>) <emphasis>only</emphasis> places
          an asterisk next to items that are out of date (i.e.,
          items that will be updated from the repository if you
          later use <command>svn update</command>).
          <option>--show-updates</option> (<option>-u</option>)
          does <emphasis>not</emphasis> cause the status listing
          to reflect the repository's version of the item
          (although you can see the revision number in the
          repository by passing the <option>--verbose</option>
          (<option>-v</option>) option).</para>
      </note>

      <para>The most information you can get out of
        the status subcommand is as follows:</para>

      <informalexample>
        <screen>
$ svn status -u -v wc
 M            965       938 sally        wc/bar.c
        *     965       922 harry        wc/foo.c
A  +          965       687 harry        wc/qax.c
              965       687 harry        wc/zig.c
Status against revision:   981
</screen>
      </informalexample>

      <para>Lastly, you can get <command>svn status</command>
        output in XML format with the <option>--xml</option>
        option:</para>

      <informalexample>
        <screen>
$ svn status --xml wc
&lt;?xml version="1.0"?&gt;
&lt;status&gt;
&lt;target
   path="wc"&gt;
&lt;entry
   path="qax.c"&gt;
&lt;wc-status
   props="none"
   item="added"
   revision="0"&gt;
&lt;/wc-status&gt;
&lt;/entry&gt;
&lt;entry
   path="bar.c"&gt;
&lt;wc-status
   props="normal"
   item="modified"
   revision="965"&gt;
&lt;commit
   revision="965"&gt;
&lt;author&gt;sally&lt;/author&gt;
&lt;date&gt;2008-05-28T06:35:53.048870Z&lt;/date&gt;
&lt;/commit&gt;
&lt;/wc-status&gt;
&lt;/entry&gt;
&lt;/target&gt;
&lt;/status&gt;
</screen>
      </informalexample>

      <para>For many more examples of <command>svn status</command>,
        see <xref linkend="svn.tour.cycle.examine.status"/>.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.switch">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>switch</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn switch (sw)</refname>
      <refpurpose>Update working copy to a different URL.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn switch URL[@PEGREV] [PATH]</literal></para>
      <para><literal>switch --relocate FROM TO [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The first variant of this subcommand (without the
        <option>--relocate</option> option) updates your working
        copy to point to a new URL.  This is the Subversion way to
        make a working copy begin tracking a new branch.  If
        specified, <replaceable>PEGREV</replaceable> determines in
        which revision the target is first looked up.  See
        <xref linkend="svn.branchmerge.switchwc"/> for an in-depth
        look at switching.</para>

      <note>
        <para>Beginning with Subversion 1.7, the <command>svn
          switch</command> command will demand by default that the
          URL to which you are switching your working copy shares
          a common ancestry with item that the working copy
          currently reflects.  You can override this behavior by
          specifying the <option>--ignore-ancestry</option>
          option.</para>
      </note>

      <para>If <option>--force</option> is used, unversioned
        obstructing paths in the working copy do not automatically
        cause a failure if the switch attempts to add the same
        path.  If the obstructing path is the same type (file or
        directory) as the corresponding path in the repository, it
        becomes versioned but its contents are left untouched in
        the working copy.  This means that an obstructing
        directory's unversioned children may also obstruct and
        become versioned.  For files, any content differences
        between the obstruction and the repository are treated
        like a local modification to the working copy.  All
        properties from the repository are applied to the
        obstructing path.</para>

      <para>As with most subcommands, you can limit the scope of
        the switch operation to a particular tree depth using the
        <option>--depth</option> option.  Alternatively, you can
        use the <option>--set-depth</option> option to set a new
        <quote>sticky</quote> working copy depth on the switch
        target.</para>

      <para>The <option>--relocate</option> option is deprecated
        as of Subversion 1.7.  Use <command>svn relocate</command>
        (described in <xref linkend="svn.ref.svn.c.relocate" />)
        to perform working copy relocation instead.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_ancestry" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.relocate" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.set_depth" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>If you're currently inside the directory
        <filename>vendors</filename>, which was branched to
        <filename>vendors-with-fix</filename>, and you'd like to
        switch your working copy to that branch:</para>

      <informalexample>
        <screen>
$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .
U    myproj/foo.txt
U    myproj/bar.txt
U    myproj/baz.c
U    myproj/qux.c
Updated to revision 31.
</screen>
      </informalexample>

      <para>To switch back, just provide the URL to the
        location in the repository from which you originally
        checked out your working copy:</para>

      <informalexample>
        <screen>
$ svn switch http://svn.red-bean.com/repos/trunk/vendors .
U    myproj/foo.txt
U    myproj/bar.txt
U    myproj/baz.c
U    myproj/qux.c
Updated to revision 31.
</screen>
      </informalexample>

      <tip>
        <para>You <emphasis>can</emphasis> switch just part of
          your working copy to a branch if you don't want to
          switch your entire working copy, but this is not
          generally recommended.  It's too easy to forget that
          you've done this and wind up accidentally making and
          committing changes both to the switched and unswitched
          portions of your tree.</para>
      </tip>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.unlock">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>unlock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn unlock</refname> 
        <refpurpose>Unlock working copy paths or URLs.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn unlock TARGET...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Unlock each <replaceable>TARGET</replaceable>.  If any
        <replaceable>TARGET</replaceable> is locked by
        another user or no valid lock token exists in the working
        copy, print a warning and continue unlocking the rest of
        the <replaceable>TARGET</replaceable>s.  Use
        <option>--force</option> to break a lock belonging to
        another user or working copy.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Unlock two files in your working copy:</para>

      <informalexample>
        <screen>
$ svn unlock tree.jpg house.jpg
'tree.jpg' unlocked.
'house.jpg' unlocked.
</screen>
      </informalexample>

      <para>Unlock a file in your working copy that is currently
        locked by another user:</para>

      <informalexample>
        <screen>
$ svn unlock tree.jpg
svn: E195013: 'tree.jpg' is not locked in this working copy
$ svn unlock --force tree.jpg
'tree.jpg' unlocked.
</screen>
      </informalexample>

      <para>Unlock a file without a working copy:</para>

      <informalexample>
        <screen>
$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg
'tree.jpg unlocked.
</screen>
      </informalexample>

      <para>For further details, see <xref
        linkend="svn.advanced.locking"/>.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.update">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>update</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn update (up)</refname>
      <refpurpose>Update your working copy.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn update [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para><command>svn update</command> brings changes from the
        repository into your working copy.  If no revision is
        given, it brings your working copy up to date with the
        <literal>HEAD</literal> revision.  Otherwise, it
        synchronizes the working copy to the revision given by the
        <option>--revision</option> (<option>-r</option>) option.
        As part of the synchronization, <command>svn
        update</command> also removes any stale locks (see
        <xref linkend="svn.tour.cleanup"/>) found in the working
        copy.</para>

      <para>For each updated item, it prints a line that starts
        with a character reporting the action taken.  These
        characters have the following meaning:</para>

      <variablelist>

        <varlistentry>
          <term><literal>A</literal></term>
          <listitem>
            <para>Added</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>B</literal></term>
          <listitem>
            <para>Broken lock (third column only)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>D</literal></term>
          <listitem>
            <para>Deleted</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>U</literal></term>
          <listitem>
            <para>Updated</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>C</literal></term>
          <listitem>
            <para>Conflicted</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>G</literal></term>
          <listitem>
            <para>Merged</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>E</literal></term>
          <listitem>
            <para>Existed</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>A character in the first column signifies an update to
        the actual file, whereas updates to the file's properties
        are shown in the second column.  Lock information is
        printed in the third column.</para>

      <para>As with most subcommands, you can limit the scope of
        the update operation to a particular tree depth using the
        <option>--depth</option> option.  Alternatively, you can
        use the <option>--set-depth</option> option to set a new
        <quote>sticky</quote> working copy depth on the update
        target.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.accept" />
<xref linkend="svn.ref.svn.sw.changelist" />
<xref linkend="svn.ref.svn.sw.depth" />
<xref linkend="svn.ref.svn.sw.diff3_cmd" />
<xref linkend="svn.ref.svn.sw.editor_cmd" />
<xref linkend="svn.ref.svn.sw.force" />
<xref linkend="svn.ref.svn.sw.ignore_externals" />
<xref linkend="svn.ref.svn.sw.parents" />
<xref linkend="svn.ref.svn.sw.quiet" />
<xref linkend="svn.ref.svn.sw.revision" />
<xref linkend="svn.ref.svn.sw.set_depth" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Pick up repository changes that have happened since
        your last update:</para>

      <informalexample>
        <screen>
$ svn update
Updating '.':
A    newdir/toggle.c
A    newdir/disclose.c
A    newdir/launch.c
D    newdir/README
Updated to revision 32.
</screen>
      </informalexample>

      <para>You can also <quote>update</quote> your working copy
        to an older revision (Subversion doesn't have the concept
        of <quote>sticky</quote> files like CVS does; see <xref
        linkend="svn.forcvs"/>):</para>

      <informalexample>
        <screen>
$ svn update -r30
Updating '.':
A    newdir/README
D    newdir/toggle.c
D    newdir/disclose.c
D    newdir/launch.c
U    foo.c
Updated to revision 30.
</screen>
      </informalexample>

      <tip>
        <para>If you want to examine an older revision of a
          single file, you may want to use <command>svn
          cat</command> instead it won't change your working
          copy.</para>
      </tip>

      <para><command>svn update</command> is also the primary
        mechanism used to configure sparse working copies.  When
        used with the <option>--set-depth</option>, the update
        operation will omit or reenlist individual working copy
        members by modifying their recorded ambient depth to the
        depth you specify (fetching information from the
        repository as necessary).  See
        <xref linkend="svn.advanced.sparsedirs" /> for more about
        sparse directories.</para>
      
      <para>You can update multiple targets with a single
        invocation, and Subversion will not only gracefully skip
        any unversioned targets you provide it, but as of
        Subversion 1.7 will also include a post-update summary of
        all the updates it performed:</para>

      <informalexample>
        <screen>
$ cd my-projects
$ svn update *
Updating 'calc':
U    button.c
U    integer.c
Updated to revision 394.
Skipped 'tempfile.tmp'
Updating 'paint':
A    palettes.c
U    brushes.c
Updated to revision 60.
Updating 'ziptastic':
At revision 43.
Summary of updates:
  Updated 'calc' to r394.
  Updated 'paint' to r60.
  Updated 'ziptastic' to r43.
Summary of conflicts:
  Skipped paths: 1
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svn.c.upgrade">

    <indexterm>
      <primary>svn</primary>
      <secondary>subcommands</secondary>
      <tertiary>upgrade</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svn upgrade</refname>
      <refpurpose>Upgrade the metadata storage format for a
        working copy.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svn upgrade [PATH...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>As new versions of Subversion are released, the format
        used for the working copy metadata changes to accomodate
        new features or fix bugs.  Older versions of Subversion
        would automatically upgrade working copies to the new
        format the first time the working copy was used by the new
        version of the software.  Beginning with Subversion 1.7,
        working copy upgrades must be explicitly performed at the
        user's request.  <command>svn upgrade</command> is the
        subcommand used to trigger that upgrade process.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svn.sw.quiet" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>If you attempt to use Subversion 1.7 on a working copy
        created with an older version of Subversion, you will see
        an error:</para>

      <informalexample>
        <screen>
$ svn status
svn: E155036: Please see the 'svn upgrade' command
svn: E155036: Working copy '/home/sally/project' is too old (format 10, create
d by Subversion 1.6)
$
</screen>
      </informalexample>

      <para>Use the <command>svn upgrade</command> command to
        upgrade the working copy to the most recent metadata
        format supported by your version of Subversion.</para>

      <informalexample>
        <screen>
$ svn upgrade
Upgraded '.'
Upgraded 'A'
Upgraded 'A/B'
Upgraded 'A/B/E'
Upgraded 'A/B/F'
Upgraded 'A/C'
Upgraded 'A/D'
Upgraded 'A/D/G'
Upgraded 'A/D/H'
$ svn status
D       A/B/E/alpha
M       A/D/gamma
A       A/newfile
$
</screen>
      </informalexample>

      <para>Notice that <command>svn upgrade</command> preserved
        the local modifications present in the working copy at the
        time of the upgrade, which were introduced by the version
        of Subversion previously used to manipulate this working
        copy.</para>

      <warning>
        <para>As was the case with automatically upgraded working
          copies in the past, explicitly upgraded working copies
          will be unusable by older versions of Subversion,
          too.</para>
      </warning>
      
    </refsect1>
  </refentry>

</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnadmin">
  <title>svnadmin Reference Subversion Repository Administration</title>
  
  <partintro>
    <para><command>svnadmin</command> is the administrative tool for
      monitoring and repairing your Subversion repository.  For
      detailed information on repository administration, see the maintenance section for <xref
      linkend="svn.reposadmin.maint.tk.svnadmin"/>.</para>

    <para>Since <command>svnadmin</command> works via direct repository access
      (and thus can only be used on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</para>
      
    <para>Options in <command>svnadmin</command> are global, just
      as they are in <command>svn</command>:</para>

    <variablelist id="svn.ref.svnadmin.sw">
      <title>svnadmin Options</title>
      
      <varlistentry id="svn.ref.svnadmin.sw.bdb_log_keep">
        <term><option>--bdb-log-keep</option></term>
        <listitem>
          <para>(Berkeley DB-specific.) Disable automatic log removal
            of database logfiles.  Having these logfiles around
            can be convenient if you need to restore from a
            catastrophic repository failure.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svnadmin.sw.bdb_txn_nosync">
        <term><option>--bdb-txn-nosync</option></term>
        <listitem>

          <para>(Berkeley DB-specific.) Disables fsync when
            committing database transactions.  Used with the
            <command>svnadmin create</command> command to create a
            Berkeley DB-backed repository with
            <literal>DB_TXN_NOSYNC</literal> enabled (which improves
            speed but has some risks associated with it).</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svnadmin.sw.bypass_hooks">
        <term><option>--bypass-hooks</option></term>
        <listitem>
          <para>Bypass the repository hook system.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.bypass_prop_validation">
        <term><option>--bypass-prop-validation</option></term>
        <listitem>
          <para>When loading a dump file, disable the logic which
            validates property values.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.clean_logs">
        <term><option>--clean-logs</option></term>
        <listitem>
          <para>Remove unused Berkeley DB logs.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.compatible_version">
        <term><option>--compatible-version</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Use repository format compatible with Subversion version
            <replaceable>ARG</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.config_dir">
        <!-- Only 'svnadmin create' accepts it, and the underlying
             logic doesn't even use it.  Weird. -->
        <term><option>--config-dir</option> <replaceable>DIR</replaceable></term>
        <listitem>
          <para>Instructs Subversion to read configuration
            information from the specified directory instead of the
            default location (<filename>.subversion</filename> in
            the user's home directory).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.deltas">
        <term><option>--deltas</option></term>
        <listitem>
          <para>When creating a repository dump file, specify
            changes in versioned properties and file contents as
            deltas against their previous state.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.file">
        <term><option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable></term>
        <listitem>
          <para>Uses the contents of the named file for the
            specified subcommand.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.fs_type">
        <term><option>--fs-type</option> <replaceable>ARG</replaceable></term>
        <listitem>
          <para>When creating a repository,
            use <replaceable>ARG</replaceable> as the requested
            filesyste type.  <replaceable>ARG</replaceable> may be
            either <literal>bdb</literal>
            or <literal>fsfs</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.force_uuid">
        <term><option>--force-uuid</option></term>
        <listitem>
          <para>By default, when loading data into a repository that
            already contains revisions, <command>svnadmin</command>
            will ignore the UUID from the dump stream.  This option
            will cause the repository's UUID to be set to the UUID
            from the stream.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.ignore_uuid">
        <term><option>--ignore-uuid</option></term>
        <listitem>
          <para>By default, when loading data into an empty repository,
            <command>svnadmin</command> will set the repository's UUID
            to the UUID from the dump stream.  This option will cause
            the UUID from the stream to be ignored.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.incremental">
        <term><option>--incremental</option></term>
        <listitem>
          <para>Dump a revision only as a diff against the
            previous revision, instead of the usual
            fulltext.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.memory_cache_size">
        <term><option>--memory-cache-size</option> (<option>-M</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Configures the size (in Megabytes) of the extra
            in-memory cache used to minimize redundant operations.
            The default value is <literal>16</literal>.  (This cache
            is used for FSFS-backed repositories only.)</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.parent_dir">
        <term><option>--parent-dir</option> <replaceable>DIR</replaceable></term>
        <listitem>
          <para>When loading a dump file, root paths at
            <replaceable>DIR</replaceable> instead of
            <filename>/</filename>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.pre_1.4_compatible">
        <term><option>--pre-1.4-compatible</option></term>
        <listitem>
          <para><emphasis>Deprecated</emphasis>.  See option
            <option>--compatible-version</option>.  When creating a new
            repository, use a format that is compatible with versions of
            Subversion earlier than Subversion 1.4.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.pre_1.5_compatible">
        <term><option>--pre-1.5-compatible</option></term>
        <listitem>
          <para><emphasis>Deprecated</emphasis>.  See option
            <option>--compatible-version</option>.  When creating a new
            repository, use a format that is compatible with versions of
            Subversion earlier than Subversion 1.5.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.pre_1.6_compatible">
        <term><option>--pre-1.6-compatible</option></term>
        <listitem>
          <para><emphasis>Deprecated</emphasis>.  See option
            <option>--compatible-version</option>.  When creating a new
            repository, use a format that is compatible with versions of
            Subversion earlier than Subversion 1.6.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.revision">
        <term><option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Specify a particular revision to operate
            on.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.quiet">
        <term><option>--quiet</option> (<option>-q</option>)</term>
        <listitem>
          <para>Do not show normal progress show only
            errors.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.use_post_commit_hook">
        <term><option>--use-post-commit-hook</option></term>
        <listitem>
          <para>When loading a dump file, runs the repository's
            <literal>post-commit</literal> hook after finalizing each newly loaded
            revision.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.use_post_revprop_change_hook">
        <term><option>--use-post-revprop-change-hook</option></term>
        <listitem>
          <para>When changing a revision property, runs the
            repository's <literal>post-revprop-change</literal> hook after changing the
            revision property.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.use_pre_commit_hook">
        <term><option>--use-pre-commit-hook</option></term>
        <listitem>
          <para>When loading a dump file, runs the repository's
            <literal>pre-commit</literal> hook before finalizing each newly loaded
            revision.  If the hook fails, aborts the commit and
            terminates the load process.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.use_pre_revprop_change_hook">
        <term><option>--use-pre-revprop-change-hook</option></term>
        <listitem>
          <para>When changing a revision property, runs the
            repository's <literal>pre-revprop-change</literal> hook before changing the
            revision property.  If the hook fails, aborts the
            modification and terminates.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnadmin.sw.wait">
        <term><option>--wait</option></term>
        <listitem>
          <para>For operations which require exclusive repository
            access, wait until the requisite repository lock has
            been obtained instead of immediately erroring out when
            it cannot be.</para>
        </listitem>
      </varlistentry>

    </variablelist>
  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.crashtest">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>crashtest</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin crashtest</refname>
      <refpurpose>Simulate a process that crashes.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin crashtest REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

        <para>Open the repository at <replaceable>REPOS_PATH</replaceable>, then abort, thus
          simulating a process that crashes while holding an open
          repository handle.  This is used for testing automatic
          repository recovery (a new feature in Berkeley DB 4.4).
          It's unlikely that you'll need to run this
          command.</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <para>None</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <informalexample>
        <screen>
$ svnadmin crashtest /var/svn/repos
Aborted
</screen>
      </informalexample>

      <para>Exciting, isn't it?</para>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.create">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>create</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin create</refname>
      <refpurpose>Create a new, empty repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin create REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

        <para>Create a new, empty repository at the path provided.
          If the provided directory does not exist, it will be
          created for
          you.<footnote><para>Remember, <command>svnadmin</command>
          works only with local <emphasis>paths</emphasis>, not
          <emphasis>URLs</emphasis>.</para></footnote>  As of
          Subversion 1.2, <command>svnadmin</command> creates new
          repositories with the
          <literal>FSFS</literal> filesystem backend by
          default.</para>

        <para>While <command>svnadmin create</command> will create
          the base directory for a new repository, it will not
          create intermediate directories.  For example, if you
          have an empty directory named
          <filename>/var/svn</filename>, creating
          <filename>/var/svn/repos</filename> will work, while
          attempting to create
          <filename>/var/svn/subdirectory/repos</filename> will
          fail with an error.  Also, keep in mind that, depending
          on where on your system you are creating your
          repository, you might need to run <command>svnadmin
          create</command> as a user with elevated privileges
          (such as the <literal>root</literal> user).</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.bdb_log_keep" />
<xref linkend="svn.ref.svnadmin.sw.bdb_txn_nosync" />
<xref linkend="svn.ref.svnadmin.sw.compatible_version" />
<xref linkend="svn.ref.svnadmin.sw.config_dir" />
<xref linkend="svn.ref.svnadmin.sw.fs_type" />
<xref linkend="svn.ref.svnadmin.sw.pre_1.4_compatible" />
<xref linkend="svn.ref.svnadmin.sw.pre_1.5_compatible" />
<xref linkend="svn.ref.svnadmin.sw.pre_1.6_compatible" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Creating a new repository is this easy:</para>

      <informalexample>
        <screen>
$ cd /var/svn
$ svnadmin create repos
$
</screen>
      </informalexample>
      
      <para>In Subversion 1.0, a Berkeley DB repository is always
        created.  In Subversion 1.1, a Berkeley DB repository is
        the default repository type, but an FSFS repository can be
        created using the <option>--fs-type</option>
        option:</para>

      <informalexample>
        <screen>
$ cd /var/svn
$ svnadmin create repos --fs-type fsfs
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.deltify">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>deltify</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin deltify</refname>
      <refpurpose>Deltify changed paths in a revision range.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para><command>svnadmin deltify</command> exists in
        current versions of Subversion only for historical reasons.
        This command is deprecated and no longer needed.</para>

      <para>It dates from a time when Subversion offered
        administrators greater control over compression strategies
        in the repository.  This turned out to be a lot of
        complexity for <emphasis>very</emphasis> little gain, and
        this <quote>feature</quote> was deprecated.</para>

        </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.memory_cache_size" />
<xref linkend="svn.ref.svnadmin.sw.quiet" />
<xref linkend="svn.ref.svnadmin.sw.revision" />
</screen>
      </informalexample>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.dump">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>dump</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin dump</refname>
      <refpurpose>Dump the contents of the filesystem to <filename>stdout</filename>.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental] [--deltas]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Dump the contents of the filesystem to <filename>stdout</filename> in a
        <quote>dump file</quote> portable format, sending feedback
        to <filename>stderr</filename>.  Dump revisions
        <replaceable>LOWER</replaceable> rev through
        <replaceable>UPPER</replaceable> rev.  If no revisions are
        given, dump all revision trees.  If only
        <replaceable>LOWER</replaceable> is given, dump that one
        revision tree.  See <xref linkend="svn.reposadmin.maint.migrate"/>
        for a practical use.</para>

      <para>By default, the Subversion dump stream contains a
        single revision (the first revision in the requested
        revision range) in which every file and directory in the
        repository in that revision is presented as though that whole
        tree was added at once, followed by other revisions (the
        remainder of the revisions in the requested range), which
        contain only the files and directories that were modified
        in those revisions.  For a modified file, the complete
        full-text representation of its contents, as well as all of
        its properties, are presented in the dump file; for a
        directory, all of its properties are presented.</para>

      <para>Two useful options modify the dump file
        generator's behavior.  The first is the
        <option>--incremental</option> option, which simply causes
        that first revision in the dump stream to contain only
        the files and directories modified in that revision,
        instead of being presented as the addition of a new tree,
        and in exactly the same way that every other revision in
        the dump file is presented.  This is useful for generating
        a relatively small dump file to be loaded into another
        repository that already has the files and directories
        that exist in the original repository.</para>

      <para>The second useful option is <option>--deltas</option>.
        This option causes <command>svnadmin dump</command> to,
        instead of emitting full-text representations of file
        contents and property lists, emit only deltas of those
        items against their previous versions.  This reduces (in
        some cases, drastically) the size of the dump file that
        <command>svnadmin dump</command> creates.  There are, however,
        disadvantages to using this option deltified
        dump files are more CPU-intensive to create and tend
        not to compress as well as their nondeltified counterparts
        when using third-party tools such as <command>gzip</command>
        and <command>bzip2</command>.</para>

      <tip>
        <para>Beginning with Subversion 1.8,
          <command>svndumpfilter</command> can operate on deltified
          dump streams.  Prior to this release,
          <command>svndumpfilter</command> would not work with dump
          streams created using <option>--deltas</option>
          option.</para>
      </tip>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.deltas" />
<xref linkend="svn.ref.svnadmin.sw.incremental" />
<xref linkend="svn.ref.svnadmin.sw.memory_cache_size" />
<xref linkend="svn.ref.svnadmin.sw.quiet" />
<xref linkend="svn.ref.svnadmin.sw.revision" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Dump your whole repository:</para>

      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos &gt; full.dump
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
 
</screen>
      </informalexample>

      <para>Incrementally dump a single transaction from your
        repository:</para>

      <informalexample>
        <screen>
$ svnadmin dump /var/svn/repos -r 21 --incremental &gt; incr.dump
* Dumped revision 21.
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.freeze">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>freeze</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin freeze</refname>
      <refpurpose>Prevent commits to the repository while running an arbitary program.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin freeze REPOS_PATH PROGRAM [ARG...]</literal></para>
      <para><literal>svnadmin freeze --file FILENAME PROGRAM [ARG...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This subcommand prevents concurrent commits to the repository
        <replaceable>REPOS_PATH</replaceable> (i.e. it freezes the
        repository) while running <replaceable>PROGRAM</replaceable> with
        <replaceable>ARG</replaceable> arguments.  Clients trying to
        commit concurrently will wait until the repository becomes
        available again.  The subcommand is intended for backup purposes so
        that third-party backup tools such as <command>rsync</command> can
        be safely used on a live repository.</para>

      <para>If <option>--file</option> option is used, then all repositories
        listed in <replaceable>FILENAME</replaceable> will froze.  The
        file format is a list of <replaceable>REPOS_PATH</replaceable>
        separated by newlines.  Repositories freeze in the
        same order as they are listed in the file.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.file" />
</screen>
      </informalexample>
    </refsect1>
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Freeze the repository and run <command>rsync</command> to
        make its backup:</para>

      <informalexample>
        <screen>
$ svnadmin freeze /var/svn/repos -- rsync -av /var/svn/repos /backup/repos
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  
  <refentry id="svn.ref.svnadmin.c.help">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin help (h, ?)</refname>
      <refpurpose>Help!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin help [SUBCOMMAND...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This subcommand is useful when you're trapped on a
        desert island with neither a Net connection nor a copy of
        this book.</para>
    </refsect1>

  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.hotcopy">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>hotcopy</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin hotcopy</refname>
      <refpurpose>Make a hot copy of a repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This subcommand makes a <quote>hot</quote> backup
        of your repository, including all hooks, configuration
        files, and, of course, database files.  You can run this command at any
        time and make a safe copy of the repository, regardless of
        whether other processes are using the repository.</para>

      <para>Prior to Subversion 1.8, <command>svnadmin hotcopy</command> always
        made a full hot copy of the source repository.  Beginning with
        Subversion 1.8 it supports incremental copy to the existing
        destination copy of the same source repository.  By passing the
        <option>--incremental</option> option to
        <command>svnadmin hotcopy</command>, you can instruct Subversion to
        copy only new revisions and revisions which have changed in size or had
        timestamp modifications.  The UUID of the hotcopy destination
        repository must match the UUID of the hotcopy source repository.
        Incremental hotcopy mode is supported for FSFS repositories
        only.</para>

      <para>If you pass the <option>--clean-logs</option> option,
        <command>svnadmin</command> will perform a hot copy of your
        repository, and then remove unused Berkeley DB logs from
        the original repository.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.clean_logs" />
<xref linkend="svn.ref.svnadmin.sw.incremental" />
</screen>
      </informalexample>

      <warning>
        <para>As described in <xref
          linkend="svn.reposadmin.basics.backends.bdb"/>, hot-copied
          Berkeley DB repositories are <emphasis>not</emphasis>
          portable across operating systems, nor will they work on
          machines with a different <quote>endianness</quote> than
          the machine where they were created.</para>
      </warning>

      </refsect1>

  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.list-dblogs">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>list-dblogs</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin list-dblogs</refname>
      <refpurpose>Ask Berkeley DB which logfiles exist for a
        given Subversion repository (applies only to repositories
        using the <literal>bdb</literal> backend).</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin list-dblogs REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Berkeley DB creates logs of all changes to the
        repository, which allow it to recover in the face of
        catastrophe.  Unless you enable
        <literal>DB_LOG_AUTOREMOVE</literal>, the logfiles
        accumulate, although most are no longer used and can be
        deleted to reclaim disk space.  See <xref
        linkend="svn.reposadmin.maint.diskspace"/> for more
        information.</para>
    </refsect1>

  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.list-unused-dblogs">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>list-unused-dblogs</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin list-unused-dblogs</refname>
      <refpurpose>Ask Berkeley DB which logfiles can be safely
      deleted (applies only to repositories using the
      <literal>bdb</literal> backend).</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin list-unused-dblogs REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Berkeley DB creates logs of all changes to the
        repository, which allow it to recover in the face of
        catastrophe.  Unless you enable
        <literal>DB_LOG_AUTOREMOVE</literal>, the logfiles
        accumulate, although most are no longer used and can be
        deleted to reclaim disk space.  See <xref
        linkend="svn.reposadmin.maint.diskspace"/> for more
        information.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>Remove all unused logfiles from the repository:</para>

      <informalexample>
      <screen>
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033

$ svnadmin list-unused-dblogs /var/svn/repos | xargs rm
## disk space reclaimed!
</screen>
    </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.load">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>load</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin load</refname> <refpurpose>Read a
        repository dump stream from
        <filename>stdin</filename>.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin load REPOS_PATH [-r LOWER[:UPPER]]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Read a repository dump stream from
        <filename>stdin</filename>, committing new revisions
        into the repository's filesystem.  Progress
        feedback is sent to <filename>stdout</filename>.  If
        no revisions are given, read and commit all revisions.  But
        if <option>--revision</option> is provided, read and commit
        revisions <replaceable>LOWER</replaceable> rev through
        <replaceable>UPPER</replaceable> rev only.  If only
        <replaceable>LOWER</replaceable> is given, load that one
        revision.</para>

      <para>Prior to Subversion 1.8, <command>svnadmin load</command>
        was limited to reading all revisions that the dump stream
        contains, but now <command>svnadmin load</command> accepts
        <option>--revision</option> option that acts as a filter for
        dump stream revisions.  This allows you to incrementally load
        only a range of revisions from a single dump stream making
        some repository maintenance and reorganization tasks much
        easier.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.bypass_prop_validation" />
<xref linkend="svn.ref.svnadmin.sw.force_uuid" />
<xref linkend="svn.ref.svnadmin.sw.ignore_uuid" />
<xref linkend="svn.ref.svnadmin.sw.memory_cache_size" />
<xref linkend="svn.ref.svnadmin.sw.parent_dir" />
<xref linkend="svn.ref.svnadmin.sw.quiet" />
<xref linkend="svn.ref.svnadmin.sw.revision" />
<xref linkend="svn.ref.svnadmin.sw.use_post_commit_hook" />
<xref linkend="svn.ref.svnadmin.sw.use_pre_commit_hook" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the beginning of loading a repository from
        a backup file (made, of course, with <command>svnadmin
        dump</command>):</para>

      <informalexample>
        <screen>
$ svnadmin load /var/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
 
</screen>
      </informalexample>

      <para>Or if you want to load into a subdirectory:</para>

      <informalexample>
        <screen>
$ svnadmin load --parent-dir new/subdir/for/project \
                /var/svn/restored &lt; repos-backup
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : test ... done.
     * adding path : test/a ... done.
 
</screen>
      </informalexample>

      <para>Newer versions of Subversion have grown more strict
        regarding the format of the values of Subversion's own
        built-in properties.  Of course, properties created with
        older versions of Subversion wouldn't have benefitted from
        that strictness, and as such might be improperly
        formatted.  Dump streams carry property values as-is, so
        using Subversion 1.7 to load dump streams created from
        repositories with ill-formatted property values will, by
        default, trigger a validation error.  There are several
        workaround for this problem.  First, you can manually
        repair the problematic property values in the source
        repository and recreate the dump stream.  Or, you can
        manually tweak the dump stream itself to fix those
        property values.  Finally, if you'd rather not deal with
        the problem right now, use the
        <option>--bypass-prop-validation</option> option
        with <command>svnadmin load</command>.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.lock">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>lock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin lock</refname>
      <refpurpose>Lock path in the repository directly.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin lock REPOS_PATH PATH-IN-REPOS USERNAME FILE
        [TOKEN]</literal>
      </para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Lock <replaceable>PATH-IN-REPOS</replaceable> in the
        repository, assigning ownership of the lock
        to <replaceable>USERNAME</replaceable> and using the contents
        of <replaceable>FILE</replaceable> as comments associated with
        the created lock.  If provided,
        use <replaceable>TOKEN</replaceable> as lock token.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.bypass_hooks" />
</screen>
      </informalexample>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.lslocks">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>lslocks</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin lslocks</refname> 
      <refpurpose>Print descriptions of all locks.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin lslocks REPOS_PATH [PATH-IN-REPOS]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print descriptions of all locks in
        repository <replaceable>REPOS_PATH</replaceable>
        underneath the
        path <replaceable>PATH-IN-REPOS</replaceable>.
        If <replaceable>PATH-IN-REPOS</replaceable> is not
        provided, it defaults to the root directory of the
        repository.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      
      <para>None</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>


      <para>This lists the one locked file in the repository at
        <filename>/var/svn/repos</filename>:</para>

      <informalexample>
        <screen>
$ svnadmin lslocks /var/svn/repos
Path: /tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</screen>
      </informalexample>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.lstxns">
    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>lstxns</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin lstxns</refname>
      <refpurpose>Print the names of all uncommitted transactions.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin lstxns REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the names of all uncommitted transactions.  See
        <xref linkend="svn.reposadmin.maint.diskspace.deadtxns" />
        for information on how uncommitted transactions are
        created and what you should do with them.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>List all outstanding transactions in a
        repository:</para>

      <informalexample>
        <screen>
$ svnadmin lstxns /var/svn/repos/ 
1w
1x
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.pack">
    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>pack</tertiary>
    </indexterm>
    
    <refnamediv>
      <refname>svnadmin pack</refname>
      <refpurpose>Possibly compact the repository into a more
      efficient storage model.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin pack REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>See
      <xref linkend="svn.reposadmin.maint.diskspace.fsfspacking"
      /> for more information.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.recover">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>recover</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin recover</refname>

      <refpurpose>Bring a repository database back into a
      consistent state (applies only to repositories using the
      <literal>bdb</literal> backend).  In addition, if
      <filename>repos/conf/passwd</filename> does not exist, it
      will create a default passwordfile .</refpurpose>

    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin recover REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Run this command if you get an error indicating that
        your repository needs to be recovered.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.wait" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>Recover a hung repository:</para>

      <informalexample>
        <screen>
$ svnadmin recover /var/svn/repos/ 
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</screen>
      </informalexample>

      <para>Recovering the database requires an exclusive lock on
        the repository. (This is a <quote>database lock</quote>;
        see the sidebar <xref linkend="svn.advanced.locking.meanings"/>.)
        If another process is accessing the repository,
        then <command>svnadmin recover</command> will error:</para>

      <informalexample>
        <screen>
$ svnadmin recover /var/svn/repos
svn: E165000: Failed to get exclusive repository access; perhaps another proce
ss such as httpd, svnserve or svn has it open?
$
</screen>
      </informalexample>

      <para>The <option>--wait</option> option, however, will
        cause <command>svnadmin recover</command> to wait
        indefinitely for other processes to disconnect:</para>

      <informalexample>
        <screen>
$ svnadmin recover /var/svn/repos --wait
Waiting on repository lock; perhaps another process has it open?

### time goes by 

Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 34.
</screen>
      </informalexample>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.rmlocks">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>rmlocks</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin rmlocks</refname>
      <refpurpose>Unconditionally remove one or more locks from a
      repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin rmlocks REPOS_PATH LOCKED_PATH...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      <para>Remove one or more locks from each <replaceable>LOCKED_PATH</replaceable>.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>          
      <para>None</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This deletes the locks on
        <filename>tree.jpg</filename> and
        <filename>house.jpg</filename> in the repository at
        <filename>/var/svn/repos</filename>:</para>

      <informalexample>
        <screen>
$ svnadmin rmlocks /var/svn/repos tree.jpg house.jpg
Removed lock on '/tree.jpg.
Removed lock on '/house.jpg.
</screen>
      </informalexample>
    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.rmtxns">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>rmtxns</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin rmtxns</refname>
      <refpurpose>Delete transactions from a repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin rmtxns REPOS_PATH TXN_NAME...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Delete outstanding transactions from a repository.
        This is covered in detail in <xref
        linkend="svn.reposadmin.maint.diskspace.deadtxns" />.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.quiet" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Remove named transactions:</para>

      <informalexample>
        <screen>
$ svnadmin rmtxns /var/svn/repos/ 1w 1x
</screen>
      </informalexample>

      <para>Fortunately, the output of <command>lstxns</command>
        works great as the input for <command>rmtxns</command>:</para>

      <informalexample>
        <screen>
$ svnadmin rmtxns /var/svn/repos/  `svnadmin lstxns /var/svn/repos/`
</screen>
      </informalexample>

      <para>This removes all uncommitted transactions from
        your repository.</para>

    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.setlog">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>setlog</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin setlog</refname>
      <refpurpose>Set the log message on a revision.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin setlog REPOS_PATH -r REVISION FILE</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Set the log message on
        revision <replaceable>REVISION</replaceable> to the
        contents of <replaceable>FILE</replaceable>.</para>

      <para>This is similar to using <command>svn propset</command>
        with the <option>--revprop</option> option to set the <literal>svn:log</literal> property
        on a revision, except that you can also use the option
        <option>--bypass-hooks</option> to avoid running any pre-
        or post-commit hooks, which is useful if the modification
        of revision properties has not been enabled in
        the <literal>pre-revprop-change</literal> hook.</para>

      <warning>
        <para>Revision properties are not under version control,
          so this command will permanently overwrite the previous
          log message.</para>
      </warning>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.bypass_hooks" />
<xref linkend="svn.ref.svnadmin.sw.revision" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Set the log message for revision 19 to the contents of
        the file <filename>msg</filename>:</para>

      <informalexample>
        <screen>
$ svnadmin setlog /var/svn/repos/ -r 19 msg
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.setrevprop">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>setrevprop</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin setrevprop</refname>
      <refpurpose>Set a property on a revision.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin setrevprop REPOS_PATH -r REVISION NAME FILE</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

        <para>Set the property <replaceable>NAME</replaceable> on
          revision <replaceable>REVISION</replaceable> to the
          contents of <replaceable>FILE</replaceable>.  Use
          <option>--use-pre-revprop-change-hook</option>
          or <option>--use-post-revprop-change-hook</option> to
          trigger the revision property-related hooks (e.g., if
          you want an email notification sent from your <literal>post-revprop-change-hook</literal>).</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.revision" />
<xref linkend="svn.ref.svnadmin.sw.use_post_revprop_change_hook" />
<xref linkend="svn.ref.svnadmin.sw.use_pre_revprop_change_hook" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>The following sets the revision
      property <literal>repository-photo</literal> to the contents
      of the file <filename>sandwich.png</filename>:</para>

      <informalexample>
        <screen>
$ svnadmin setrevprop /var/svn/repos -r 0 repository-photo sandwich.png
</screen>
      </informalexample>

      <para>As you can see, <command>svnadmin setrevprop</command>
        has no output upon success.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.setuuid">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>setuuid</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin setuuid</refname>
      <refpurpose>Reset the repository UUID.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin setuuid REPOS_PATH [NEW_UUID]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Reset the repository UUID for the repository located
        at <replaceable>REPOS_PATH</replaceable>.
        If <replaceable>NEW_UUID</replaceable> is provided, use
        that as the new repository UUID; otherwise, generate a
        brand-new UUID for the repository.</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>If you've <command>svnsync</command>ed <filename>/var/svn/repos</filename>
        to <filename>/var/svn/repos-new</filename> and intend to use <filename>repos-new</filename> as your
        canonical repository, you may want to change the UUID for
        <filename>repos-new</filename> to the UUID of <filename>repos</filename> so that your users don't
        have to check out a new working copy to accommodate the
        change:</para>

      <informalexample>
        <screen>
$ svnadmin setuuid /var/svn/repos-new 2109a8dd-854f-0410-ad31-d604008985ab
</screen>
      </informalexample>

      <para>As you can see, <command>svnadmin setuuid</command>
        has no output upon success.</para>

    </refsect1>
  </refentry>
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.unlock">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>unlock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin unlock</refname>
      <refpurpose>Unlock path in the repository directly.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin unlock REPOS_PATH LOCKED_PATH USERNAME
        TOKEN</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Unlock <replaceable>LOCKED_PATH</replaceable> in the
        repository (as <replaceable>USERNAME</replaceable>) after
        verifying that the token associated with the lock
        matches <replaceable>TOKEN</replaceable>.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.bypass_hooks" />
</screen>
      </informalexample>
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.upgrade">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>upgrade</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin upgrade</refname>
      <refpurpose>Upgrade a repository to the latest supported
        schema version.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin upgrade REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Upgrade the repository located
        at <replaceable>REPOS_PATH</replaceable> to the latest
        supported schema version.</para>

      <para>This functionality is provided as a convenience for
        repository administrators who wish to make use of new
        Subversion functionality without having to undertake a
        potentially costly full repository dump and load
        operation.  As such, the upgrade performs only the minimum
        amount of work needed to accomplish this while still
        maintaining the integrity of the repository.  While a dump
        and subsequent load guarantee the most optimized
        repository state, <command>svnadmin upgrade</command> does
        not.</para>

      <warning>
        <para>You should <emphasis>always</emphasis> back up your
          repository before upgrading.</para>
      </warning>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Upgrade the repository at
        path <filename>/var/repos/svn</filename>:</para>

      <informalexample>
        <screen>
$ svnadmin upgrade /var/repos/svn
Repository lock acquired.
Please wait; upgrading the repository may take some time...

Upgrade completed.
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ### FIXME: This could use a lot more explanation.  When
       should I use it?  What do I do if it fails? -->

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnadmin.c.verify">

    <indexterm>
      <primary>svnadmin</primary>
      <secondary>subcommands</secondary>
      <tertiary>verify</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnadmin verify</refname>
      <refpurpose>Verify the data stored in the repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnadmin verify REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Run this command if you wish to verify the integrity
        of your repository.  This basically iterates through all
        revisions in the repository by internally dumping all
        revisions and discarding the output it's a good idea
        to run this on a regular basis to guard against latent
        hard disk failures and <quote>bitrot.</quote>  If this
        command fails which it will do at the first sign of
        a problem that means your repository has at
        least one corrupted revision, and you should restore the
        corrupted revision from a backup (you did make a backup,
        didn't you?).</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnadmin.sw.memory_cache_size" />
<xref linkend="svn.ref.svnadmin.sw.quiet" />
<xref linkend="svn.ref.svnadmin.sw.revision" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>Verify a hung repository:</para>

      <informalexample>
        <screen>
$ svnadmin verify /var/svn/repos/ 
* Verified revision 1729.
</screen>
      </informalexample>

    </refsect1>
  </refentry>
</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svndumpfilter">
  <title>svndumpfilter Reference Subversion History Filtering</title>
  
  <partintro>
    
    <para><command>svndumpfilter</command> is a command-line utility
      for removing history from a Subversion dump file by either
      excluding or including paths beginning with one or more named
      prefixes.  For details, see
      <xref linkend="svn.reposadmin.maint.tk.svndumpfilter"/>.</para>

    <para>Options in <command>svndumpfilter</command> are global, just
      as they are in <command>svn</command> and
      <command>svnadmin</command>:</para>

    <variablelist id="svn.ref.svndumpfilter.sw">
      <title>svndumpfilter Options</title>

      <varlistentry id="svn.ref.svndumpfilter.sw.drop_empty_revs">
        <term><option>--drop-empty-revs</option></term>
        <listitem>
          <para>If filtering causes any revision to be empty (i.e.,
            causes no change to the repository), removes these
            revisions from the final dump file.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svndumpfilter.sw.pattern">
        <term><option>--pattern</option></term>
        <listitem>
          <para>Treat the path prefixes provided to the filtering
            commands as file glob patterns rather than explicit path
            substrings.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svndumpfilter.sw.renumber_revs">
        <term><option>--renumber-revs</option></term>
        <listitem>
          <para>Renumbers revisions that remain after
            filtering.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svndumpfilter.sw.skip_missing_merge_sources">
        <term><option>--skip-missing-merge-sources</option></term>
        <listitem>
          <para>Skips merge sources that have been removed as part of
            the filtering.  Without this
            option, <command>svndumpfilter</command> will exit with
            an error if the merge source for a retained path is
            removed by filtering.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svndumpfilter.sw.preserve_revprops">
        <term><option>--preserve-revprops</option></term>
        <listitem>
          <para>If all nodes in a revision are removed by filtering
            and <option>--drop-empty-revs</option> is not passed,
            the default behavior of <command>svndumpfilter</command>
            is to remove all revision properties except for the date
            and the log message (which will merely indicate that the
            revision is empty).  Passing this option will preserve
            existing revision properties (which may or may not make
            sense since the related content is no longer present in
            the dump file).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svndumpfilter.sw.targets">
        <term><option>--targets</option> <replaceable>FILENAME</replaceable></term>
        <listitem>
          <para>Instructs <command>svndumpfilter</command> to read
            additional path prefixes one per line from
            the file located at <replaceable>FILENAME</replaceable>.
            This is especially useful for complex filtering
            operations which require more prefixes than the
            operating system allows to be specified on a single
            command line.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svndumpfilter.sw.quiet">
        <term><option>--quiet</option></term>
        <listitem>
          <para>Does not display filtering statistics.</para>
        </listitem>
      </varlistentry>

    </variablelist>

  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svndumpfilter.commands.c.exclude">

    <indexterm>
      <primary>svndumpfilter</primary>
      <secondary>subcommands</secondary>
      <tertiary>exclude</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svndumpfilter exclude</refname>
      <refpurpose>Filter out nodes with given prefixes from the dump stream.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svndumpfilter exclude PATH_PREFIX...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This can be used to exclude nodes that begin with one or
        more <replaceable>PATH_PREFIX</replaceable>es from a
        filtered dump file.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svndumpfilter.sw.drop_empty_revs" />
<xref linkend="svn.ref.svndumpfilter.sw.pattern" />
<xref linkend="svn.ref.svndumpfilter.sw.preserve_revprops" />
<xref linkend="svn.ref.svndumpfilter.sw.quiet" />
<xref linkend="svn.ref.svndumpfilter.sw.renumber_revs" />
<xref linkend="svn.ref.svndumpfilter.sw.skip_missing_merge_sources" />
<xref linkend="svn.ref.svndumpfilter.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>If we have a dump file from a repository with a number
        of different picnic-related directories in it, but we want
        to keep everything <emphasis>except</emphasis>
        the <filename>sandwiches</filename> part of the
        repository, we'll exclude only that path:</para>

      <informalexample>
        <screen>
$ svndumpfilter exclude sandwiches &lt; dumpfile &gt; filtered-dumpfile
Excluding prefixes:
   '/sandwiches'

Revision 0 committed as 0.
Revision 1 committed as 1.
Revision 2 committed as 2.
Revision 3 committed as 3.
Revision 4 committed as 4.

Dropped 1 node(s):
   '/sandwiches'
$
</screen>
      </informalexample>

      <para>Beginning in Subversion 1.7,
        <command>svndumpfilter</command> can optionally treat
        the <replaceable>PATH_PREFIX</replaceable>s not merely as
        explicit substrings, but as file patterns instead.  So,
        for example, if you wished to filter out paths which ended
        with <filename>.OLD</filename>, you would do the
        following:</para>

      <informalexample>
        <screen>
$ svndumpfilter exclude --pattern "*.OLD" &lt; dumpfile &gt; filtered-dumpfile
Excluding prefix patterns:
   '/*.OLD'

Revision 0 committed as 0.
Revision 1 committed as 1.
Revision 2 committed as 2.
Revision 3 committed as 3.
Revision 4 committed as 4.

Dropped 3 node(s):
   '/condiments/salt.OLD'
   '/condiments/pepper.OLD'
   '/toppings/cheese.OLD'
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svndumpfilter.commands.c.include">

    <indexterm>
      <primary>svndumpfilter</primary>
      <secondary>subcommands</secondary>
      <tertiary>include</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svndumpfilter include</refname>
      <refpurpose>Filter out nodes without given prefixes from
        dump stream.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svndumpfilter include PATH_PREFIX...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Can be used to include nodes that begin with one or
        more <replaceable>PATH_PREFIX</replaceable>es in a
        filtered dump file (thus excluding all other paths).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svndumpfilter.sw.drop_empty_revs" />
<xref linkend="svn.ref.svndumpfilter.sw.pattern" />
<xref linkend="svn.ref.svndumpfilter.sw.preserve_revprops" />
<xref linkend="svn.ref.svndumpfilter.sw.quiet" />
<xref linkend="svn.ref.svndumpfilter.sw.renumber_revs" />
<xref linkend="svn.ref.svndumpfilter.sw.skip_missing_merge_sources" />
<xref linkend="svn.ref.svndumpfilter.sw.targets" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Example</title>

      <para>If we have a dump file from a repository with a number of
        different picnic-related directories in it, but want to
        keep only the <filename>sandwiches</filename> part of the
        repository, we'll include only that path:</para>

      <informalexample>
        <screen>
$ svndumpfilter include sandwiches &lt; dumpfile &gt; filtered-dumpfile
Including prefixes:
   '/sandwiches'

Revision 0 committed as 0.
Revision 1 committed as 1.
Revision 2 committed as 2.
Revision 3 committed as 3.
Revision 4 committed as 4.

Dropped 12 node(s):
   '/condiments'
   '/condiments/pepper'
   '/condiments/pepper.OLD'
   '/condiments/salt'
   '/condiments/salt.OLD'
   '/drinks'
   '/snacks'
   '/supplies'
   '/toppings'
   '/toppings/cheese'
   '/toppings/cheese.OLD'
   '/toppings/lettuce'
$
</screen>
      </informalexample>

      <para>Beginning in Subversion 1.7,
        <command>svndumpfilter</command> can optionally treat
        the <replaceable>PATH_PREFIX</replaceable>s not merely as
        explicit substrings, but as file patterns instead.  So,
        for example, if you wished to include only paths which ended
        with <filename>ks</filename>, you would do the
        following:</para>

      <informalexample>
        <screen>
$ svndumpfilter include --pattern "*ks" &lt; dumpfile &gt; filtered-dumpfile
Including prefix patterns:
   '/*ks'

Revision 0 committed as 0.
Revision 1 committed as 1.
Revision 2 committed as 2.
Revision 3 committed as 3.
Revision 4 committed as 4.

Dropped 11 node(s):
   '/condiments'
   '/condiments/pepper'
   '/condiments/pepper.OLD'
   '/condiments/salt'
   '/condiments/salt.OLD'
   '/sandwiches'
   '/supplies'
   '/toppings'
   '/toppings/cheese'
   '/toppings/cheese.OLD'
   '/toppings/lettuce'
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svndumpfilter.commands.c.help">

    <indexterm>
      <primary>svndumpfilter</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svndumpfilter help</refname>
      <refpurpose>Help!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svndumpfilter help [SUBCOMMAND...]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Displays the help message
        for <command>svndumpfilter</command>.  Unlike other help
        commands documented in this chapter, there is no witty
        commentary for this help command.  The authors of this
        book deeply regret the omission.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>

  </refentry>

</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnlook">
  <title>svnlook Reference Subversion Repository Examination</title>
    
  <partintro>
    <para><command>svnlook</command> is a command-line utility for
      examining different aspects of a Subversion repository.  It
      does not make any changes to the repository it's just
      used for <quote>peeking.</quote>
      <command>svnlook</command> is typically used by the
      repository hooks, but a repository administrator might find it
      useful for diagnostic purposes.</para>

    <para>Since <command>svnlook</command> works via direct repository access
      (and thus can be used only on the machine that holds the
      repository), it refers to the repository with a path, not a URL.</para>

    <para>If no revision or transaction is specified,
      <command>svnlook</command> defaults to the youngest (most
      recent) revision of the repository.</para>
    
    <para>Options in <command>svnlook</command> are global, just
      as they are in <command>svn</command> and
      <command>svnadmin</command>; however, most options apply
      to only one subcommand since the functionality of
      <command>svnlook</command> is (intentionally) limited in
      scope:</para>

    <variablelist id="svn.ref.svnlook.sw">
      <title>svnlook Options</title>

      <varlistentry id="svn.ref.svnlook.sw.copy_info">
        <term><option>--copy-info</option></term>
        <listitem>
          <para>Causes <command>svnlook changed</command> to show
            detailed copy source information.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.diff_copy_from">
        <term><option>--diff-copy-from</option></term>
        <listitem>
          <para>Print differences for copied items against the copy
            source.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.extensions">
        <term><option>--extensions</option> (<option>-x</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Specifies customizations which Subversion should
            make when performing difference calculations.  Valid
            extensions include:</para>
          <variablelist>
            <varlistentry>
              <term><option>--ignore-space-change</option> (<option>-b</option>)</term>
              <listitem>
                <para>Ignore changes in the amount of white space.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--ignore-all-space</option> (<option>-w</option>)</term>
              <listitem>
                <para>Ignore all white space.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--ignore-eol-style</option></term>
              <listitem>
                <para>Ignore changes in EOL (end-of-line) style.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--show-c-function</option> (<option>-p</option>)</term>
              <listitem>
                <para>Show C function names in the diff output.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>--unified</option> (<option>-u</option>)</term>
              <listitem>
                <para>Show three lines of unified diff context.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>The default value is <literal>-u</literal>.</para>
          <para>Note that when Subversion is configured to invoke an
            external diff command, the value of
            the <option>--extension</option> (<option>-x</option>)
            option isn't restricted to the previously mentioned
            options, but may be <emphasis>any</emphasis> additional
            arguments which Subversion should pass to that command.
            If you wish to pass multiple arguments, you must enclose
            all of them in quotes.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.full_paths">
        <term><option>--full-paths</option></term>
        <listitem>
          <para>Causes <command>svnlook tree</command> to display
            full paths instead of hierarchical, indented path
            components.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.limit">
        <term><option>--limit</option> (<option>-l</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Limit output to a maximum number of
            <replaceable>ARG</replaceable> items.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.no_diff_deleted">
        <term><option>--no-diff-deleted</option></term>
        <listitem>
          <para>Prevents <command>svnlook diff</command> from printing
            differences for deleted files.  The default behavior
            when a file is deleted in a transaction/revision is
            to print the same differences that you would see if
            you had left the file but removed all the content.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.no_diff_added">
        <term><option>--no-diff-added</option></term>
      <listitem>
        <para>Prevents <command>svnlook diff</command> from printing
          differences for added files.  The default behavior when
          you add a file is to print the same differences that you
          would see if you had added the entire contents of an
          existing (empty) file.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svnlook.sw.non_recursive">
        <term><option>--non-recursive</option> (<option>-N</option>)</term>
        <listitem>
          <para>Operate on a single directory only.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.revision">
        <term><option>--revision</option> (<option>-r</option>)</term>
        <listitem>
          <para>Specifies a particular revision number that you wish
            to examine.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.revprop">
        <term><option>--revprop</option></term>
        <listitem>
          <para>Operates on a revision property instead of a
            property specific to a file or directory.  This option
            requires that you also pass a revision with the
            <option>--revision</option> (<option>-r</option>)
            option.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.show_inherited_props">
        <term><option>--show-inherited-props</option></term>
        <listitem>
          <para>Works with <command>svnlook propget</command> and
            <command>svnlook proplist</command> to display the versioned
            properties inherited by a path.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.transaction">
        <term><option>--transaction</option> (<option>-t</option>)</term>
        <listitem>
          <para>Specifies a particular transaction ID that you wish to
            examine.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.show_ids">
        <term><option>--show-ids</option></term>
        <listitem>
          <para>Shows the filesystem node revision IDs for each path
            in the filesystem tree.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.verbose">
        <term><option>--verbose</option> (<option>-v</option>)</term>
        <listitem>
          <para>Be verbose.  When used with <command>svnlook
            proplist</command>, for example, this causes Subversion
            to display not just the list of properties, but their
            values also.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnlook.sw.xml">
        <term><option>--xml</option></term>
        <listitem>
          <para></para>
        </listitem>
      </varlistentry>

    </variablelist>

  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.author">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>author</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook author</refname>
      <refpurpose>Print the author.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook author REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the author of a revision or transaction in
        the repository.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

    <para><command>svnlook author</command> is handy, but not
      very exciting:</para>

    <informalexample>
        <screen>
$ svnlook author -r 40 /var/svn/repos 
sally
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.cat">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>cat</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook cat</refname>
      <refpurpose>Print the contents of a file.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook cat REPOS_PATH PATH_IN_REPOS</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the contents of a file.</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the contents of a file in transaction
        <literal>ax8</literal>, located
        at <filename>/trunk/README</filename>:</para>

      <informalexample>
        <screen>
$ svnlook cat -t ax8 /var/svn/repos /trunk/README

               Subversion, a version control system.
               =====================================

$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $

Contents:

     I. A FEW POINTERS
    II. DOCUMENTATION
   III. PARTICIPATING IN THE SUBVERSION COMMUNITY
 
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.changed">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>changed</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook changed</refname>
      <refpurpose>Print the paths that were changed.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook changed REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the paths that were changed in a particular
        revision or transaction, as well as <quote>svn
        update-style</quote> status letters in the first two
        columns:</para>

      <variablelist>
        
        <varlistentry>
          <term><literal>'A '</literal></term>
          <listitem>
            <para>Item added to repository</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'D '</literal></term>
          <listitem>
            <para>Item deleted from repository</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'U '</literal></term>
          <listitem>
            <para>File contents changed</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'_U'</literal></term>
          <listitem>
            <para>Properties of item changed; note the leading underscore</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>'UU'</literal></term>
          <listitem>
            <para>File contents and properties changed</para>
          </listitem>
        </varlistentry>

      </variablelist>

      <para>Files and directories can be distinguished, as
        directory paths are displayed with a
        trailing <quote><literal>/</literal></quote>
        character.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.copy_info" />
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows a list of all the changed files and
        directories in revision 39 of a test repository.  Note
        that the first changed item is a directory, as evidenced
        by the trailing <literal>/</literal>:</para>

      <informalexample>
        <screen>
$ svnlook changed -r 39 /var/svn/repos
A   trunk/vendors/deli/
A   trunk/vendors/deli/chips.txt
A   trunk/vendors/deli/sandwich.txt
A   trunk/vendors/deli/pickle.txt
U   trunk/vendors/baker/bagel.txt
_U  trunk/vendors/baker/croissant.txt
UU  trunk/vendors/baker/pretzel.txt
D   trunk/vendors/baker/baguette.txt
</screen>
      </informalexample>

      <para>Here's an example that shows a revision in which a
        file was renamed:</para>

      <informalexample>
        <screen>
$ svnlook changed -r 64 /var/svn/repos
A   trunk/vendors/baker/toast.txt
D   trunk/vendors/baker/bread.txt
</screen>
      </informalexample>

      <para>Unfortunately, nothing in the preceding output reveals
        the connection between the deleted and added files.  Use
        the <option>--copy-info</option> option to make this
        relationship more apparent:</para>

      <informalexample>
        <screen>
$ svnlook changed -r 64 --copy-info /var/svn/repos
A + trunk/vendors/baker/toast.txt
    (from trunk/vendors/baker/bread.txt:r63)
D   trunk/vendors/baker/bread.txt
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.date">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>date</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook date</refname>
      <refpurpose>Print the datestamp.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook date REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the datestamp of a revision or transaction in
        a repository.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>This shows the date of revision 40 of a test
        repository:</para>

      <informalexample>
        <screen>
$ svnlook date -r 40 /var/svn/repos/
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.diff">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>diff</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook diff</refname>
      <refpurpose>Print differences of changed files and properties.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook diff REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print GNU-style differences of changed files and
        properties in a repository.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.diff_copy_from" />
<xref linkend="svn.ref.svnlook.sw.no_diff_added" />
<xref linkend="svn.ref.svnlook.sw.no_diff_deleted" />
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
<xref linkend="svn.ref.svnlook.sw.extensions" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>This shows a newly added (empty) file, a modified
        binary file, and a renamed (that is, copied and deleted)
        file with modifications:</para>

      <informalexample>
        <screen>
$ svnlook diff -r 40 /var/svn/repos
Copied: trunk/relish.txt (from rev 39, trunk/vendors/deli/pickle.txt)
===================================================================
--- trunk/relish.txt	                        (rev 0)
+++ trunk/relish.txt	2013-01-29 20:39:17 UTC (rev 40)
@@ -0,0 +1 @@
+Pickle relish is mostly made from cucumbers.

Deleted: trunk/vendors/deli/pickle.txt
===================================================================
--- trunk/vendors/deli/pickle.txt	                        (rev 39)
+++ trunk/vendors/deli/pickle.txt	2013-01-29 20:39:17 UTC (rev 49)
@@ -1 +0,0 @@
-Pickles are mostly made from cucumbers.

Modified: trunk/vendors/deli/logo.jpg
===================================================================
(Binary files differ)

Added: trunk/vendors/deli/soda.txt
===================================================================
$
</screen>
      </informalexample>

      <para>By default, <command>svnlook diff</command> will treat
        copied files very much like any other added file,
        displaying in their entirety the contents of the new file
        and merely using a different label to draw the copy/add
        distinction.  However, you can use the
        <option>--diff-copy-from</option> option to cause
        <command>svnlook diff</command> to consider a copied
        file as worthy of mention only if it differs from the file
        from which it was copied, and to actually describe those
        differences.</para>

      <informalexample>
        <screen>
$ svnlook diff -r 40 /var/svn/repos --diff-copy-from
Copied: trunk/relish.txt (from rev 39, trunk/vendors/deli/pickle.txt)
===================================================================
--- trunk/vendors/deli/pickle.txt	2013-01-29 20:39:17 UTC (rev 39)
+++ trunk/relish.txt	2013-01-29 20:47:40 UTC (rev 3)
@@ -1 +1 @@
-Pickles are mostly made from cucumbers.
+Pickle relish is mostly made from cucumbers.

Deleted: trunk/vendors/deli/pickle.txt
===================================================================
--- trunk/vendors/deli/pickle.txt	(rev 39)
+++ trunk/vendors/deli/pickle.txt	2013-01-29 20:39:17 UTC (rev 40)
@@ -1 +0,0 @@
-Pickles are mostly made from cucumbers.

Modified: trunk/vendors/deli/logo.jpg
===================================================================
(Binary files differ)

Added: trunk/vendors/deli/soda.txt
==============================================================================
$
</screen>
      </informalexample>

      <para>Use the <option>--no-diff-deleted</option> option to
        silence output regarding deleted files.</para>

      <informalexample>
        <screen>
$ svnlook diff -r 40 /var/svn/repos --no-diff-deleted
Copied: trunk/relish.txt (from rev 39, trunk/vendors/deli/pickle.txt)
===================================================================
--- trunk/relish.txt	                        (rev 0)
+++ trunk/relish.txt	2013-01-29 20:39:17 UTC (rev 40)
@@ -0,0 +1 @@
+Pickle relish is mostly made from cucumbers.

Modified: trunk/vendors/deli/logo.jpg
===================================================================
(Binary files differ)

Added: trunk/vendors/deli/soda.txt
==============================================================================
$
</screen>
      </informalexample>
      
      <para>Note that in each of the previous examples, when a
        file has a nontextual <literal>svn:mime-type</literal>
        property, the differences are not explicitly shown.</para>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.dirs-changed">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>dirs-changed</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook dirs-changed</refname>
      <refpurpose>Print the directories that were themselves changed.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook dirs-changed REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the directories that were themselves changed
        (property edits) or whose file children were
        changed.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the directories that changed in
        revision 40 in our sample repository:</para>

      <informalexample>
        <screen>
$ svnlook dirs-changed -r 40 /var/svn/repos
trunk/vendors/deli/
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.filesize">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>filesize</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook filesize</refname>
      <refpurpose>Print the size (in bytes) of a versioned
        file.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook filesize REPOS_PATH
        PATH_IN_REPOS</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the file size (in bytes) of the file located
        at <replaceable>PATH_IN_REPOS</replaceable> in the HEAD
        revision of the repository identified
        by <replaceable>REPOS_PATH</replaceable> as a base-10
        integer followed by an end-of-line character.  Use
        the <option>--revision</option> (<option>-r</option>)
        and <option>--transaction</option> (<option>-t</option>)
        options to specify a version of the file other than HEAD
        whose file size you wish to display.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>The following demonstrates how to display the size of
        the <filename>trunk/vendors/deli/soda.txt</filename> file
        as it appeared in revision 40 of our sample
        repository:</para>

      <informalexample>
        <screen>
$ svnlook filesize -r 40 /var/svn/repos trunk/vendors/deli/soda.txt
23
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.help">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook help (h, ?)</refname>
      <refpurpose>Help!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>Also svnlook -h and svnlook -?.</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Displays the help message
        for <command>svnlook</command>.  This command, like its
        brother, <command>svn help</command>, is also your friend,
        even though you never call it anymore and forgot to invite
        it to your last party.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>

  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.history">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>history</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook history</refname>
      <refpurpose>Print information about the history of a path in
        the repository (or the root directory if no path is
        supplied).</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook history REPOS_PATH [PATH_IN_REPOS]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print information about the history of a path in
        the repository (or the root directory if no path is
        supplied).</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.limit" />
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.show_ids" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the history output for the path
        <filename>/branches/bookstore</filename> as of revision 13 in our
        sample repository:</para>

      <informalexample>
        <screen>
$ svnlook history -r 13 /var/svn/repos /branches/bookstore --show-ids
REVISION   PATH &lt;ID&gt;
--------   ---------
      13   /branches/bookstore &lt;1.1.r13/390&gt;
      12   /branches/bookstore &lt;1.1.r12/413&gt;
      11   /branches/bookstore &lt;1.1.r11/0&gt;
       9   /trunk &lt;1.0.r9/551&gt;
       8   /trunk &lt;1.0.r8/131357096&gt;
       7   /trunk &lt;1.0.r7/294&gt;
       6   /trunk &lt;1.0.r6/353&gt;
       5   /trunk &lt;1.0.r5/349&gt;
       4   /trunk &lt;1.0.r4/332&gt;
       3   /trunk &lt;1.0.r3/335&gt;
       2   /trunk &lt;1.0.r2/295&gt;
       1   /trunk &lt;1.0.r1/532&gt;
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.info">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>info</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook info</refname>
      <refpurpose>Print the author, datestamp, log message size,
        and log message.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook info REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the author, datestamp, log message size (in bytes),
        and log message, followed by a newline character.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the info output for revision 40 in our
        sample repository:</para>

      <informalexample>
        <screen>
$ svnlook info -r 40 /var/svn/repos
sally
2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)
16
Rearrange lunch.
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.lock">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>lock</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook lock</refname>
      <refpurpose>If a lock exists on a path in the repository,
        describe it.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook lock REPOS_PATH PATH_IN_REPOS</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print all information available for the lock at
        <replaceable>PATH_IN_REPOS</replaceable>.  If
        <replaceable>PATH_IN_REPOS</replaceable> is not locked,
        print nothing.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
        
      <para>None</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This describes the lock on the file
        <filename>tree.jpg</filename>:</para>

      <informalexample>
        <screen>
$ svnlook lock /var/svn/repos tree.jpg
UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753
Owner: harry
Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)
Expires: 
Comment (1 line):
Rework the uppermost branches on the bald cypress in the foreground.
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>


  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.log">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>log</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook log</refname>
      <refpurpose>Print the log message, followed by a newline 
        character.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook log REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the log message.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>
      
      <para>This shows the log output for revision 40 in our sample
        repository:</para>

      <informalexample>
        <screen>
$ svnlook log /var/svn/repos/
Rearrange lunch.
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.propget">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>propget</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook propget (pget, pg)</refname>
      <refpurpose>Print the raw value of a property on a path in
        the repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>List the value of a property on a path in the
        repository.</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.revprop" />
<xref linkend="svn.ref.svnlook.sw.show_inherited_props" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the value of the <quote>seasonings</quote> property
        on the file <filename>/trunk/sandwich</filename> in the
        <literal>HEAD</literal> revision:</para>

      <informalexample>
        <screen>
$ svnlook pg /var/svn/repos seasonings /trunk/sandwich
mustard
</screen>
      </informalexample>

      <para>This shows the inherited values of the <literal>
        svn:auto-props</literal> property on the directory
        <filename>/trunk</filename> in revision 14:</para>

      <informalexample>
        <screen>
$ svnlook pg repos svn:auto-props trunk --show-inherited-props -v -r14
Inherited properties on '/trunk',
from '/':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.proplist">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>proplist</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook proplist (plist, pl)</refname>
      <refpurpose>Print the names and values of versioned file and
        directory properties.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook proplist REPOS_PATH [PATH_IN_REPOS]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>List the properties of a path in the repository.  With
        <option>--verbose</option> (<option>-v</option>), show the
        property values too.</para>

      </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.revprop" />
<xref linkend="svn.ref.svnlook.sw.show_inherited_props" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
<xref linkend="svn.ref.svnlook.sw.verbose" />
<xref linkend="svn.ref.svnlook.sw.xml" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>This shows the names of properties set on the file
        <filename>/trunk/README</filename> in the
        <literal>HEAD</literal> revision:</para>

      <informalexample>
        <screen>
$ svnlook proplist /var/svn/repos /trunk/README
  original-author
  svn:mime-type
</screen>
      </informalexample>

      <para>This is the same command as in the preceding example,
        but this time showing the property values as well:</para>

      <informalexample>
        <screen>
$ svnlook -v proplist /var/svn/repos /trunk/README
  original-author : harry
  svn:mime-type : text/plain
</screen>
      </informalexample>

      <para>This shows the properties inherited by a directory:
        </para>

      <informalexample>
        <screen>
$ svnlook pl /var/svn/repos branches --show-inherited-props -v
Inherited properties on '/branches',
from '/':
  svn:auto-props
    *.py = svn:eol-style=native
    *.c = svn:eol-style=native
    *.h = svn:eol-style=native

  svn:global-ignores
    *.diff
    *.patch

Properties on '/branches':

</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.tree">
    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>tree</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook tree</refname>
      <refpurpose>Print the tree.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook tree REPOS_PATH [PATH_IN_REPOS]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      <para>Print the tree, starting at
        <replaceable>PATH_IN_REPOS</replaceable> (if supplied; at
        the root of the tree otherwise), optionally showing node
        revision IDs.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnlook.sw.full_paths" />
<xref linkend="svn.ref.svnlook.sw.non_recursive" />
<xref linkend="svn.ref.svnlook.sw.revision" />
<xref linkend="svn.ref.svnlook.sw.show_ids" />
<xref linkend="svn.ref.svnlook.sw.transaction" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Example</title>
      
      <para>This shows the tree output for revision 13 in our
        sample repository:</para>

      <informalexample>
        <screen>
$ svnlook tree -r 13 /var/svn/repos
/
 trunk/
  button.c
  Makefile
  integer.c
 branches/
  bookstore/
   button.c
   Makefile
   integer.c
 
</screen>
      </informalexample>

      <para>Use the <option>--show-ids</option> option to include
        node revision IDs (unique internal identifiers for
        specific nodes in Subversion's versioned filesystem
        implementation):</para>

      <informalexample>
        <screen>
$ svnlook tree -r 13 /var/svn/repos --show-ids
/ &lt;0.0.r13/811&gt;
 trunk/ &lt;1.0.r9/551&gt;
  button.c &lt;2.0.r9/238&gt;
  Makefile &lt;3.0.r7/41&gt;
  integer.c &lt;4.0.r6/98&gt;
 branches/ &lt;5.0.r13/593&gt;
  bookstore/ &lt;1.1.r13/390&gt;
   button.c &lt;2.1.r12/85&gt;
   Makefile &lt;3.0.r7/41&gt;
   integer.c &lt;4.1.r13/109&gt;
 
</screen>
      </informalexample>

      <para>For output which lends itself more readily to being
        parsed by scripts, use the <option>--full-paths</option>
        option, which causes <command>svnlook</command> to print
        the full repository path of each tree item and to not use
        indentation to indicate hierarchy:</para>

      <informalexample>
        <screen>
$ svnlook tree -r 13 /var/svn/repos --show-ids --full-paths
/ &lt;0.0.r13/811&gt;
trunk/ &lt;1.0.r9/551&gt;
trunk/button.c &lt;2.0.r9/238&gt;
trunk/Makefile &lt;3.0.r7/41&gt;
trunk/integer.c &lt;4.0.r6/98&gt;
branches/ &lt;5.0.r13/593&gt;
branches/bookstore/ &lt;1.1.r13/390&gt;
branches/bookstore/button.c &lt;2.1.r12/85&gt;
branches/bookstore/Makefile &lt;3.0.r7/41&gt;
branches/bookstore/integer.c &lt;4.1.r13/109&gt;
 
</screen>
      </informalexample>
      
    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.uuid">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>uuid</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook uuid</refname>
      <refpurpose>Print the repository's
      <literal>UUID</literal>.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook uuid REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the <literal>UUID</literal> for the repository.
        The <literal>UUID</literal> is the repository's
        <emphasis>u</emphasis>niversal <emphasis>u</emphasis>nique
        <emphasis>id</emphasis>entifier.  The Subversion client
        uses this identifier to differentiate between one
        repository and another.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <informalexample>
        <screen>
$ svnlook uuid /var/svn/repos
e7fe1b91-8cd5-0310-98dd-2f12e793c5e8
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnlook.c.youngest">

    <indexterm>
      <primary>svnlook</primary>
      <secondary>subcommands</secondary>
      <tertiary>youngest</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnlook youngest</refname>
      <refpurpose>Print the youngest revision number.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnlook youngest REPOS_PATH</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Print the youngest revision number of a repository.</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

    <para>This shows the youngest revision of our sample
      repository:</para>

    <informalexample>
        <screen>
$ svnlook youngest /var/svn/repos/ 
42
</screen>
      </informalexample>

    </refsect1>
  </refentry>

</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnmucc">
  <title>svnmucc Reference Subversion Multiple URL Command Client</title>

  <partintro>

    <para>The Subversion Multiple URL Command Client
      (<command>svnmucc</command>) is a tool that can make arbitrary
      changes to the repository without the use of a working copy.  As
      regards remote commit capabilities, the functionality provided
      by this tool is similar to, but far exceeds, that which is
      offered by the Subversion command-line client itself.  For
      example, <command>svnmucc</command> is not limited to performing
      only a single type of change in a given commit.  It is also able
      to perform working-copy-less file content and versioned property
      modifications, which is functionality not currently offered
      by <command>svn</command>.</para>

    <para>This reference describes the <command>svnmucc</command> tool,
      and the various remote modification actions you can perform
      using it.</para>

  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnmucc.re">

    <indexterm>
      <primary>svnmucc</primary>
    </indexterm>

    <refnamediv>
      <refname>svnmucc</refname>

      <refpurpose>Perform one or more Subversion repository
        URL-based ACTIONs, committing the result as a (single) new
        revision.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnmucc ACTION...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnmucc.re.desc">
      <title>Description</title>

      <para><command>svnmucc</command> is a program for modifying
        Subversion-versioned data without the use of a working copy.
        It allows operations to be performed directly against the
        repository URLs of the files and directories that the user
        wishes to change.  Each invocation of <command>svnmucc</command>
        attempts one or more <replaceable>ACTION</replaceable>s,
        atomically committing the results of those combined
        <replaceable>ACTION</replaceable>s as a single new
        revision.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnmucc.re.actions">
      <title>Actions</title>

      <para><command>svnmucc</command> supports the following
        actions (and related arguments), which may be combined into
        ordered sequences on the command line:</para>

      <variablelist>

        <varlistentry>
          <term>cp <replaceable>REV</replaceable>
            <replaceable>SRC-URL</replaceable> 
            <replaceable>DST-URL</replaceable></term>
          <listitem>
            <para>Copy the file or directory located
              at <replaceable>SRC-URL</replaceable> in
              revision <replaceable>REV</replaceable>
              to <replaceable>DST-URL</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mkdir <replaceable>URL</replaceable></term>
          <listitem>
            <para>Create a new directory at <replaceable>URL</replaceable>.
              The parent directory of <replaceable>URL</replaceable>
              must already exist (or have been created by a
              prior <command>svnmucc</command> action), as this
              command does not offer the ability to automatically
              create any missing intermediate parent
              directories.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mv <replaceable>SRC-URL</replaceable> 
            <replaceable>DST-URL</replaceable></term>
          <listitem>
            <para>Move the file or directory located
              at <replaceable>SRC-URL</replaceable> to
              <replaceable>DST-URL</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>rm <replaceable>URL</replaceable></term>
          <listitem>
            <para>Delete the file or directory located
              at <replaceable>URL</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>put <replaceable>SRC-FILE</replaceable>
            <replaceable>URL</replaceable></term>
          <listitem>
            <para>Add a new file or modify an existing
              one located at <replaceable>URL</replaceable>,
              copying the contents of the local file
              <replaceable>SRC-FILE</replaceable> as the new contents
              of the created or modified file.  As a special
              consideration, <replaceable>SRC-FILE</replaceable> may
              be <literal>-</literal> to instruct
              <command>svnmucc</command> to read from standard input
              rather than a local filesystem file.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>propset <replaceable>NAME</replaceable>
            <replaceable>VALUE</replaceable>
            <replaceable>URL</replaceable></term>
          <listitem>
            <para>Set the value of the
              property <replaceable>NAME</replaceable> on the
              target <replaceable>URL</replaceable>
              to <replaceable>VALUE</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>propsetf <replaceable>NAME</replaceable>
            <replaceable>FILE</replaceable>
            <replaceable>URL</replaceable></term>
          <listitem>
            <para>Set the value of the
              property <replaceable>NAME</replaceable> on the
              target <replaceable>URL</replaceable>
              to the contents of the file
              <replaceable>FILE</replaceable>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>propdel <replaceable>NAME</replaceable>
            <replaceable>URL</replaceable></term>
          <listitem>
            <para>Delete the property <replaceable>NAME</replaceable>
              from the target <replaceable>URL</replaceable>.</para>
          </listitem>
        </varlistentry>

      </variablelist>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnmucc.re.sw">
      <title>Options</title>

      <para>Options specified on the <command>svnmucc</command>
        command line are global to all actions performed by that
        command line.  The following is a list of the options
        supported by this tool:</para>

      <variablelist>

        <varlistentry>
          <term><option>--config-dir</option>
            <replaceable>DIR</replaceable></term>
          <listitem>
            <para>Read configuration information from the specified
              directory instead of the default location
              (<filename>.subversion</filename> in the user's home
              directory).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--config-option</option>
            <replaceable>CONFSPEC</replaceable></term>
          <listitem>
            <para>Set, for the duration of the command, the value
              of a runtime configuration option.
              <replaceable>CONFSPEC</replaceable> is a
              string which specifies the configuration option
              namespace, name and value that you'd like to assign,
              formatted as
              <replaceable>FILE</replaceable>:<replaceable>SECTION</replaceable>:<replaceable>OPTION</replaceable>=[<replaceable>VALUE</replaceable>].
              In this syntax, <replaceable>FILE</replaceable>
              and <replaceable>SECTION</replaceable> are the runtime
              configuration file (either <literal>config</literal>
              or <literal>servers</literal>) and the section
              thereof, respectively, which contain the option whose
              value you wish to
              change.  <replaceable>OPTION</replaceable> is, of
              course, the option itself,
              and <replaceable>VALUE</replaceable> the value (if
              any) you wish to assign to the option.  For example,
              to temporarily disable the use of the automatic
              property setting feature,
              use <option>--config-option=config:miscellany:enable-auto-props=no</option>.
              You can use this option multiple times to change
              multiple option values simultaneously.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--extra-args</option> (<option>-X</option>)
            <replaceable>ARGFILE</replaceable></term>
          <listitem>
            <para>Read additional would-be command-line arguments
              from <replaceable>ARGFILE</replaceable>, one argument
              per line.  As a special consideration,
              <replaceable>ARGFILE</replaceable> may be
              <literal>-</literal> to indicate that additional
              arguments should be read instead from standard
              input.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--file</option> (<option>-F</option>)
            <replaceable>MSGFILE</replaceable></term>
          <listitem>
             <para>Use the contents of the <replaceable>MSGFILE</replaceable>
               as the log message for the commit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--help</option> (<option>-h</option>,
            <option>-?</option>)</term>
          <listitem>
             <para>Show program usage information and exit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--message</option> (<option>-m</option>)
            <replaceable>MSG</replaceable></term>
          <listitem>
             <para>Use <replaceable>MSG</replaceable> as the log
               message for the commit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--no-auth-cache</option></term>
          <listitem>
            <para>Prevent caching of authentication information
              (e.g., username and password) in the Subversion
              runtime configuration directories.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--non-interactive</option></term>
          <listitem>
            <para>Disable all interactive prompting (e.g., requests
              for authentication credentials).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--revision</option> (<option>-r</option>)
            <replaceable>REV</replaceable></term>
          <listitem>
            <para>Use revision <replaceable>REV</replaceable> as the
              baseline revision for all changes made via
              the <command>svnmucc</command> actions.  This is an
              important option which users should habituate to using
              whenever modifying existing versioned items to avoid
              inadvertently undoing contemporary changes made by
              fellow team members.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--root-url</option> (<option>-U</option>)
            <replaceable>ROOT-URL</replaceable></term>
          <listitem>
            <para>Use <replaceable>ROOT-URL</replaceable> as a base
              URL to which all other URL targets are relative.  This
              URL need not be the repository's root URL (such
              as might be reported by <command>svn info</command>).
              It can be any URL common to the various targets which
              are specified in the <command>svnmucc</command>
              actions.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--password</option> (<option>-p</option>)
            <replaceable>PASSWD</replaceable></term>
          <listitem>
            <para>Use <replaceable>PASSWD</replaceable> as the
              password when authenticating against a Subversion
              server.  If not provided, or if incorrect, Subversion
              will prompt you for this information as needed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--username</option>
            <replaceable>NAME</replaceable></term>
          <listitem>
            <para>Use <replaceable>USERNAME</replaceable> as the
              username when authenticating against a Subversion
              server.  If not provided, or if incorrect, Subversion
              will prompt you for this information as needed.</para>
          </listitem>
        </varlistentry>
      
        <varlistentry>
          <term><option>--version</option></term>
          <listitem>
            <para>Display the program's version information and
              exit.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>--with-revprop</option>
            <replaceable>NAME</replaceable>=<replaceable>VALUE</replaceable></term>
          <listitem>
            <para>Set the value of the revision property
              <replaceable>NAME</replaceable> to
              <replaceable>VALUE</replaceable> on the committed
              revision.</para>
          </listitem>
        </varlistentry>

      </variablelist>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnmucc.re.examples">
      <title>Examples</title>

      <para>To (safely) modify a file's contents without using a
        working copy, use <command>svn cat</command> to fetch the
        current contents of the file, and <command>svnmucc
        put</command> to commit the edited contents thereof.</para>

      <informalexample>
        <screen>
$ # Calculate some convenience variables.
$ export FILEURL=http://svn.example.com/projects/sandbox/README
$ export BASEREV=`svn info ${FILEURL} | \
                  grep '^Last Changed Rev' | cut -d ' ' -f 2`
$ # Get a copy of the file's current contents.
$ svn cat ${FILEURL}@${BASEREV} > /tmp/README.tmpfile
$ # Edit the (copied) file.
$ vi /tmp/README.tmpfile
$ # Commit the new content for our file.
$ svnmucc -r ${BASEREV} put README.tmpfile ${FILEURL} \
          -m "Tweak the README file."
r24 committed by harry at 2013-01-21T16:21:23.100133Z
# Cleanup after ourselves.
$ rm /tmp/README.tmpfile
</screen>
      </informalexample>

      <para>Apply a similar approach to change a file or directory
        property.  Simply use <command>svn propget</command>
        and <command>svnmucc propsetf</command> instead
        of <command>svn cat</command> and <command>svnmucc
        put</command>, respectively.</para>

      <informalexample>
        <screen>
$ # Calculate some convenience variables.
$ export PROJURL=http://svn.example.com/projects/sandbox
$ export BASEREV=`svn info ${PROJURL} | \
                  grep '^Last Changed Rev' | cut -d ' ' -f 2`
$ # Get a copy of the directory's "license" property value.
$ svn -r ${BASEREV} propget license ${PROJURL} > /tmp/prop.tmpfile
$ # Tweak the property.
$ vi /tmp/prop.tmpfile
$ # Commit the new property value.
$ svnmucc -r ${BASEREV} propsetf prop.tmpfile ${PROJURL} \
          -m "Tweak the project directory 'license' property."
r25 committed by harry at 2013-01-21T16:24:11.375936Z
# Cleanup after ourselves.
$ rm /tmp/prop.tmpfile
</screen>
      </informalexample>

      <para>Let's look now at some multi-operation examples.</para>

      <para>To implement a <quote>moving tag</quote>, where a single
        tag name is recycled to point to different snapshots (for
        example, the current latest stable version) of a codebase,
        use <command>svnmucc rm</command> and <command>svnmucc
        cp</command>:</para>

      <informalexample>
        <screen>
$ svnmucc -U http://svn.example.com/projects/doohickey \
          rm tags/latest-stable \
          cp HEAD trunk tags/latest-stable \
          -m "Slide the 'latest-stable' tag forward."
r134 committed by harry at 2013-01-12T11:02:16.142536Z
$ 
</screen>
      </informalexample>

      <para>In the previous example, we slyly introduced the use of
        the <option>--root-url (-U)</option> option.  Use this
        option to specify a base URL to which all other operand URLs
        are treated as relative (and save yourself some
        typing).</para>

      <para>The following shows an example of using
        <command>svnmucc</command> to, in a single revision, create
        a new tag of your project which includes a newly created
        descriptive file and which lacks a directory which shouldn't
        be included in, say, a release tarball.</para>

      <informalexample>
        <screen>
$ echo "This is the 1.2.0 release." | \
       svnmucc -U http://svn.example.com/projects/doohickey \
               -m "Tag the 1.2.0 release." \
               -- \
               cp HEAD trunk tags/1.2.0 \
               rm tags/1.2.0/developer-notes \
               put - tags/1.2.0/README.tag
r164 committed by cmpilato at 2013-01-22T05:26:15.563327Z
$ svn log -c 164 -v http://svn.example.com/projects/doohickey
------------------------------------------------------------------------
r164 | cmpilato | 2013-01-22 00:26:15 -0500 (Tue, 22 Jan 2013) | 1 line
Changed paths:
   A /tags/1.2.0 (from /trunk:163)
   A /tags/1.2.0/README.tag
   D /tags/1.2.0/developer-notes

Tag the 1.2.0 release.
$ 
</screen>
      </informalexample>

      <para>The previous example demonstrates not only how to do
        several different things in a single <command>svnmucc</command>
        invocation, but also the use of standard input as the source
        of new file contents.  Note the presence of <literal>--</literal>
        to indicate that no more options follow on the command line.
        This is required so that the bare <literal>-</literal> used
        in the <command>svnmucc put</command> action won't be
        flagged as a malformed option indicator.</para>

    </refsect1>

  </refentry>
</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnrdump">
  <title>svnrdump Reference Remote Subversion Repository Data Migration</title>

  <partintro>
    <para><command>svnrdump</command> joined the Subversion tool chain
      in the Subversion 1.7 release.  It is best described as a
      network-aware version of the <command>svnadmin dump</command>
      and <command>svnadmin load</command> commands, paired together
      and released as a separate standalone program.  We discuss the
      process of dumping and loading repository data using
      both <command>svnadmin</command>
      and <command>svnrdump</command>  in
      <xref linkend="svn.reposadmin.maint.migrate" />.</para>

    <para>Options in <command>svnrdump</command> are global, just
      as they are in <command>svn</command> and
      <command>svnadmin</command>:</para>

    <variablelist id="svn.ref.svnrdump.sw">
      <title>svnrdump Options</title>

      <varlistentry id="svn.ref.svnrdump.sw.config_dir">
        <term><option>--config-dir</option> <replaceable>DIR</replaceable></term>
        <listitem>
          <para>Instructs Subversion to read configuration
            information from the specified directory instead of the
            default location (<filename>.subversion</filename> in
            the user's home directory).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.config_option">
        <term><option>--config-option</option> <replaceable>FILE</replaceable>:<replaceable>SECTION</replaceable>:<replaceable>OPTION</replaceable>=[<replaceable>VALUE</replaceable>]</term>
        <listitem>
          <para>Sets, for the duration of the command, the value of
            a runtime configuration
            option.  <replaceable>FILE</replaceable>
            and <replaceable>SECTION</replaceable> are the runtime
            configuration file (either <literal>config</literal>
            or <literal>servers</literal>) and the section thereof,
            respectively, which contain the option whose value you
            wish to change.  <replaceable>OPTION</replaceable> is,
            of course, the option itself,
            and <replaceable>VALUE</replaceable> the value (if any)
            you wish to assign to the option.  For example, to
            temporarily disable the use of the automatic property
            setting feature,
            use <option>--config-option=servers:global:http-library=serf</option>.
            You can use this option multiple times to change
            multiple option values simultaneously.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.incremental">
        <term><option>--incremental</option></term>
        <listitem>
          <para>Dump a revision or revision range only as a diff
            against the previous revision, instead of the default,
            which is begin a dumped revision range with a complete
            expansion of all contents of the repository as of that
            revision.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.no_auth_cache">
        <term><option>--no-auth-cache</option></term>
        <listitem>
          <para>Prevents caching of authentication information
            (e.g., username and password) in the Subversion
            runtime configuration directories.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.non_interactive">
        <term><option>--non-interactive</option></term>
        <listitem>
          <para>In the case of an authentication failure or
            insufficient credentials, prevents prompting for
            credentials (e.g., username or password).  This is useful
            if you're running Subversion inside an automated
            script and it's more appropriate to have Subversion fail
            than to prompt for more information.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.password">
        <term><option>--password</option> <replaceable>PASSWD</replaceable></term>
        <listitem>
          <para>Specifies the password to use when authenticating
            against a Subversion server.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.quiet">
        <term><option>--quiet</option> (<option>-q</option>)</term>
        <listitem>
          <para>Requests that the client print only essential
            information while performing an operation.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.revision">
        <term><option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Used by <command>svnsync copy-revprops</command> to
            specify a particular revision or revision range on which
            to operate.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.trust_server_cert">
        <term><option>--trust-server-cert</option></term>
        <listitem>
          <para>Used with <option>--non-interactive</option> to accept
            any unknown SSL server certificates without prompting.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnrdump.sw.username">
        <term><option>--username</option> <replaceable>NAME</replaceable></term>
        <listitem>
          <para>Specifies the username to use when authenticating
            against a Subversion server.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
        </listitem>
      </varlistentry>

    </variablelist>

  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnrdump.c.dump">

    <indexterm>
      <primary>svnrdump</primary>
      <secondary>subcommands</secondary>
      <tertiary>dump</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnrdump dump</refname>
      <refpurpose></refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnrdump dump SOURCE_URL</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Dump that is, generate a repository dump stream
        of revisions of the repository item located
        at <replaceable>SOURCE_URL</replaceable>, printing the
        information to standard output.  By default, the entire
        history will be included in the dump stream, but the scope
        of the operation can be limited via the use of
        the <option>--revision</option> (<option>-r</option>)
        option.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnrdump.sw.config_dir" />
<xref linkend="svn.ref.svnrdump.sw.config_option" />
<xref linkend="svn.ref.svnrdump.sw.incremental" />
<xref linkend="svn.ref.svnrdump.sw.no_auth_cache" />
<xref linkend="svn.ref.svnrdump.sw.non_interactive" />
<xref linkend="svn.ref.svnrdump.sw.password" />
<xref linkend="svn.ref.svnrdump.sw.quiet" />
<xref linkend="svn.ref.svnrdump.sw.revision" />
<xref linkend="svn.ref.svnrdump.sw.trust_server_cert" />
<xref linkend="svn.ref.svnrdump.sw.username" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Generate a dump stream of the full history of a remote
        repository (assuming that the user as who this runs has
        authorization to read all paths in the repository).</para>

      <informalexample>
        <screen>
$ svnrdump dump http://svn.example.com/repos/calc &gt; full.dump
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
 
</screen>
      </informalexample>

      <para>Incrementally dump a single revision from that same
        repository:</para>

      <informalexample>
        <screen>
$ svnrdump dump http://svn.example.com/repos/calc \
           -r 21 --incremental &gt; inc.dump
* Dumped revision 21.
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnrdump.c.help">

    <indexterm>
      <primary>svnrdump</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnrdump help</refname>
      <refpurpose>Help!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnrdump help</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Use this to get help.  Well, certain kinds of help.
        Need white lab coat and straightjackets kind of help?
        There's a whole different protocol for that sort of
        thing.</para>
        
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>

  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnrdump.c.load">

    <indexterm>
      <primary>svnrdump</primary>
      <secondary>subcommands</secondary>
      <tertiary>load</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnrdump load</refname>
      <refpurpose></refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnrdump load DEST_URL</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Read from standard input revision information
        described in a Subversion repository dump stream, and load
        that information into the repository located
        at <replaceable>DEST_URL</replaceable>.</para>

    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnrdump.sw.config_dir" />
<xref linkend="svn.ref.svnrdump.sw.config_option" />
<xref linkend="svn.ref.svnrdump.sw.no_auth_cache" />
<xref linkend="svn.ref.svnrdump.sw.non_interactive" />
<xref linkend="svn.ref.svnrdump.sw.password" />
<xref linkend="svn.ref.svnrdump.sw.quiet" />
<xref linkend="svn.ref.svnrdump.sw.trust_server_cert" />
<xref linkend="svn.ref.svnrdump.sw.username" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Dump the contents of a local repository, and
        use <command>svnrdump load</command> to transfer that
        revision information into an existing remote
        repository:</para>

      <informalexample>
        <screen>
$ svnadmin dump -q /var/svn/repos/new-project | \
      svnrdump load http://svn.example.com/repos/new-project
* Loaded revision 0
* Loaded revision 1.
* Loaded revision 2.
 
</screen>
      </informalexample>

      <note>
        <para>To operate properly <command>svnrdump load</command>
          requires that the target repository have revision
          property modification enabled via the pre-revprop-change
          hook.  For details about that hook, see
          <xref linkend="svn.ref.reposhooks.pre-revprop-change"
          />.</para>
      </note>

    </refsect1>
  </refentry>

</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnserve">
  <title>svnserve Reference Custom Subversion Server</title>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnserve.re">

    <indexterm>
      <primary>svnserve</primary>
    </indexterm>

    <refnamediv>
      <refname>svnserve</refname>
      <refpurpose>Serve Subversion repositories via Subversion's
        custom network protocol</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnserve [-d | -i | -t | -X] OPTIONS...</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnserve.re.desc">
      <title>Description</title>

      <para><command>svnserve</command> allows access to Subversion
        repositories using Subversion's custom network
        protocol.</para>

      <para>You can run <command>svnserve</command> as a standalone
        server process (for clients that are using the
        <literal>svn://</literal> access method); you can have a
        daemon such as <command>inetd</command>
        or <command>xinetd</command> launch it for you on demand (also
        for <literal>svn://</literal>), or you can have
        <command>sshd</command> launch it on demand for the
        <literal>svn+ssh://</literal> access method.</para>

      <para>Unless the <option>--config-file</option> option was specified on
        the command line, once the client has selected a repository by
        transmitting its URL, <command>svnserve</command> reads a file named
        <filename>conf/svnserve.conf</filename> in the repository
        directory to determine repository-specific settings such as
        what authentication database to use and what authorization
        policies to apply.  See
        <xref linkend="svn.serverconfig.svnserve"/> for details of the
        <filename>svnserve.conf</filename> file.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnserve.re.options">
      <title>Options</title>
    
      <para>Unlike the previous commands we've
        described, <command>svnserve</command> has no
        subcommands it is controlled exclusively by
        options.</para>

      <variablelist>

        <varlistentry id="svn.ref.svnserve.sw.cache_fulltexts">
          <term><option>--cache-fulltexts</option> <replaceable>ARG</replaceable></term>
          <listitem>
            <para>Toggles support for fulltext file content caching (in
              FSFS repositories only).</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.cache_txdeltas">
          <term><option>--cache-txdeltas</option> <replaceable>ARG</replaceable></term>
          <listitem>
            <para>Toggles support for file content delta caching (in
              FSFS repositories only).</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.compression">
          <term><option>--compression</option> <replaceable>LEVEL</replaceable></term>
          <listitem>
            <para>Specifies the level of compression used for wire
              transmissions as an integer beween 0 and 9, inclusive.
              A value of <literal>9</literal> offers the best
              compression, <literal>5</literal> is the default value,
              and <literal>0</literal> disables compression
              altogether.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.config_file">
          <term><option>--config-file</option> <replaceable>FILENAME</replaceable></term>
          <listitem>
            <para>When specified, <command>svnserve</command> reads
              <replaceable>FILENAME</replaceable> once at program startup and
              caches the <command>svnserve</command> configuration.  The
              password and authorization configurations referenced from filename
              will be loaded on each connection.  <command>svnserve</command>
              will not read any per‐repository
              <filename>conf/svnserve.conf</filename> files when this option is
              used.  See the <xref linkend="svn.serverconfig.svnserve"/> for
              details of the file format for this option.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.daemon">
          <term><option>--daemon</option> (<option>-d</option>)</term>
          <listitem>
            <para>Causes <command>svnserve</command> to run in daemon
              mode.  <command>svnserve</command> backgrounds itself
              and accepts and serves TCP/IP connections on
              the <literal>svn</literal> port (3690, by
              default).</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.foreground">
          <term><option>--foreground</option></term>
          <listitem>
            <para>When used together with <option>-d</option>,
              causes <command>svnserve</command> to stay in the
              foreground.  This is mainly useful for debugging.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.inetd">
          <term><option>--inetd</option> (<option>-i</option>)</term>
          <listitem>
            <para>Causes <command>svnserve</command> to use the
              <filename>stdin</filename> and <filename>stdout</filename> file descriptors, as is appropriate for a
              daemon running out of <command>inetd</command>.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.help">
          <term><option>--help</option> (<option>-h</option>)</term>
          <listitem>
            <para>Displays a usage summary and exits.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.listen_host">
          <term><option>--listen-host</option> <replaceable>HOST</replaceable></term>
          <listitem>
            <para>Causes <command>svnserve</command> to listen on the
              interface specified by <replaceable>HOST</replaceable>,
              which may be either a hostname or an IP address.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.listen_once">
          <term><option>--listen-once</option> (<option>-X</option>)</term>
          <listitem>
            <para>Causes <command>svnserve</command> to accept one
              connection on the <literal>svn</literal> port, serve it,
              and exit.  This option is mainly useful for
              debugging.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.listen_port">
          <term><option>--listen-port</option> <replaceable>PORT</replaceable></term>
          <listitem>
            <para>Causes <command>svnserve</command> to listen on
              <replaceable>PORT</replaceable> when run in daemon mode.
              (FreeBSD daemons listen only on tcp6 by default this
              option tells them to also listen on tcp4.)</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.log_file">
          <term><option>--log-file</option> <replaceable>FILENAME</replaceable></term>
          <listitem>
            <para>Instructs <command>svnserve</command> to create (if
              necessary) and use the file located
              at <replaceable>FILENAME</replaceable> for Subversion
              operational log output of the same sort
              that <command>mod_dav_svn</command> generates.  See
              <xref linkend="svn.serverconfig.operational-logging" />
              for details.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.memory_cache_size">
          <term><option>--memory-cache-size</option> (<option>-M</option>) <replaceable>ARG</replaceable></term>
          <listitem>
            <para>Configures the size (in Megabytes) of the extra
              in-memory cache used to minimize redundant operations.
              The default value is <literal>16</literal>.  (This cache
              is used for FSFS-backed repositories only.)</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.pid_file">
          <term><option>--pid-file</option> <replaceable>FILENAME</replaceable></term>
          <listitem>
            <para>Causes <command>svnserve</command> to write its
              process ID to <replaceable>FILENAME</replaceable>, which
              must be writable by the user under
              which <command>svnserve</command> is running.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.prefer_ipv6">
          <term><option>--prefer-ipv6</option> (<option>-6</option></term>
          <listitem>
            <para>When resolving the listen hostname, prever an IPv6
              answer over an IPv4 one.  IPv4 is preferred by
              default.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.quiet">
          <term><option>--quiet</option></term>
          <listitem>
            <para>Disables progress notifications.  Error output will
              still be printed.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.root">
          <term><option>--root</option> (<option>-r</option>) <replaceable>ROOT</replaceable></term>
          <listitem>
            <para>Sets the virtual root for repositories served by
              <command>svnserve</command>.  The pathname in URLs
              provided by the client will be interpreted relative to
              this root and will not be allowed to escape this
              root.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.threads">
          <term><option>--threads</option> (<option>-T</option>)</term>
          <listitem>
            <para>When running in daemon mode, causes
              <command>svnserve</command> to spawn a thread instead of
              a process for each connection (e.g., for when running on
              Windows).  The <command>svnserve</command> process still
              backgrounds itself at startup time.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.tunnel">
          <term><option>--tunnel</option> (<option>-t</option>)</term>
          <listitem>
            <para>Causes <command>svnserve</command> to run in tunnel
              mode, which is just like the <command>inetd</command>
              mode of operation (both modes serve one connection over
              <filename>stdin</filename>/<filename>stdout</filename>, and then exit), except that the connection
              is considered to be preauthenticated with the username
              of the current UID.  This flag is automatically passed
              for you by the client when running over a tunnel agent
              such as <command>ssh</command>.  That means there's
              rarely any need for <emphasis>you</emphasis> to pass
              this option to <command>svnserve</command>.  So, if you
              find yourself
              typing <literal>svnserve --tunnel</literal> on the
              command line and wondering what to do next, see
              <xref linkend="svn.serverconfig.svnserve.sshauth"/>.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.tunnel_user">
          <term><option>--tunnel-user</option> <replaceable>NAME</replaceable></term>
          <listitem>
            <para>Used in conjunction with the <option>--tunnel</option>
              option, tells <command>svnserve</command> to assume that
              <replaceable>NAME</replaceable> is the authenticated
              user, rather than the UID of the <command>svnserve</command>
              process.  This is useful for users wishing to share a single
              system account over SSH, but to maintain separate commit
              identities.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="svn.ref.svnserve.sw.version">
          <term><option>--version</option></term>
          <listitem>
            <para>Displays version information and a list of repository
            backend modules available, and then exits.</para>
          </listitem>
        </varlistentry>

      </variablelist>

    </refsect1>
  </refentry>
</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnsync">
  <title>svnsync Reference Subversion Repository Mirroring</title>
    
  <partintro>
    <para><command>svnsync</command> is the Subversion remote
      repository mirroring tool.  Put simply, it allows you to replay
      the revisions of one repository into another one.</para>

    <para>In any mirroring scenario, there are two repositories: the
      source repository, and the mirror (or <quote>sink</quote>)
      repository.  The source repository is the repository from which
      <command>svnsync</command> pulls revisions.  The mirror
      repository is the destination for the revisions pulled from the
      source repository.  Each of the repositories may be local or
      remote they are only ever addressed by their URLs.</para>

    <para>The <command>svnsync</command> process requires only read
      access to the source repository; it never attempts to modify it.
      But obviously, <command>svnsync</command> requires both read and
      write access to the mirror repository.</para>

    <warning>
      <para><command>svnsync</command> is very sensitive to changes
        made in the mirror repository that weren't made as part of a
        mirroring operation.  To prevent this from happening, it's
        best if the <command>svnsync</command> process is the only
        process permitted to modify the mirror repository.</para>
    </warning>

    <para>Options in <command>svnsync</command> are global, just
      as they are in <command>svn</command> and
      <command>svnadmin</command>:</para>

    <variablelist id="svn.ref.svnsync.sw">
      <title>svnsync Options</title>

      <varlistentry id="svn.ref.svnsync.sw.allow_non_empty">
        <term><option>--allow-non-empty</option></term>
        <listitem>
          <para>Disables the verification (which <command>svnsync
            initialize</command> performs by default) that the
            repository being initialized is empty of history
            version.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.config_dir">
        <term><option>--config-dir</option> <replaceable>DIR</replaceable></term>
        <listitem>
          <para>Instructs Subversion to read configuration
            information from the specified directory instead of the
            default location (<filename>.subversion</filename> in
            the user's home directory).</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.config_option">
        <term><option>--config-option</option> <replaceable>CONFSPEC</replaceable></term>
        <listitem>
          <para>Sets, for the duration of the command, the value of
            a runtime configuration
            option.  <replaceable>CONFSPEC</replaceable> is a string
            which specifies the configuration option namespace, name
            and value that you'd like to assign, formatted as
            <replaceable>FILE</replaceable>:<replaceable>SECTION</replaceable>:<replaceable>OPTION</replaceable>=[<replaceable>VALUE</replaceable>].
            In this syntax, <replaceable>FILE</replaceable>
            and <replaceable>SECTION</replaceable> are the runtime
            configuration file (either <literal>config</literal>
            or <literal>servers</literal>) and the section thereof,
            respectively, which contain the option whose value you
            wish to change.  <replaceable>OPTION</replaceable> is,
            of course, the option itself,
            and <replaceable>VALUE</replaceable> the value (if any)
            you wish to assign to the option.  For example, to
            temporarily disable the use of the automatic property
            setting feature,
            use <option>--config-option=servers:global:http-library=serf</option>.
            You can use this option multiple times to change
            multiple option values simultaneously.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.disable_locking">
        <term><option>--disable-locking</option></term>
        <listitem>
          <para>Causes <command>svnsync</command> to bypass its own
            exclusive access mechanisms and operate on the
            assumption that its exclusive access to the mirror
            repository is being guaranteed through some other,
            out-of-band mechanism.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.no_auth_cache">
        <term><option>--no-auth-cache</option></term>
        <listitem>
          <para>Prevents caching of authentication information
            (e.g., username and password) in the Subversion
            runtime configuration directories.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.non_interactive">
        <term><option>--non-interactive</option></term>
        <listitem>
          <para>In the case of an authentication failure or
            insufficient credentials, prevents prompting for
            credentials (e.g., username or password).  This is useful
            if you're running Subversion inside an automated
            script and it's more appropriate to have Subversion fail
            than to prompt for more information.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.quiet">
        <term><option>--quiet</option> (<option>-q</option>)</term>
        <listitem>
          <para>Requests that the client print only essential
            information while performing an operation.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.revision">
        <term><option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable></term>
        <listitem>
          <para>Used by <command>svnsync copy-revprops</command> to
            specify a particular revision or revision range on which
            to operate.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.source_password">
        <term><option>--source-password</option> <replaceable>PASSWD</replaceable></term>
        <listitem>
          <para>Specifies the password for the Subversion server
            from which you are syncing.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.source_prop_encoding ">
        <term><option>--source-prop-encoding <replaceable>ARG</replaceable></option></term>
        <listitem>
          <para>Instructs <command>svnsync</command> to assume that
            translatable Subversion revision properties found in the
            source repository are stored using the character
            encoding <replaceable>ARG</replaceable> and to transcode
            those into UTF-8 when copying them into the mirror
            repository.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.source_username">
        <term><option>--source-username</option> <replaceable>NAME</replaceable></term>
        <listitem>
          <para>Specifies the username for the Subversion server
            from which you are syncing.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.steal_lock">
        <term><option>--steal-lock</option></term>
        <listitem>
          <para>Causes <command>svnsync</command> to steal, as
            necessary, the lock which it uses on the mirror
            repository to ensure exclusive repository access.  (This
            option should only be used when a lock exists in the
            mirror repository and is known to be stale that
            is, when you are certain that there are no
            other <command>svnsync</command> processes accessing
            that repository.)</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svnsync.sw.sync_password">
        <term><option>--sync-password</option> <replaceable>PASSWD</replaceable></term>
        <listitem>
          <para>Specifies the password for the Subversion server to
            which you are syncing.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry id="svn.ref.svnsync.sw.sync_username">
        <term><option>--sync-username</option> <replaceable>NAME</replaceable></term>
        <listitem>
          <para>Specifies the username for the Subversion server to
            which you are syncing.  If not provided, or if
            incorrect, Subversion will prompt you for this
            information as needed.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="svn.ref.svnsync.sw.trust_server_cert">
        <term><option>--trust-server-cert</option></term>
        <listitem>
          <para>Used with <option>--non-interactive</option> to accept
            any unknown SSL server certificates without prompting.</para>
        </listitem>
      </varlistentry>

    </variablelist>

  </partintro>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnsync.c.copy-revprops">

    <indexterm>
      <primary>svnsync</primary>
      <secondary>subcommands</secondary>
      <tertiary>copy-revprops</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnsync copy-revprops</refname>
      <refpurpose>Copy all revision properties for a particular
        revision (or range of revisions) from the source
        repository to the mirror repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnsync copy-revprops DEST_URL
        [SOURCE_URL]</literal></para>
      <para><literal>svnsync copy-revprops DEST_URL
        REV[:REV2]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>Because Subversion revision properties can be changed
        at any time, it's possible that the properties for some
        revision might be changed after that revision has already
        been synchronized to another repository.  Because the
        <command>svnsync synchronize</command> command operates
        only on the range of revisions that have not yet been
        synchronized, it won't notice a revision property change
        outside that range.  Left as is, this causes a deviation
        in the values of that revision's properties between the
        source and mirror repositories.  <command>svnsync
        copy-revprops</command> is the answer to this problem.
        Use it to resynchronize the revision properties for a
        particular revision or range of revisions.</para>

      <para>When <replaceable>SOURCE_URL</replaceable> is
        provided, <command>svnsync</command> will use it as the
        repository URL which the destination repository is
        mirroring. Generally, <replaceable>SOURCE_URL</replaceable>
        will be exactly the same source URL as was used with
        the <command>svnsync initialize</command> command when the
        mirror was first set up.  You may choose, however, to
        omit <replaceable>SOURCE_URL</replaceable>, in which
        case <command>svnsync</command> will consult the mirror
        repository's records to determine the source URL which
        should be used.</para>

      <warning>
        <para>We strongly recommend that you specify the source
          URL on the command-line, especially when untrusted users
          have write access to the revision 0 properties
          which <command>svnsync</command> uses to coordinate its
          efforts.</para>
      </warning>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnsync.sw.config_dir" />
<xref linkend="svn.ref.svnsync.sw.config_option" />
<xref linkend="svn.ref.svnsync.sw.disable_locking" />
<xref linkend="svn.ref.svnsync.sw.no_auth_cache" />
<xref linkend="svn.ref.svnsync.sw.non_interactive" />
<xref linkend="svn.ref.svnsync.sw.quiet" />
<xref linkend="svn.ref.svnsync.sw.revision" />
<xref linkend="svn.ref.svnsync.sw.source_password" />
<xref linkend="svn.ref.svnsync.sw.source_prop_encoding" />
<xref linkend="svn.ref.svnsync.sw.source_username" />
<xref linkend="svn.ref.svnsync.sw.steal_lock" />
<xref linkend="svn.ref.svnsync.sw.sync_password" />
<xref linkend="svn.ref.svnsync.sw.sync_username" />
<xref linkend="svn.ref.svnsync.sw.trust_server_cert" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Resynchronize the revision properties associated with
        a single revision (r6):</para>

      <informalexample>
        <screen>
$ svnsync copy-revprops -r 6 file:///var/svn/repos-mirror \
                             http://svn.example.com/repos
Copied properties for revision 6.
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnsync.c.help">

    <indexterm>
      <primary>svnsync</primary>
      <secondary>subcommands</secondary>
      <tertiary>help</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnsync help</refname>
      <refpurpose>Help!</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnsync help</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>This subcommand is useful when you're trapped in a
        foreign prison with neither a Net connection nor a copy of
        this book, but you do have a local Wi-Fi network running
        and you'd like to sync a copy of your repository over to
        the backup server that Ira The Knife is running over in
        cell block D.</para>
        
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>
      <para>None</para>
    </refsect1>

  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnsync.c.info">

    <indexterm>
      <primary>svnsync</primary>
      <secondary>subcommands</secondary>
      <tertiary>info</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnsync info</refname>
      <refpurpose>Print information about the synchronization
        of a destination repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnsync info DEST_URL</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>
      
      <para>Print the synchronization source URL, source repository
        UUID and the last revision merged from the source to the
        destination repository at <replaceable>DEST_URL</replaceable>.</para>
    </refsect1>
    
    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnsync.sw.config_dir" />
<xref linkend="svn.ref.svnsync.sw.config_option" />
<xref linkend="svn.ref.svnsync.sw.no_auth_cache" />
<xref linkend="svn.ref.svnsync.sw.non_interactive" />
<xref linkend="svn.ref.svnsync.sw.source_password" />
<xref linkend="svn.ref.svnsync.sw.source_username" />
<xref linkend="svn.ref.svnsync.sw.sync_password" />
<xref linkend="svn.ref.svnsync.sw.sync_username" />
<xref linkend="svn.ref.svnsync.sw.trust_server_cert" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Print the synchronization information of a mirror
        repository:</para>

      <informalexample>
        <screen>
$ svnsync info file:///var/svn/repos-mirror
Source URL: http://svn.example.com/repos
Source Repository UUID: e7fe1b91-8cd5-0310-98dd-2f12e793c5e8
Last Merged Revision: 47
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnsync.c.init">

    <indexterm>
      <primary>svnsync</primary>
      <secondary>subcommands</secondary>
      <tertiary>initialize</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnsync initialize (init)</refname>
      <refpurpose>Initialize a mirror repository for
        synchronization from the source repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnsync initialize MIRROR_URL
        SOURCE_URL</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para><command>svnsync initialize</command> verifies that a
        repository meets the basic requirements of a new mirror
        repository and records the initial administrative
        information that associates the mirror repository with the
        source repository (specified
        by <replaceable>SOURCE_URL</replaceable>).  This is the
        first <command>svnsync</command> operation you run on a
        would-be mirror repository.</para>

      <para>Ordinarily, <replaceable>SOURCE_URL</replaceable> is
        the URL of the root directory of the Subversion repository
        you wish to mirror.  Subversion 1.5 and newer allow you to
        use <command>svnsync</command> for partial repository
        mirroring, though   simply specify the URL of the
        source repository subdirectory you wish to mirror
        as <replaceable>SOURCE_URL</replaceable>.</para>

      <para>By default, the aforementioned basic requirements of a
        mirror are that it allows revision property modifications
        and that it contains no version history.  However, as of
        Subversion 1.7, you may now optionally disable the
        verification that the target repository is empty using
        the <option>--allow-non-empty</option> option.  While the
        use of this option should not become habitual (as it
        bypasses a valuable safeguard mechanism), it does aid in
        one very common use-case: initializing a copy of a
        repository as a mirror of the original.  This is
        especially handy when setting up new mirrors of
        repositories which contain a large amount of version
        history.  Rather than initialize a brand new repository as
        a mirror and then syncronize all of the history into it,
        administrators will find it <emphasis>significantly</emphasis>
        faster to first make a copy of the mature repository
        (perhaps using <command>svnadmin hotcopy</command>) and
        then use <command>svnsync initialize
        --allow-non-empty</command> to initialize that copy as a
        mirror which is now already up-to-date with the
        original.</para>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnsync.sw.allow_non_empty" />
<xref linkend="svn.ref.svnsync.sw.config_dir" />
<xref linkend="svn.ref.svnsync.sw.config_option" />
<xref linkend="svn.ref.svnsync.sw.disable_locking" />
<xref linkend="svn.ref.svnsync.sw.no_auth_cache" />
<xref linkend="svn.ref.svnsync.sw.non_interactive" />
<xref linkend="svn.ref.svnsync.sw.quiet" />
<xref linkend="svn.ref.svnsync.sw.source_password" />
<xref linkend="svn.ref.svnsync.sw.source_prop_encoding" />
<xref linkend="svn.ref.svnsync.sw.source_username" />
<xref linkend="svn.ref.svnsync.sw.steal_lock" />
<xref linkend="svn.ref.svnsync.sw.sync_password" />
<xref linkend="svn.ref.svnsync.sw.sync_username" />
<xref linkend="svn.ref.svnsync.sw.trust_server_cert" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Fail to initialize a mirror repository due to
        inability to modify revision properties:</para>

      <informalexample>
        <screen>
$ svnsync initialize file:///var/svn/repos-mirror \
                     http://svn.example.com/repos
svnsync: Repository has not been enabled to accept revision propchanges;
ask the administrator to create a pre-revprop-change hook
$
</screen>
      </informalexample>

      <para>Initialize a repository as a mirror, having already
        created a <literal>pre-revprop-change</literal> hook that
        permits all revision property changes:</para>

      <informalexample>
        <screen>
$ svnsync initialize file:///var/svn/repos-mirror \
                     http://svn.example.com/repos
Copied properties for revision 0.
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnsync.c.sync">

    <indexterm>
      <primary>svnsync</primary>
      <secondary>subcommands</secondary>
      <tertiary>synchronize</tertiary>
    </indexterm>

    <refnamediv>
      <refname>svnsync synchronize (sync)</refname>
      <refpurpose>Transfer all pending revisions from the source
        repository to the mirror repository.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnsync synchronize DEST_URL
        [SOURCE_URL]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1>
      <title>Description</title>

      <para>The <command>svnsync synchronize</command> command
        does all the heavy lifting of a repository mirroring
        operation.  After consulting with the mirror repository to
        see which revisions have already been copied into it, it
        then begins to copy any not-yet-mirrored revisions from
        the source repository.</para>

      <para><command>svnsync synchronize</command> can be
        gracefully canceled and restarted.</para>

      <para>When <replaceable>SOURCE_URL</replaceable> is
        provided, <command>svnsync</command> will use it as the
        repository URL which the destination repository is
        mirroring. Generally, <replaceable>SOURCE_URL</replaceable>
        will be exactly the same source URL as was used with
        the <command>svnsync initialize</command> command when the
        mirror was first set up.  You may choose, however, to
        omit <replaceable>SOURCE_URL</replaceable>, in which
        case <command>svnsync</command> will consult the mirror
        repository's records to determine the source URL which
        should be used.</para>

      <warning>
        <para>We strongly recommend that you specify the source
          URL on the command-line, especially when untrusted users
          have write access to the revision 0 properties
          which <command>svnsync</command> uses to coordinate its
          efforts.</para>
      </warning>

    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Options</title>

      <informalexample>
        <screen>
<xref linkend="svn.ref.svnsync.sw.config_dir" />
<xref linkend="svn.ref.svnsync.sw.config_option" />
<xref linkend="svn.ref.svnsync.sw.disable_locking" />
<xref linkend="svn.ref.svnsync.sw.no_auth_cache" />
<xref linkend="svn.ref.svnsync.sw.non_interactive" />
<xref linkend="svn.ref.svnsync.sw.quiet" />
<xref linkend="svn.ref.svnsync.sw.source_password" />
<xref linkend="svn.ref.svnsync.sw.source_prop_encoding" />
<xref linkend="svn.ref.svnsync.sw.source_username" />
<xref linkend="svn.ref.svnsync.sw.steal_lock" />
<xref linkend="svn.ref.svnsync.sw.sync_password" />
<xref linkend="svn.ref.svnsync.sw.sync_username" />
<xref linkend="svn.ref.svnsync.sw.trust_server_cert" />
</screen>
      </informalexample>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1>
      <title>Examples</title>

      <para>Copy unsynchronized revisions from the source
        repository to the mirror repository:</para>

      <informalexample>
        <screen>
$ svnsync synchronize file:///var/svn/repos-mirror \
                      http://svn.example.com/repos
Committed revision 1.
Copied properties for revision 1.
Committed revision 2.
Copied properties for revision 2.
Committed revision 3.
Copied properties for revision 3.
 
Committed revision 45.
Copied properties for revision 45.
Committed revision 46.
Copied properties for revision 46.
Committed revision 47.
Copied properties for revision 47.
$
</screen>
      </informalexample>

    </refsect1>
  </refentry>

</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->
<!-- -*- sgml -*- -->

<reference id="svn.ref.svnversion">
  <title>svnversion Reference Subversion Working Copy Version Info</title>
    
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <!-- ================================================================= -->
  <refentry id="svn.ref.svnversion.re">

    <indexterm>
      <primary>svnversion</primary>
    </indexterm>

    <refnamediv>
      <refname>svnversion</refname>
      <refpurpose>Summarize the local revision(s) of a working 
        copy.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <para><literal>svnversion [OPTIONS] [WC_PATH [TRAIL_URL]]</literal></para>
    </refsynopsisdiv>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnversion.re.desc">
      <title>Description</title>

      <para><command>svnversion</command> is a program for
        summarizing the revision mixture of a working copy.  The
        resultant revision number, or revision range, is written to
        standard output.</para>

      <para>It's common to use this output in your build process
        when defining the version number of your program.</para>
      
      <para><replaceable>TRAIL_URL</replaceable>, if present, is the
        trailing portion of the URL used to determine whether
        <replaceable>WC_PATH</replaceable> itself is switched
        (detection of switches within
        <replaceable>WC_PATH</replaceable> does not rely on
        <replaceable>TRAIL_URL</replaceable>).</para>

      <para>When <replaceable>WC_PATH</replaceable> is not defined,
        the current directory will be used as the working copy path.
        <replaceable>TRAIL_URL</replaceable> cannot be defined if
        <replaceable>WC_PATH</replaceable> is not explicitly
        given.</para>
  
    </refsect1>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnversion.re.sw">
      <title>Options</title>

      <para>Like <command>svnserve</command>,
        <command>svnversion</command> has no subcommands only
        options:</para>

      <variablelist>
  
        <varlistentry id="svn.ref.svnversion.sw.no_newline">
          <term><option>--no-newline</option> (<option>-n</option>)</term>
          <listitem>
            <para>Omits the usual trailing newline from the output.</para>
          </listitem>
        </varlistentry>
  
        <varlistentry id="svn.ref.svnversion.sw.committed">
          <term><option>--committed</option> (<option>-c</option>)</term>
          <listitem>
            <para>Uses the last-changed revisions rather than the
            current (i.e., highest locally available) revisions.</para>
          </listitem>
        </varlistentry>
  
        <varlistentry id="svn.ref.svnversion.sw.help">
          <term><option>--help</option> (<option>-h</option>)</term>
          <listitem>
            <para>Prints a help summary.</para>
          </listitem>
        </varlistentry>
  
        <varlistentry id="svn.ref.svnversion.sw.quiet">
          <term><option>--quiet</option> (<option>-q</option>)</term>
          <listitem>
            <para>Requests that the program print only essential
              information while performing an operation.</para>
          </listitem>
        </varlistentry>
      
        <varlistentry id="svn.ref.svnversion.sw.version">
          <term><option>--version</option></term>
          <listitem>
            <para>Prints the version of <command>svnversion</command>
            and exit with no error.</para>
          </listitem>
        </varlistentry>

      </variablelist>
    </refsect1>

    <!-- =============================================================== -->
    <refsect1 id="svn.ref.svnversion.re.examples">
      <title>Examples</title>

      <para>If the working copy is all at the same revision (e.g.,
        immediately after an update), then that revision is
        printed out:</para>

      <informalexample>
        <screen>
$ svnversion
4168
</screen>
      </informalexample>

      <para>You can add <replaceable>TRAIL_URL</replaceable> to make
        sure the working copy is not switched from what you
        expect.  Note that the <replaceable>WC_PATH</replaceable>
        is required in this command:</para>

      <informalexample>
        <screen>
$ svnversion . /var/svn/trunk
4168
</screen>
      </informalexample>

      <para>For a mixed-revision working copy, the range of
        revisions present is printed:</para>

      <informalexample>
        <screen>
$ svnversion
4123:4168
</screen>
      </informalexample>

      <para>If the working copy contains modifications, a trailing
        '<literal>M</literal>' is added:</para>

      <informalexample>
        <screen>
$ svnversion
4168M
</screen>
      </informalexample>

      <para>If the working copy is switched, a trailing
        '<literal>S</literal>' is added:</para>

      <informalexample>
        <screen>
$ svnversion
4168S
</screen>
      </informalexample>

      <para><command>svnversion</command> will also inform you if
        the target working copy is sparsely populated (see
        <xref linkend="svn.advanced.sparsedirs" />) by attaching the
        '<literal>P</literal>' code to its output:</para>

      <informalexample>
        <screen>
$ svnversion
4168P
</screen>
      </informalexample>

      <para>Thus, here is a mixed-revision, sparsely populated and
        switched working copy containing some local
        modifications:</para>

      <informalexample>
        <screen>
$ svnversion
4123:4168MSP
</screen>
      </informalexample>

    </refsect1>

  </refentry>
</reference>

<!--
local variables: 
sgml-parent-document: ("book.xml" "reference")
end:
-->


</d:InfElement></d:DocumentationCore>